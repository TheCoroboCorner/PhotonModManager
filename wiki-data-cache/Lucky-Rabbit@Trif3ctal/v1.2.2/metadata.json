{
  "locMap": {
    "j_fmod_generator": {
      "name": "Generator",
      "text": [
        "Retrigger all {C:attention}played cards{}",
        "{C:red}Destroy{} {C:attention}leftmost{} consumable at",
        "start of round, {C:red}self destructs{} if",
        "no consumable can be destroyed"
      ],
      "type": "Joker"
    },
    "j_fmod_fennex": {
      "name": "Fennex",
      "text": [
        "Every {C:attention}#1#{} rerolls, add",
        "a {C:attention}Voucher{} to the shop",
        "{C:inactive,s:0.8}(#2# remaining)"
      ],
      "type": "Joker"
    },
    "j_fmod_terminal_velocity": {
      "name": "Terminal Velocity",
      "text": [
        "Played {C:attention}Wild Cards{} permanently",
        "gain {X:mult,C:white}X#1#{} Mult"
      ],
      "type": "Joker"
    },
    "j_fmod_low_hanging_fruit": {
      "name": "Low Hanging Fruit",
      "text": [
        "Each played {C:attention}6{} or {C:attention}9",
        "gives {C:mult}+#2#{} Mult and",
        "{C:chips}+#1#{} Chips when scored"
      ],
      "type": "Joker"
    },
    "j_fmod_nerdcubed": {
      "name": "Nerdcubed",
      "text": [
        "Each played {C:attention}3{} is",
        "retriggered {C:attention}3{} times"
      ],
      "type": "Joker"
    },
    "j_fmod_penny_joker": {
      "name": "Penny Joker",
      "text": [
        "Gains {C:chips}+#2#{} Chip for",
        "every card scored",
        "{C:inactive}(Currently {C:chips}+#1#{C:inactive} Chips)"
      ],
      "type": "Joker"
    },
    "j_fmod_countdown": {
      "name": "Countdown",
      "text": [
        "The next {C:attention}#1#{} scored gives {C:mult}+#2#{} Mult,",
        "then required rank decreases by {C:attention}1{}",
        "When an {C:attention}#3#{} is reached and scored,",
        "it gives {X:mult,C:white}X#4#{} Mult"
      ],
      "type": "Joker"
    },
    "j_fmod_despicable_bear": {
      "name": "Despicable Bear",
      "text": [
        "Played {C:attention}Two Pair{} hands are",
        "considered {C:attention}Four of a Kind{}",
        "if played with exactly {C:attention}4{} cards"
      ],
      "type": "Joker"
    },
    "j_fmod_nerothefool": {
      "name": "Nero the Fool",
      "text": [
        "If {C:attention}first hand{} of round",
        "has exactly {C:attention}#1#{} cards,",
        "destroy them"
      ],
      "type": "Joker"
    },
    "j_fmod_negativejoker": {
      "name": "Negative Joker",
      "text": [
        "{C:chips}+#1#{} Chips, becomes",
        "{C:attention}Negative{} after {C:attention}#2#{} rounds",
        "{C:inactive}(Rounds left: {C:attention}#3#{C:inactive})"
      ],
      "type": "Joker"
    },
    "j_fmod_passport": {
      "name": "Passport",
      "text": [
        "{C:mult}+#1#{} Mult per unique",
        "{C:attention}poker hand{} played,",
        "resets after {C:attention}Boss Blind{}",
        "{C:inactive}(Currently: {C:mult}+#2#{C:inactive} Mult)"
      ],
      "type": "Joker"
    },
    "j_fmod_steve": {
      "name": "Steve",
      "text": [
        "Creates a random {C:dark_edition}Negative {C:attention}Food",
        "{C:attention}Joker{} at the start of each round"
      ],
      "type": "Joker"
    },
    "j_fmod_blue_angel_mushroom": {
      "name": "Blue Angel Mushroom",
      "text": [
        "The next {C:attention}#2#{} times",
        "you would {C:attention}die{}, instead",
        "resume the round with {C:blue}+1{} hand"
      ],
      "type": "Joker"
    },
    "j_fmod_impractical_joker": {
      "name": "Impractical Joker",
      "text": [
        "First {C:attention}lowest ranking{}",
        "card in played hand",
        "gives {X:mult,C:white}X#1#{} Mult",
        "when scored"
      ],
      "type": "Joker"
    },
    "j_fmod_ferromancy": {
      "name": "Ferromancy",
      "text": [
        "{C:attention}Gold Cards{} give {X:mult,C:white}X#1#{} Mult",
        "when held in hand",
        "{C:attention}Steel Cards{} give {C:money}$#2#{}",
        "at end of round",
        "{C:inactive}(Overrides default behavior)"
      ],
      "type": "Joker"
    },
    "j_fmod_jazzercise": {
      "name": "Jazzercise Joker",
      "text": [
        "Gains {C:attention}+#1#{} hand size for",
        "every {C:attention}#2# {C:inactive}[#3#]{} cards destroyed",
        "{C:inactive}(Currently {C:attention}+#4#{C:inactive})"
      ],
      "type": "Joker"
    },
    "j_fmod_pomni": {
      "name": "Pomni",
      "text": [
        "After skipping {C:attention}#2#{} Blinds, {C:attention}-#1#{} Ante",
        "{C:green}#3# in #4#{} chance for {C:attention}-#5#{} Ante instead",
        "{C:inactive}(Currently {C:attention}#6#{C:inactive}/#2#)"
      ],
      "type": "Joker"
    },
    "j_fmod_loonette": {
      "name": "Loonette",
      "text": [
        "{C:attention}Number{} cards give {X:mult,C:white}X#1#{} Mult when",
        "scored, increases by {X:mult,C:white}X#2#{} Mult for",
        "each consecutively scored {C:attention}number{} card",
        "{C:inactive}(Resets after hand played)"
      ],
      "type": "Joker"
    },
    "j_fmod_wordle": {
      "name": "Wordle",
      "text": [
        "Gains {C:chips}+#1#{} Chips if played",
        "hand contains a scoring",
        "{C:attention}3{}, {C:attention}7{}, {C:attention}8{}, or {C:attention}Queen{}",
        "{C:inactive}(Currently {C:chips}+#2#{C:inactive} Chips)"
      ],
      "type": "Joker"
    },
    "j_fmod_hyperfixation": {
      "name": "Hyperfixation",
      "text": [
        "Each played {C:attention}#1#{} of {V:1}#2#{}",
        "is retriggered {C:attention}#3#{} time#7#",
        "Gains {C:attention}1{} retrigger every {C:attention}#5#{} {C:inactive}[#6#]{} times",
        "a round's {C:attention}required rank{} (#4#) is scored",
        "{C:inactive}(Required rank changes every round)"
      ],
      "type": "Joker"
    },
    "j_fmod_fragile_sticker": {
      "name": "Fragile Sticker",
      "text": [
        "{C:attention}Glass Cards{} no longer",
        "break through use"
      ],
      "type": "Joker"
    },
    "j_fmod_ghost_trick": {
      "name": "Ghost Trick",
      "text": [
        "Played cards have a {C:green}#1# in #2#{} chance",
        "to create a {C:dark_edition}Negative {C:spectral}Spectral{}",
        "card when {C:attention}retriggered"
      ],
      "type": "Joker"
    },
    "j_fmod_rabbit": {
      "name": "Rabbit",
      "text": [
        "The first {C:attention}#1#{} times each round",
        "you play a {C:attention}Five of a Kind{},",
        "create a {C:attention}copy{} of the leftmost",
        "played card and {C:attention}discard{} it",
        "{C:inactive}(Currently {C:attention}#2#{C:inactive} remaining){}"
      ],
      "type": "Joker"
    },
    "j_fmod_crazy_neils_crazy_deals": {
      "name": "Crazy Neil's Crazy Deals",
      "text": [
        "One random shop item is",
        "{C:attention}#1#%{} off every shop"
      ],
      "type": "Joker"
    },
    "j_fmod_pop_idol_cat": {
      "name": "Pop Idol Cat",
      "text": [
        "Increase the {C:green}odds{} of {C:attention}Lucky",
        "{C:attention}Cards{} by {C:green}#1#{} every time",
        "one is triggered, {C:attention}resets{}",
        "after hand played"
      ],
      "type": "Joker"
    },
    "j_fmod_pub_burger": {
      "name": "Pub Burger",
      "text": [
        "{C:attention}+#1#{} discards, {C:red}-#2#{}",
        "for every hand played",
        "after the first hand"
      ],
      "type": "Joker"
    },
    "j_fmod_orbit": {
      "name": "Orbit",
      "text": [
        "If holding a non-{C:dark_edition}Negative",
        "{C:planet}Planet{} card at end of round,",
        "create a random {C:dark_edition}Negative {C:planet}Planet{}"
      ],
      "type": "Joker"
    },
    "j_fmod_calculator": {
      "name": "Calculator",
      "text": [
        "Gives {X:mult,C:white}XMult{} equal to the {C:attention}rank difference",
        "between first and last {C:attention}scored{} cards,",
        "{C:red}inactive{} for that many hands after scoring",
        "{C:inactive}(No effect if difference <= 1)",
        "{C:inactive}(#1#{C:attention}#2#{C:inactive}#3#)"
      ],
      "type": "Joker"
    },
    "j_fmod_tax_return": {
      "name": "Tax Return",
      "text": [
        "Earn {C:money}$#1#{} for each",
        "{C:attention}unscored{} card in",
        "played hand"
      ],
      "type": "Joker"
    },
    "j_fmod_civic_secretary": {
      "name": "Civic Secretary",
      "text": [
        "When another Joker gives",
        "{C:chips}+Chips{} or {C:mult}+Mult{}, that amount",
        "is {C:attention}matched{} by this Joker"
      ],
      "type": "Joker"
    },
    "j_fmod_trans_joker": {
      "name": "Trans Joker",
      "text": [
        "Any cards that have had",
        "their {C:attention,V:1}rank{} or {C:attention,V:2}suit{} changed",
        "gain {C:mult}+#1#{} Mult"
      ],
      "type": "Joker"
    },
    "j_fmod_litterbug": {
      "name": "Litterbug",
      "text": [
        "When hand played, {C:attention}discards{} a",
        "random card and gains {C:white,X:mult}#2#X{}",
        "its base {C:chips}Chip value{} as {C:mult}XMult{}",
        "{C:inactive}(Currently {C:white,X:mult}X#1#{C:inactive} Mult)"
      ],
      "type": "Joker"
    },
    "j_fmod_sad_clown": {
      "name": "Sad Clown",
      "text": [
        "Creates a random {V:1}Silly{} card",
        "every {C:attention}#1# {C:inactive}[#2#]{} discards",
        "{C:inactive}(Must have room)"
      ],
      "type": "Joker"
    },
    "j_fmod_claw_machine": {
      "name": "Claw Machine",
      "text": [
        "Each {C:attention}7{} held in hand gives",
        "{C:white,X:mult}X#1#{} Mult, and has a {C:green}#2#",
        "{C:green}in #3#{} chance to increase",
        "given Mult by {C:white,X:mult}X#4#"
      ],
      "type": "Joker"
    },
    "j_fmod_fennex_the_clown": {
      "name": "Fennex the Clown",
      "text": [
        "This Joker gains {C:white,X:mult}X#1#{}",
        "Mult per {C:attention}Voucher{} owned",
        "{C:inactive}(Currently {C:white,X:mult}X#2#{C:inactive})"
      ],
      "type": "Joker"
    },
    "j_fmod_dating_sim": {
      "name": "Dating Sim",
      "text": [
        "Played {C:hearts}Hearts{} permanently",
        "gain {C:chips}+#1#{} Chips when",
        "scored"
      ],
      "type": "Joker"
    },
    "j_fmod_rhythm_game": {
      "name": "Rhythm Game",
      "text": [
        "Played {C:diamonds}Diamonds{C:attention} retrigger",
        "when scored"
      ],
      "type": "Joker"
    },
    "j_fmod_dungeon_crawler": {
      "name": "Dungeon Crawler",
      "text": [
        "If played hand contains a",
        "scoring {C:spades}Spade{}, a {C:spades}Spade in",
        "that hand is given a random",
        "{C:attention}Enhancement{}, {C:attention}Seal{}, or {C:attention}Marking{}",
        "{C:inactive}(Won't override existing modifiers)"
      ],
      "type": "Joker"
    },
    "j_fmod_fighting_game": {
      "name": "Fighting Game",
      "text": [
        "Played {C:clubs}Clubs{} have a",
        "{C:green}#1# in #2#{} chance to",
        "give {C:attention}+#3# hand size{}",
        "until end of round"
      ],
      "type": "Joker"
    },
    "j_fmod_free_shipping": {
      "name": "Free Shipping",
      "text": [
        "Consumables created",
        "by {C:attention}Raffle Cards{} are",
        "{C:dark_edition}Negative"
      ],
      "type": "Joker"
    },
    "j_fmod_comic_book_ad": {
      "name": "Comic Book Ad",
      "text": [
        "{C:attention}Raffle Cards{} always",
        "generate {V:1}Silly{} cards"
      ],
      "type": "Joker"
    },
    "j_fmod_lottery": {
      "name": "Lottery",
      "text": [
        "{C:green}#1# in #2#{} chance to gain",
        "between {C:money}$#3#{} and {C:money}$#4# {C:attention}sell",
        "{C:attention}value{} at end of round"
      ],
      "type": "Joker"
    },
    "j_fmod_detective": {
      "name": "Detective",
      "text": [
        "{C:attention}Cards{} that were previously",
        "played this {C:attention}Ante{} give {C:money}$#1#"
      ],
      "type": "Joker"
    },
    "j_fmod_strange_dreams": {
      "name": "Strange Dreams",
      "text": [
        "After hand played, turn",
        "a random {C:attention}unscored{} card",
        "into the {C:attention}rightmost scored",
        "card"
      ],
      "type": "Joker"
    },
    "j_fmod_ransome": {
      "name": "Ransome",
      "text": [
        "When a card is {C:attention}destroyed{},",
        "creates a {C:dark_edition}Polychrome{} copy",
        "with a {C:red}Red Seal{}"
      ],
      "type": "Joker"
    },
    "j_fmod_feline_fleecer": {
      "name": "Feline Fleecer",
      "text": [
        "Add a free {C:attention}Remix Pack",
        "to the {C:attention}Shop{} upon",
        "beating a {C:attention}Blind"
      ],
      "type": "Joker"
    },
    "j_fmod_tem_shop": {
      "name": "Tem Shop",
      "text": [
        "{C:attention}Sell value{} of all cards",
        "starts off at {C:attention}75%{} of",
        "their {C:attention}base{} price"
      ],
      "type": "Joker"
    },
    "j_fmod_debut_album": {
      "name": "Debut Album",
      "text": [
        "{C:white,X:mult}X#1#{} Mult, {C:white,X:mult}-X#2#{} Mult",
        "per hand played",
        "{C:inactive}(Self destructs at {C:white,X:mult}X1{C:inactive} Mult)"
      ],
      "type": "Joker"
    },
    "j_fmod_zany_to_the_max": {
      "name": "Zany to the Max",
      "text": [
        "If played hand is a {C:attention}Three of a Kind,",
        "gain {C:chips}+#1#{} Chips, {C:mult}+#2#{} Mult, or {C:white,X:mult}+X#3#{} Mult",
        "{C:inactive}(Currently {C:chips}+#4#{C:inactive} Chips, {C:mult}+#5#{C:inactive} Mult, {C:white,X:mult}X#6#{C:inactive} Mult)"
      ],
      "type": "Joker"
    },
    "j_fmod_ghostly_joker": {
      "name": "Ghostly Joker",
      "text": [
        "Creates a {C:attention}Death{} {C:tarot}Tarot{} card for",
        "every {C:attention}fourth{} scoring {C:attention}4 {C:inactive}[#1#]",
        "{C:inactive}(Must have room)"
      ],
      "type": "Joker"
    },
    "j_fmod_friend_inside_me": {
      "name": "Friend Inside Me",
      "text": [
        "If {C:attention}first discard{} of round has",
        "only {C:attention}1{} card, {C:attention}destroy{} it and",
        "create {C:attention}#1#{} temporary copies",
        "{C:inactive}(Destroyed at end of round)"
      ],
      "type": "Joker"
    },
    "j_fmod_prismatic_joker": {
      "name": "Prismatic Joker",
      "text": [
        "If played hand contains a",
        "{C:attention}Four of a Kind{}, all {C:attention}scored",
        "cards become {C:attention}Copycat",
        "{C:attention}Cards"
      ],
      "type": "Joker"
    },
    "j_fmod_newtons_cradle": {
      "name": "Newton's Cradle",
      "text": [
        "For every non-{C:attention}High Card{} hand",
        "played consisting of only {V:1}#1#{},",
        "the {C:attention}rightmost{} card gains {C:attention}#3#{}",
        "retriggers {C:inactive}(Currently {C:attention}#2#{C:inactive})",
        "{C:inactive}(Retriggers reset, suit changes",
        "{C:inactive}at end of round)"
      ],
      "type": "Joker"
    },
    "tag_fmod_appraisal": {
      "name": "Appraisal Tag",
      "text": [
        "Gives {C:money}$#1#{} for each {C:attention}Enhanced",
        "card in your full deck",
        "{C:inactive}(Will give {C:money}$#2#{C:inactive})"
      ],
      "type": "Tag"
    },
    "tag_fmod_lunchbreak": {
      "name": "Lunch Break Tag",
      "text": [
        "Creates a random",
        "{C:dark_edition}Negative {C:attention}Food Joker{}"
      ],
      "type": "Tag"
    },
    "tag_fmod_boost": {
      "name": "Boost Tag",
      "text": [
        "Adds two {C:attention}free",
        "{C:attention}Booster Packs",
        "to the next shop"
      ],
      "type": "Tag"
    },
    "tag_fmod_goofy": {
      "name": "Goofy Tag",
      "text": [
        "Gives a free",
        "{V:1}Mega Silly Pack{}"
      ],
      "type": "Tag"
    },
    "bl_fmod_hoard": {
      "name": "The Hoard",
      "text": [
        "All number cards",
        "are drawn face down"
      ],
      "type": "Blind"
    },
    "bl_fmod_tool": {
      "name": "The Tool",
      "text": [
        "All consumables",
        "are debuffed"
      ],
      "type": "Blind"
    },
    "bl_fmod_baby": {
      "name": "The Baby",
      "text": [
        "All enhanced cards",
        "are drawn face down"
      ],
      "type": "Blind"
    },
    "bl_fmod_priest": {
      "name": "The Priest",
      "text": [
        "Cannot play more",
        "than 4 cards"
      ],
      "type": "Blind"
    },
    "bl_fmod_dice": {
      "name": "The Dice",
      "text": [
        "All odds fall",
        "to zero"
      ],
      "type": "Blind"
    },
    "bl_fmod_final_sword": {
      "name": "Ivory Sword",
      "text": [
        "Cannot play a",
        "#1#"
      ],
      "type": "Blind"
    },
    "bl_fmod_light": {
      "name": "The Light",
      "text": [
        "Played Enhanced cards",
        "lose their Enhancements"
      ],
      "type": "Blind"
    },
    "bl_fmod_elder": {
      "name": "The Elder",
      "text": [
        "All unenhanced cards",
        "are drawn face down"
      ],
      "type": "Blind"
    },
    "bl_fmod_flux": {
      "name": "The Flux",
      "text": [
        "Two random suits",
        "debuffed every hand"
      ],
      "type": "Blind"
    },
    "bl_fmod_final_shield": {
      "name": "Saffron Shield",
      "text": [
        "All #1#s are",
        "debuffed"
      ],
      "type": "Blind"
    },
    "bl_fmod_final_horn": {
      "name": "Lavender Horn",
      "text": [
        "All cards are",
        "drawn face down"
      ],
      "type": "Blind"
    },
    "bl_fmod_thorn": {
      "name": "The Thorn",
      "text": [
        "Cards with seals",
        "are debuffed"
      ],
      "type": "Blind"
    },
    "b_fmod_recursive": {
      "name": "Recursive Deck",
      "text": [
        "{C:attention}Joker{}, {C:tarot}Tarot{}, {C:planet}Planet{},",
        "and {C:spectral}Spectral{} cards may",
        "appear multiple times"
      ],
      "type": "Back"
    },
    "b_fmod_fennex": {
      "name": "Fennex Deck",
      "text": [
        "Start run with the",
        "{C:attention,T:j_fmod_fennex}Fennex{} Joker,",
        "{C:legendary}Lucky Rabbit{C:attention} Jokers{} are",
        "{X:green,C:white}3X{} more likely to appear"
      ],
      "type": "Back"
    },
    "b_fmod_clown": {
      "name": "Clown Deck",
      "text": [
        "Start run with the",
        "{V:1,T:v_fmod_circus}#1#{} Voucher"
      ],
      "type": "Back"
    },
    "b_fmod_reaper": {
      "name": "Reaper Deck",
      "text": [
        "Every Boss Blind is a",
        "{C:attention}Finisher Blind{} with {X:mult,C:white}X2{} {C:red}Size{}",
        "{C:chips}+1{} Hand, {C:red}+1{} Discard, {C:attention}+1{}",
        "Hand Size, {C:attention}+1{} Joker Slot"
      ],
      "type": "Back"
    },
    "b_fmod_harmony": {
      "name": "Harmony Deck",
      "text": [
        "All cards in deck are",
        "the same {C:attention}rank{} and {C:attention}suit{}",
        "{C:red}-2{} Discards"
      ],
      "type": "Back"
    },
    "c_fmod_pie": {
      "name": "Pie",
      "text": [
        "Select {C:attention}#1#{} cards, copy the",
        "{C:attention}rank{} of the {C:attention}left{} card",
        "onto the {C:attention}right{} card"
      ],
      "type": "Silly"
    },
    "c_fmod_clown_car": {
      "name": "Clown Car",
      "text": [
        "Creates a random {C:dark_edition}Negative{}",
        "{C:attention}Joker{}, {C:money}-$#1#{} for each",
        "{C:dark_edition}Negative{} Joker owned",
        "{C:inactive}(Joker has no {C:attention}sell value{C:inactive})"
      ],
      "type": "Silly"
    },
    "c_fmod_bang_gun": {
      "name": "Bang Gun",
      "text": [
        "Select {C:attention}#1#{} cards, copy the",
        "{C:attention}suit{} of the {C:attention}left{} card",
        "onto the {C:attention}right{} card"
      ],
      "type": "Silly"
    },
    "c_fmod_squirt_flower": {
      "name": "Squirt Flower",
      "text": [
        "Select {C:attention}#1#{} cards, copy the",
        "{C:attention}seal{} of the {C:attention}left{} card",
        "onto the {C:attention}right{} card"
      ],
      "type": "Silly"
    },
    "c_fmod_whoopie_cushion": {
      "name": "Whoopie Cushion",
      "text": [
        "Select {C:attention}#1#{} cards, copy the",
        "{C:attention}Enhancement{} of the {C:attention}left card",
        "onto the {C:attention}right{} card"
      ],
      "type": "Silly"
    },
    "c_fmod_joy_buzzer": {
      "name": "Joy Buzzer",
      "text": [
        "Select {C:attention}#1#{} cards, copy the",
        "{C:dark_edition}Edition{} of the {C:attention}left card",
        "onto the {C:attention}right{} card"
      ],
      "type": "Silly"
    },
    "c_fmod_midway_games": {
      "name": "Midway Games",
      "text": [
        "Gives a {C:attention}Standard Tag{},",
        "{C:tarot}Charm Tag{}, {C:planet}Meteor Tag{},",
        "or {C:inactive}Buffoon Tag{}"
      ],
      "type": "Silly"
    },
    "c_fmod_juggler": {
      "name": "Juggler",
      "text": [
        "Gain {C:money}$#1#{}. Increases",
        "by +{C:money}$#2#{} each time",
        "Juggler is used this run"
      ],
      "type": "Silly"
    },
    "c_fmod_balloons": {
      "name": "Balloons",
      "text": [
        "{C:attention}Doubles{} the {C:chips}Chip value{}",
        "of all cards held in hand",
        "{C:inactive}(Excludes {C:dark_edition}Editions{C:inactive})"
      ],
      "type": "Silly"
    },
    "c_fmod_split_pants": {
      "name": "Split Pants",
      "text": [
        "Decreases rank of",
        "up to {C:attention}#1#{} selected",
        "cards by {C:attention}1"
      ],
      "type": "Silly"
    },
    "c_fmod_balloon_animal": {
      "name": "Balloon Animal",
      "text": [
        "Gain {C:money}$#1#{} per unique",
        "{C:attention}rank{} in your hand",
        "{C:inactive}(Currently {C:money}$#2#{C:inactive})"
      ],
      "type": "Silly"
    },
    "c_fmod_soully": {
      "name": "Soully",
      "text": [
        "Creates a {C:legendary,E:1}Legendary{} Joker",
        "from the {C:attention}Lucky Rabbit{} Mod",
        "{C:inactive}(Must have room)"
      ],
      "type": "Silly"
    },
    "c_fmod_tightrope": {
      "name": "Tightrope",
      "text": [
        "{C:green}50%{} chance to create",
        "{C:attention}1{} copy of {C:attention}1{} selected card",
        "{C:green}25%{} chance to create",
        "{C:attention}2{} copies",
        "{C:green}25%{} chance to {C:red}destroy{}",
        "selected card",
        "{C:inactive}(Odds cannot be changed)"
      ],
      "type": "Silly"
    },
    "c_fmod_fire_breath": {
      "name": "Fire Breath",
      "text": [
        "Destroy selected {C:attention}Joker{}, then",
        "copy its {C:dark_edition}Edition{} onto the",
        "{C:attention}Joker{} to its right"
      ],
      "type": "Silly"
    },
    "c_fmod_rodeo": {
      "name": "Rodeo",
      "text": [
        "Select {C:attention}#1#{} cards. Give a random one",
        "{C:dark_edition}Foil{}, {C:dark_edition}Holographic{}, or {C:dark_edition}Polychrome{},",
        "and {C:red}destroy{} the other"
      ],
      "type": "Silly"
    },
    "c_fmod_endless_scarf": {
      "name": "Endless Scarf",
      "text": [
        "{C:attention}+#1#{} hand size",
        "until end of round"
      ],
      "type": "Silly"
    },
    "c_fmod_knife_throw": {
      "name": "Knife Throw",
      "text": [
        "Select up to {C:attention}#1#{} cards,",
        "each selected card will",
        "either gain a random",
        "{C:attention}Seal{}, or be destroyed"
      ],
      "type": "Silly"
    },
    "c_fmod_trapeze": {
      "name": "Trapeze",
      "text": [
        "After using Trapeze {C:attention}#2#{} times,",
        "its next appearance will be",
        "replaced by a {C:attention}Soul{} card",
        "{C:inactive}(Currently {C:attention}#1#{C:inactive}/#2#)"
      ],
      "type": "Silly"
    },
    "c_fmod_greasepaint": {
      "name": "Greasepaint",
      "text": [
        "Select up to {C:attention}#1#{} cards to",
        "{C:attention}mark{} with {C:attention}Ink{}"
      ],
      "type": "Silly"
    },
    "c_fmod_unicycle": {
      "name": "Unicycle",
      "text": [
        "Select up to {C:attention}#1#{} cards to",
        "{C:attention}mark{} with a {C:attention}Crease{}"
      ],
      "type": "Silly"
    },
    "c_fmod_cannon": {
      "name": "Cannon",
      "text": [
        "Select up to {C:attention}#1#{} cards to",
        "{C:attention}mark{} with a {C:attention}Pinhole{}"
      ],
      "type": "Silly"
    },
    "c_fmod_barker": {
      "name": "Barker",
      "text": [
        "Enhances {C:attention}#1#",
        "selected cards into",
        "{C:attention}Raffle Cards{}"
      ],
      "type": "Silly"
    },
    "c_fmod_suspenders": {
      "name": "Suspenders",
      "text": [
        "Select {C:attention}#1#{} cards, copy the",
        "{C:attention}Clip{} of the {C:attention}left{} card",
        "onto the {C:attention}right{} card"
      ],
      "type": "Silly"
    },
    "c_fmod_hall_of_mirrors": {
      "name": "Hall of Mirrors",
      "text": [
        "Enhances {C:attention}#1#",
        "selected cards into",
        "{C:attention}Copycat Cards{}"
      ],
      "type": "Silly"
    },
    "v_fmod_circus": {
      "name": "Circus",
      "text": [
        "{V:1}Silly Cards{} may",
        "appear in any of",
        "the {C:tarot}Arcana{} packs"
      ],
      "type": "Voucher"
    },
    "v_fmod_showtime": {
      "name": "Showtime",
      "text": [
        "{V:1}Silly Cards{} can",
        "be purchased",
        "in the {C:attention}shop{}"
      ],
      "type": "Voucher"
    },
    "v_fmod_reroll_superfluity": {
      "name": "Reroll Superfluity",
      "text": [
        "Rerolls only increase",
        "in price {C:attention}every",
        "{C:attention}other{} reroll"
      ],
      "type": "Voucher"
    },
    "v_fmod_buffet": {
      "name": "Buffet",
      "text": [
        "Permanently gain",
        "yet another {C:blue}+#1#{}",
        "hands per round"
      ],
      "type": "Voucher"
    },
    "v_fmod_dumpster_ritual": {
      "name": "Dumpster Ritual",
      "text": [
        "Permanently gain",
        "yet another {C:red}+#1#{}",
        "discards each round"
      ],
      "type": "Voucher"
    },
    "v_fmod_anti_higgs_boson": {
      "name": "Anti-Higgs Boson",
      "text": [
        "{C:dark_edition}+1{} Joker Slot",
        "The {C:inactive}Blank{} and {C:dark_edition}Antimatter{}",
        "{C:attention}Vouchers{} are returned",
        "to the {C:attention}Voucher{} pool"
      ],
      "type": "Voucher"
    },
    "v_fmod_big_bang": {
      "name": "Big Bang",
      "text": [
        "{C:attention}-#1#{} Ante,",
        "{C:attention}-#2#{} hand size"
      ],
      "type": "Voucher"
    },
    "v_fmod_color_swatches": {
      "name": "Color Swatches",
      "text": [
        "{C:attention}+#1#{} hand size"
      ],
      "type": "Voucher"
    },
    "v_fmod_fire_sale": {
      "name": "Fire Sale",
      "text": [
        "{C:attention}+#1#{} card slot,",
        "{C:attention}+#2#{} {C:attention}Booster Pack{} slot",
        "available in shop"
      ],
      "type": "Voucher"
    },
    "v_fmod_coupon": {
      "name": "Coupon",
      "text": [
        "{C:attention}+#1#{} consumable slot"
      ],
      "type": "Voucher"
    },
    "v_fmod_extreme_couponing": {
      "name": "Extreme Couponing",
      "text": [
        "{C:attention}+#1#{} additional consumable slot"
      ],
      "type": "Voucher"
    },
    "v_fmod_shopaholic": {
      "name": "Shopaholic",
      "text": [
        "Add a {C:attention}free{}",
        "{C:attention}Booster Pack{}",
        "to each shop"
      ],
      "type": "Voucher"
    },
    "v_fmod_grab_bag": {
      "name": "Grab Bag",
      "text": [
        "Open a free {C:attention}Remix{}",
        "{C:attention}Pack{} upon clearing",
        "a {C:attention}Boss Blind{}"
      ],
      "type": "Voucher"
    },
    "v_fmod_gachapon": {
      "name": "Gachapon",
      "text": [
        "{C:attention}Remix Packs{}",
        "appear in the",
        "{C:attention}shop"
      ],
      "type": "Voucher"
    },
    "v_fmod_mystery_box": {
      "name": "Mystery Box",
      "text": [
        "+1 {C:attention}Booster Pack{}",
        "available in the",
        "{C:attention}shop"
      ],
      "type": "Voucher"
    },
    "m_fmod_raffle_card": {
      "name": "Raffle Card",
      "text": [
        "{C:green}#1# in #2#{} chance to create",
        "a random {C:attention}Consumable",
        "when scored",
        "{C:inactive}(Must have room)"
      ],
      "type": "Enhanced"
    },
    "m_fmod_copycat_card": {
      "name": "Copycat Card",
      "text": [
        "All Copycat cards in deck",
        "become the same random",
        "{C:attention}rank{} after scoring"
      ],
      "type": "Enhanced"
    },
    "p_fmod_silly_small": {
      "name": "Silly Pack",
      "text": [
        "Choose {C:attention}#1#{} of up to",
        "{C:attention}#2# {V:1}Silly{} cards to",
        "be used immediately"
      ],
      "type": "Other"
    },
    "p_fmod_silly_small_2": {
      "name": "Silly Pack",
      "text": [
        "Choose {C:attention}#1#{} of up to",
        "{C:attention}#2# {V:1}Silly{} cards to",
        "be used immediately"
      ],
      "type": "Other"
    },
    "p_fmod_silly_small_3": {
      "name": "Silly Pack",
      "text": [
        "Choose {C:attention}#1#{} of up to",
        "{C:attention}#2# {V:1}Silly{} cards to",
        "be used immediately"
      ],
      "type": "Other"
    },
    "p_fmod_silly_small_4": {
      "name": "Silly Pack",
      "text": [
        "Choose {C:attention}#1#{} of up to",
        "{C:attention}#2# {V:1}Silly{} cards to",
        "be used immediately"
      ],
      "type": "Other"
    },
    "p_fmod_silly_jumbo": {
      "name": "Jumbo Silly Pack",
      "text": [
        "Choose {C:attention}#1#{} of up to",
        "{C:attention}#2# {V:1}Silly{} cards to",
        "be used immediately"
      ],
      "type": "Other"
    },
    "p_fmod_silly_jumbo_2": {
      "name": "Jumbo Silly Pack",
      "text": [
        "Choose {C:attention}#1#{} of up to",
        "{C:attention}#2# {V:1}Silly{} cards to",
        "be used immediately"
      ],
      "type": "Other"
    },
    "p_fmod_silly_mega": {
      "name": "Mega Silly Pack",
      "text": [
        "Choose {C:attention}#1#{} of up to",
        "{C:attention}#2# {V:1}Silly{} cards to",
        "be used immediately"
      ],
      "type": "Other"
    },
    "p_fmod_silly_mega_2": {
      "name": "Mega Silly Pack",
      "text": [
        "Choose {C:attention}#1#{} of up to",
        "{C:attention}#2# {V:1}Silly{} cards to",
        "be used immediately"
      ],
      "type": "Other"
    },
    "p_fmod_remix_small_1": {
      "name": "Remix Pack",
      "text": [
        "Choose {C:attention}#1#{} of up to {C:attention}#2#",
        "{C:attention}Jokers{}, {C:attention}Playing{} cards, or",
        "{C:attention}Consumables{} to add or use"
      ],
      "type": "Other"
    },
    "p_fmod_remix_small_2": {
      "name": "Remix Pack",
      "text": [
        "Choose {C:attention}#1#{} of up to {C:attention}#2#",
        "{C:attention}Jokers{}, {C:attention}Playing{} cards, or",
        "{C:attention}Consumables{} to add or use"
      ],
      "type": "Other"
    },
    "p_fmod_remix_jumbo": {
      "name": "Jumbo Remix Pack",
      "text": [
        "Choose {C:attention}#1#{} of up to {C:attention}#2#",
        "{C:attention}Jokers{}, {C:attention}Playing{} cards, or",
        "{C:attention}Consumables{} to add or use"
      ],
      "type": "Other"
    },
    "p_fmod_remix_mega": {
      "name": "Mega Remix Pack",
      "text": [
        "Choose {C:attention}#1#{} of up to {C:attention}#2#",
        "{C:attention}Jokers{}, {C:attention}Playing{} cards, or",
        "{C:attention}Consumables{} to add or use"
      ],
      "type": "Other"
    },
    "fmod_ink_mark": {
      "name": "Inked",
      "text": [
        "Cannot be",
        "{C:attention}flipped"
      ],
      "type": "Other"
    },
    "fmod_crease_mark": {
      "name": "Creased",
      "text": [
        "Always shuffled to",
        "the {C:attention}top{} of deck"
      ],
      "type": "Other"
    },
    "fmod_pinhole_mark": {
      "name": "Pinholed",
      "text": [
        "{C:attention}Returns{} to the",
        "deck when played"
      ],
      "type": "Other"
    },
    "k_fmod_fuel": {
      "name": "\"Fueled!\"",
      "text": [],
      "type": "dictionary"
    },
    "k_fmod_drained": {
      "name": "\"Drained!\"",
      "text": [],
      "type": "dictionary"
    },
    "k_fmod_neil_deal": {
      "name": "\"Discounted!\"",
      "text": [],
      "type": "dictionary"
    },
    "k_fmod_sillypack": {
      "name": "\"Silly Pack\"",
      "text": [],
      "type": "dictionary"
    },
    "k_fmod_remixpack": {
      "name": "\"Remix Pack\"",
      "text": [],
      "type": "dictionary"
    },
    "r_fmod_mostplayed": {
      "name": "\"(most played rank)\"",
      "text": [],
      "type": "dictionary"
    },
    "k_fmod_config_restart": {
      "name": "\"Requires Restart\"",
      "text": [],
      "type": "dictionary"
    },
    "k_fmod_config_jokers": {
      "name": "\"Enable Jokers\"",
      "text": [],
      "type": "dictionary"
    },
    "k_fmod_config_silly": {
      "name": "\"Enable Silly Cards\"",
      "text": [],
      "type": "dictionary"
    },
    "k_fmod_config_vouchers": {
      "name": "\"Enable Vouchers\"",
      "text": [],
      "type": "dictionary"
    },
    "k_fmod_config_blinds": {
      "name": "\"Enable Blinds\"",
      "text": [],
      "type": "dictionary"
    },
    "k_fmod_config_tags": {
      "name": "\"Enable Tags\"",
      "text": [],
      "type": "dictionary"
    },
    "k_fmod_config_decks": {
      "name": "\"Enable Decks\"",
      "text": [],
      "type": "dictionary"
    },
    "k_fmod_config_markings": {
      "name": "\"Enable Markings\"",
      "text": [],
      "type": "dictionary"
    },
    "k_fmod_config_enhancements": {
      "name": "\"Enable Enhancements\"",
      "text": [],
      "type": "dictionary"
    },
    "k_fmod_config_remix": {
      "name": "\"Enable Remix Packs\"",
      "text": [],
      "type": "dictionary"
    },
    "k_fmod_planet_orbit": {
      "name": "\"+1 Planet\"",
      "text": [],
      "type": "dictionary"
    },
    "k_fmod_debut_destruct": {
      "name": "\"Finished!\"",
      "text": [],
      "type": "dictionary"
    },
    "k_fmod_copycat": {
      "name": "\"Copycat!\"\n        ",
      "text": [],
      "type": "dictionary"
    },
    "a_fmod_discards": {
      "name": "\"+#1# Discards\"",
      "text": [],
      "type": "v_dictionary"
    },
    "a_fmod_silly_card": {
      "name": "\"+#1# Silly\"",
      "text": [],
      "type": "v_dictionary"
    },
    "a_fmod_money": {
      "name": "\"+$#1#\"",
      "text": [],
      "type": "v_dictionary"
    },
    "a_fmod_booster": {
      "name": "\"+#1# Booster\"",
      "text": [],
      "type": "v_dictionary"
    }
  },
  "atlases": {
    "Jokers": {
      "path": "Jokers.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/Lucky-Rabbit@Trif3ctal/v1.2.2/Jokers.png",
      "resolvedGitHubPath": "assets/1x/Jokers.png"
    },
    "Consumables": {
      "path": "Consumables.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/Lucky-Rabbit@Trif3ctal/v1.2.2/Consumables.png",
      "resolvedGitHubPath": "assets/1x/Consumables.png"
    },
    "modicon": {
      "path": "Fennex_Mod_Icon.png",
      "px": 32,
      "py": 32,
      "localPath": "/wiki-data/Lucky-Rabbit@Trif3ctal/v1.2.2/Fennex_Mod_Icon.png",
      "resolvedGitHubPath": "assets/1x/Fennex_Mod_Icon.png"
    },
    "Vouchers": {
      "path": "Vouchers.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/Lucky-Rabbit@Trif3ctal/v1.2.2/Vouchers.png",
      "resolvedGitHubPath": "assets/1x/Vouchers.png"
    },
    "Blinds": {
      "path": "Blinds.png",
      "px": 34,
      "py": 34,
      "localPath": "/wiki-data/Lucky-Rabbit@Trif3ctal/v1.2.2/Blinds.png",
      "resolvedGitHubPath": "assets/1x/Blinds.png"
    },
    "Tags": {
      "path": "Tags.png",
      "px": 34,
      "py": 34,
      "localPath": "/wiki-data/Lucky-Rabbit@Trif3ctal/v1.2.2/Tags.png",
      "resolvedGitHubPath": "assets/1x/Tags.png"
    },
    "Boosters": {
      "path": "Booster.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/Lucky-Rabbit@Trif3ctal/v1.2.2/Booster.png",
      "resolvedGitHubPath": "assets/1x/Booster.png"
    },
    "Decks": {
      "path": "Decks.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/Lucky-Rabbit@Trif3ctal/v1.2.2/Decks.png",
      "resolvedGitHubPath": "assets/1x/Decks.png"
    },
    "peppered_diamonds_lc": {
      "path": "collabs/peppered_diamonds_lc.png",
      "px": 71,
      "py": 95,
      "resolvedGitHubPath": "assets/1x/collabs/peppered_diamonds_lc.png"
    },
    "peppered_diamonds_hc": {
      "path": "collabs/peppered_diamonds_hc.png",
      "px": 71,
      "py": 95,
      "resolvedGitHubPath": "assets/1x/collabs/peppered_diamonds_hc.png"
    },
    "yttd_clubs_lc": {
      "path": "collabs/yttd_clubs_lc.png",
      "px": 71,
      "py": 95,
      "resolvedGitHubPath": "assets/1x/collabs/yttd_clubs_lc.png"
    },
    "yttd_clubs_hc": {
      "path": "collabs/yttd_clubs_hc.png",
      "px": 71,
      "py": 95,
      "resolvedGitHubPath": "assets/1x/collabs/yttd_clubs_hc.png"
    },
    "catgirl_hearts_lc": {
      "path": "collabs/catgirl_hearts_lc.png",
      "px": 71,
      "py": 95,
      "resolvedGitHubPath": "assets/1x/collabs/catgirl_hearts_lc.png"
    },
    "catgirl_hearts_hc": {
      "path": "collabs/catgirl_hearts_hc.png",
      "px": 71,
      "py": 95,
      "resolvedGitHubPath": "assets/1x/collabs/catgirl_hearts_hc.png"
    },
    "deathnote_spades_lc": {
      "path": "collabs/deathnote_spades_lc.png",
      "px": 71,
      "py": 95,
      "resolvedGitHubPath": "assets/1x/collabs/deathnote_spades_lc.png"
    },
    "deathnote_spades_hc": {
      "path": "collabs/deathnote_spades_hc.png",
      "px": 71,
      "py": 95,
      "resolvedGitHubPath": "assets/1x/collabs/deathnote_spades_hc.png"
    },
    "deltarune_hearts_lc": {
      "path": "collabs/deltarune_hearts_lc.png",
      "px": 71,
      "py": 95,
      "resolvedGitHubPath": "assets/1x/collabs/deltarune_hearts_lc.png"
    },
    "deltarune_hearts_hc": {
      "path": "collabs/deltarune_hearts_hc.png",
      "px": 71,
      "py": 95,
      "resolvedGitHubPath": "assets/1x/collabs/deltarune_hearts_hc.png"
    },
    "celeste_spades_lc": {
      "path": "collabs/celeste_spades_lc.png",
      "px": 71,
      "py": 95,
      "resolvedGitHubPath": "assets/1x/collabs/celeste_spades_lc.png"
    },
    "celeste_spades_hc": {
      "path": "collabs/celeste_spades_hc.png",
      "px": 71,
      "py": 95,
      "resolvedGitHubPath": "assets/1x/collabs/celeste_spades_hc.png"
    },
    "peppered_stars_lc": {
      "path": "collabs/peppered_stars_lc.png",
      "px": 71,
      "py": 95,
      "resolvedGitHubPath": "assets/1x/collabs/peppered_stars_lc.png"
    },
    "peppered_stars_hc": {
      "path": "collabs/peppered_stars_hc.png",
      "px": 71,
      "py": 95,
      "resolvedGitHubPath": "assets/1x/collabs/peppered_stars_hc.png"
    },
    "yttd_crowns_lc": {
      "path": "collabs/yttd_crowns_lc.png",
      "px": 71,
      "py": 95,
      "resolvedGitHubPath": "assets/1x/collabs/yttd_crowns_lc.png"
    },
    "yttd_crowns_hc": {
      "path": "collabs/yttd_crowns_hc.png",
      "px": 71,
      "py": 95,
      "resolvedGitHubPath": "assets/1x/collabs/yttd_crowns_hc.png"
    }
  },
  "cards": [
    {
      "type": "Atlas",
      "key": "Jokers",
      "atlas": null,
      "pos": null,
      "raw": "key = \"Jokers\",\n    path = \"Jokers.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Atlas",
      "key": "Consumables",
      "atlas": null,
      "pos": null,
      "raw": "key = \"Consumables\",\n    path = \"Consumables.png\",\n    px = 71,\n    py = 95,"
    },
    {
      "type": "Atlas",
      "key": "modicon",
      "atlas": null,
      "pos": null,
      "raw": "key = \"modicon\",\n    path = \"Fennex_Mod_Icon.png\",\n    px = 32,\n    py = 32"
    },
    {
      "type": "Atlas",
      "key": "Vouchers",
      "atlas": null,
      "pos": null,
      "raw": "key = \"Vouchers\",\n    path = \"Vouchers.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Atlas",
      "key": "Blinds",
      "atlas": null,
      "pos": null,
      "raw": "key = \"Blinds\",\n    path = \"Blinds.png\",\n    atlas_table = 'ANIMATION_ATLAS',\n    frames = 21,\n    px = 34,\n    py = 34"
    },
    {
      "type": "Atlas",
      "key": "Tags",
      "atlas": null,
      "pos": null,
      "raw": "key = \"Tags\",\n    path = \"Tags.png\",\n    px = 34,\n    py = 34"
    },
    {
      "type": "Atlas",
      "key": "Boosters",
      "atlas": null,
      "pos": null,
      "raw": "key = \"Boosters\",\n    path = \"Booster.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Atlas",
      "key": "Decks",
      "atlas": null,
      "pos": null,
      "raw": "key = \"Decks\",\n    path = \"Decks.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Atlas",
      "key": "peppered_diamonds_lc",
      "atlas": null,
      "pos": null,
      "raw": "key = 'peppered_diamonds_lc',\n    path = 'collabs/peppered_diamonds_lc.png',\n    px = 71,\n    py = 95"
    },
    {
      "type": "Atlas",
      "key": "peppered_diamonds_hc",
      "atlas": null,
      "pos": null,
      "raw": "key = 'peppered_diamonds_hc',\n    path = 'collabs/peppered_diamonds_hc.png',\n    px = 71,\n    py = 95"
    },
    {
      "type": "Atlas",
      "key": "yttd_clubs_lc",
      "atlas": null,
      "pos": null,
      "raw": "key = 'yttd_clubs_lc',\n    path = 'collabs/yttd_clubs_lc.png',\n    px = 71,\n    py = 95"
    },
    {
      "type": "Atlas",
      "key": "yttd_clubs_hc",
      "atlas": null,
      "pos": null,
      "raw": "key = 'yttd_clubs_hc',\n    path = 'collabs/yttd_clubs_hc.png',\n    px = 71,\n    py = 95"
    },
    {
      "type": "Atlas",
      "key": "catgirl_hearts_lc",
      "atlas": null,
      "pos": null,
      "raw": "key = 'catgirl_hearts_lc',\n    path = 'collabs/catgirl_hearts_lc.png',\n    px = 71,\n    py = 95"
    },
    {
      "type": "Atlas",
      "key": "catgirl_hearts_hc",
      "atlas": null,
      "pos": null,
      "raw": "key = 'catgirl_hearts_hc',\n    path = 'collabs/catgirl_hearts_hc.png',\n    px = 71,\n    py = 95"
    },
    {
      "type": "Atlas",
      "key": "deathnote_spades_lc",
      "atlas": null,
      "pos": null,
      "raw": "key = \"deathnote_spades_lc\",\n    path = \"collabs/deathnote_spades_lc.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Atlas",
      "key": "deathnote_spades_hc",
      "atlas": null,
      "pos": null,
      "raw": "key = \"deathnote_spades_hc\",\n    path = \"collabs/deathnote_spades_hc.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Atlas",
      "key": "deltarune_hearts_lc",
      "atlas": null,
      "pos": null,
      "raw": "key = \"deltarune_hearts_lc\",\n    path = \"collabs/deltarune_hearts_lc.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Atlas",
      "key": "deltarune_hearts_hc",
      "atlas": null,
      "pos": null,
      "raw": "key = \"deltarune_hearts_hc\",\n    path = \"collabs/deltarune_hearts_hc.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Atlas",
      "key": "celeste_spades_lc",
      "atlas": null,
      "pos": null,
      "raw": "key = \"celeste_spades_lc\",\n    path = \"collabs/celeste_spades_lc.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Atlas",
      "key": "celeste_spades_hc",
      "atlas": null,
      "pos": null,
      "raw": "key = \"celeste_spades_hc\",\n    path = \"collabs/celeste_spades_hc.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Blind",
      "key": "baby",
      "atlas": "Blinds",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = \"baby\",\n    atlas = \"Blinds\",\n    pos = { x = 0, y = 2 },\n    discovered = true,\n    boss = { min = 2 },\n    boss_colour = HEX('ffc0cb'),\n    stay_flipped = function(self, area, card)\n        if next(SMODS.get_enhancements(card)) and area == G.hand then\n            return true\n        end\n    end"
    },
    {
      "type": "Blind",
      "key": "dice",
      "atlas": "Blinds",
      "pos": {
        "x": 0,
        "y": 9
      },
      "raw": "key = \"dice\",\n    atlas = \"Blinds\",\n    pos = { x = 0, y = 9 },\n    discovered = true,\n    boss = { min = 4 },\n    boss_colour = HEX('90c7e6'),\n    debuff = {\n        old_prob = 1,\n    },\n    set_blind = function(self)\n        self.debuff.old_prob = G.GAME.probabilities.normal or 1\n        for k, v in pairs(G.GAME.probabilities) do\n            G.GAME.probabilities[k] = 0\n        end\n    end,\n    defeat = function (self)\n        for k, v in pairs(G.GAME.probabilities) do\n            G.GAME.probabilities[k] = self.debuff.old_prob\n        end\n    end,\n    disable = function (self)\n        for k, v in pairs(G.GAME.probabilities) do\n            G.GAME.probabilities[k] = self.debuff.old_prob\n        end\n    end"
    },
    {
      "type": "Blind",
      "key": "elder",
      "atlas": "Blinds",
      "pos": {
        "x": 0,
        "y": 8
      },
      "raw": "key = \"elder\",\n    atlas = \"Blinds\",\n    pos = { x = 0, y = 8 },\n    discovered = true,\n    boss = { min = 6 },\n    boss_colour = HEX('dbbc99'),\n    stay_flipped = function(self, area, card)\n        if not next(SMODS.get_enhancements(card)) and area == G.hand then\n            return true\n        end\n    end"
    },
    {
      "type": "Blind",
      "key": "final_horn",
      "atlas": "Blinds",
      "pos": {
        "x": 0,
        "y": 12
      },
      "raw": "key = \"final_horn\",\n    atlas = \"Blinds\",\n    pos = { x = 0, y = 12 },\n    discovered = true,\n    boss = { showdown = true, min = 16 },\n    boss_colour = HEX('b57edc'),\n    stay_flipped = function(self, area, card)\n        if area == G.hand then return true end\n    end"
    },
    {
      "type": "Blind",
      "key": "final_shield",
      "atlas": "Blinds",
      "pos": {
        "x": 0,
        "y": 15
      },
      "raw": "key = \"final_shield\",\n    atlas = \"Blinds\",\n    pos = { x = 0, y = 15 },\n    discovered = true,\n    boss = { showdown = true, min = 8 },\n    boss_colour = HEX('ff9933'),\n    debuff = {\n        value = {}\n    },\n    set_blind = function(self)\n        G.GAME.blind.debuff.value = G.GAME.current_round.most_played_rank\n    end,\n    loc_vars = function(self)\n        return { vars = { localize(G.GAME.current_round.most_played_rank, 'ranks') } }\n    end,\n    collection_loc_vars = function(self)\n        return { vars = { localize('r_fmod_mostplayed') } }\n    end"
    },
    {
      "type": "Blind",
      "key": "final_sword",
      "atlas": "Blinds",
      "pos": {
        "x": 0,
        "y": 13
      },
      "raw": "key = \"final_sword\",\n    atlas = \"Blinds\",\n    pos = { x = 0, y = 13 },\n    discovered = true,\n    boss = { showdown = true, min = 8 },\n    boss_colour = HEX('becacc'),\n    debuff_hand = function(self, cards, hand, handname, check)\n        if handname == G.GAME.current_round.most_played_poker_hand then\n            return true\n        else\n            return false\n        end\n    end,\n    loc_vars = function(self)\n        return { vars = { localize(G.GAME.current_round.most_played_poker_hand, 'poker_hands') } }\n    end,\n    collection_loc_vars = function(self)\n        return { vars = { localize('ph_most_played') } }\n    end"
    },
    {
      "type": "Blind",
      "key": "flux",
      "atlas": "Blinds",
      "pos": {
        "x": 0,
        "y": 10
      },
      "raw": "key = \"flux\",\n    atlas = \"Blinds\",\n    pos = { x = 0, y = 10 },\n    discovered = true,\n    boss = { min = 3 },\n    boss_colour = HEX('702791'),\n    suit1 = 'Spades',\n    suit2 = 'Hearts',\n    drawn_to_hand = function(self)\n        if G.GAME.blind.prepped then\n            for i = 1, #G.playing_cards do\n                for b = 1, #G.hand.cards do\n                    if G.playing_cards[i] == G.hand.cards[b] then\n                        G.hand.cards[b]:juice_up()\n                    end\n                end\n                G.playing_cards[i]:set_debuff(false)\n                SMODS.juice_up_blind()\n            end\n            G.GAME.blind.suit1 = pseudorandom_element(SMODS.Suits, pseudoseed('flux1')).name or 'Spades'\n            G.GAME.blind.suit2 = pseudorandom_element(SMODS.Suits, pseudoseed('flux2')).name or 'Hearts'\n            while G.GAME.blind.suit2 == G.GAME.blind.suit1 do\n                G.GAME.blind.suit2 = pseudorandom_element(SMODS.Suits, pseudoseed('flux2')).name or 'Hearts'\n            end\n            for i = 1, #G.playing_cards do\n                local card = G.playing_cards[i]\n                if (card.base.suit == G.GAME.blind.suit1 or card.base.suit == G.GAME.blind.suit2) and not SMODS.has_no_rank(card) then\n                    card:set_debuff(true)\n                    for b = 1, #G.hand.cards do\n                        if card == G.hand.cards[b] then\n                            card:juice_up()\n                        end\n                    end\n                end\n            end\n        end\n        G.GAME.blind.prepped = nil\n    end,\n    press_play = function(self)\n        G.GAME.blind.prepped = true\n    end,"
    },
    {
      "type": "Blind",
      "key": "hoard",
      "atlas": "Blinds",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"hoard\",\n    atlas = \"Blinds\",\n    pos = { x = 0, y = 0 },\n    discovered = true,\n    boss = { min = 5 },\n    boss_colour = HEX('963f39'),\n    stay_flipped = function(self, area, card)\n        if not card:is_face() and area == G.hand then\n            return true\n        end\n    end"
    },
    {
      "type": "Blind",
      "key": "light",
      "atlas": "Blinds",
      "pos": {
        "x": 0,
        "y": 5
      },
      "raw": "key = \"light\",\n    atlas = \"Blinds\",\n    pos = { x = 0, y = 5 },\n    discovered = true,\n    boss = { min = 2 },\n    boss_colour = HEX('d8d5c0'),\n    calculate = function(self, card, context)\n        -- SMODS blind calc might get fixed,\n        -- then G.GAME.blind.disabled won't be needed\n        if not G.GAME.blind.disabled and context.before and not context.blueprint then\n            for k, v in ipairs(context.scoring_hand) do\n                if next(SMODS.get_enhancements(v)) and not v.debuff and not v.vampired then\n                    v.vampired = true\n                    v:set_ability('c_base', nil, true)\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            play_sound('generic1', 0.9 + math.random()*0.1, 0.8)\n                            v:juice_up()\n                            v.vampired = nil\n                            return true\n                        end\n                    }))\n                end\n            end\n        end\n    end"
    },
    {
      "type": "Blind",
      "key": "priest",
      "atlas": "Blinds",
      "pos": {
        "x": 0,
        "y": 3
      },
      "raw": "key = \"priest\",\n    atlas = \"Blinds\",\n    pos = { x = 0, y = 3 },\n    discovered = true,\n    boss = { min = 5 },\n    boss_colour = HEX('424138'),\n    debuff = {h_size_le = 4}"
    },
    {
      "type": "Blind",
      "key": "thorn",
      "atlas": "Blinds",
      "pos": {
        "x": 0,
        "y": 7
      },
      "raw": "key = \"thorn\",\n    atlas = \"Blinds\",\n    pos = { x = 0, y = 7 },\n    discovered = true,\n    boss = { min = 4 },\n    boss_colour = HEX('747d45'),\n    recalc_debuff = function(self, card, from_blind)\n        if card.seal then\n            return true\n        end\n    end"
    },
    {
      "type": "Blind",
      "key": "tool",
      "atlas": "Blinds",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"tool\",\n    atlas = \"Blinds\",\n    pos = { x = 0, y = 1 },\n    discovered = true,\n    boss = { min = 5 },\n    boss_colour = HEX('9c6838'),\n    set_blind = function(self)\n        for i, k in ipairs(G.consumeables.cards) do\n            k:juice_up(0.3, 0.5)\n            k:set_debuff(true)\n        end\n    end,\n    defeat = function (self)\n        for i, k in ipairs(G.consumeables.cards) do\n            k:juice_up(0.3, 0.5)\n            k:set_debuff(false)\n        end\n    end,\n    disable = function (self)\n        for i, k in ipairs(G.consumeables.cards) do\n            k:juice_up(0.3, 0.5)\n            k:set_debuff(false)\n        end\n    end"
    },
    {
      "type": "Booster",
      "key": "remix_small_1",
      "atlas": "Boosters",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = \"remix_small_1\",\n    config = { extra = 3, choose = 1 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.choose, card.ability.extra } }\n    end,\n    group_key = \"k_fmod_remixpack\",\n    cost = 4,\n    weight = 0,\n    atlas = \"Boosters\",\n    pos = { x = 0, y = 2 },\n    draw_hand = true,\n    kind = \"Remix\",\n    create_card = function(self, card, i) -- this implementation SUCKS\n        local types = {\"Joker\", \"Playing Card\"}\n        for k, v in ipairs(SMODS.ConsumableType.ctype_buffer) do\n            types[#types + 1] = v\n        end\n        if i == 1 then\n            return SMODS.create_card({set = pseudorandom_element(types, \"remix_sm_1\"), skip_materialize = true, area = G.pack_cards})\n        elseif i == 2 then\n            return SMODS.create_card({set = pseudorandom_element(types, \"remix_sm_2\"), skip_materialize = true, area = G.pack_cards})\n        else\n            return SMODS.create_card({set = pseudorandom_element(types, \"remix_sm_3\"), skip_materialize = true, area = G.pack_cards})\n        end\n    end,\n    ease_background_colour = function(self)\n        ease_colour(G.C.DYN_UI.MAIN, HEX(\"c3d7e3\"))\n        ease_background_colour({ new_colour = HEX('c3d7e3'), special_colour = HEX(\"5d6366\"), contrast = 2 })\n    end"
    },
    {
      "type": "Booster",
      "key": "remix_small_2",
      "atlas": "Boosters",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "key = \"remix_small_2\",\n    config = { extra = 3, choose = 1 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.choose, card.ability.extra } }\n    end,\n    group_key = \"k_fmod_remixpack\",\n    cost = 4,\n    weight = 0,\n    atlas = \"Boosters\",\n    pos = { x = 1, y = 2 },\n    draw_hand = true,\n    kind = \"Remix\",\n    create_card = function(self, card, i) -- this implementation SUCKS\n        local types = {\"Joker\", \"Playing Card\"}\n        for k, v in ipairs(SMODS.ConsumableType.ctype_buffer) do\n            types[#types + 1] = v\n        end\n        if i == 1 then\n            return SMODS.create_card({set = pseudorandom_element(types, \"remix_sm_1\"), skip_materialize = true, area = G.pack_cards})\n        elseif i == 2 then\n            return SMODS.create_card({set = pseudorandom_element(types, \"remix_sm_2\"), skip_materialize = true, area = G.pack_cards})\n        else\n            return SMODS.create_card({set = pseudorandom_element(types, \"remix_sm_3\"), skip_materialize = true, area = G.pack_cards})\n        end\n    end,\n    ease_background_colour = function(self)\n        ease_colour(G.C.DYN_UI.MAIN, HEX(\"d76c1a\"))\n        ease_background_colour({ new_colour = HEX('d76c1a'), special_colour = HEX(\"f5dbc7\"), contrast = 2 })\n    end"
    },
    {
      "type": "Booster",
      "key": "remix_jumbo",
      "atlas": "Boosters",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "key = \"remix_jumbo\",\n    config = { extra = 5, choose = 1 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.choose, card.ability.extra } }\n    end,\n    group_key = \"k_fmod_remixpack\",\n    cost = 6,\n    weight = 0,\n    atlas = \"Boosters\",\n    pos = { x = 2, y = 2 },\n    draw_hand = true,\n    kind = \"Remix\",\n    create_card = function(self, card, i) -- this implementation SUCKS\n        local types = {\"Joker\", \"Playing Card\"}\n        for k, v in ipairs(SMODS.ConsumableType.ctype_buffer) do\n            types[#types + 1] = v\n        end\n        if i == 1 then\n            return SMODS.create_card({set = pseudorandom_element(types, \"remix_ju_1\"), skip_materialize = true, area = G.pack_cards})\n        elseif i == 2 then\n            return SMODS.create_card({set = pseudorandom_element(types, \"remix_ju_2\"), skip_materialize = true, area = G.pack_cards})\n        elseif i == 3 then\n            return SMODS.create_card({set = pseudorandom_element(types, \"remix_ju_3\"), skip_materialize = true, area = G.pack_cards})\n        elseif i == 4 then\n            return SMODS.create_card({set = pseudorandom_element(types, \"remix_ju_4\"), skip_materialize = true, area = G.pack_cards})\n        else\n            return SMODS.create_card({set = pseudorandom_element(types, \"remix_ju_5\"), skip_materialize = true, area = G.pack_cards})\n        end\n    end,\n    ease_background_colour = function(self)\n        ease_colour(G.C.DYN_UI.MAIN, HEX(\"ab7de5\"))\n        ease_background_colour({ new_colour = HEX('ab7de5'), special_colour = HEX(\"fbecfd\"), contrast = 2 })\n    end"
    },
    {
      "type": "Booster",
      "key": "remix_mega",
      "atlas": "Boosters",
      "pos": {
        "x": 3,
        "y": 2
      },
      "raw": "key = \"remix_mega\",\n    config = { extra = 5, choose = 2 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.choose, card.ability.extra } }\n    end,\n    group_key = \"k_fmod_remixpack\",\n    cost = 8,\n    weight = 0,\n    atlas = \"Boosters\",\n    pos = { x = 3, y = 2 },\n    draw_hand = true,\n    kind = \"Remix\",\n    create_card = function(self, card, i) -- this implementation SUCKS\n        local types = {\"Joker\", \"Playing Card\"}\n        for k, v in ipairs(SMODS.ConsumableType.ctype_buffer) do\n            types[#types + 1] = v\n        end\n        if i == 1 then\n            return SMODS.create_card({set = pseudorandom_element(types, \"remix_me_1\"), skip_materialize = true, area = G.pack_cards})\n        elseif i == 2 then\n            return SMODS.create_card({set = pseudorandom_element(types, \"remix_me_2\"), skip_materialize = true, area = G.pack_cards})\n        elseif i == 3 then\n            return SMODS.create_card({set = pseudorandom_element(types, \"remix_me_3\"), skip_materialize = true, area = G.pack_cards})\n        elseif i == 4 then\n            return SMODS.create_card({set = pseudorandom_element(types, \"remix_me_4\"), skip_materialize = true, area = G.pack_cards})\n        else\n            return SMODS.create_card({set = pseudorandom_element(types, \"remix_me_5\"), skip_materialize = true, area = G.pack_cards})\n        end\n    end,\n    ease_background_colour = function(self)\n        ease_colour(G.C.DYN_UI.MAIN, HEX(\"59c69a\"))\n        ease_background_colour({ new_colour = HEX('59c69a'), special_colour = HEX(\"59c69a\"), contrast = 2 })\n    end"
    },
    {
      "type": "Booster",
      "key": "silly_small",
      "atlas": "Boosters",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"silly_small\",\n    config = { extra = 3, choose = 1 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.choose, card.ability.extra, colours = {HEX(\"ff98e2\")} } }\n    end,\n    group_key = \"k_fmod_sillypack\",\n    cost = 4,\n    atlas = \"Boosters\",\n    weight = 0.75,\n    pos = { x = 0, y = 0 },\n    draw_hand = true,\n    kind = \"Silly\",\n    create_card = function(self, card, i)\n        return SMODS.create_card({set = \"Silly\", skip_materialize = true, area = G.pack_cards})\n    end,\n    ease_background_colour = function(self)\n        ease_colour(G.C.DYN_UI.MAIN, HEX(\"d66a5e\"))\n        ease_background_colour({ new_colour = HEX('d66a5e'), special_colour = HEX(\"90c7e6\"), contrast = 2 })\n    end"
    },
    {
      "type": "Booster",
      "key": "silly_small_2",
      "atlas": "Boosters",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"silly_small_2\",\n    config = { extra = 3, choose = 1 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.choose, card.ability.extra, colours = {HEX(\"ff98e2\")} } }\n    end,\n    group_key = \"k_fmod_sillypack\",\n    cost = 4,\n    atlas = \"Boosters\",\n    weight = 0.75,\n    pos = { x = 1, y = 0 },\n    draw_hand = true,\n    kind = \"Silly\",\n    create_card = function(self, card, i)\n        return SMODS.create_card({set = \"Silly\", skip_materialize = true, area = G.pack_cards})\n    end,\n    ease_background_colour = function(self)\n        ease_colour(G.C.DYN_UI.MAIN, HEX(\"d66a5e\"))\n        ease_background_colour({ new_colour = HEX('d66a5e'), special_colour = HEX(\"90c7e6\"), contrast = 2 })\n    end"
    },
    {
      "type": "Booster",
      "key": "silly_small_4",
      "atlas": "Boosters",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"silly_small_4\",\n    config = { extra = 3, choose = 1 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.choose, card.ability.extra, colours = {HEX(\"ff98e2\")} } }\n    end,\n    group_key = \"k_fmod_sillypack\",\n    cost = 4,\n    atlas = \"Boosters\",\n    weight = 0.75,\n    pos = { x = 2, y = 0 },\n    draw_hand = true,\n    kind = \"Silly\",\n    create_card = function(self, card, i)\n        return SMODS.create_card({set = \"Silly\", skip_materialize = true, area = G.pack_cards})\n    end,\n    ease_background_colour = function(self)\n        ease_colour(G.C.DYN_UI.MAIN, HEX(\"d66a5e\"))\n        ease_background_colour({ new_colour = HEX('d66a5e'), special_colour = HEX(\"90c7e6\"), contrast = 2 })\n    end"
    },
    {
      "type": "Booster",
      "key": "silly_small_3",
      "atlas": "Boosters",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"silly_small_3\",\n    config = { extra = 3, choose = 1 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.choose, card.ability.extra, colours = {HEX(\"ff98e2\")} } }\n    end,\n    group_key = \"k_fmod_sillypack\",\n    cost = 4,\n    atlas = \"Boosters\",\n    weight = 0.75,\n    pos = { x = 3, y = 0 },\n    draw_hand = true,\n    kind = \"Silly\",\n    create_card = function(self, card, i)\n        return SMODS.create_card({set = \"Silly\", skip_materialize = true, area = G.pack_cards})\n    end,\n    ease_background_colour = function(self)\n        ease_colour(G.C.DYN_UI.MAIN, HEX(\"d66a5e\"))\n        ease_background_colour({ new_colour = HEX('d66a5e'), special_colour = HEX(\"90c7e6\"), contrast = 2 })\n    end"
    },
    {
      "type": "Booster",
      "key": "silly_jumbo",
      "atlas": "Boosters",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"silly_jumbo\",\n    config = { extra = 5, choose = 1 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.choose, card.ability.extra, colours = {HEX(\"ff98e2\")} } }\n    end,\n    group_key = \"k_fmod_sillypack\",\n    cost = 6,\n    atlas = \"Boosters\",\n    weight = 0.75,\n    pos = { x = 0, y = 1 },\n    draw_hand = true,\n    kind = \"Silly\",\n    create_card = function(self, card, i)\n        return SMODS.create_card({set = \"Silly\", skip_materialize = true, area = G.pack_cards})\n    end,\n    ease_background_colour = function(self)\n        ease_colour(G.C.DYN_UI.MAIN, HEX(\"d66a5e\"))\n        ease_background_colour({ new_colour = HEX('d66a5e'), special_colour = HEX(\"90c7e6\"), contrast = 2 })\n    end"
    },
    {
      "type": "Booster",
      "key": "silly_jumbo_2",
      "atlas": "Boosters",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"silly_jumbo_2\",\n    config = { extra = 5, choose = 1 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.choose, card.ability.extra, colours = {HEX(\"ff98e2\")} } }\n    end,\n    group_key = \"k_fmod_sillypack\",\n    cost = 6,\n    atlas = \"Boosters\",\n    weight = 0.75,\n    pos = { x = 1, y = 1 },\n    draw_hand = true,\n    kind = \"Silly\",\n    create_card = function(self, card, i)\n        return SMODS.create_card({set = \"Silly\", skip_materialize = true, area = G.pack_cards})\n    end,\n    ease_background_colour = function(self)\n        ease_colour(G.C.DYN_UI.MAIN, HEX(\"d66a5e\"))\n        ease_background_colour({ new_colour = HEX('d66a5e'), special_colour = HEX(\"90c7e6\"), contrast = 2 })\n    end"
    },
    {
      "type": "Booster",
      "key": "silly_mega",
      "atlas": "Boosters",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"silly_mega\",\n    config = { extra = 5, choose = 2 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.choose, card.ability.extra, colours = {HEX(\"ff98e2\")} } }\n    end,\n    group_key = \"k_fmod_sillypack\",\n    cost = 8,\n    weight = 0.19,\n    atlas = \"Boosters\",\n    pos = { x = 2, y = 1 },\n    draw_hand = true,\n    kind = \"Silly\",\n    create_card = function(self, card, i)\n        return SMODS.create_card({set = \"Silly\", skip_materialize = true, area = G.pack_cards})\n    end,\n    ease_background_colour = function(self)\n        ease_colour(G.C.DYN_UI.MAIN, HEX(\"d66a5e\"))\n        ease_background_colour({ new_colour = HEX('d66a5e'), special_colour = HEX(\"90c7e6\"), contrast = 2 })\n    end"
    },
    {
      "type": "Booster",
      "key": "silly_mega_2",
      "atlas": "Boosters",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"silly_mega_2\",\n    config = { extra = 5, choose = 2 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.choose, card.ability.extra, colours = {HEX(\"ff98e2\")} } }\n    end,\n    group_key = \"k_fmod_sillypack\",\n    cost = 8,\n    weight = 0.19,\n    atlas = \"Boosters\",\n    pos = { x = 3, y = 1 },\n    draw_hand = true,\n    kind = \"Silly\",\n    create_card = function(self, card, i)\n        return SMODS.create_card({set = \"Silly\", skip_materialize = true, area = G.pack_cards})\n    end,\n    ease_background_colour = function(self)\n        ease_colour(G.C.DYN_UI.MAIN, HEX(\"d66a5e\"))\n        ease_background_colour({ new_colour = HEX('d66a5e'), special_colour = HEX(\"90c7e6\"), contrast = 2 })\n    end"
    },
    {
      "type": "Consumable",
      "key": "balloon_animal",
      "atlas": "Consumables",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"balloon_animal\",\n    set = \"Silly\",\n    config = {\n        extra = {\n            money = 3,\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.money, card.ability.extra.money * LR_UTIL.get_unique_ranks() } }\n    end,\n    atlas = \"Consumables\",\n    pos = { x = 0, y = 1 },\n    cost = 5,\n    use = function(self, card, context, copier)\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n            play_sound('timpani')\n            card:juice_up(0.3, 0.5)\n            ease_dollars((card.ability.extra.money * LR_UTIL.get_unique_ranks()), true)\n            return true end }))\n        delay(0.6)\n    end,\n    can_use = function(self, card, context, copier)\n        if G.STATE == G.STATES.SELECTING_HAND or G.STATE == G.STATES.SMODS_BOOSTER_OPENED then\n            return true\n        end\n    end,"
    },
    {
      "type": "Consumable",
      "key": "balloons",
      "atlas": "Consumables",
      "pos": {
        "x": 7,
        "y": 0
      },
      "raw": "key = \"balloons\",\n    set = \"Silly\",\n    config = {\n        extra = {\n            mult = 2\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.mult } }\n    end,\n    atlas = \"Consumables\",\n    pos = { x = 7, y = 0 },\n    cost = 5,\n    use = function(self, card, context, copier)\n        \n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n            play_sound('tarot1')\n            card:juice_up(0.3, 0.5)\n            delay(0.3)\n            for i = 1, #G.hand.cards do\n                local hand_card = G.hand.cards[i]\n                hand_card:juice_up(0.3,0.5)\n                hand_card.ability.perma_bonus = (hand_card.ability.perma_bonus or 0) + hand_card:get_chip_bonus()\n                delay(0.1)\n            end\n            play_sound('timpani')\n            return true end }))\n    end,\n    can_use = function(self, card)\n        if G.STATE == G.STATES.SELECTING_HAND or G.STATE == G.STATES.SMODS_BOOSTER_OPENED then\n            return true\n        end\n    end"
    },
    {
      "type": "Consumable",
      "key": "bang_gun",
      "atlas": "Consumables",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"bang_gun\",\n    set = \"Silly\",\n    config = {\n        max_highlighted = 2,\n    },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.max_highlighted } }\n    end,\n    atlas = \"Consumables\",\n    pos = { x = 3, y = 0 },\n    cost = 3,\n    use = function(self, card, context, copier)\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n            play_sound('tarot1')\n            card:juice_up(0.3, 0.5)\n            return true end }))\n        for i=1, #G.hand.highlighted do\n            local percent = 1.15 - (i-0.999)/(#G.hand.highlighted-0.998)*0.3\n            G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.15,func = function() G.hand.highlighted[i]:flip();play_sound('card1', percent);G.hand.highlighted[i]:juice_up(0.3, 0.3);return true end }))\n        end\n        delay(0.2)\n        local leftmost = G.hand.highlighted[1]\n        for i=1, #G.hand.highlighted do\n            G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.1,func = function()\n                if G.hand.highlighted[i] ~= leftmost then\n                    SMODS.change_base(G.hand.highlighted[i], leftmost.base.suit, nil)\n                    card:juice_up(0.3, 0.5)\n                end\n            return true end }))\n        end\n        for i=1, #G.hand.highlighted do\n            local percent = 0.85 + (i-0.999)/(#G.hand.highlighted-0.998)*0.3\n            G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.15,func = function() G.hand.highlighted[i]:flip();play_sound('tarot2', percent, 0.6);G.hand.highlighted[i]:juice_up(0.3, 0.3);return true end }))\n        end\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.2,func = function() update_hand_text({immediate = true, nopulse = true, delay = 0}, {mult = 0, chips = 0, level = '', handname = ''}); G.hand:unhighlight_all(); return true end }))\n        delay(0.5)\n    end,\n    can_use = function(self, card)\n        if G.hand and #G.hand.highlighted <= card.ability.max_highlighted and #G.hand.highlighted > 1 then\n            for i = 1, #G.hand.highlighted do\n                if SMODS.has_no_rank(G.hand.highlighted[i]) then\n                    return false\n                end\n            end\n            return true\n        end\n    end,"
    },
    {
      "type": "Consumable",
      "key": "barker",
      "atlas": "Consumables",
      "pos": {
        "x": 4,
        "y": 2
      },
      "raw": "key = \"barker\",\n        set = \"Silly\",\n        config = {\n            max_highlighted = 2,\n            mod_conv = \"m_fmod_raffle_card\",\n        },\n        loc_vars = function(self, info_queue, card)\n            info_queue[#info_queue + 1] = G.P_CENTERS.m_fmod_raffle_card\n            return { vars = { card.ability.max_highlighted } }\n        end,\n        atlas = \"Consumables\",\n        pos = { x = 4, y = 2 },\n        cost = 3,"
    },
    {
      "type": "Consumable",
      "key": "cannon",
      "atlas": "Consumables",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"cannon\",\n    set = \"Silly\",\n    config = {\n        max_highlighted = 2,\n    },\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue+1] = LR_UTIL.marking_tooltip(\"pinhole\")\n        return { vars = { card.ability.max_highlighted } }\n    end,\n    atlas = \"Consumables\",\n    pos = { x = 2, y = 1 },\n    cost = 5,\n    use = function(self, card, context, copier)\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n            play_sound('tarot1')\n            card:juice_up(0.3, 0.5)\n            return true end }))\n        for i=1, #G.hand.highlighted do\n            local percent = 1.15 - (i-0.999)/(#G.hand.highlighted-0.998)*0.3\n            G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.15,func = function() G.hand.highlighted[i]:flip();play_sound('card1', percent);G.hand.highlighted[i]:juice_up(0.3, 0.3);return true end }))\n        end\n        delay(0.2)\n        for i=1, #G.hand.highlighted do\n            G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.1,func = function()\n                LR_UTIL.set_marking(G.hand.highlighted[i], 'pinhole')\n            return true end }))\n        end\n        for i=1, #G.hand.highlighted do\n            local percent = 0.85 + (i-0.999)/(#G.hand.highlighted-0.998)*0.3\n            G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.15,func = function() G.hand.highlighted[i]:flip();play_sound('tarot2', percent, 0.6);G.hand.highlighted[i]:juice_up(0.3, 0.3);return true end }))\n        end\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.2,func = function() update_hand_text({immediate = true, nopulse = true, delay = 0}, {mult = 0, chips = 0, level = '', handname = ''}); G.hand:unhighlight_all(); return true end }))\n        delay(0.5)\n    end,"
    },
    {
      "type": "Consumable",
      "key": "clown_car",
      "atlas": "Consumables",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"clown_car\",\n    set = \"Silly\",\n    config = {\n        extra = {\n            minus_money = 5,\n            sell = 0\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue+1] = G.P_CENTERS.e_negative\n        return { vars = { card.ability.extra.minus_money, card.ability.extra.sell } }\n    end,\n    atlas = \"Consumables\",\n    pos = {x = 0, y = 0 },\n    cost = 5,\n    use = function(self, card, context, copier)\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n            play_sound('timpani')\n            if LR_UTIL.get_negatives(G.jokers.cards) > 0 then\n                ease_dollars(-(LR_UTIL.get_negatives(G.jokers.cards) * card.ability.extra.minus_money))\n            end\n            local joker = SMODS.add_card({set = 'Joker', area = G.jokers, edition = \"e_negative\"})\n            joker.ability.fmod_no_sell_value = true\n            joker:set_cost()\n            card:juice_up(0.3, 0.5)\n            return true end }))\n        delay(0.6)\n    end,\n    can_use = function(self, card)\n        return true\n    end"
    },
    {
      "type": "Consumable",
      "key": "endless_scarf",
      "atlas": "Consumables",
      "pos": {
        "x": 7,
        "y": 1
      },
      "raw": "key = \"endless_scarf\",\n    set = \"Silly\",\n    config = {\n        extra = {\n            h_size = 2\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.h_size } }\n    end,\n    atlas = \"Consumables\",\n    pos = {x = 7, y = 1 },\n    cost = 5,\n    use = function(self, card, area, copier)\n        if #G.hand.cards > 1 then\n            G.FUNCS.draw_from_deck_to_hand(card.ability.extra.h_size)\n        end\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n            G.hand:change_size(card.ability.extra.h_size)\n            G.GAME.round_resets.temp_handsize = (G.GAME.round_resets.temp_handsize or 0) + card.ability.extra.h_size\n            card:juice_up(0.3, 0.5)\n        return true end }))\n        delay(0.4)\n    end,\n    can_use = function(self, card)\n        return true\n    end"
    },
    {
      "type": "Consumable",
      "key": "fire_breath",
      "atlas": "Consumables",
      "pos": {
        "x": 9,
        "y": 1
      },
      "raw": "key = \"fire_breath\",\n    set = \"Silly\",\n    config = {\n        extra = {\n            cards = 1,\n        }\n    },\n    atlas = \"Consumables\",\n    pos = { x = 9, y = 1 },\n    cost = 5,\n    use = function(self, card, context, copier)\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n            local save_edition = nil\n            if G.jokers.highlighted[1].edition then\n                save_edition = G.jokers.highlighted[1].edition.key\n            end\n            for i=1, #G.jokers.cards do\n                if G.jokers.cards[i] == G.jokers.highlighted[1] then\n                    if G.jokers.cards[i+1] then G.jokers.cards[i+1]:set_edition(save_edition, true, false) end\n                end\n            end\n            if not G.jokers.highlighted[1].ability.eternal then G.jokers.highlighted[1]:start_dissolve(nil) end\n            card:juice_up(0.3, 0.5)\n            return true end }))\n        delay(0.6)\n    end,\n    can_use = function(self, card, context, copier)\n        if #G.jokers.highlighted == card.ability.extra.cards and #G.jokers.cards >= 2 then\n            return true\n        end\n    end,"
    },
    {
      "type": "Consumable",
      "key": "greasepaint",
      "atlas": "Consumables",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"greasepaint\",\n    set = \"Silly\",\n    config = {\n        max_highlighted = 2,\n    },\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue+1] = LR_UTIL.marking_tooltip(\"ink\")\n        return { vars = { card.ability.max_highlighted } }\n    end,\n    atlas = \"Consumables\",\n    pos = { x = 3, y = 1 },\n    cost = 4,\n    use = function(self, card, context, copier)\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n            play_sound('tarot1')\n            card:juice_up(0.3, 0.5)\n            return true end }))\n        for i=1, #G.hand.highlighted do\n            local percent = 1.15 - (i-0.999)/(#G.hand.highlighted-0.998)*0.3\n            G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.15,func = function() G.hand.highlighted[i]:flip();play_sound('card1', percent);G.hand.highlighted[i]:juice_up(0.3, 0.3);return true end }))\n        end\n        delay(0.2)\n        for i=1, #G.hand.highlighted do\n            G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.1,func = function()\n                LR_UTIL.set_marking(G.hand.highlighted[i], 'ink')\n            return true end }))\n        end\n        for i=1, #G.hand.highlighted do\n            local percent = 0.85 + (i-0.999)/(#G.hand.highlighted-0.998)*0.3\n            G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.15,func = function()\n                if G.hand.highlighted[i].facing == \"back\" then\n                    G.hand.highlighted[i]:flip()\n                end\n                play_sound('tarot2', percent, 0.6)\n                G.hand.highlighted[i]:juice_up(0.3, 0.3)\n                return true end\n            }))\n        end\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.2,func = function() \n            G.hand:unhighlight_all()\n            update_hand_text({immediate = true, nopulse = true, delay = 0}, {mult = 0, chips = 0, level = '', handname = ''})\n            return true end\n        }))\n        delay(0.5)\n    end,"
    },
    {
      "type": "Consumable",
      "key": "hall_of_mirrors",
      "atlas": "Consumables",
      "pos": {
        "x": 6,
        "y": 2
      },
      "raw": "key = \"hall_of_mirrors\",\n        set = \"Silly\",\n        config = {\n            max_highlighted = 2,\n            mod_conv = \"m_fmod_copycat_card\",\n        },\n        loc_vars = function(self, info_queue, card)\n            info_queue[#info_queue + 1] = G.P_CENTERS.m_fmod_copycat_card\n            return { vars = { card.ability.max_highlighted } }\n        end,\n        atlas = \"Consumables\",\n        pos = { x = 6, y = 2 },\n        cost = 3,"
    },
    {
      "type": "Consumable",
      "key": "joy_buzzer",
      "atlas": "Consumables",
      "pos": {
        "x": 5,
        "y": 0
      },
      "raw": "key = \"joy_buzzer\",\n    set = \"Silly\",\n    config = {\n        max_highlighted = 2\n    },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.max_highlighted } }\n    end,\n    atlas = \"Consumables\",\n    pos = { x = 5, y = 0 },\n    cost = 3,\n    use = function(self, card, context, copier)\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n            play_sound('tarot1')\n            card:juice_up(0.3, 0.5)\n            return true end }))\n        for i=1, #G.hand.highlighted do\n            local percent = 1.15 - (i-0.999)/(#G.hand.highlighted-0.998)*0.3\n            G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.15,func = function() G.hand.highlighted[i]:flip();play_sound('card1', percent);G.hand.highlighted[i]:juice_up(0.3, 0.3);return true end }))\n        end\n        delay(0.2)\n        local leftmost = G.hand.highlighted[1]\n        for i=1, #G.hand.highlighted do\n            G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.1,func = function()\n                if G.hand.highlighted[i] ~= leftmost then\n                        G.hand.highlighted[i]:set_edition(leftmost.edition, nil, true)\n                        card:juice_up(0.3, 0.5)\n                end\n            return true end }))\n        end\n        for i=1, #G.hand.highlighted do\n            local percent = 0.85 + (i-0.999)/(#G.hand.highlighted-0.998)*0.3\n            G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.15,func = function() G.hand.highlighted[i]:flip();play_sound('tarot2', percent, 0.6);G.hand.highlighted[i]:juice_up(0.3, 0.3);return true end }))\n        end\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.2,func = function() update_hand_text({immediate = true, nopulse = true, delay = 0}, {mult = 0, chips = 0, level = '', handname = ''}); G.hand:unhighlight_all(); return true end }))\n        delay(0.5)\n    end,\n    can_use = function(self, card)\n        if #G.hand.highlighted <= card.ability.max_highlighted and #G.hand.highlighted > 1 then\n            if G.hand.highlighted[1].edition then\n                return true\n            end\n        end\n        return false\n    end,\n    in_pool = function(self, args)\n        for _, playing_card in ipairs(G.playing_cards or {}) do\n            if playing_card.edition then\n                return true\n            end\n        end\n        return false\n    end"
    },
    {
      "type": "Consumable",
      "key": "juggler",
      "atlas": "Consumables",
      "pos": {
        "x": 6,
        "y": 0
      },
      "raw": "key = \"juggler\",\n    set = \"Silly\",\n    config = {\n        extra = {\n            dollars = 10,\n            increase = 5\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.dollars + ((G.GAME.juggler_count or 0) * card.ability.extra.increase), card.ability.extra.increase } }\n    end,\n    atlas = \"Consumables\",\n    pos = {x = 6, y = 0 },\n    cost = 5,\n    use = function(self, card, context, copier)\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n            play_sound('timpani')\n            card:juice_up(0.3, 0.5)\n            ease_dollars((card.ability.extra.dollars + (G.GAME.juggler_count * card.ability.extra.increase)), true)\n            G.GAME.juggler_count = (G.GAME.juggler_count or 0) + 1\n            return true end }))\n        delay(0.6)\n    end,\n    can_use = function(self, card)\n        return true\n    end"
    },
    {
      "type": "Consumable",
      "key": "knife_throw",
      "atlas": "Consumables",
      "pos": {
        "x": 8,
        "y": 1
      },
      "raw": "key = \"knife_throw\",\n    set = \"Silly\",\n    atlas = \"Consumables\",\n    config = {\n        max_highlighted = 3,\n        extra = {\n            odds = 2,\n            base = 1\n        }\n    },\n    pos = {x = 8, y = 1 },\n    cost = 3,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.max_highlighted } }\n    end,\n    use = function(self, card, context, copier)\n        local outcomes = {}\n        local destroyed_cards = {}\n        for i = 1, #G.hand.highlighted do\n            local k_card = G.hand.highlighted[i]\n            if pseudorandom(pseudoseed('knifethrow')) < card.ability.extra.base/card.ability.extra.odds then\n                table.insert(outcomes, { k_card = k_card, success = true })\n            else\n                table.insert(outcomes, { k_card = k_card, success = false })\n                table.insert(destroyed_cards, k_card)\n            end\n        end\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n            play_sound('tarot1')\n            for _, outcome in ipairs(outcomes) do\n                local k_card = outcome.k_card\n                if outcome.success then\n                    local seal = SMODS.poll_seal({\n                        guaranteed = true\n                    })\n                    k_card:juice_up(0.3, 0.5)\n                    k_card:set_seal(seal)\n                else\n                    if k_card.ability.name == 'Glass Card' then\n                        k_card:shatter()\n                    else\n                        k_card:start_dissolve(nil)\n                    end\n                end\n            end\n            card:juice_up(0.3, 0.5)\n        return true end}))\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.2,func = function()\n            G.hand:unhighlight_all()\n        return true end }))\n        delay(0.5)\n        SMODS.calculate_context({ remove_playing_cards = true, removed = destroyed_cards })\n    end,"
    },
    {
      "type": "Consumable",
      "key": "midway_games",
      "atlas": "Consumables",
      "pos": {
        "x": 4,
        "y": 1
      },
      "raw": "key = \"midway_games\",\n    set = \"Silly\",\n    config = {\n        extra = {\n\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue+1] = {key = \"tag_standard\", set = \"Tag\"}\n        info_queue[#info_queue+1] = {key = \"tag_charm\", set = \"Tag\"}\n        info_queue[#info_queue+1] = {key = \"tag_meteor\", set = \"Tag\"}\n        info_queue[#info_queue+1] = {key = \"tag_buffoon\", set = \"Tag\"}\n    end,\n    atlas = \"Consumables\",\n    pos = {x = 4, y = 1 },\n    cost = 8,\n    use = function(self, card, context, copier)\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n            local tags = {\n                \"tag_standard\",\n                \"tag_charm\",\n                \"tag_meteor\",\n                \"tag_buffoon\"\n            }\n            local tag = Tag(pseudorandom_element(tags, pseudoseed(\"midway\")))\n            add_tag(tag)\n            play_sound('generic1', 0.9 + math.random()*0.1, 0.8)\n            play_sound('holo1', 1.2 + math.random()*0.1, 0.4)\n            card:juice_up(0.3, 0.5)\n        return true end}))\n        delay(0.5)\n    end,\n    can_use = function(self, card)\n        return true\n    end"
    },
    {
      "type": "Consumable",
      "key": "pie",
      "atlas": "Consumables",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"pie\",\n    set = \"Silly\",\n    config = {\n        max_highlighted = 2,\n    },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.max_highlighted } }\n    end,\n    atlas = \"Consumables\",\n    pos = { x = 2, y = 0 },\n    cost = 3,\n    use = function(self, card, context, copier)\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n            play_sound('tarot1')\n            card:juice_up(0.3, 0.5)\n            return true end }))\n        for i=1, #G.hand.highlighted do\n            local percent = 1.15 - (i-0.999)/(#G.hand.highlighted-0.998)*0.3\n            G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.15,func = function() G.hand.highlighted[i]:flip();play_sound('card1', percent);G.hand.highlighted[i]:juice_up(0.3, 0.3);return true end }))\n        end\n        delay(0.2)\n        local leftmost = G.hand.highlighted[1]\n        for i=1, #G.hand.highlighted do\n            G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.1,func = function()\n                if G.hand.highlighted[i] ~= leftmost then\n                    if SMODS.has_enhancement(leftmost, 'm_stone') then\n                        G.hand.highlighted[i]:set_ability('m_stone', nil, false)\n                    else\n                        SMODS.change_base(G.hand.highlighted[i], nil, leftmost.base.value)\n                        card:juice_up(0.3, 0.5)\n                    end\n                end\n            return true end }))\n        end\n        for i=1, #G.hand.highlighted do\n            local percent = 0.85 + (i-0.999)/(#G.hand.highlighted-0.998)*0.3\n            G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.15,func = function() G.hand.highlighted[i]:flip();play_sound('tarot2', percent, 0.6);G.hand.highlighted[i]:juice_up(0.3, 0.3);return true end }))\n        end\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.2,func = function() update_hand_text({immediate = true, nopulse = true, delay = 0}, {mult = 0, chips = 0, level = '', handname = ''}); G.hand:unhighlight_all(); return true end }))\n        delay(0.5)\n    end,\n    can_use = function(self, card)\n        if G.hand and #G.hand.highlighted <= card.ability.max_highlighted and #G.hand.highlighted > 1 then\n            if not SMODS.has_no_rank(G.hand.highlighted[1]) then\n                return true\n            end\n\t\tend\n\t\treturn false\n    end,"
    },
    {
      "type": "Consumable",
      "key": "rodeo",
      "atlas": "Consumables",
      "pos": {
        "x": 5,
        "y": 1
      },
      "raw": "key = \"rodeo\",\n    set = \"Silly\",\n    config = {\n        max_highlighted = 2,\n    },\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue+1] = G.P_CENTERS.e_foil\n        info_queue[#info_queue+1] = G.P_CENTERS.e_holo\n        info_queue[#info_queue+1] = G.P_CENTERS.e_polychrome\n        return { vars = { card.ability.max_highlighted } }\n    end,\n    atlas = \"Consumables\",\n    pos = { x = 5, y = 1 },\n    cost = 5,\n    use = function(self, card, context, copier)\n        local cards = { G.hand.highlighted[1], G.hand.highlighted[2] }\n        local destroy_card = pseudorandom_element(cards, pseudoseed('rodeo'))\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n            play_sound('tarot1')\n            card:juice_up(0.3, 0.5)\n        return true end }))\n        for i = 1, #G.hand.highlighted do\n            -- adapted from vanilla code, so sorry for the mess\n            if G.hand.highlighted[i] ~= destroy_card then\n                local percent = 1.15 - (i-0.999)/(#G.hand.highlighted-0.998)*0.3\n                G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.15,func = function()\n                    G.hand.highlighted[i]:flip()\n                    play_sound('card1', percent)\n                    G.hand.highlighted[i]:juice_up(0.3, 0.3)\n                return true end }))\n                delay(0.6)\n                G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.1,func = function()\n                    G.hand.highlighted[i]:set_edition(poll_edition('rodeo', nil, true, true), nil, true)\n                return true end }))\n                local percent = 0.85 + (i-0.999)/(#G.hand.highlighted-0.998)*0.3\n                G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.15,func = function()\n                    G.hand.highlighted[i]:flip()\n                    play_sound('tarot2', percent, 0.6)\n                    G.hand.highlighted[i]:juice_up(0.3, 0.3)\n                return true end }))\n                G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.2,func = function() \n                    G.hand:unhighlight_all()\n                return true end }))\n            end\n        end\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.1,\n            func = function()\n                local d_card = destroy_card\n                if d_card.ability.name == 'Glass Card' then\n                    d_card:shatter()\n                else\n                    d_card:start_dissolve(nil)\n                end\n                return true\n            end\n        }))\n        delay(0.6)\n        SMODS.calculate_context({ remove_playing_cards = true, removed = {destroy_card} })\n    end,"
    },
    {
      "type": "Consumable",
      "key": "soully",
      "atlas": "Consumables",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = \"soully\",\n    set = \"Silly\",\n    atlas = \"Consumables\",\n    pos = {x = 0, y = 2 },\n    soul_pos = { x = 2, y = 2,\n        draw = function(card, scale_mod, rotate_mod)\n            local _scale_mod = 0.08 + 0.05*math.sin(1.8*G.TIMERS.REAL) + 0.03*math.sin((G.TIMERS.REAL - math.floor(G.TIMERS.REAL))*math.pi*11)*(1 - (G.TIMERS.REAL - math.floor(G.TIMERS.REAL)))^3\n            local _rotate_mod = 0.2*math.sin(1.219*G.TIMERS.REAL) + 0.10*math.sin((G.TIMERS.REAL)*math.pi*5)*(1 - (G.TIMERS.REAL - math.floor(G.TIMERS.REAL)))^2\n\n            card.children.floating_sprite.role.draw_major = card\n            card.children.floating_sprite:draw_shader('dissolve',0, nil, nil, card.children.center, _scale_mod, _rotate_mod,nil, 0.1 + 0.03*math.sin(1.8*G.TIMERS.REAL),nil, 0.6)\n            card.children.floating_sprite:draw_shader('dissolve', nil, nil, nil, card.children.center, _scale_mod, _rotate_mod)\n        end,\n    },\n    cost = 10,\n    hidden = true,\n    soul_set = \"Spectral\",\n    use = function(self, card, context, copier)\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n            local key = LR_UTIL.get_fmod_legendaries('soully')\n            play_sound('timpani')\n            SMODS.add_card({set = 'Joker', area = G.jokers, key = key})\n            return true end }))\n        delay(0.6)\n    end,\n    can_use = function(self, card)\n        if #G.jokers.cards < G.jokers.config.card_limit or self.area == G.jokers then\n            return true\n        else\n            return false\n        end\n    end"
    },
    {
      "type": "Consumable",
      "key": "split_pants",
      "atlas": "Consumables",
      "pos": {
        "x": 8,
        "y": 0
      },
      "raw": "key = \"split_pants\",\n    set = \"Silly\",\n    config = {\n        max_highlighted = 2,\n    },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.max_highlighted } }\n    end,\n    atlas = \"Consumables\",\n    pos = { x = 8, y = 0 },\n    cost = 3,\n    use = function(self, card, context, copier)\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n            play_sound('tarot1')\n            card:juice_up(0.3, 0.5)\n            return true end }))\n        for i=1, #G.hand.highlighted do\n            local percent = 1.15 - (i-0.999)/(#G.hand.highlighted-0.998)*0.3\n            G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.15,func = function() G.hand.highlighted[i]:flip();play_sound('card1', percent);G.hand.highlighted[i]:juice_up(0.3, 0.3);return true end }))\n        end\n        delay(0.2)\n        for i=1, #G.hand.highlighted do\n            G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.1,func = function()\n                local card = G.hand.highlighted[i]\n                local suit = card.base.suit\n                local rank = math.max(card.base.id-1, 1)\n                if rank == 1 then rank = 'Ace'\n                elseif rank <= 10 then rank = tostring(rank)\n                elseif rank == 11 then rank = 'Jack'\n                elseif rank == 12 then rank = 'Queen'\n                elseif rank == 13 then rank = 'King'\n                end\n                assert(SMODS.change_base(card, suit, rank))\n            return true end }))\n        end\n        for i=1, #G.hand.highlighted do\n            local percent = 0.85 + (i-0.999)/(#G.hand.highlighted-0.998)*0.3\n            G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.15,func = function() G.hand.highlighted[i]:flip();play_sound('tarot2', percent, 0.6);G.hand.highlighted[i]:juice_up(0.3, 0.3);return true end }))\n        end\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.2,func = function() update_hand_text({immediate = true, nopulse = true, delay = 0}, {mult = 0, chips = 0, level = '', handname = ''}); G.hand:unhighlight_all(); return true end }))\n        delay(0.5)\n    end,"
    },
    {
      "type": "Consumable",
      "key": "squirt_flower",
      "atlas": "Consumables",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"squirt_flower\",\n    set = \"Silly\",\n    config = {\n        max_highlighted = 2\n    },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.max_highlighted } }\n    end,\n    atlas = \"Consumables\",\n    pos = { x = 1, y = 0 },\n    cost = 3,\n    use = function(self, card, context, copier)\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n            play_sound('tarot1')\n            card:juice_up(0.3, 0.5)\n            return true end }))\n        for i=1, #G.hand.highlighted do\n            local percent = 1.15 - (i-0.999)/(#G.hand.highlighted-0.998)*0.3\n            G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.15,func = function() G.hand.highlighted[i]:flip();play_sound('card1', percent);G.hand.highlighted[i]:juice_up(0.3, 0.3);return true end }))\n        end\n        delay(0.2)\n        local leftmost = G.hand.highlighted[1]\n        for i=1, #G.hand.highlighted do\n            G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.1,func = function()\n                if G.hand.highlighted[i] ~= leftmost then\n                    G.hand.highlighted[i]:set_seal(leftmost.seal, nil, true)\n                    card:juice_up(0.3, 0.5)\n                end\n            return true end }))\n        end\n        for i=1, #G.hand.highlighted do\n            local percent = 0.85 + (i-0.999)/(#G.hand.highlighted-0.998)*0.3\n            G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.15,func = function() G.hand.highlighted[i]:flip();play_sound('tarot2', percent, 0.6);G.hand.highlighted[i]:juice_up(0.3, 0.3);return true end }))\n        end\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.2,func = function() update_hand_text({immediate = true, nopulse = true, delay = 0}, {mult = 0, chips = 0, level = '', handname = ''}); G.hand:unhighlight_all(); return true end }))\n        delay(0.5)\n    end,\n    can_use = function(self, card)\n\t\tif G.hand and #G.hand.highlighted <= card.ability.max_highlighted and #G.hand.highlighted > 1 then\n            if G.hand.highlighted[1].seal then\n                return true\n            end\n\t\tend\n\t\treturn false\n    end,\n    in_pool = function(self, args)\n        for _, playing_card in ipairs(G.playing_cards or {}) do\n            if playing_card.seal then\n                return true\n            end\n        end\n        return false\n    end"
    },
    {
      "type": "Consumable",
      "key": "suspenders",
      "atlas": "Consumables",
      "pos": {
        "x": 5,
        "y": 2
      },
      "raw": "key = \"suspenders\",\n            set = \"Silly\",\n            config = {\n                max_highlighted = 2,\n            },\n            loc_vars = function(self, info_queue, card)\n                return { vars = { card.ability.max_highlighted } }\n            end,\n            atlas = \"Consumables\",\n            pos = { x = 5, y = 2 },\n            cost = 3,\n            use = function(self, card, context, copier)\n                G.E_MANAGER:add_event(Event({\n                    trigger = 'after',\n                    delay = 0.4,\n                    func = function()\n                        play_sound('tarot1')\n                        card:juice_up(0.3, 0.5)\n                        return true\n                    end\n                }))\n                for i = 1, #G.hand.highlighted do\n                    local percent = 1.15 - (i - 0.999) / (#G.hand.highlighted - 0.998) * 0.3\n                    G.E_MANAGER:add_event(Event({\n                        trigger = 'after',\n                        delay = 0.15,\n                        func = function()\n                            G.hand.highlighted[i]:flip(); play_sound('card1', percent); G.hand.highlighted[i]:juice_up(0.3, 0.3); return true\n                        end\n                    }))\n                end\n                delay(0.2)\n                local leftmost = G.hand.highlighted[1]\n                for i = 1, #G.hand.highlighted do\n                    G.E_MANAGER:add_event(Event({\n                        trigger = 'after',\n                        delay = 0.1,\n                        func = function()\n                            if G.hand.highlighted[i] ~= leftmost then\n                                PB_UTIL.set_paperclip(G.hand.highlighted[i], string.sub(PB_UTIL.has_paperclip(leftmost), 11, -6))\n                                card:juice_up(0.3, 0.5)\n                            end\n                            return true\n                        end\n                    }))\n                end\n                for i = 1, #G.hand.highlighted do\n                    local percent = 0.85 + (i - 0.999) / (#G.hand.highlighted - 0.998) * 0.3\n                    G.E_MANAGER:add_event(Event({\n                        trigger = 'after',\n                        delay = 0.15,\n                        func = function()\n                            G.hand.highlighted[i]:flip(); play_sound('tarot2', percent, 0.6); G.hand.highlighted[i]:juice_up(0.3,0.3); return true\n                        end\n                    }))\n                end\n                G.E_MANAGER:add_event(Event({\n                    trigger = 'after',\n                    delay = 0.2,\n                    func = function()\n                        update_hand_text({ immediate = true, nopulse = true, delay = 0 },\n                            { mult = 0, chips = 0, level = '', handname = '' }); G.hand:unhighlight_all(); return true\n                    end\n                }))\n                delay(0.5)\n            end,\n            can_use = function(self, card)\n                if G.hand and #G.hand.highlighted <= card.ability.max_highlighted and #G.hand.highlighted > 1 and PB_UTIL.has_paperclip(G.hand.highlighted[1]) then\n                    return true\n                end\n                return false\n            end,\n            --[[set_badges = function(self, card, badges)\n                SMODS.create_mod_badges({ mod = SMODS.find_mod(\"paperback\")[1] }, badges)\n            end,]]--"
    },
    {
      "type": "Consumable",
      "key": "tightrope",
      "atlas": "Consumables",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"tightrope\",\n    set = \"Silly\",\n    config = {\n        max_highlighted = 1,\n        extra = {\n            copy_1_amt = 1,\n            copy_2_amt = 2,\n            destroy_amt = 1,\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        return { vars = {  } }\n    end,\n    atlas = \"Consumables\",\n    pos = { x = 1, y = 1 },\n    cost = 3,\n    use = function(self, card, context, copier)\n        local pseudo = pseudorandom(pseudoseed('tightrope'))\n        if pseudo <= 0.5 then\n            -- 50% chance to copy 1 card\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    local _first_dissolve = nil\n                    local new_cards = {}\n                    for i = 1, card.ability.extra.copy_1_amt do\n                        G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                        local _card = copy_card(G.hand.highlighted[1], nil, nil, G.playing_card)\n                        _card:add_to_deck()\n                        G.deck.config.card_limit = G.deck.config.card_limit + 1\n                        table.insert(G.playing_cards, _card)\n                        G.hand:emplace(_card)\n                        _card:start_materialize(nil, _first_dissolve)\n                        _first_dissolve = true\n                        new_cards[#new_cards+1] = _card\n                    end\n                    playing_card_joker_effects(new_cards)\n                    return true\n                end\n            }))\n        elseif pseudo <= 0.75 then\n            -- 25% chance to copy 2 cards\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    local _first_dissolve = nil\n                    local new_cards = {}\n                    for i = 1, card.ability.extra.copy_2_amt do\n                        G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                        local _card = copy_card(G.hand.highlighted[1], nil, nil, G.playing_card)\n                        _card:add_to_deck()\n                        G.deck.config.card_limit = G.deck.config.card_limit + 1\n                        table.insert(G.playing_cards, _card)\n                        G.hand:emplace(_card)\n                        _card:start_materialize(nil, _first_dissolve)\n                        _first_dissolve = true\n                        new_cards[#new_cards+1] = _card\n                    end\n                    playing_card_joker_effects(new_cards)\n                    return true\n                end\n            }))\n        else\n            -- 25% chance to destroy the card\n            local destroy_card = G.hand.highlighted[1]\n            G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n                play_sound('tarot1')\n                card:juice_up(0.3, 0.5)\n                return true\n            end }))\n            G.E_MANAGER:add_event(Event({\n                trigger = 'after',\n                delay = 0.1,\n                func = function()\n                    local d_card = destroy_card\n                    if d_card.ability.name == 'Glass Card' then\n                        d_card:shatter()\n                    else\n                        d_card:start_dissolve(nil)\n                    end\n                    return true\n                end\n            }))\n            SMODS.calculate_context({ remove_playing_cards = true, removed = {destroy_card} })\n        end\n    end,"
    },
    {
      "type": "Consumable",
      "key": "trapeze",
      "atlas": "Consumables",
      "pos": {
        "x": 6,
        "y": 1
      },
      "raw": "key = \"trapeze\",\n    set = \"Silly\",\n    config = {\n        extra = {\n            amount = 5,\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue+1] = G.P_CENTERS.c_soul\n        info_queue[#info_queue+1] = G.P_CENTERS.c_fmod_soully\n        if GB then info_queue[#info_queue+1] = G.P_CENTERS.c_gb_shatter end\n        if MINTY then info_queue[#info_queue+1] = G.P_CENTERS.c_minty_wand end\n        if next(SMODS.find_mod(\"VISIBILITY\")) then info_queue[#info_queue+1] = G.P_CENTERS.c_vis_hamsa end\n        return { vars = { G.GAME.trapeze_count, card.ability.extra.amount } }\n    end,\n    atlas = \"Consumables\",\n    pos = {x = 6, y = 1 },\n    cost = 5,\n    use = function(self, card, context, copier)\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n            play_sound('timpani')\n            card:juice_up(0.3, 0.5)\n            G.GAME.trapeze_count = (G.GAME.trapeze_count or 0) + 1\n            return true end }))\n        delay(0.6)\n    end,\n    can_use = function(self, card)\n        return true\n    end,\n    set_ability = function(self, card, initial, delay_sprites)\n        if G.GAME.trapeze_count == card.ability.extra.amount then\n            local eval = function() return not card.REMOVED end\n            juice_card_until(card, eval, true)\n        end\n    end"
    },
    {
      "type": "Consumable",
      "key": "unicycle",
      "atlas": "Consumables",
      "pos": {
        "x": 9,
        "y": 0
      },
      "raw": "key = \"unicycle\",\n    set = \"Silly\",\n    config = {\n        max_highlighted = 2\n    },\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue+1] = LR_UTIL.marking_tooltip(\"crease\")\n        return { vars = { card.ability.max_highlighted } }\n    end,\n    atlas = \"Consumables\",\n    pos = { x = 9, y = 0 },\n    cost = 4,\n    use = function(self, card, context, copier)\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n            play_sound('tarot1')\n            card:juice_up(0.3, 0.5)\n            return true end }))\n        for i=1, #G.hand.highlighted do\n            local percent = 1.15 - (i-0.999)/(#G.hand.highlighted-0.998)*0.3\n            G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.15,func = function() G.hand.highlighted[i]:flip();play_sound('card1', percent);G.hand.highlighted[i]:juice_up(0.3, 0.3);return true end }))\n        end\n        delay(0.2)\n        for i=1, #G.hand.highlighted do\n            G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.1,func = function()\n                LR_UTIL.set_marking(G.hand.highlighted[i], 'crease')\n            return true end }))\n        end\n        for i=1, #G.hand.highlighted do\n            local percent = 0.85 + (i-0.999)/(#G.hand.highlighted-0.998)*0.3\n            G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.15,func = function() G.hand.highlighted[i]:flip();play_sound('tarot2', percent, 0.6);G.hand.highlighted[i]:juice_up(0.3, 0.3);return true end }))\n        end\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.2,func = function() update_hand_text({immediate = true, nopulse = true, delay = 0}, {mult = 0, chips = 0, level = '', handname = ''}); G.hand:unhighlight_all(); return true end }))\n        delay(0.5)\n    end,"
    },
    {
      "type": "Consumable",
      "key": "whoopie_cushion",
      "atlas": "Consumables",
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "key = \"whoopie_cushion\",\n    set = \"Silly\",\n    config = {\n        max_highlighted = 2,\n    },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.max_highlighted } }\n    end,\n    atlas = \"Consumables\",\n    pos = { x = 4, y = 0 },\n    cost = 3,\n    use = function(self, card, context, copier)\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n            play_sound('tarot1')\n            card:juice_up(0.3, 0.5)\n            return true end }))\n        for i=1, #G.hand.highlighted do\n            local percent = 1.15 - (i-0.999)/(#G.hand.highlighted-0.998)*0.3\n            G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.15,func = function() G.hand.highlighted[i]:flip();play_sound('card1', percent);G.hand.highlighted[i]:juice_up(0.3, 0.3);return true end }))\n        end\n        delay(0.2)\n        local leftmost = G.hand.highlighted[1]\n        for i=1, #G.hand.highlighted do\n            G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.1,func = function()\n                if G.hand.highlighted[i] ~= leftmost then\n                    G.hand.highlighted[i]:set_ability(leftmost.config.center)\n                    card:juice_up(0.3, 0.5)\n                end\n            return true end }))\n        end\n        for i=1, #G.hand.highlighted do\n            local percent = 0.85 + (i-0.999)/(#G.hand.highlighted-0.998)*0.3\n            G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.15,func = function() G.hand.highlighted[i]:flip();play_sound('tarot2', percent, 0.6);G.hand.highlighted[i]:juice_up(0.3, 0.3);return true end }))\n        end\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.2,func = function() update_hand_text({immediate = true, nopulse = true, delay = 0}, {mult = 0, chips = 0, level = '', handname = ''}); G.hand:unhighlight_all(); return true end }))\n        delay(0.5)\n    end,\n    can_use = function(self, card)\n\t\tif G.hand and #G.hand.highlighted <= card.ability.max_highlighted and #G.hand.highlighted > 1 then\n            for _, playing_card in ipairs(G.hand.highlighted) do\n                if next(SMODS.get_enhancements(playing_card)) then\n                    return true\n                end\n            end\n\t\tend\n\t\treturn false\n    end,\n    in_pool = function(self, args)\n        for _, playing_card in ipairs(G.playing_cards or {}) do\n            if next(SMODS.get_enhancements(playing_card)) then\n                return true\n            end\n        end\n        return false\n    end"
    },
    {
      "type": "Back",
      "key": "clown",
      "atlas": "Decks",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = 'clown',\n    atlas = 'Decks',\n    pos = { x = 0, y = 1 },\n    config = {\n        voucher = 'v_fmod_circus'\n    },\n    unlocked = true,\n    discovered = true,\n    loc_vars = function(self, info_queue, card)\n        return {\n            vars = {\n                localize {\n                    type = \"name_text\",\n                    set = \"Voucher\",\n                    key = \"v_fmod_circus\"\n                }, \n                colours = {HEX(\"ff98e2\")}\n            }\n        }\n    end"
    },
    {
      "type": "Back",
      "key": "fennex",
      "atlas": "Decks",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = 'fennex',\n    atlas = 'Decks',\n    pos = { x = 1, y = 1 },\n    unlocked = true,\n    discovered = true,\n    config = {\n        jokers = {\n            'j_fmod_fennex'\n        }\n    },"
    },
    {
      "type": "Back",
      "key": "harmony",
      "atlas": "Decks",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = 'harmony',\n    atlas = 'Decks',\n    pos = { x = 2, y = 1 },\n    unlocked = true,\n    discovered = true,\n    config = {\n        discards = -2\n    },\n    apply = function(self, back)\n        G.GAME.starting_params.fmod_harmony = true\n    end"
    },
    {
      "type": "Back",
      "key": "reaper",
      "atlas": "Decks",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = 'reaper',\n    atlas = 'Decks',\n    pos = { x = 3, y = 1 },\n    unlocked = true,\n    discovered = true,\n    config = {\n        hands = 1,\n        discards = 1,\n        hand_size = 1,\n        joker_slot = 1,\n    },\n    loc_vars = function(self, info_queue, card)\n    end,\n    apply = function(self, back)\n        G.GAME.reaper_set = true\n    end,\n    calculate = function(self, back, context)\n        if context.end_of_round and G.GAME.blind.boss then\n            G.GAME.reaper_set = true\n            return\n        end\n        if context.setting_blind and G.GAME.blind.boss then\n            G.GAME.blind.chips = G.GAME.blind.chips * 2\n            G.GAME.blind.chip_text = number_format(G.GAME.blind.chips)\n        end\n    end"
    },
    {
      "type": "Back",
      "key": "recursive",
      "atlas": "Decks",
      "pos": {
        "x": 4,
        "y": 1
      },
      "raw": "key = \"recursive\",\n    atlas = \"Decks\",\n    pos = { x = 4, y = 1 },\n    config = {\n    },\n    unlocked = true,\n    discovered = true,"
    },
    {
      "type": "Enhancement",
      "key": "copycat_card",
      "atlas": "Decks",
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "key = \"copycat_card\",\n    atlas = \"Decks\",\n    pos = { x = 4, y = 0 },\n    config = {\n        extra = {\n            \n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.rank } }\n    end,\n    calculate = function(self, card, context)\n        if context.after and context.cardarea == G.play then\n            local rank = pseudorandom_element(SMODS.Ranks, \"copycat_card\").key\n            for k, v in ipairs(context.scoring_hand) do\n                if SMODS.has_enhancement(v, \"m_fmod_copycat_card\") then\n                    v.ability.copy_master = true\n                    break\n                end\n            end\n            if card.ability.copy_master and SMODS.has_enhancement(card, \"m_fmod_copycat_card\") then\n                local copycats = {}\n                local copy = false\n                for i = 1, #G.hand.cards do\n                    if SMODS.has_enhancement(G.hand.cards[i], \"m_fmod_copycat_card\") then copycats[#copycats + 1] = G.hand.cards[i] end\n                end\n                for i = 1, #G.play.cards do\n                    if SMODS.has_enhancement(G.play.cards[i], \"m_fmod_copycat_card\") then copycats[#copycats + 1] = G.play.cards[i] end\n                end\n                if #copycats > 0 then\n                    copy = true\n                    for i = 1, #copycats do\n                        local percent = 1.15 - (i - 0.999) / (#copycats - 0.998) * 0.3\n                        G.E_MANAGER:add_event(Event({\n                            trigger = 'after',\n                            delay = 0.15,\n                            func = function()\n                                copycats[i]:flip(); play_sound('card1', percent); copycats[i]:juice_up(0.3, 0.3); return true\n                            end\n                        }))\n                    end\n                end\n                delay(0.2)\n                for i = 1, #copycats do\n                    local _card = copycats[i]\n                    if SMODS.has_enhancement(_card, \"m_fmod_copycat_card\") then\n                        G.E_MANAGER:add_event(Event({\n                            func = function()\n                                assert(SMODS.change_base(_card, nil, rank))\n                                _card:juice_up(0.3, 0.5)\n                                return true\n                            end\n                        }))\n                    end\n                end\n                delay(0.2)\n                if copy then\n                    for i = 1, #copycats do\n                        local percent = 0.85 + (i - 0.999) / (#copycats - 0.998) * 0.3\n                        G.E_MANAGER:add_event(Event({\n                            trigger = 'after',\n                            delay = 0.15,\n                            func = function()\n                                copycats[i]:flip(); play_sound('tarot2', percent, 0.6); copycats[i]:juice_up(0.3, 0.3); return true\n                            end\n                        }))\n                    end\n                end\n                for i = 1, #G.playing_cards do\n                    local _card = G.playing_cards[i]\n                    local changable = true\n                    for n = 1, #copycats do\n                        if _card == copycats[n] then\n                            changable = false\n                            break\n                        end\n                    end\n                    if changable and SMODS.has_enhancement(_card, \"m_fmod_copycat_card\") then\n                        G.E_MANAGER:add_event(Event({\n                            func = function()\n                                assert(SMODS.change_base(_card, nil, rank))\n                                return true\n                            end\n                        }))\n                    end\n                end\n                card.ability.copy_master = false\n            end\n        end\n    end"
    },
    {
      "type": "Enhancement",
      "key": "raffle_card",
      "atlas": "Decks",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"raffle_card\",\n    atlas = \"Decks\",\n    pos = { x = 3, y = 0 },\n    config = {\n        extra = {\n            odds = 5,\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { (G.GAME.probabilities.normal or 1), (aij and 5 or card.ability.extra.odds) } }\n    end,\n    calculate = function(self, card, context)\n        if context.main_scoring and context.cardarea == G.play then\n            local free = nil\n            local silly = nil\n            if next(SMODS.find_card('j_fmod_free_shipping')) then\n                free = 'e_negative'\n            end\n            if next(SMODS.find_card('j_fmod_comic_book_ad')) then\n                silly = true\n            end\n            if pseudorandom(\"raffle_cons\") < G.GAME.probabilities.normal / (aij and 5 or card.ability.extra.odds) and (free or (#G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit)) then\n                G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1\n                local selected = \"\"\n                local passed = false\n                local tries = 50\n                while tries > 0 and not passed do -- modified from a cryptid function, could easily be absolute garbage\n                    tries = tries - 1\n                    passed = false\n                    local key = \"\"\n                    if not silly then\n                        key = pseudorandom_element(G.P_CENTER_POOLS.Consumeables, pseudoseed(\"raffle_cons\")).key\n                    else\n                        key = pseudorandom_element(G.P_CENTER_POOLS.Silly, pseudoseed(\"raffle_cons\")).key\n                    end\n                    selected = G.P_CENTERS[key]\n                    if not (selected[\"hidden\"] or (G.GAME and G.GAME[\"hidden\"] and G.GAME[\"hidden\"][selected]) or false) then\n                        passed = true\n                    end\n                    if passed or tries <= 0 then\n                        if tries <= 0 then\n                            selected = \"c_strength\"\n                        else\n                            selected = selected\n                        end\n                    end\n                end\n                G.E_MANAGER:add_event(Event({\n                    delay = 0.3,\n                    func = function()\n                        SMODS.add_card( { area = G.consumeables, soulable = false, key = selected.key, edition = (free or nil) })\n                        G.GAME.consumeable_buffer = 0\n                        return true\n                    end\n                }))\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "blue_angel_mushroom",
      "atlas": "Jokers",
      "pos": {
        "x": 4,
        "y": 1
      },
      "raw": "key = 'blue_angel_mushroom',\n\tatlas = 'Jokers',\n\tpos = { x = 4, y = 1 },\n\trarity = 2,\n\tcost = 5,\n\tunlocked = true,\n\tdiscovered = true,\n\tblueprint_compat = false,\n\tconfig = { extra = { life = 3, uses = 0 } },\n\tloc_vars = function(self, info_queue, card)\n\t\treturn {\n\t\t\tvars = {\n\t\t\t\tcard.ability.extra.life,\n                card.ability.extra.life - card.ability.extra.uses,\n\t\t}\n    }\n\tend,\n\tcalculate = function(self, card, context)\n\t\tif context.after and G.GAME.current_round.hands_left == 0 and G.GAME.blind.chips > G.GAME.chips then\n            card.ability.extra.uses = card.ability.extra.uses + 1\n            G.GAME.current_round.hands_left = G.GAME.current_round.hands_left + 1\n            if card.ability.extra.uses < card.ability.extra.life then\n                return {\n                    message = localize('k_saved_ex'),\n                    colour = G.C.RED\n                }\n            else\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        G.hand_text_area.blind_chips:juice_up()\n                        G.hand_text_area.game_chips:juice_up()\n                        play_sound('tarot1')\n                        card:start_dissolve()\n                        return true\n                    end\n                }))\n                return {\n                    message = localize('k_saved_ex'),\n                    colour = G.C.RED\n                }\n            end\n        end\n\tend"
    },
    {
      "type": "Joker",
      "key": "calculator",
      "atlas": "Jokers",
      "pos": {
        "x": 7,
        "y": 1
      },
      "raw": "key = \"calculator\",\n    config = {\n        extra = {\n            inactive_hands = 0,\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        if card.ability.extra.inactive_hands > 0 then\n            local hands_left = card.ability.extra.inactive_hands\n            return { vars = {\n                \"Inactive for \",\n                hands_left,\n                \" hand\" .. (card.ability.extra.inactive_hands == 1 and \"\" or \"s\")\n            } }\n        else\n            return { vars = { \"Active!\", \"\", \"\" } }\n        end\n    end,\n    rarity = 2,\n    atlas = \"Jokers\",\n    unlocked = true,\n    discovered = true,\n    pos = { x = 7, y = 1 },\n    pixel_size = { w = 71, h = 65 },\n    cost = 4,\n    blueprint_compat = true,\n    calculate = function(self, card, context)\n        if context.joker_main and card.ability.extra.inactive_hands == 0 then\n            local first_card = context.scoring_hand[1]\n            local last_card = context.scoring_hand[#context.scoring_hand]\n            if card.ability.extra.inactive_hands == 0 then\n                if first_card ~= last_card\n                and not SMODS.has_no_rank(first_card)\n                and not SMODS.has_no_rank(last_card) then\n                    local function adjusted_id(card)\n                        local id = card:get_id()\n                        if id >= 11 and id <= 13 then\n                            return 10\n                        elseif id == 14 then\n                            return 11\n                        else\n                            return id\n                        end\n                    end\n                    local xmult = adjusted_id(first_card) - adjusted_id(last_card)\n                    if xmult > 1 then\n                        if not context.blueprint then\n                            card.ability.extra.inactive_hands_to_add = (card.ability.extra.inactive_hands_to_add or 0) + xmult\n                        end\n                        return {\n                            xmult = xmult\n                        }\n                    end\n                end\n            end\n        end\n        if context.after and not context.blueprint then\n            if card.ability.extra.inactive_hands_to_add then\n                card.ability.extra.inactive_hands =\n                    card.ability.extra.inactive_hands + card.ability.extra.inactive_hands_to_add\n                card.ability.extra.inactive_hands_to_add = nil\n            else\n                card.ability.extra.inactive_hands = math.max(card.ability.extra.inactive_hands - 1, 0)\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "civic_secretary",
      "atlas": "Jokers",
      "pos": {
        "x": 8,
        "y": 1
      },
      "raw": "key = 'civic_secretary',\n    config = { extra = { active = false }},\n    loc_vars = function(self,info_queue,card)\n\t\treturn {vars = {}}\n\tend,\n\trarity = 2,\n    atlas = 'Jokers',\n    unlocked = true,\n    discovered = true,\n    pos = { x = 8, y = 1 },\n\tcost = 6,\n\tblueprint_compat = true,\n\tcalculate = function(self,card,context)\n\t\tif context.before then\n\t\t\tcard.ability.extra.active = true\n\t\tend\n\t\tif context.after then\n\t\t\tcard.ability.extra.active = false\n\t\tend\n\t\tif card.ability.extra.active then\n            local total_chips = 0\n            local total_mult = 0\n\t\t\tfor _, v in ipairs(G.jokers.cards) do\n\t\t\t\tif v.ability.name ~= 'Blueprint' and v.ability.name ~= 'Brainstorm' and v.ability.name ~= \"j_fmod_civic_secretary\" then\n\t\t\t\t\tcontext.blueprint = nil\n\t\t\t\t\tlocal ret = SMODS.blueprint_effect(card, v, context)\n\t\t\t\t\tif ret then\n\t\t\t\t\t\ttotal_chips = total_chips + (ret.chips or 0)\n                        total_chips = total_chips + (ret.chip_mod or 0)\n                        total_mult = total_mult + (ret.mult or 0)\n                        total_mult = total_mult + (ret.mult_mod or 0)\n                        total_mult = total_mult + (ret.h_mult or 0)\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n            if total_chips > 0 or total_mult > 0 then\n                return {\n                    chips = total_chips,\n                    mult = total_mult,\n                }\n            end\n\t\tend\n\tend,"
    },
    {
      "type": "Joker",
      "key": "claw_machine",
      "atlas": "Jokers",
      "pos": {
        "x": 6,
        "y": 2
      },
      "raw": "key = 'claw_machine',\n    config = {\n        extra = {\n            xmult = 1.1,\n            odds = 7,\n            increase = 0.1\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n\t\treturn {vars = { card.ability.extra.xmult, (G.GAME.probabilities.normal or 1), card.ability.extra.odds, card.ability.extra.increase } }\n\tend,\n\trarity = 3,\n    atlas = 'Jokers',\n    unlocked = true,\n    discovered = true,\n    pos = { x = 6, y = 2 },\n\tcost = 8,\n\tblueprint_compat = true,\n\tcalculate = function(self,card,context)\n\t\tif context.individual and context.cardarea == G.hand and not context.end_of_round and context.other_card:get_id() == 7 then\n            if pseudorandom('claw') < G.GAME.probabilities.normal / card.ability.extra.odds and not context.blueprint then\n                card.ability.extra.xmult = card.ability.extra.xmult + card.ability.extra.increase\n            end\n            if not context.other_card.debuff then\n                return {\n                    x_mult = card.ability.extra.xmult\n                }\n            end\n        end\n\tend,"
    },
    {
      "type": "Joker",
      "key": "comic_book_ad",
      "atlas": "Jokers",
      "pos": {
        "x": 5,
        "y": 5
      },
      "raw": "key = \"comic_book_ad\",\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue+1] = G.P_CENTERS.m_fmod_raffle_card\n        return { vars = { colours = {HEX(\"ff98e2\")} } }\n    end,\n    rarity = 1,\n    atlas = \"Jokers\",\n    unlocked = true,\n    discovered = true,\n    blueprint_compat = false,\n    pos = { x = 5, y = 5 },\n    cost = 4,\n    enhancement_gate = \"m_fmod_raffle_card\""
    },
    {
      "type": "Joker",
      "key": "countdown",
      "atlas": "Jokers",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"countdown\",\n    config = {\n        extra = {\n            rank = 13,\n            mult = 15,\n            xmult = 3\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        local rank = nil\n        if card.ability.extra.rank == 14 then\n            rank = localize(\"Ace\", \"ranks\")\n        elseif card.ability.extra.rank == 13 then\n            rank = localize(\"King\", \"ranks\")\n        elseif card.ability.extra.rank == 12 then\n            rank = localize(\"Queen\", \"ranks\")\n        elseif card.ability.extra.rank == 11 then\n            rank = localize(\"Jack\", \"ranks\")\n        else\n            rank = card.ability.extra.rank\n        end\n        return { vars = { rank, card.ability.extra.mult, localize(\"Ace\", \"ranks\"), card.ability.extra.xmult } }\n    end,\n    rarity = 2,\n    atlas = \"Jokers\",\n    unlocked = true,\n    discovered = true,\n    blueprint_compat = true,\n    pos = { x = 3, y = 0 },\n    cost = 5,\n    calculate = function(self, card, context)\n        if context.individual and context.cardarea == G.play then\n            if context.other_card:get_id() == card.ability.extra.rank then\n                local ret = {}\n                if card.ability.extra.rank == 14 then\n                    if not context.blueprint then card.ability.extra.rank = card.ability.extra.rank - 1 end\n                    ret = {\n                        message = localize(\"k_reset\"),\n                        mult = card.ability.extra.mult,\n                        xmult = card.ability.extra.xmult,\n                        message_card = context.blueprint_card or card\n                    }\n                    return ret\n                elseif card.ability.extra.rank == 2 and not context.blueprint then\n                    card.ability.extra.rank = 14\n                elseif not context.blueprint then card.ability.extra.rank = card.ability.extra.rank - 1 end\n                ret = {\n                    mult = card.ability.extra.mult,\n                    message_card = context.blueprint_card or card,\n                }\n                return ret\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "crazy_neils_crazy_deals",
      "atlas": "Jokers",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = 'crazy_neils_crazy_deals',\n\tatlas = 'Jokers',\n\tpos = { x = 3, y = 1 },\n\trarity = 1,\n\tcost = 5,\n\tunlocked = true,\n\tdiscovered = true,\n\tblueprint_compat = false,\n\tconfig = {\n        extra = {\n            divide = 75,\n            real_amt = 0.75\n        }\n    },\n\tloc_vars = function(self, info_queue, card)\n\t\treturn {\n\t\t\tvars = {\n\t\t\t\tcard.ability.extra.divide\n\t\t    }\n        }\n\tend,\n\tcalculate = function(self, card, context)\n\t    if context.starting_shop and not context.blueprint then\n            local items = {}\n            for i = 1, #G.shop_booster.cards do\n                if G.shop_booster.cards[i].cost + (G.shop_booster.cards[i].extra_cost or 0) ~= 0 then\n                    items[#items+1] = G.shop_booster.cards[i]\n                end\n            end\n            for i = 1, #G.shop_jokers.cards do\n                if G.shop_jokers.cards[i].cost + (G.shop_jokers.cards[i].extra_cost or 0) ~= 0 then\n                    items[#items+1] = G.shop_jokers.cards[i]\n                end\n            end\n            for i = 1, #G.shop_vouchers.cards do\n                if G.shop_vouchers.cards[i].cost + (G.shop_vouchers.cards[i].extra_cost or 0) ~= 0 then\n                    items[#items + 1] = G.shop_vouchers.cards[i]\n                end\n            end\n            if #items > 0 then\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        local chosen = pseudorandom_element(items, pseudoseed('crazy_neil'))\n                        chosen.ability.fmod_crazy_neil_discount = true\n                        chosen:set_cost()\n                        delay(0.7)\n                        card_eval_status_text(card, 'extra', nil, nil, nil,\n                            { message = localize(\"k_fmod_neil_deal\"), colour = G.C.RED })\n                        chosen:juice_up(0.3, 0.5)\n                        return true\n                    end\n                }))\n            end\n\t    end\n    end"
    },
    {
      "type": "Joker",
      "key": "dating_sim",
      "atlas": "Jokers",
      "pos": {
        "x": 0,
        "y": 5
      },
      "raw": "key = \"dating_sim\",\n\tatlas = \"Jokers\",\n\tpos = { x = 0, y = 5 },\n\trarity = 2,\n\tcost = 5,\n\tunlocked = true,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tconfig = { extra = { chips = 10 } },\n\tloc_vars = function(self, info_queue, card)\n        return {\n            vars = {\n                card.ability.extra.chips,\n            }\n        }\n\tend,\n\tcalculate = function(self, card, context)\n\t\tif context.individual and context.cardarea == G.play then\n\t\t\tif context.other_card:is_suit('Hearts') then\n                context.other_card.ability.perma_bonus = (context.other_card.ability.perma_bonus or 0) + card.ability.extra.chips\n                return {\n                    message = localize('k_upgrade_ex'),\n                    colour = G.C.CHIPS\n                }\n            end\n\t\tend\n\tend"
    },
    {
      "type": "Joker",
      "key": "debut_album",
      "atlas": "Jokers",
      "pos": {
        "x": 8,
        "y": 5
      },
      "raw": "key = \"debut_album\",\n\tatlas = \"Jokers\",\n\tpos = { x = 8, y = 5 },\n\trarity = 2,\n\tcost = 4,\n\tunlocked = true,\n\tdiscovered = true,\n\tblueprint_compat = true,\n    pixel_size = { w = 71, h = 70 },\n\tconfig = { extra = { mult_loss = 0.5, xmult = 5 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.xmult, card.ability.extra.mult_loss } }\n    end,\n    calculate = function(self, card, context)\n        if context.after and not context.blueprint then\n            if card.ability.extra.xmult - card.ability.extra.mult_loss <= 1 then\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        -- This replicates the food destruction effect\n                        -- If you want a simpler way to destroy Jokers, you can do card:start_dissolve() for a dissolving animation\n                        -- or just card:remove() for no animation\n                        play_sound('tarot1')\n                        card.T.r = -0.2\n                        card:juice_up(0.3, 0.4)\n                        card.states.drag.is = true\n                        card.children.center.pinch.x = true\n                        G.E_MANAGER:add_event(Event({\n                            trigger = 'after',\n                            delay = 0.3,\n                            blockable = false,\n                            func = function()\n                                card:remove()\n                                return true\n                            end\n                        }))\n                        return true\n                    end\n                }))\n                return {\n                    message = localize('k_fmod_debut_destruct'),\n                    colour = G.C.RED\n                }\n            else\n                card.ability.extra.xmult = card.ability.extra.xmult - card.ability.extra.mult_loss\n                return {\n                    message = localize{type = 'variable', key = 'a_xmult_minus', vars = { card.ability.extra.mult_loss }},\n                    colour = G.C.MULT\n                }\n            end\n        end\n        if context.joker_main then\n            return {\n                xmult = card.ability.extra.xmult\n            }\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "despicable_bear",
      "atlas": "Jokers",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"despicable_bear\",\n    config = {\n        extra = {\n        }\n    },\n    rarity = 2,\n    atlas = \"Jokers\",\n    unlocked = true,\n    discovered = true,\n    blueprint_compat = false,\n    pos = { x = 1, y = 0 },\n    cost = 6,"
    },
    {
      "type": "Joker",
      "key": "detective",
      "atlas": "Jokers",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "key = \"detective\",\n\tatlas = \"Jokers\",\n\tpos = { x = 1, y = 2 },\n\trarity = 2,\n\tcost = 6,\n\tunlocked = true,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tconfig = { extra = { dollars = 1 } },\n\tloc_vars = function(self, info_queue, card)\n        return {\n            vars = {\n                card.ability.extra.dollars,\n            }\n        }\n\tend,\n\tcalculate = function(self, card, context)\n\t\tif context.individual and context.cardarea == G.play and context.other_card.ability.detective_played then\n\t\t\treturn {\n\t\t\t\tdollars = card.ability.extra.dollars\n\t\t\t}\n\t\tend\n        if context.hand_drawn and not context.blueprint then\n            for i = 1, #G.hand.cards do\n                if G.hand.cards[i].ability.played_this_ante then\n                    G.hand.cards[i].ability.detective_played = true\n                end\n            end\n        end\n        if context.end_of_round and not context.blueprint and context.cardarea == G.jokers then\n            for i = 1, #G.playing_cards do\n                if G.playing_cards[i].ability.detective_played then\n                    G.playing_cards[i].ability.detective_played = nil\n                end\n            end\n        end\n\tend"
    },
    {
      "type": "Joker",
      "key": "dungeon_crawler",
      "atlas": "Jokers",
      "pos": {
        "x": 2,
        "y": 5
      },
      "raw": "key = \"dungeon_crawler\",\n\tatlas = \"Jokers\",\n\tpos = { x = 2, y = 5 },\n\trarity = 2,\n\tcost = 5,\n\tunlocked = true,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tconfig = { extra = { chips = 10 } },\n\tloc_vars = function(self, info_queue, card)\n        return {\n            vars = {\n                card.ability.extra.chips,\n            }\n        }\n\tend,\n\tcalculate = function(self, card, context)\n\t\tif context.before then\n            local spade_in_hand = false\n            local spade_list = {}\n\t\t\tfor i = 1, #context.scoring_hand do\n                if context.scoring_hand[i]:is_suit('Spades') and not context.scoring_hand[i].ability.no_dc then\n                    table.insert(spade_list, context.scoring_hand[i])\n                    spade_in_hand = true\n                end\n            end\n            if spade_in_hand then\n                local valid_pairs = {}\n                for _, card_ in ipairs(spade_list) do\n                    if not next(SMODS.get_enhancements(card_)) or not card_.ability.no_dc then\n                        table.insert(valid_pairs, { card = card_, mod = \"enhancement\" })\n                    end\n                    if not card_.seal or not card_.ability.no_dc_seal then\n                        table.insert(valid_pairs, { card = card_, mod = \"seal\" })\n                    end\n                    if LR_CONFIG.markings_enabled and not LR_UTIL.has_marking(card_) or not card_.ability.no_dc_mrk then\n                        table.insert(valid_pairs, { card = card_, mod = \"marking\" })\n                    end\n                end\n                if #valid_pairs > 0 then\n                    local pair = pseudorandom_element(valid_pairs, pseudoseed('dungeon_crawler'))\n                    local chosen = pair.card\n                    local modify = pair.mod\n                    if modify == \"enhancement\" then\n                        chosen:set_ability(SMODS.poll_enhancement({ guaranteed = true, key = 'dungeon_crawler1' }),\n                            nil, true)\n                        G.E_MANAGER:add_event(Event({\n                            func = function()\n                                chosen:juice_up()\n                                chosen.ability.no_dc = true\n                                return true\n                            end\n                        }))\n                    elseif modify == \"seal\" then\n                        chosen:set_seal(SMODS.poll_seal({ guaranteed = true, key = 'dungeon_crawler2' }))\n                        G.E_MANAGER:add_event(Event({\n                            func = function()\n                                chosen.ability.no_dc_seal = true\n                                return true\n                            end\n                        }))\n                    elseif modify == \"marking\" then\n                        LR_UTIL.set_marking(chosen,\n                            string.sub(\n                                pseudorandom_element(LR_UTIL.ENABLED_MARKINGS, pseudoseed('dungeon_crawler3')), 0,\n                                -6))\n                        G.E_MANAGER:add_event(Event({\n                            func = function()\n                                chosen.ability.no_dc_mrk = true\n                                chosen:juice_up()\n                                return true\n                            end\n                        }))\n                    end\n                    return {\n                        message = localize('k_upgrade_ex'),\n                        colour = G.C.CHIPS\n                    }\n                end\n            end\n\t\tend\n\tend"
    },
    {
      "type": "Joker",
      "key": "feline_fleecer",
      "atlas": "Jokers",
      "pos": {
        "x": 9,
        "y": 5
      },
      "raw": "key = \"feline_fleecer\",\n\tatlas = \"Jokers\",\n\tpos = { x = 9, y = 5 },\n\trarity = 2,\n\tcost = 5,\n\tunlocked = true,\n\tdiscovered = true,\n\tblueprint_compat = true,\n    loc_vars = function(self, info_queue)\n        info_queue[#info_queue + 1] = G.P_CENTERS.p_fmod_remix_small_1\n    end,\n    calculate = function(self, card, context)\n        if context.starting_shop then\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    local booster = SMODS.add_booster_to_shop('p_fmod_remix_small_' .. pseudorandom_element({ 1, 2 }, \"feline_fleecer\" .. G.GAME.round_resets.ante))\n                    if booster then booster.ability.couponed = true end\n                    booster:set_cost()\n                    return true\n                end\n            }))\n            return {\n                message = localize({ type = \"variable\", key = \"a_fmod_booster\", vars = { 1 } }),\n                colour = G.C.CHIPS\n            }\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "fennex",
      "atlas": "Jokers",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"fennex\",\n    config = {\n        extra = {\n            total_rerolls = 10,\n            rerolls = 10\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.total_rerolls, (card.ability.extra.rerolls or 10) } }\n    end,\n    rarity = 1,\n    atlas = \"Jokers\",\n    unlocked = true,\n    discovered = true,\n    pos = { x = 0, y = 0 },\n    cost = 4,\n    blueprint_compat = false,\n    calculate = function(self, card, context)\n        if context.reroll_shop and not context.blueprint then\n            card.ability.extra.rerolls = card.ability.extra.rerolls - 1\n        end\n        if card.ability.extra.rerolls == 0 and not context.blueprint then\n            G.GAME.current_round.voucher_2 = get_next_voucher_key()\n            G.shop_vouchers.config.card_limit = G.shop_vouchers.config.card_limit + 1\n            if G.GAME.current_round.voucher_2 and G.P_CENTERS[G.GAME.current_round.voucher_2] then\n                local voucher = Card(G.shop_vouchers.T.x + G.shop_vouchers.T.w/2,\n                G.shop_vouchers.T.y, G.CARD_W, G.CARD_H, G.P_CARDS.empty, G.P_CENTERS[G.GAME.current_round.voucher_2],{bypass_discovery_center = true, bypass_discovery_ui = true})\n                voucher.shop_voucher = true\n                create_shop_card_ui(voucher, 'Voucher', G.shop_vouchers)\n                voucher:start_materialize()\n                card:juice_up(0.5, 0.5)\n                G.shop_vouchers:emplace(voucher)\n            end\n            card.ability.extra.rerolls = 10\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "fennex_the_clown",
      "atlas": "Jokers",
      "pos": {
        "x": 7,
        "y": 3
      },
      "raw": "key = \"fennex_the_clown\",\n    config = {\n        extra = {\n            xmult = 1,\n            total = 1\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.xmult, 1 + (card.ability.extra.xmult * LR_UTIL.num_vouchers()) } }\n    end,\n    pools = {\n        [\"Fmod_Legendary\"] = true,\n    },\n    rarity = 4,\n    atlas = \"Jokers\",\n    unlocked = true,\n    discovered = true,\n    pos = { x = 7, y = 3 },\n    soul_pos = { x = 7, y = 4 },\n    blueprint_compat = true,\n    cost = 20,\n    calculate = function(self, card, context)\n        if context.cardarea == G.jokers and context.joker_main then\n            local count = LR_UTIL.num_vouchers()\n            if count > 0 then\n                card.ability.extra.total = card.ability.extra.xmult + count\n                return {\n                    xmult = card.ability.extra.total,\n                    card = card\n                }\n            end\n        end\n    end,\n    in_pool = function (self, args)\n        return not args or not args.source or args.source ~= 'sou'\n    end"
    },
    {
      "type": "Enhancement",
      "key": "m_steel",
      "atlas": null,
      "pos": null,
      "raw": "loc_vars = function(self, info_queue, card)\n            if #SMODS.find_card('j_fmod_ferromancy') > 0 then\n                return {\n                    vars = { (card.ability.h_x_mult or 2) },\n                    key = 'm_steel'\n                }\n            else\n                return {\n                    vars = { '$' .. card.ability.h_dollars },\n                }\n            end\n        end,\n        update = function(self, card, dt)\n            if #SMODS.find_card('j_fmod_ferromancy') > 0 then\n                card.ability.h_x_mult = 2\n                    * (card.ability.jest_charged_applied and card.ability.jest_charged_applied.factor or 1)\n                card.ability.h_dollars = 0\n            else\n                card.ability.h_x_mult = 1\n                card.ability.h_dollars = 3\n                    * (card.ability.jest_charged_applied and card.ability.jest_charged_applied.factor or 1)\n            end\n        end"
    },
    {
      "type": "Joker",
      "key": "ferromancy",
      "atlas": "Jokers",
      "pos": {
        "x": 9,
        "y": 0
      },
      "raw": "key = \"ferromancy\",\n    config = {\n        extra = {\n            xmult = 2,\n            money = 5,\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue+1] = G.P_CENTERS.m_gold\n        info_queue[#info_queue+1] = G.P_CENTERS.m_steel\n        return { vars = { card.ability.extra.xmult, card.ability.extra.money } }\n    end,\n    rarity = 3,\n    atlas = \"Jokers\",\n    unlocked = true,\n    discovered = true,\n    blueprint_compat = false,\n    pos = { x = 9, y = 0 },\n    cost = 8,\n    in_pool = function(self, args)\n        for _, playing_card in ipairs(G.playing_cards or {}) do\n            if SMODS.has_enhancement(playing_card, 'm_steel') or SMODS.has_enhancement(playing_card, 'm_gold') then\n                return true\n            end\n        end\n        return false\n    end"
    },
    {
      "type": "Joker",
      "key": "fighting_game",
      "atlas": "Jokers",
      "pos": {
        "x": 3,
        "y": 5
      },
      "raw": "key = \"fighting_game\",\n\tatlas = \"Jokers\",\n\tpos = { x = 3, y = 5 },\n\trarity = 2,\n\tcost = 5,\n\tunlocked = true,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tconfig = { extra = { odds = 3, h_size = 1, total_size = 0 } },\n\tloc_vars = function(self, info_queue, card)\n        return {\n            vars = {\n                G.GAME.probabilities.normal or 1,\n                card.ability.extra.odds,\n                card.ability.extra.h_size\n            }\n        }\n\tend,\n\tcalculate = function(self, card, context)\n\t\tif context.individual and context.cardarea == G.play then\n\t\t\tif context.other_card:is_suit('Clubs') and pseudorandom(\"fighting_game\") < G.GAME.probabilities.normal / card.ability.extra.odds then\n                G.E_MANAGER:add_event(Event({\n                    trigger = 'after',\n                    func = function()\n                        G.E_MANAGER:add_event(Event({\n                            func = function()\n                                G.hand:change_size(card.ability.extra.h_size)\n                                return true\n                            end\n                        }))\n                        card.ability.extra.total_size = card.ability.extra.total_size + card.ability.extra.h_size\n                        return true\n                    end\n                }))\n                return {\n                    message = localize{type=\"variable\", key=\"a_handsize\", vars={card.ability.extra.h_size}},\n                }\n            end\n\t\tend\n        if context.end_of_round and card.ability.extra.total_size > 0 then\n            G.hand:change_size(-card.ability.extra.total_size)\n            card.ability.extra.total_size = 0\n        end\n\tend"
    },
    {
      "type": "Joker",
      "key": "fragile_sticker",
      "atlas": "Jokers",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"fragile_sticker\",\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue + 1] = G.P_CENTERS.m_glass\n    end,\n    rarity = 3,\n    atlas = \"Jokers\",\n    unlocked = true,\n    discovered = true,\n    blueprint_compat = false,\n    pos = { x = 0, y = 1 },\n    cost = 8,\n    enhancement_gate = \"m_glass\""
    },
    {
      "type": "Joker",
      "key": "free_shipping",
      "atlas": "Jokers",
      "pos": {
        "x": 4,
        "y": 5
      },
      "raw": "key = \"free_shipping\",\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue+1] = G.P_CENTERS.m_fmod_raffle_card\n        info_queue[#info_queue+1] = {key = 'e_negative_consumable', set = 'Edition', config = {extra = 1}}\n        return { vars = { } }\n    end,\n    rarity = 2,\n    atlas = \"Jokers\",\n    unlocked = true,\n    discovered = true,\n    blueprint_compat = false,\n    pos = { x = 4, y = 5 },\n    cost = 5,\n    enhancement_gate = \"m_fmod_raffle_card\""
    },
    {
      "type": "Joker",
      "key": "friend_inside_me",
      "atlas": "Jokers",
      "pos": {
        "x": 0,
        "y": 6
      },
      "raw": "key = \"friend_inside_me\",\n    rarity = 3,\n    atlas = \"Jokers\",\n    config = {\n        extra = {\n            copies = 6,\n            used = false\n        }\n    },\n    unlocked = true,\n    discovered = true,\n    blueprint_compat = false,\n    pos = { x = 0, y = 6 },\n    soul_pos = { x = 1, y = 6 },\n    cost = 8,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.copies } }\n    end,\n    calculate = function(self, card, context)\n        if context.discard and not card.ability.extra.used and #context.full_hand == 1 and G.GAME.current_round.discards_used <= 0 and not context.blueprint then\n            local cards = {}\n            card.ability.extra.used = true\n            for i = 1, card.ability.extra.copies do\n                G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                local copy_card = copy_card(context.full_hand[1], nil, nil, G.playing_card)\n                copy_card:add_to_deck()\n                G.deck.config.card_limit = G.deck.config.card_limit + 1\n                table.insert(G.playing_cards, copy_card)\n                G.hand:emplace(copy_card)\n                copy_card.states.visible = nil\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        copy_card:start_materialize()\n                        return true\n                    end\n                }))\n                copy_card.ability.lr_temp = true\n                cards[i] = copy_card\n            end\n            return {\n                remove = true,\n                message = localize('k_copied_ex'),\n                colour = G.C.CHIPS,\n                func = function()\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            SMODS.calculate_context({ playing_card_added = true, cards = cards })\n                            return true\n                        end\n                    }))\n                end\n            }\n        end\n        if context.end_of_round and context.cardarea == G.jokers and not context.blueprint then\n            card.ability.extra.used = false\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "generator",
      "atlas": "Jokers",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"generator\",\n    config = {\n        extra = {\n            retriggers = 1\n        }\n    },\n    rarity = 2,\n    atlas = \"Jokers\",\n    unlocked = true,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = false,\n    pos = { x = 2, y = 0 },\n    cost = 6,\n    calculate = function(self, card, context)\n        local destroyed = G.consumeables.cards[1]\n        if context.setting_blind and G and G.consumeables and G.consumeables.cards and not context.blueprint then\n            if destroyed then\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        destroyed:start_dissolve()\n                        card:juice_up()\n                    return true end\n                }))\n                card_eval_status_text(card, 'extra', nil, nil, nil, { message = localize('k_fmod_fuel'), colour = G.C.RED } )\n            end\n            if not destroyed then\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        play_sound('tarot1')\n                        card:start_dissolve()\n                        G.jokers:remove_card(card)\n                        card_eval_status_text(card, 'extra', nil, nil, nil, { message = localize('k_fmod_drained'), colour = G.C.RED } )\n                        card = nil\n                    return true end\n                }))\n            end\n        end\n        if context.cardarea == G.play and context.repetition then\n            return {\n                    message = localize('k_again_ex'),\n                    repetitions = card.ability.extra.retriggers,\n                    card = card\n            }\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "ghost_trick",
      "atlas": "Jokers",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = \"ghost_trick\",\n    config = {\n        extra = {\n            odds = 5\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue+1] = {key = 'e_negative_consumable', set = 'Edition', config = {extra = 1}}\n        return { vars = { (G.GAME.probabilities.normal or 1), card.ability.extra.odds } }\n    end,\n    rarity = 2,\n    atlas = \"Jokers\",\n    unlocked = true,\n    discovered = true,\n    pos = { x = 0, y = 2 },\n    cost = 4,\n    blueprint_compat = true,\n    calculate = function(self, card, context)\n        if context.individual and context.cardarea == G.play then\n\t\t\tif not context.other_card.ghost_tricked and not context.blueprint then\n\t\t\t\tcontext.other_card.ghost_tricked = true\n\t\t\t\tlocal c = context.other_card\n\t\t\t\tG.E_MANAGER:add_event(Event({\n\t\t\t\t\tfunc = function()\n\t\t\t\t\t\tif c then\n\t\t\t\t\t\t\tc.ghost_tricked = nil\n\t\t\t\t\t\tend\n\t\t\t\t\t\treturn true\n\t\t\t\t\tend,\n\t\t\t\t}))\n\t\t\telse\n\t\t\t\tif pseudorandom(pseudoseed('ghost_trick')) < G.GAME.probabilities.normal/card.ability.extra.odds then\n                    G.E_MANAGER:add_event(Event({\n                        trigger = 'before',\n                        delay = 0.0,\n                        func = (function()\n                            SMODS.add_card({set=\"Spectral\", area=G.consumeables, key_append=\"gtrick\", edition=\"e_negative\"})\n                            return true\n                        end)\n                    }))\n                    return {\n                        message = localize('k_plus_spectral'),\n                        colour = G.C.SECONDARY_SET.Spectral,\n                        card = card\n                    }\n                end\n\t\t\tend\n\t\tend\n    end"
    },
    {
      "type": "Joker",
      "key": "ghostly_joker",
      "atlas": "Jokers",
      "pos": {
        "x": 3,
        "y": 6
      },
      "raw": "key = \"ghostly_joker\",\n    rarity = 2,\n    atlas = \"Jokers\",\n    config = {\n        extra = {\n            fours = 4,\n        }\n    },\n    unlocked = true,\n    discovered = true,\n    blueprint_compat = false,\n    pos = { x = 3, y = 6 },\n    soul_pos = { x = 4, y = 6,\n        draw = function(card, scale_mod, rotate_mod)\n            local _scale_mod = 0.1 + 0.05*math.sin(1.8*G.TIMERS.REAL) + 0.00*math.sin((G.TIMERS.REAL - math.floor(G.TIMERS.REAL))*math.pi*11)*(1 - (G.TIMERS.REAL - math.floor(G.TIMERS.REAL)))^3\n            local _rotate_mod = 0.1*math.sin(0.6*G.TIMERS.REAL) + 0.00*math.sin((G.TIMERS.REAL)*math.pi*2)*(1 - (G.TIMERS.REAL - math.floor(G.TIMERS.REAL)))^2\n\n            card.children.floating_sprite.role.draw_major = card\n            card.children.floating_sprite:draw_shader('dissolve',0, nil, nil, card.children.center, _scale_mod, _rotate_mod,nil, 0.1 + 0.03*math.sin(1.8*G.TIMERS.REAL),nil, 0.6)\n            card.children.floating_sprite:draw_shader('dissolve', nil, nil, nil, card.children.center, _scale_mod, _rotate_mod)\n        end,\n    },\n    cost = 4,\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue + 1] = G.P_CENTERS.c_death\n        return { vars = { card.ability.extra.fours } }\n    end,\n    calculate = function(self, card, context)\n        if context.individual and context.cardarea == G.play and not context.blueprint and context.other_card:get_id() == 4 then\n            if card.ability.extra.fours - 1 <= 0 and #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then\n                G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1\n                card.ability.extra.fours = 4\n                return {\n                    extra = {\n                        message = localize('k_plus_tarot'),\n                        message_card = card,\n                        func = function()\n                            G.E_MANAGER:add_event(Event({\n                                func = function()\n                                    SMODS.add_card { set = 'Tarot', key = 'c_death' }\n                                    G.GAME.consumeable_buffer = 0\n                                    return true\n                                end\n                            }))\n                        end\n                    },\n                }\n            else\n                card.ability.extra.fours = card.ability.extra.fours - 1\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "hyperfixation",
      "atlas": "Jokers",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"hyperfixation\",\n    config = {\n        extra = {\n            retriggers = 0,\n            amt_needed = 5,\n            current_amt = 5,\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        return {\n            vars = {\n                localize(G.GAME.hyperfix_card.rank, 'ranks'), \n                localize(G.GAME.hyperfix_card.suit, 'suits_plural'),\n                card.ability.extra.retriggers,\n                G.GAME.current_round.hyperfix_card.rank and localize(G.GAME.current_round.hyperfix_card.rank, 'ranks') or 'None',\n                card.ability.extra.amt_needed,\n                card.ability.extra.current_amt,\n                card.ability.extra.retriggers == 1 and \"\" or \"s\",\n                colours = {G.C.SUITS[G.GAME.hyperfix_card.suit]}\n            }\n        }\n    end,\n    rarity = 2,\n    atlas = \"Jokers\",\n    unlocked = true,\n    discovered = true,\n    pos = { x = 1, y = 1 },\n    cost = 6,\n    blueprint_compat = true,\n    calculate = function(self, card, context)\n        if context.repetition and context.cardarea == G.play then\n            local hyperfix_id = SMODS.Ranks[G.GAME.hyperfix_card.rank].id\n            if context.other_card:get_id() == hyperfix_id and\n            context.other_card:is_suit(G.GAME.hyperfix_card.suit) then\n                if card.ability.extra.retriggers > 0 then\n                    return {\n                        message = localize('k_again_ex'),\n                        repetitions = card.ability.extra.retriggers,\n                        card = card\n                    }\n                end\n            end\n        end\n        if context.individual and context.cardarea == G.play and not context.blueprint then\n            local current_round_id =\n                G.GAME.current_round.hyperfix_card.rank and SMODS.Ranks[G.GAME.current_round.hyperfix_card.rank].id\n            if context.other_card:get_id() == current_round_id then\n                card.ability.extra.current_amt = card.ability.extra.current_amt - 1\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        card:juice_up()\n                        return true\n                    end\n                }))\n                if card.ability.extra.current_amt == 0 then\n                    card.ability.extra.current_amt = card.ability.extra.amt_needed\n                    card.ability.extra.retriggers = card.ability.extra.retriggers + 1\n                    -- (same as Wee)\n                    return {\n                        extra = {focus = card, message = localize('k_upgrade_ex')},\n                        card = card,\n                    }\n                end\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "impractical_joker",
      "atlas": "Jokers",
      "pos": {
        "x": 7,
        "y": 0
      },
      "raw": "key = \"impractical_joker\",\n    config = {\n        extra = {\n            mult = 2\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.mult } }\n    end,\n    rarity = 2,\n    atlas = \"Jokers\",\n    unlocked = true,\n    discovered = true,\n    pixel_size = { w = 71, h = 80 },\n    pos = { x = 7, y = 0 },\n    cost = 4,\n    blueprint_compat = true,\n    calculate = function(self, card, context)\n        if context.individual and context.cardarea == G.play then\n            local temp_ID = 15\n            local raised_card = nil\n            for i = 1, #context.scoring_hand do\n                if temp_ID > context.scoring_hand[i].base.id and not SMODS.has_no_rank(context.scoring_hand[i]) then\n                    temp_ID = context.scoring_hand[i].base.id\n                    raised_card = context.scoring_hand[i]\n                end\n            end\n            if raised_card == context.other_card then\n                return {\n                    x_mult = card.ability.extra.mult,\n                    colour = G.C.RED,\n                    card = card\n                }\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "jazzercise",
      "atlas": "Jokers",
      "pos": {
        "x": 9,
        "y": 2
      },
      "raw": "key = \"jazzercise\",\n    config = {\n        extra = {\n            destroy = 5,\n            destroy_amt = 5,\n            h_size = 0,\n            h_inc = 1\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.h_inc, card.ability.extra.destroy, card.ability.extra.destroy_amt, card.ability.extra.h_size } }\n    end,\n    rarity = 2,\n    atlas = \"Jokers\",\n    unlocked = true,\n    discovered = true,\n    pixel_size = { w = 64, h = 95 },\n    pos = { x = 9, y = 2 },\n    cost = 4,\n    blueprint_compat = false,\n    calculate = function(self, card, context)\n        if context.remove_playing_cards and not context.blueprint then\n            for i = 1, #context.removed do\n                if card.ability.extra.destroy_amt <= 1 then\n                    card.ability.extra.h_size = card.ability.extra.h_size + card.ability.extra.h_inc\n                    card.ability.extra.destroy_amt = card.ability.extra.destroy\n                    G.hand:change_size(card.ability.extra.h_inc)\n                    if #G.hand.cards > 1 then\n                        G.FUNCS.draw_from_deck_to_hand(card.ability.extra.h_inc)\n                    end\n                    return {\n                        delay = 0.2,\n                        message = localize{type = 'variable',key = 'a_handsize', vars = {card.ability.extra.h_inc}}, \n                        colour = G.C.ORANGE\n                    }\n                else\n                    card.ability.extra.destroy_amt = card.ability.extra.destroy_amt - 1\n                end\n            end\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        G.hand:change_size(-card.ability.extra.h_size)\n    end"
    },
    {
      "type": "Joker",
      "key": "litterbug",
      "atlas": "Jokers",
      "pos": {
        "x": 8,
        "y": 3
      },
      "raw": "key = 'litterbug',\n    config = {\n        extra = {\n            mult = 1,\n            base = 0.01,\n            mult_gain = 0.01,\n            discard = 1\n        }\n    },\n    rarity = 2,\n    atlas = 'Jokers',\n    pos = { x = 8, y = 3 },\n    discovered = true,\n    blueprint_compat = true,\n    cost = 4,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.mult, card.ability.extra.base, card.ability.extra.discard } }\n    end,\n    calculate = function(self, card, context)\n        if context.joker_main and card.ability.extra.mult > 1 then\n            return {\n                xmult = card.ability.extra.mult,\n                card = card\n            }\n        end\n\n        if context.press_play and not context.blueprint then\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    local any_selected = nil\n                    local text = nil\n                    local _cards = {}\n                    for k, v in ipairs(G.hand.cards) do\n                        _cards[#_cards + 1] = v\n                    end\n                    if G.hand.cards[1] then\n                        local selected_card, card_key = pseudorandom_element(_cards, pseudoseed('litterbug'))\n                        if not selected_card.debuff and not SMODS.has_no_rank(selected_card) then\n                            card.ability.extra.mult_gain = (0.01 * selected_card.base.nominal)\n                            card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.mult_gain\n                            text = true\n                        end\n                        G.hand:add_to_highlighted(selected_card, true)\n                        table.remove(_cards, card_key)\n                        any_selected = true\n                        play_sound('card1', 1)\n                    end\n                    delay(0.7)\n                    if text then\n                        card_eval_status_text(card, \"extra\", nil, nil, nil, {\n                            message = localize { type = \"variable\", key = \"a_xmult\", vars = { card.ability.extra.mult } },\n                            colour = G.C.MULT,\n                            card = card\n                        })\n                    end\n                    if any_selected then G.FUNCS.discard_cards_from_highlighted(nil, true) end\n                    return true\n                end\n            }))\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "loonette",
      "atlas": "Jokers",
      "pos": {
        "x": 6,
        "y": 3
      },
      "raw": "key = \"loonette\",\n    config = {\n        extra = {\n            xmult = 1.5,\n            xmult_base = 1.5,\n            increase = 0.1\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.xmult_base, card.ability.extra.increase } }\n    end,\n    pools = {\n        [\"Fmod_Legendary\"] = true,\n    },\n    rarity = 4,\n    atlas = \"Jokers\",\n    unlocked = true,\n    discovered = true,\n    pos = { x = 6, y = 3 },\n    soul_pos = { x = 6, y = 4 },\n    blueprint_compat = true,\n    cost = 20,\n    calculate = function(self, card, context)\n        if context.individual and context.cardarea == G.play then\n            if context.other_card:is_face() then\n                card.ability.extra.xmult = card.ability.extra.xmult_base\n            end\n            if not context.other_card:is_face() and not SMODS.has_no_rank(context.other_card) then\n                local xmult = card.ability.extra.xmult\n                if not context.blueprint then\n                    card.ability.extra.xmult = card.ability.extra.xmult + card.ability.extra.increase\n                end\n                return {\n                x_mult = xmult,\n                card = card\n                }\n            end\n        end\n        if context.after and not context.blueprint then\n            card.ability.extra.xmult = card.ability.extra.xmult_base\n        end\n    end,\n    in_pool = function (self, args)\n        return not args or not args.source or args.source ~= 'sou'\n    end"
    },
    {
      "type": "Joker",
      "key": "lottery",
      "atlas": "Jokers",
      "pos": {
        "x": 6,
        "y": 5
      },
      "raw": "key = 'lottery',\n\tatlas = 'Jokers',\n\tpos = { x = 6, y = 5 },\n    config = {\n        extra = {\n            odds = 2,\n            min = 1,\n            max = 9\n        }\n    },\n\trarity = 1,\n\tcost = 4,\n\tunlocked = true,\n\tdiscovered = true,\n\tblueprint_compat = false,\n\tloc_vars = function(self, info_queue, card)\n        return { vars = { G.GAME.probabilities.normal, card.ability.extra.odds, card.ability.extra.min, card.ability.extra.max } }\n\tend,\n\tcalculate = function(self, card, context)\n\t\tif context.end_of_round and context.main_eval and context.game_over == false and pseudorandom(\"lottery\") < G.GAME.probabilities.normal / card.ability.extra.odds and not context.blueprint then\n            local money = math.floor(pseudorandom(pseudoseed(\"lottery2\")) * card.ability.extra.max) + 1\n            card.ability.extra_value = (card.ability.extra_value or 0) + money\n            card:set_cost()\n            return {\n                message = localize{type=\"variable\", key=\"a_fmod_money\", vars={money}},\n                colour = G.C.MONEY,\n                sound = \"coin\" .. pseudorandom(\"lottery3\", 1, 7)\n            }\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "low_hanging_fruit",
      "atlas": "Jokers",
      "pos": {
        "x": 5,
        "y": 1
      },
      "raw": "key = \"low_hanging_fruit\",\n    config = {\n        extra = {\n            chips = 9,\n            mult = 6\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.chips, card.ability.extra.mult } }\n    end,\n    rarity = 1,\n    atlas = \"Jokers\",\n    unlocked = true,\n    discovered = true,\n    blueprint_compat = true,\n    pos = { x = 5, y = 1 },\n    cost = 4,\n    calculate = function(self, card, context)\n        if context.individual and context.cardarea == G.play then\n            if context.other_card:get_id() == 9 or context.other_card:get_id() == 6 then\n                return {\n                    chips = card.ability.extra.chips,\n\t\t\t\t\tmult = card.ability.extra.mult,\n\t\t\t\t\tcard = card\n                }\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "negativejoker",
      "atlas": "Jokers",
      "pos": {
        "x": 6,
        "y": 0
      },
      "raw": "key = \"negativejoker\",\n    config = {\n        extra = {\n            chips = 60,\n            rounds = 9,\n            uses = 0,\n            edition = {negative = true},\n            flag = false\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue+1] = G.P_CENTERS.e_negative\n        return { vars = { card.ability.extra.chips, card.ability.extra.rounds, math.max((card.ability.extra.rounds - card.ability.extra.uses), 0)  } }\n    end,\n    rarity = 1,\n    atlas = \"Jokers\",\n    unlocked = true,\n    discovered = true,\n    pos = { x = 6, y = 0 },\n    blueprint_compat = true,\n    cost = 4,\n    calculate = function(self, card, context)\n        if context.setting_blind and not context.blueprint then\n            card.ability.extra.flag = false\n        end\n        if context.joker_main then\n            return {\n                chips = card.ability.extra.chips\n            }\n        end\n        if context.end_of_round and not card.ability.extra.flag and not context.blueprint then\n            card.ability.extra.uses = card.ability.extra.uses + 1\n            if card.ability.extra.uses == card.ability.extra.rounds then\n                card:set_edition(card.ability.extra.edition)\n            end\n            card.ability.extra.flag = true\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "nerdcubed",
      "atlas": "Jokers",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "key = \"nerdcubed\",\n    config = {\n        extra = {\n            repetitions = 3\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.repetitions } }\n    end,\n    rarity = 2,\n    atlas = \"Jokers\",\n    unlocked = true,\n    discovered = true,\n    blueprint_compat = true,\n    pos = { x = 2, y = 2 },\n    cost = 7,\n    calculate = function(self, card, context)\n        if context.cardarea == G.play and context.repetition and not context.repetition_only then\n            if context.other_card:get_id() == 3 then\n                return {\n                    message = localize('k_again_ex'),\n                    repetitions = card.ability.extra.repetitions,\n                    message_card = card\n                }\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "nerothefool",
      "atlas": "Jokers",
      "pos": {
        "x": 5,
        "y": 0
      },
      "raw": "key = \"nerothefool\",\n    config = {\n        extra = {\n            cards_played = 2,\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.cards_played } }\n    end,\n    rarity = 2,\n    atlas = \"Jokers\",\n    unlocked = true,\n    discovered = true,\n    pos = { x = 5, y = 0 },\n    blueprint_compat = false,\n    cost = 4,\n    calculate = function(self, card, context)\n        if context.destroy_card and (context.cardarea == G.play or context.cardarea == 'unscored') and #context.full_hand == 2 and G.GAME.current_round.hands_played == 0 and not context.blueprint then\n            return {remove = true}\n       end\n    end"
    },
    {
      "type": "Joker",
      "key": "newtons_cradle",
      "atlas": "Jokers",
      "pos": {
        "x": 5,
        "y": 2
      },
      "raw": "key = \"newtons_cradle\",\n    config = {\n        extra = {\n            retriggers = 0,\n            retrigger_gain = 2,\n            suit_count = 0,\n            increased = false\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        local suit = (G.GAME.current_round.ncradle_card or {}).suit or 'Spades'\n        return { vars = { localize(suit, 'suits_plural'), card.ability.extra.retriggers, card.ability.extra.retrigger_gain, colours = { G.C.SUITS[suit] } } }\n    end,\n    rarity = 2,\n    atlas = \"Jokers\",\n    unlocked = true,\n    discovered = true,\n    pos = { x = 5, y = 2 },\n    blueprint_compat = true,\n    cost = 6,\n    calculate = function(self, card, context)\n        -- increment suit count when a card of the same suit is played\n        if context.individual and context.cardarea == G.play and context.scoring_name ~= \"High Card\" then\n            if context.other_card:is_suit(G.GAME.current_round.ncradle_card.suit) and not SMODS.has_no_suit(context.other_card) and not context.other_card.ability.ncradle_set then\n                card.ability.extra.suit_count = card.ability.extra.suit_count + 1\n                -- ncradle_set is to prevent the same card from being counted multiple times given retriggers\n                context.other_card.ability.ncradle_set = true\n            end\n            -- if it's the last card in the scoring hand and the entire hand consists of that suit, increment retriggers\n            -- also, juice up to signify the increasing\n            if context.other_card == context.scoring_hand[#context.scoring_hand] and card.ability.extra.suit_count >= #context.scoring_hand and not card.ability.extra.increased then\n                card.ability.extra.retriggers = card.ability.extra.retriggers + card.ability.extra.retrigger_gain\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        card:juice_up()\n                        return true\n                    end\n                }))\n                -- keep increasing from happening again this hand\n                card.ability.extra.increased = true\n            end\n        end\n        if context.after then -- clear card variables after scoring since local vars were annoying to use\n            for i = 1, #G.playing_cards do\n                if G.playing_cards[i].ability.ncradle_set then\n                    -- clear ncradle_set to allow for the same card to be counted again in the next hand\n                    G.playing_cards[i].ability.ncradle_set = nil\n                end\n            end\n            card.ability.extra.suit_count = 0\n            card.ability.extra.increased = false\n        end\n        if context.repetition and context.cardarea == G.play and card.ability.extra.retriggers > 0 then -- retrigger the rightmost card if we have any retriggers\n            local rightmost = context.scoring_hand[#context.scoring_hand]\n            if context.other_card == rightmost then\n                return {\n                    message = localize('k_again_ex'),\n                    repetitions = card.ability.extra.retriggers,\n                    card = card\n                }\n            end\n        end\n        if context.end_of_round and context.cardarea == G.jokers and card.ability.extra.retriggers > 0 then -- reset number of retriggers at end of round\n            card.ability.extra.retriggers = 0\n            return {\n                message = localize('k_reset'),\n            }\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "orbit",
      "atlas": "Jokers",
      "pos": {
        "x": 7,
        "y": 2
      },
      "raw": "key = 'orbit',\n\tatlas = 'Jokers',\n\tpos = { x = 7, y = 2 },\n\trarity = 1,\n\tcost = 4,\n\tunlocked = true,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tloc_vars = function(self, info_queue, card)\n        info_queue[#info_queue+1] = {key = 'e_negative_consumable', set = 'Edition', config = {extra = 1}}\n        return { vars = { } }\n\tend,\n\tcalculate = function(self, card, context)\n\t\tif context.end_of_round and context.cardarea == G.jokers and #G.consumeables.cards > 0 then\n            for i = 1, #G.consumeables.cards do\n                if G.consumeables.cards[i].ability.set == \"Planet\" and (not G.consumeables.cards[i].edition or G.consumeables.cards[i].edition.key ~= \"e_negative\") then\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            SMODS.add_card{\n                                set = \"Planet\",\n                                key_append = \"orbit\",\n                                edition = \"e_negative\"\n                            }\n                            return true\n                        end\n                    }))\n                    return {\n                        message = localize(\"k_fmod_planet_orbit\"),\n                        colour = G.C.SECONDARY_SET.Planet\n                    }\n                end\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "passport",
      "atlas": "Jokers",
      "pos": {
        "x": 8,
        "y": 0
      },
      "raw": "key = 'passport',\n\tatlas = 'Jokers',\n\tpos = { x = 8, y = 0 },\n\trarity = 2,\n\tcost = 4,\n\tunlocked = true,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tconfig = {\n\t\textra = {\n\t\t\tmult = 0,\n            mult_mod = 8,\n\t\t\tplayed_hands = {}\n\t\t}\n\t},\n\tloc_vars = function(self, info_queue, card)\n        card.ability.extra.mult = 0\n        for scoring_name, played_count in pairs(card.ability.extra.played_hands) do\n\t\t\tif played_count >= 1 then\n\t\t\t\tcard.ability.extra.mult = card.ability.extra.mult + card.ability.extra.mult_mod\n\t\t\tend\n\t\tend\n\t\treturn {\n\t\t\tvars = {\n\t\t\t\tcard.ability.extra.mult_mod,\n                card.ability.extra.mult\n\t\t\t}\n\t\t}\n\tend,\n\tcalculate = function(self, card, context)\n\t\tif context.before then\n\t\t\tcard.ability.extra.played_hands[context.scoring_name] = (card.ability.extra.played_hands[context.scoring_name] or 0) + 1\n\t\tend\n\t\tif context.joker_main then\n\t\t\tcard.ability.extra.mult = 0\n\t\t\tfor scoring_name, played_count in pairs(card.ability.extra.played_hands) do\n\t\t\t\tif played_count >= 1 then\n\t\t\t\t\tcard.ability.extra.mult = card.ability.extra.mult + card.ability.extra.mult_mod\n\t\t\t\tend\n\t\t\tend\n\t\t\treturn {\n\t\t\t\tmult = card.ability.extra.mult\n\t\t\t}\n\t\tend\n\t\tif context.end_of_round and G.GAME.blind.boss and not context.blueprint then\n\t\t\tfor k in pairs(card.ability.extra.played_hands) do\n\t\t\t\tcard.ability.extra.played_hands[k] = 0\n\t\t\tend\n\t\t\tcard.ability.extra.mult = 0\n\t\tend\n\tend"
    },
    {
      "type": "Joker",
      "key": "penny_joker",
      "atlas": "Jokers",
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "key = \"penny_joker\",\n    config = {\n        extra = {\n            chips = 0,\n            chip_gain = 1\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.chips, card.ability.extra.chip_gain } }\n    end,\n    rarity = 1,\n    atlas = \"Jokers\",\n    unlocked = true,\n    discovered = true,\n    pos = { x = 4, y = 0 },\n    blueprint_compat = true,\n    cost = 4,\n    calculate = function(self, card, context)\n        if context.individual and context.cardarea == G.play and not context.blueprint then\n            card.ability.extra.chips = card.ability.extra.chips + card.ability.extra.chip_gain\n            return {\n                message_card = card,\n                message = localize('k_upgrade_ex')\n            }\n        end\n        if context.joker_main then\n            return {\n                chips = card.ability.extra.chips,\n            }\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "pomni",
      "atlas": "Jokers",
      "pos": {
        "x": 3,
        "y": 3
      },
      "raw": "key = \"pomni\",\n    config = {\n        extra = {\n            blind_count = 0,\n            base_ante = 1,\n            chance_ante = 2,\n            odds = 4,\n            skip_amt = 3\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        return { vars = {card.ability.extra.base_ante, card.ability.extra.skip_amt, (G.GAME.probabilities.normal or 1), card.ability.extra.odds, card.ability.extra.chance_ante, card.ability.extra.blind_count } }\n    end,\n    pools = {\n        [\"Fmod_Legendary\"] = true,\n    },\n    rarity = 4,\n    atlas = \"Jokers\",\n    unlocked = true,\n    discovered = true,\n    pos = { x = 3, y = 3 },\n    soul_pos = { x = 3, y = 4 },\n    blueprint_compat = false,\n    cost = 20,\n    calculate = function(self, card, context)\n        if context.skip_blind and not context.blueprint then\n            card.ability.extra.blind_count = card.ability.extra.blind_count + 1\n            if card.ability.extra.blind_count == card.ability.extra.skip_amt then\n                card.ability.extra.blind_count = 0\n                if pseudorandom('tadc') < G.GAME.probabilities.normal/card.ability.extra.odds then\n                    ease_ante(-card.ability.extra.chance_ante)\n                    G.GAME.round_resets.blind_ante = G.GAME.round_resets.blind_ante or G.GAME.round_resets.ante\n                    G.GAME.round_resets.blind_ante = G.GAME.round_resets.blind_ante - card.ability.extra.chance_ante\n                else\n                    ease_ante(-card.ability.extra.base_ante)\n                    G.GAME.round_resets.blind_ante = G.GAME.round_resets.blind_ante or G.GAME.round_resets.ante\n                    G.GAME.round_resets.blind_ante = G.GAME.round_resets.blind_ante - card.ability.extra.base_ante\n                end\n                return {\n                    message = localize('k_reset'),\n                }\n            else\n                return {\n                    message = card.ability.extra.blind_count..'/'..card.ability.extra.skip_amt,\n                }\n            end\n        end\n    end,\n    in_pool = function (self, args)\n        return not args or not args.source or args.source ~= 'sou'\n    end"
    },
    {
      "type": "Joker",
      "key": "pop_idol_cat",
      "atlas": "Jokers",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"pop_idol_cat\",\n    rarity = 2,\n    atlas = \"Jokers\",\n    config = {\n        extra = {\n            plus_chance = 1\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue+1] = G.P_CENTERS.m_lucky\n        return { vars = { card.ability.extra.plus_chance } }\n    end,\n    unlocked = true,\n    discovered = true,\n    pos = { x = 2, y = 1 },\n    blueprint_compat = false,\n    cost = 5,\n    calculate = function(self, card, context)\n        if context.individual and context.cardarea == G.play and SMODS.has_enhancement(context.other_card, \"m_lucky\") then\n            G.GAME.pop_idol_plus = (G.GAME.pop_idol_plus or 0) + card.ability.extra.plus_chance\n            return {\n                message = \"+\"..card.ability.extra.plus_chance,\n                colour = G.C.GREEN,\n                message_card = card\n            }\n        end\n        if context.end_of_round and context.cardarea == G.jokers then\n            G.GAME.pop_idol_plus = 0\n            return {\n                message = localize(\"k_reset\"),\n                card = card\n            }\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "prismatic_joker",
      "atlas": "Jokers",
      "pos": {
        "x": 2,
        "y": 6
      },
      "raw": "key = \"prismatic_joker\",\n\tatlas = \"Jokers\",\n\tpos = { x = 2, y = 6 },\n\trarity = 2,\n\tcost = 8,\n\tunlocked = true,\n\tdiscovered = true,\n\tblueprint_compat = false,\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue+1] = G.P_CENTERS.m_fmod_copycat_card\n    end,\n\tcalculate = function(self, card, context)\n        if context.before and context.main_eval and not context.blueprint and next(context.poker_hands[\"Four of a Kind\"]) then\n            for i = 1, #context.scoring_hand do\n                local card_ = context.scoring_hand[i]\n                G.E_MANAGER:add_event(Event({\n                    trigger = 'after',\n                    delay = 0.15,\n                    func = function()\n                        card_:flip()\n                        play_sound('card1', 1)\n                        card_:juice_up(0.3, 0.5)\n                        return true\n                    end\n                }))\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        card_:set_ability(\"m_fmod_copycat_card\")\n                        return true\n                    end\n                }))\n                G.E_MANAGER:add_event(Event({\n                    trigger = 'after',\n                    delay = 0.15,\n                    func = function()\n                        card_:flip()\n                        play_sound('tarot2', 0.85, 0.6)\n                        card_:juice_up(0.3, 0.5)\n                        return true\n                    end\n                }))\n            end\n            return {\n                message = localize(\"k_fmod_copycat\"),\n                colour = G.C.PURPLE\n            }\n        end\n\tend"
    },
    {
      "type": "Joker",
      "key": "pub_burger",
      "atlas": "Jokers",
      "pos": {
        "x": 6,
        "y": 1
      },
      "raw": "key = \"pub_burger\",\n    config = {\n        extra = {\n            discards = 5,\n            discard_mod = 1,\n            base_discard = 3\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.discards, card.ability.extra.discard_mod } }\n    end,\n    rarity = 3,\n    atlas = \"Jokers\",\n    pools = {\n        Food = true\n    },\n    unlocked = true,\n    discovered = true,\n    pos = { x = 6, y = 1 },\n    blueprint_compat = false,\n    cost = 6,\n    add_to_deck = function(self, card, from_debuff)\n        card.ability.extra.base_discard = G.GAME.round_resets.discards\n        G.E_MANAGER:add_event(Event({func = function()\n            G.GAME.round_resets.discards = G.GAME.round_resets.discards + card.ability.extra.discards\n            ease_discard((card.ability.extra.discards), nil, false)\n            card_eval_status_text(card, 'extra', nil, nil, nil, {message = localize{type = 'variable', key = 'a_fmod_discards', vars = {card.ability.extra.discards}}})\n        return true end }))\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        G.E_MANAGER:add_event(Event({func = function()\n            G.GAME.round_resets.discards = card.ability.extra.base_discard\n            ease_discard(-(card.ability.extra.discards), nil, false)\n        return true end }))\n    end,\n    calculate = function(self, card, context)\n        if context.before and G.GAME.current_round.hands_played > 0 then\n            if card.ability.extra.discards - card.ability.extra.discard_mod <= 0 then\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        play_sound('tarot1')\n                        card.T.r = -0.2\n                        card:juice_up(0.3, 0.4)\n                        card.states.drag.is = true\n                        card.children.center.pinch.x = true\n                        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.3, blockable = false,\n                            func = function()\n                                    G.jokers:remove_card(card)\n                                    card:remove()\n                                    card = nil\n                                return true; end}))\n                        return true\n                    end\n                }))\n                return {\n                    message = localize('k_eaten_ex'),\n                    colour = G.C.RED\n                }\n            else\n                card.ability.extra.discards = card.ability.extra.discards - card.ability.extra.discard_mod\n                G.GAME.round_resets.discards = G.GAME.round_resets.discards - card.ability.extra.discard_mod\n                ease_discard(-(card.ability.extra.discard_mod), nil, false)\n                return {\n                    message = localize{type='variable',key='a_chips_minus',vars={card.ability.extra.discard_mod}},\n                    colour = G.C.RED\n                }\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "rabbit",
      "atlas": "Jokers",
      "pos": {
        "x": 8,
        "y": 2
      },
      "raw": "key = \"rabbit\",\n    rarity = 3,\n    atlas = \"Jokers\",\n    config = {\n        extra = {\n            max_times = 2,\n            base = 0\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        return {\n            vars = {\n                card.ability.extra.max_times,\n                card.ability.extra.max_times - card.ability.extra.base\n            }\n        }\n    end,\n    unlocked = true,\n    discovered = true,\n    pos = { x = 8, y = 2 },\n    blueprint_compat = true,\n    cost = 8,\n    calculate = function(self, card, context)\n        if context.joker_main and next(context.poker_hands[\"Five of a Kind\"]) and card.ability.extra.base < card.ability.extra.max_times then\n            G.E_MANAGER:add_event(Event({\n                func =  function()\n                G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                local _card = copy_card(context.full_hand[1], nil, nil, G.playing_card)\n                _card:add_to_deck()\n                G.deck.config.card_limit = G.deck.config.card_limit + 1\n                table.insert(G.playing_cards, _card)\n                G.hand:emplace(_card)\n                _card.states.visible = nil\n                _card:start_materialize()\n                delay(0.2)\n                draw_card(G.hand, G.discard, 90, \"up\", nil, _card)\n                return true\n            end\n            }))\n            card.ability.extra.base = card.ability.extra.base + 1\n            return {\n                message = localize('k_copied_ex'),\n                colour = G.C.CHIPS,\n                card = card,\n                playing_cards_created = { true }\n            }\n        end\n        if context.end_of_round and not context.blueprint then\n            card.ability.extra.base = 0\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "ransome",
      "atlas": "Jokers",
      "pos": {
        "x": 5,
        "y": 3
      },
      "raw": "key = \"ransome\",\n    unlocked = true,\n    discovered = true,\n    blueprint_compat = true,\n    rarity = 4,\n    cost = 20,\n    atlas = \"Jokers\",\n    pools = {\n        [\"Fmod_Legendary\"] = true,\n    },\n    pos = { x = 5, y = 3 },\n    soul_pos = { x = 5, y = 4 },\n    calculate = function(self, card, context)\n        if context.remove_playing_cards then\n            local bp = context.blueprint_card\n            for _, removed_card in ipairs(context.removed) do\n                G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                local copy_card = copy_card(removed_card, nil, nil, G.playing_card)\n                copy_card:set_edition(\"e_polychrome\")\n                copy_card:set_seal(\"Red\", nil, true)\n                copy_card:add_to_deck()\n                table.insert(G.playing_cards, copy_card)\n                copy_card.states.visible = nil\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        G.deck.config.card_limit = G.deck.config.card_limit + 1\n                        G.hand:emplace(copy_card)\n                        copy_card:start_materialize()\n                        return true\n                    end\n                }))\n                SMODS.calculate_effect({\n                    message = localize('k_copied_ex'),\n                    colour = G.C.CHIPS,\n                    func = function()\n                        G.E_MANAGER:add_event(Event({\n                            func = function()\n                                SMODS.calculate_context({ playing_card_added = true, cards = { copy_card } })\n                                return true\n                            end\n                        }))\n                    end\n                }, bp or card)\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "rhythm_game",
      "atlas": "Jokers",
      "pos": {
        "x": 1,
        "y": 5
      },
      "raw": "key = \"rhythm_game\",\n\tatlas = \"Jokers\",\n\tpos = { x = 1, y = 5 },\n\trarity = 2,\n\tcost = 5,\n\tunlocked = true,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tconfig = { extra = { retriggers = 1 } },\n    calculate = function(self, card, context)\n        if context.repetition and context.cardarea == G.play and context.other_card:is_suit(\"Diamonds\") then\n            return {\n                repetitions = card.ability.extra.retriggers,\n            }\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "sad_clown",
      "atlas": "Jokers",
      "pos": {
        "x": 0,
        "y": 4
      },
      "raw": "key = \"sad_clown\",\n    config = {\n        extra = {\n            discards = 15,\n            discards_remaining = 15,\n            card_amt = 1\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.discards, card.ability.extra.discards_remaining, colours = {HEX(\"ff98e2\")} } }\n    end,\n    rarity = 1,\n    atlas = \"Jokers\",\n    unlocked = true,\n    discovered = true,\n    pos = { x = 0, y = 4 },\n    blueprint_compat = true,\n    cost = 4,\n    calculate = function(self, card, context)\n        if context.discard then\n            if card.ability.extra.discards_remaining <= 1 then\n                if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then\n                    G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1\n                    local bp = context.blueprint_card\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            G.E_MANAGER:add_event(Event({\n                                func = function()\n                                    play_sound('timpani')\n                                    SMODS.add_card({ set = \"Silly\", area = G.consumeables, key_append = \"cln\" })\n                                    G.GAME.consumeable_buffer = 0\n                                    return true\n                                end\n                            }))\n                            SMODS.calculate_effect({\n                                message = localize({ type = \"variable\", key = \"a_fmod_silly_card\", vars = { card.ability.extra.card_amt } }),\n                                colour = HEX(\"ff98e2\"),\n                            }, bp or card)\n                            card.ability.extra.discards_remaining = card.ability.extra.discards\n                            return true\n                        end\n                    }))\n                else\n                    card.ability.extra.discards_remaining = card.ability.extra.discards\n                end\n            end\n            if not context.blueprint then\n                card.ability.extra.discards_remaining = card.ability.extra.discards_remaining - 1\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "steve",
      "atlas": "Jokers",
      "pos": {
        "x": 2,
        "y": 3
      },
      "raw": "key = \"steve\",\n    config = {\n        extra = {\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue+1] = G.P_CENTERS.e_negative\n    end,\n    pools = {\n        [\"Fmod_Legendary\"] = true,\n    },\n    rarity = 4,\n    atlas = \"Jokers\",\n    unlocked = true,\n    discovered = true,\n    pos = { x = 2, y = 3 },\n    soul_pos = { x = 2, y = 4 },\n    blueprint_compat = false,\n    cost = 20,\n    calculate = function(self, card, context)\n        if context.setting_blind and not context.blueprint then\n            card:juice_up(0.3, 0.5)\n            local key = LR_UTIL.get_food_jokers('steve')\n            SMODS.add_card({set = 'Joker', key = key, edition = 'e_negative'})\n            return true\n        end\n    end,\n    in_pool = function (self, args)\n        return not args or not args.source or args.source ~= 'sou'\n    end"
    },
    {
      "type": "Joker",
      "key": "strange_dreams",
      "atlas": "Jokers",
      "pos": {
        "x": 3,
        "y": 2
      },
      "raw": "key = \"strange_dreams\",\n\tatlas = \"Jokers\",\n\tpos = { x = 3, y = 2 },\n\trarity = 3,\n\tcost = 8,\n    config = {\n        extra = {\n            unscored = {}\n        }\n    },\n\tunlocked = true,\n\tdiscovered = true,\n\tblueprint_compat = false,\n\tcalculate = function(self, card, context)\n\t\tif context.individual and context.cardarea == 'unscored' and not context.blueprint then\n            card.ability.extra.unscored[#card.ability.extra.unscored + 1] = context.other_card\n\t\tend\n        if context.after and not context.blueprint then\n            local card_ = pseudorandom_element(card.ability.extra.unscored, pseudoseed(\"strange_dreams\"))\n            if card_ then\n                G.E_MANAGER:add_event(Event({\n                    trigger = 'after',\n                    delay = 0.15,\n                    func = function()\n                        card_:flip()\n                        play_sound('card1', 1)\n                        card_:juice_up(0.3, 0.5)\n                        return true\n                    end\n                }))\n                delay(0.3)\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        copy_card(context.scoring_hand[#context.scoring_hand], card_)\n                        return true\n                    end\n                }))\n                delay(0.3)\n                G.E_MANAGER:add_event(Event({\n                    trigger = 'after',\n                    delay = 0.15,\n                    func = function()\n                        card_:flip()\n                        play_sound('tarot2', 0.85, 0.6)\n                        card_:juice_up(0.3, 0.5)\n                        return true\n                    end\n                }))\n                delay(0.3)\n                card.ability.extra.unscored = {}\n                return {\n                    message = localize('k_copied_ex'),\n                    colour = G.C.CHIPS,\n                }\n            end\n        end\n\tend"
    },
    {
      "type": "Joker",
      "key": "tax_return",
      "atlas": "Jokers",
      "pos": {
        "x": 8,
        "y": 4
      },
      "raw": "key = \"tax_return\",\n\tatlas = \"Jokers\",\n\tpos = { x = 8, y = 4 },\n\trarity = 1,\n\tcost = 6,\n\tunlocked = true,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tconfig = { extra = { dollars = 1 } },\n\tloc_vars = function(self, info_queue, card)\n        return {\n            vars = {\n                card.ability.extra.dollars,\n            }\n        }\n\tend,\n\tcalculate = function(self, card, context)\n\t\tif context.individual and context.cardarea == 'unscored' then\n\t\t\treturn {\n\t\t\t\tdollars = card.ability.extra.dollars\n\t\t\t}\n\t\tend\n\tend"
    },
    {
      "type": "Joker",
      "key": "tem_shop",
      "atlas": "Jokers",
      "pos": {
        "x": 9,
        "y": 4
      },
      "raw": "key = \"tem_shop\",\n\tatlas = \"Jokers\",\n\tpos = { x = 9, y = 4 },\n\trarity = 2,\n\tcost = 5,\n\tunlocked = true,\n\tdiscovered = true,\n\tblueprint_compat = false,\n    add_to_deck = function(self, card, from_debuff)\n        for i = 1, #G.jokers.cards do\n            G.jokers.cards[i]:set_cost()\n        end\n        for i = 1, #G.consumeables.cards do\n            G.consumeables.cards[i]:set_cost()\n        end\n        if G.shop_jokers then \n\t    for i = 1, #G.shop_jokers.cards do\n                G.shop_jokers.cards[i]:set_cost()\n            end \n\tend\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        for i = 1, #G.jokers.cards do\n            G.jokers.cards[i]:set_cost()\n        end\n        for i = 1, #G.consumeables.cards do\n            G.consumeables.cards[i]:set_cost()\n        end\n        if G.shop_jokers then \n\t    for i = 1, #G.shop_jokers.cards do\n                G.shop_jokers.cards[i]:set_cost()\n            end \n\tend\n    end,"
    },
    {
      "type": "Joker",
      "key": "terminal_velocity",
      "atlas": "Jokers",
      "pos": {
        "x": 4,
        "y": 2
      },
      "raw": "key = \"terminal_velocity\",\n    config = {\n        extra = {\n            perma_xmult = 0.02\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue + 1] = G.P_CENTERS.m_wild\n        return { vars = { card.ability.extra.perma_xmult } }\n    end,\n    rarity = 2,\n    atlas = \"Jokers\",\n    unlocked = true,\n    discovered = true,\n    pos = { x = 4, y = 2 },\n    soul_pos = { x = 1, y = 4 },\n    blueprint_compat = true,\n    cost = 6,\n    calculate = function(self, card, context)\n        if context.individual and context.cardarea == G.play then\n            if SMODS.has_enhancement(context.other_card, 'm_wild') then\n                context.other_card.ability.perma_x_mult = context.other_card.ability.perma_x_mult or 0\n                context.other_card.ability.perma_x_mult = context.other_card.ability.perma_x_mult + card.ability.extra.perma_xmult\n                return {\n                    extra = { message = localize('k_upgrade_ex'), colour = G.C.CHIPS },\n                    card = card\n                }\n            end\n        end\n    end,\n    enhancement_gate = \"m_wild\","
    },
    {
      "type": "Joker",
      "key": "trans_joker",
      "atlas": "Jokers",
      "pos": {
        "x": 1,
        "y": 3
      },
      "raw": "key = \"trans_joker\",\n    config = {\n        extra = {\n            mult = 5\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.mult, colours = {HEX(\"ff98e2\"), HEX(\"5bcefa\") }  },  }\n    end,\n    atlas = \"Jokers\",\n    pos = { x = 1, y = 3 },\n    rarity = 2,\n    unlocked = true,\n    discovered = true,\n    blueprint_compat = false,\n    cost = 5,"
    },
    {
      "type": "Joker",
      "key": "wordle",
      "atlas": "Jokers",
      "pos": {
        "x": 9,
        "y": 1
      },
      "raw": "key = \"wordle\",\n    config = {\n        extra = {\n            chip_gain = 5,\n            chips = 0\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.chip_gain, card.ability.extra.chips } }\n    end,\n    rarity = 1,\n    atlas = \"Jokers\",\n    unlocked = true,\n    discovered = true,\n    pos = { x = 9, y = 1 },\n    cost = 4,\n    blueprint_compat = true,\n    calculate = function(self, card, context)\n        if context.joker_main then\n            return {\n                chips = card.ability.extra.chips,\n                card = card\n            }\n        end\n        if context.before and context.main_eval and not context.blueprint then\n            for _, playingcard in ipairs(context.scoring_hand) do\n                if not SMODS.has_no_rank(playingcard) and not playingcard.debuff and playingcard:get_id() == 3\n                or playingcard:get_id() == 7 or playingcard:get_id() == 8\n                or playingcard:get_id() == 12 then\n                    card.ability.extra.chips = card.ability.extra.chips + card.ability.extra.chip_gain\n                    return {\n                        message = localize(\"k_upgrade_ex\"),\n                        colour = G.C.CHIPS,\n                        card = card\n                    }\n                end\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "zany_to_the_max",
      "atlas": "Jokers",
      "pos": {
        "x": 7,
        "y": 5
      },
      "raw": "key = \"zany_to_the_max\",\n\tatlas = \"Jokers\",\n\tpos = { x = 7, y = 5 },\n\trarity = 2,\n\tcost = 5,\n\tunlocked = true,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tconfig = {\n        extra = {\n            chip_gain = 10,\n            chips = 0,\n            mult_gain = 1,\n            mult = 0,\n            xmult_gain = 0.1,\n            xmult = 1,\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.chip_gain, card.ability.extra.mult_gain, card.ability.extra.xmult_gain, card.ability.extra.chips, card.ability.extra.mult, card.ability.extra.xmult } }\n    end,\n    calculate = function(self, card, context)\n        if context.before and context.main_eval and not context.blueprint and context.scoring_name == \"Three of a Kind\" then\n            local pseudo = pseudorandom(pseudoseed('zany_to_the_max'))\n            -- 33% chance #1\n            if pseudo <= 0.33 then\n                card.ability.extra.chips = card.ability.extra.chips + card.ability.extra.chip_gain\n                -- 33% chance #2\n            elseif pseudo <= 0.66 then\n                card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.mult_gain\n                -- 33% chance #3\n            else\n                card.ability.extra.xmult = card.ability.extra.xmult + card.ability.extra.xmult_gain\n            end\n            return {\n                message = localize(\"k_upgrade_ex\"),\n                colour = G.C.CHIPS\n            }\n        end\n        if context.joker_main then\n            local ret = {}\n            if card.ability.extra.chips > 0 then\n                ret.chips = card.ability.extra.chips\n            end\n            if card.ability.extra.mult > 0 then\n                ret.mult = card.ability.extra.mult\n            end\n            if card.ability.extra.xmult > 1 then\n                ret.xmult = card.ability.extra.xmult\n            end\n            return ret\n        end\n    end"
    },
    {
      "type": "Tag",
      "key": "appraisal",
      "atlas": "Tags",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"appraisal\",\n    atlas = \"Tags\",\n    pos = { x = 3, y = 0 },\n    min_ante = 2,\n    config = {\n        type = \"immediate\",\n        money = 2,\n        tally = 0\n    },\n    discovered = true,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.money, (self.config.money * (LR_UTIL.get_enhanced() or '0')) } }\n    end,\n    apply = function(self, tag, context)\n        if context.type == self.config.type then\n            tag:yep('+', G.C.MONEY,function()\n                return true\n            end)\n            ease_dollars(self.config.money * LR_UTIL.get_enhanced())\n            tag.triggered = true\n            return true\n        end\n    end"
    },
    {
      "type": "Tag",
      "key": "boost",
      "atlas": "Tags",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"boost\",\n    atlas = \"Tags\",\n    pos = { x = 2, y = 0 },\n    config = {\n    },\n    discovered = true,\n    apply = function(self, tag, context)\n        if context.type == 'voucher_add' then\n            tag:yep('+', G.C.BOOSTER, function()\n                for i = 1, 2 do\n                    SMODS.add_booster_to_shop()\n                    local booster = G.shop_booster.cards[#G.shop_booster.cards]\n                    if booster then booster.ability.couponed = true end\n                    booster:set_cost()\n                end\n                return true\n            end)\n            self.triggered = true\n        end\n    end,"
    },
    {
      "type": "Tag",
      "key": "goofy",
      "atlas": "Tags",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"goofy\",\n    atlas = \"Tags\",\n    pos = { x = 0, y = 0 },\n    min_ante = 2,\n    config = {\n        type = \"new_blind_choice\",\n    },\n    discovered = true,\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue+1] = G.P_CENTERS.p_fmod_silly_mega\n        return { vars = { colours = {HEX(\"ff98e2\")} } }\n    end,\n    apply = function(self, tag, context)\n        if context.type == self.config.type then\n            tag:yep('+', G.C.GREEN, function()\n                local key = 'p_fmod_silly_mega'\n                local card = Card(\n                    G.play.T.x + G.play.T.w / 2 - G.CARD_W * 1.27 / 2,\n                    G.play.T.y + G.play.T.h / 2 - G.CARD_H * 1.27 / 2,\n                    G.CARD_W * 1.27, G.CARD_H * 1.27, G.P_CARDS.empty,\n                    G.P_CENTERS[key],\n                    { bypass_discovery_center = true, bypass_discovery_ui = true }\n                )\n                card.cost = 0\n                card.from_tag = true\n                G.FUNCS.use_card({config = {ref_table = card}})\n                card:start_materialize()\n                return true\n            end)\n            tag.triggered = true\n            return true\n        end\n    end"
    },
    {
      "type": "Tag",
      "key": "lunchbreak",
      "atlas": "Tags",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"lunchbreak\",\n    atlas = \"Tags\",\n    pos = { x = 1, y = 0 },\n    config = {\n        type = \"immediate\",\n    },\n    discovered = true,\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue+1] = G.P_CENTERS.e_negative\n    end,\n    apply = function(self, tag, context)\n        if context.type == self.config.type then\n            tag:yep('+', G.C.GREEN, function()\n                local key = LR_UTIL.get_food_jokers('lunchbreak')\n                SMODS.add_card({set = 'Joker', key = key, edition = 'e_negative'})\n                return true\n            end)\n            tag.triggered = true\n            return true\n        end\n    end"
    },
    {
      "type": "Voucher",
      "key": "anti_higgs_boson",
      "atlas": "Vouchers",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"anti_higgs_boson\",\n    atlas = \"Vouchers\",\n    pos = { x = 2, y = 1 },\n    cost = 10,\n    unlocked = true,\n    available = true,\n    requires = {\"v_blank\", \"v_antimatter\"},\n    redeem = function(self, card)\n        if G.GAME.used_vouchers.v_blank then\n            G.GAME.used_vouchers.v_blank = false\n            G.GAME.used_jokers.v_blank = false\n        end\n        if G.GAME.used_vouchers.v_antimatter then\n            G.GAME.used_vouchers.v_antimatter = false\n            G.GAME.used_jokers.v_antimatter = false\n        end\n        G.E_MANAGER:add_event(Event({func = function()\n            if G.jokers then\n                G.jokers.config.card_limit = G.jokers.config.card_limit + 1\n            end\n        return true end }))\n    end,\n    draw = function(self, card, layer)\n        card.children.center:draw_shader(\"negative\", nil, card.ARGS.send_to_shader)\n    end,"
    },
    {
      "type": "Voucher",
      "key": "big_bang",
      "atlas": "Vouchers",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"big_bang\",\n    atlas = \"Vouchers\",\n    pos = { x = 3, y = 0 },\n    config = {\n        extra = {\n            ante = 2,\n            hand_size = 1\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.ante, card.ability.extra.hand_size } }\n    end,\n    cost = 10,\n    unlocked = true,\n    available = true,\n    requires = {\"hieroglyph\", \"petroglyph\"},\n    redeem = function(self, card)\n        ease_ante(- card.ability.extra.ante)\n        G.GAME.round_resets.blind_ante = G.GAME.round_resets.blind_ante or G.GAME.round_resets.ante\n        G.GAME.round_resets.blind_ante = G.GAME.round_resets.blind_ante - card.ability.extra.ante\n        G.hand:change_size(-card.ability.extra.hand_size)\n    end,"
    },
    {
      "type": "Voucher",
      "key": "buffet",
      "atlas": "Vouchers",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"buffet\",\n    atlas = \"Vouchers\",\n    pos = { x = 1, y = 1 },\n    cost = 10,\n    config = {\n        extra = {\n            hand = 2\n        }\n    },\n    unlocked = true,\n    available = true,\n    requires = {\"v_grabber\", \"v_nacho_tong\"},\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.hand } }\n    end,\n    redeem = function(self, card)\n        G.GAME.round_resets.hands = G.GAME.round_resets.hands + card.ability.extra.hand\n        ease_hands_played(card.ability.extra.hand)\n    end"
    },
    {
      "type": "Voucher",
      "key": "circus",
      "atlas": "Vouchers",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"circus\",\n    atlas = \"Vouchers\",\n    pos = { x = 0, y = 0 },\n    cost = 10,\n    unlocked = true,\n    available = true,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { colours = {HEX(\"ff98e2\")} } }\n    end,"
    },
    {
      "type": "Voucher",
      "key": "color_swatches",
      "atlas": "Vouchers",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"color_swatches\",\n    atlas = \"Vouchers\",\n    pos = { x = 3, y = 1 },\n    cost = 10,\n    config = {\n        extra = {\n            hand_size = 2\n        }\n    },\n    unlocked = true,\n    available = true,\n    requires = {\"v_paint_brush\", \"v_palette\"},\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.hand_size } }\n    end,\n    redeem = function(self, card)\n        G.hand:change_size(card.ability.extra.hand_size)\n    end"
    },
    {
      "type": "Voucher",
      "key": "coupon",
      "atlas": "Vouchers",
      "pos": {
        "x": 4,
        "y": 1
      },
      "raw": "key = \"coupon\",\n    atlas = \"Vouchers\",\n    pos = { x = 4, y = 1 },\n    config = {\n        extra = {\n            slot = 1\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.slot } }\n    end,\n    cost = 10,\n    unlocked = true,\n    available = true,\n    redeem = function(self, card)\n        G.E_MANAGER:add_event(Event({func = function()\n            G.consumeables.config.card_limit = G.consumeables.config.card_limit + card.ability.extra.slot\n        return true end}))\n    end,"
    },
    {
      "type": "Voucher",
      "key": "dumpster_ritual",
      "atlas": "Vouchers",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"dumpster_ritual\",\n    atlas = \"Vouchers\",\n    pos = { x = 2, y = 0 },\n    cost = 10,\n    config = {\n        extra = {\n            discard = 2\n        }\n    },\n    unlocked = true,\n    available = true,\n    requires = {\"v_wasteful\", \"v_recyclomancy\"},\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.discard } }\n    end,\n    redeem = function(self, card)\n        G.GAME.round_resets.discards = G.GAME.round_resets.discards + card.ability.extra.discard\n        ease_discard(card.ability.extra.discard)\n    end"
    },
    {
      "type": "Voucher",
      "key": "extreme_couponing",
      "atlas": "Vouchers",
      "pos": {
        "x": 5,
        "y": 0
      },
      "raw": "key = \"extreme_couponing\",\n    atlas = \"Vouchers\",\n    pos = { x = 5, y = 0 },\n    config = {\n        extra = {\n            slot = 1\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.slot } }\n    end,\n    cost = 10,\n    unlocked = true,\n    available = true,\n    requires = {\"v_fmod_coupon\"},\n    redeem = function(self, card)\n        G.E_MANAGER:add_event(Event({func = function()\n            G.consumeables.config.card_limit = G.consumeables.config.card_limit + card.ability.extra.slot\n        return true end}))\n    end,"
    },
    {
      "type": "Voucher",
      "key": "fire_sale",
      "atlas": "Vouchers",
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "key = \"fire_sale\",\n    atlas = \"Vouchers\",\n    pos = { x = 4, y = 0 },\n    config = {\n        extra = {\n            packs = 1,\n            card = 1\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.card, card.ability.extra.packs } }\n    end,\n    cost = 10,\n    unlocked = true,\n    available = true,\n    requires = {\"v_clearance_sale\", \"v_liquidation\"},\n    redeem = function(self, card)\n        G.E_MANAGER:add_event(Event({func = function()\n            SMODS.change_booster_limit(card.ability.extra.packs)\n            change_shop_size(1)\n        return true end}))\n    end,"
    },
    {
      "type": "Voucher",
      "key": "gachapon",
      "atlas": "Vouchers",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "key = \"gachapon\",\n        atlas = \"Vouchers\",\n        config = {\n            extra = {\n                s_rate = 0.75,\n                m_rate = 0.19\n            }\n        },\n        pos = { x = 1, y = 2 },\n        cost = 10,\n        unlocked = true,\n        available = true,\n        requires = { \"v_fmod_grab_bag\" },\n        loc_vars = function(self, info_queue, card)\n            info_queue[#info_queue + 1] = G.P_CENTERS.p_fmod_remix_small_1\n            return { vars = {} }\n        end,\n        redeem = function(self, card)\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    G.P_CENTERS.p_fmod_remix_small_1.weight = card.ability.extra.s_rate\n                    G.P_CENTERS.p_fmod_remix_small_2.weight = card.ability.extra.s_rate\n                    G.P_CENTERS.p_fmod_remix_jumbo.weight = card.ability.extra.s_rate\n                    G.P_CENTERS.p_fmod_remix_mega.weight = card.ability.extra.m_rate\n                    return true\n                end\n            }))\n        end"
    },
    {
      "type": "Voucher",
      "key": "grab_bag",
      "atlas": "Vouchers",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = 'grab_bag',\n        config = {\n            triggered = false,\n            extra = {\n                types = {\n                    \"small_1\",\n                    \"small_2\",\n                    \"jumbo\",\n                    \"mega\"\n                }\n            }\n        },\n        atlas = 'Vouchers',\n        pos = { x = 0, y = 2 },\n        discovered = true,\n        loc_vars = function(self, info_queue)\n            info_queue[#info_queue + 1] = G.P_CENTERS.p_fmod_remix_small_1\n        end,\n        calculate = function(self, card, context)\n            if context.starting_shop and card.ability.triggered then\n                card.ability.triggered = false\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        local key = 'p_fmod_remix_' ..\n                        pseudorandom_element(card.ability.extra.types, \"grab_bag\" .. G.GAME.round_resets.ante)\n                        local _card = Card(\n                            G.play.T.x + G.play.T.w / 2 - G.CARD_W * 1.27 / 2,\n                            G.play.T.y + G.play.T.h / 2 - G.CARD_H * 1.27 / 2,\n                            G.CARD_W * 1.27, G.CARD_H * 1.27, G.P_CARDS.empty,\n                            G.P_CENTERS[key],\n                            { bypass_discovery_center = true, bypass_discovery_ui = true }\n                        )\n                        _card.cost = 0\n                        G.FUNCS.use_card({ config = { ref_table = _card } })\n                        _card:start_materialize()\n                        return true\n                    end\n                }))\n            end\n\n            if context.end_of_round and context.main_eval and G.GAME.blind.boss then\n                card.ability.triggered = true\n            end\n        end"
    },
    {
      "type": "Voucher",
      "key": "mystery_box",
      "atlas": "Vouchers",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "key = \"mystery_box\",\n        atlas = \"Vouchers\",\n        config = {\n            extra = {\n                slot = 1\n            }\n        },\n        pos = { x = 2, y = 2 },\n        cost = 10,\n        unlocked = true,\n        available = true,\n        requires = { \"v_fmod_grab_bag\", \"v_fmod_gachapon\" },\n        loc_vars = function(self, info_queue, card)\n            return { vars = {} }\n        end,\n        redeem = function(self, card)\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    SMODS.change_booster_limit(card.ability.extra.slot)\n                    return true\n                end\n            }))\n        end"
    },
    {
      "type": "Voucher",
      "key": "reroll_superfluity",
      "atlas": "Vouchers",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"reroll_superfluity\",\n    atlas = \"Vouchers\",\n    pos = { x = 1, y = 0 },\n    cost = 10,\n    unlocked = true,\n    available = true,\n    requires = {\"v_reroll_surplus\", \"v_reroll_glut\"},"
    },
    {
      "type": "Voucher",
      "key": "shopaholic",
      "atlas": "Vouchers",
      "pos": {
        "x": 5,
        "y": 1
      },
      "raw": "key = \"shopaholic\",\n    atlas = \"Vouchers\",\n    pos = { x = 5, y = 1 },\n    config = {\n        extra = {\n            slot = 1\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.slot } }\n    end,\n    cost = 10,\n    unlocked = true,\n    available = true,\n    requires = {\"v_fmod_coupon\", \"v_fmod_extreme_couponing\"},\n    redeem = function(self, card)\n        G.E_MANAGER:add_event(Event({func = function()\n            SMODS.change_booster_limit(card.ability.extra.slot)\n            local booster = G.shop_booster.cards[#G.shop_booster.cards]\n            if booster then booster.ability.couponed = true end\n            booster:set_cost()\n        return true end}))\n    end,"
    },
    {
      "type": "Voucher",
      "key": "showtime",
      "atlas": "Vouchers",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"showtime\",\n    atlas = \"Vouchers\",\n    config = {\n        extra = {\n            rate = 4\n        }\n    },\n    pos = { x = 0, y = 1 },\n    cost = 10,\n    unlocked = true,\n    available = true,\n    requires = {\"v_fmod_circus\"},\n    loc_vars = function(self, info_queue, card)\n        return { vars = { colours = {HEX(\"ff98e2\")} } }\n    end,\n    redeem = function(self, card)\n        G.E_MANAGER:add_event(Event({func = function()\n            G.GAME.silly_rate = card.ability.extra.rate\n        return true end }))\n    end"
    },
    {
      "type": "ConsumableType",
      "key": "Silly",
      "atlas": null,
      "pos": null,
      "raw": "key = 'Silly',\n        primary_colour = HEX('f4d494'),\n        secondary_colour = HEX('db8787'),\n        collection_rows = { 5, 6 },\n        default = 'c_fmod_pie',\n        shop_rate = 0,\n        cards = {\n            [\"c_fmod_clown_car\"] = true,\n            [\"c_fmod_squirt_flower\"] = true,\n            [\"c_fmod_pie\"] = true,\n            [\"c_fmod_bang_gun\"] = true,\n            [\"c_fmod_whoopie_cushion\"] = true,\n            [\"c_fmod_joy_buzzer\"] = true,\n            [\"c_fmod_juggler\"] = true,\n            [\"c_fmod_balloons\"] = true,\n            [\"c_fmod_split_pants\"] = true,\n            [\"c_fmod_midway_games\"] = true,\n            [\"c_fmod_balloon_animal\"] = true,\n            [\"c_fmod_tightrope\"] = true,\n            [\"c_fmod_soully\"] = true,\n            [\"c_fmod_fire_breath\"] = true,\n            [\"c_fmod_rodeo\"] = true,\n            [\"c_fmod_endless_scarf\"] = true,\n            [\"c_fmod_knife_throw\"] = true,\n            [\"c_fmod_trapeze\"] = true,\n            [\"c_fmod_greasepaint\"] = true,\n            [\"c_fmod_unicycle\"] = true,\n            [\"c_fmod_cannon\"] = true,\n            [\"c_fmod_barker\"] = true,\n            [\"c_fmod_suspenders\"] = true,\n            [\"c_fmod_hall_of_mirrors\"] = true,\n        },\n        loc_txt = {\n            name = \"Silly\",\n            collection = \"Silly Cards\",\n            undiscovered = {\n                name = \"Not Discovered\",\n                text = {\n                    \"Purchase or use\",\n                    \"this card in an\",\n                    \"unseeded run to\",\n                    \"learn what it does\"\n                }\n            }\n        },"
    },
    {
      "type": "UndiscoveredSprite",
      "key": "Silly",
      "atlas": "Consumables",
      "pos": {
        "x": 3,
        "y": 2
      },
      "raw": "key = 'Silly',\n        atlas = 'Consumables',\n        pos = { x = 3, y = 2 },\n        --overlay_pos = { x = 4, y = 2 }"
    },
    {
      "type": "DeckSkin",
      "key": "peppered_diamonds",
      "atlas": "fmod_peppered_diamonds_lc",
      "pos": null,
      "raw": "key = \"peppered_diamonds\",\n    suit = \"Diamonds\",\n    loc_txt = \"PEPPERED\",\n    palettes = {\n        {\n            key = 'lc',\n            ranks = { '2', '3', '4', '5', '6', '7', '8', '9', '10', 'Jack', 'Queen', 'King', 'Ace' },\n            display_ranks = { 'Ace', 'King', 'Queen', 'Jack', '10' },\n            pos_style = 'ranks',\n            atlas = 'fmod_peppered_diamonds_lc'\n        },\n        {\n            key = 'hc',\n            ranks = { '2', '3', '4', '5', '6', '7', '8', '9', '10', 'Jack', 'Queen', 'King', 'Ace' },\n            display_ranks = { 'Ace', 'King', 'Queen', 'Jack', '10' },\n            pos_style = 'ranks',\n            atlas = 'fmod_peppered_diamonds_hc'\n        }\n    },"
    },
    {
      "type": "DeckSkin",
      "key": "yttd_clubs",
      "atlas": "fmod_yttd_clubs_lc",
      "pos": null,
      "raw": "key = \"yttd_clubs\",\n    suit = \"Clubs\",\n    loc_txt = \"Your Turn To Die\",\n    palettes = {\n        {\n            key = 'lc',\n            ranks = { 'Jack', 'Queen', 'King', 'Ace' },\n            display_ranks = { 'Ace', 'King', 'Queen', 'Jack' },\n            pos_style = 'ranks',\n            atlas = 'fmod_yttd_clubs_lc'\n        },\n        {\n            key = 'hc',\n            ranks = { 'Jack', 'Queen', 'King', 'Ace' },\n            display_ranks = { 'Ace', 'King', 'Queen', 'Jack' },\n            pos_style = 'ranks',\n            atlas = 'fmod_yttd_clubs_hc'\n        }\n    },"
    },
    {
      "type": "DeckSkin",
      "key": "catgirl_hearts",
      "atlas": "fmod_catgirl_hearts_lc",
      "pos": null,
      "raw": "key = \"catgirl_hearts\",\n    suit = \"Hearts\",\n    loc_txt = \"Catgirls\",\n    palettes = {\n        {\n            key = 'lc',\n            ranks = { 'Jack', 'Queen', 'King', 'Ace' },\n            display_ranks = { 'Ace', 'King', 'Queen', 'Jack' },\n            pos_style = 'ranks',\n            atlas = 'fmod_catgirl_hearts_lc'\n        },\n        {\n            key = 'hc',\n            ranks = { 'Jack', 'Queen', 'King', 'Ace' },\n            display_ranks = { 'Ace', 'King', 'Queen', 'Jack' },\n            pos_style = 'ranks',\n            atlas = 'fmod_catgirl_hearts_hc'\n        }\n    },"
    },
    {
      "type": "DeckSkin",
      "key": "deathnote_spades",
      "atlas": "fmod_deathnote_spades_lc",
      "pos": null,
      "raw": "key = \"deathnote_spades\",\n    suit = \"Spades\",\n    loc_txt = \"Death Note\",\n    palettes = {\n        {\n            key = 'lc',\n            ranks = { 'Jack', 'Queen', 'King', 'Ace' },\n            display_ranks = { 'Ace', 'King', 'Queen', 'Jack' },\n            pos_style = 'ranks',\n            atlas = 'fmod_deathnote_spades_lc'\n        },\n        {\n            key = 'hc',\n            ranks = { 'Jack', 'Queen', 'King', 'Ace' },\n            display_ranks = { 'Ace', 'King', 'Queen', 'Jack' },\n            pos_style = 'ranks',\n            atlas = 'fmod_deathnote_spades_hc'\n        }\n    },"
    },
    {
      "type": "DeckSkin",
      "key": "deltarune_hearts",
      "atlas": "fmod_deltarune_hearts_lc",
      "pos": null,
      "raw": "key = \"deltarune_hearts\",\n    suit = \"Hearts\",\n    loc_txt = \"Deltarune\",\n    palettes = {\n        {\n            key = 'lc',\n            ranks = { 'Jack', 'Queen', 'King', 'Ace' },\n            display_ranks = { 'Ace', 'King', 'Queen', 'Jack' },\n            pos_style = 'ranks',\n            atlas = 'fmod_deltarune_hearts_lc'\n        },\n        {\n            key = 'hc',\n            ranks = { 'Jack', 'Queen', 'King', 'Ace' },\n            display_ranks = { 'Ace', 'King', 'Queen', 'Jack' },\n            pos_style = 'ranks',\n            atlas = 'fmod_deltarune_hearts_hc'\n        }\n    },"
    },
    {
      "type": "DeckSkin",
      "key": "celeste_spades",
      "atlas": "fmod_celeste_spades_lc",
      "pos": null,
      "raw": "key = \"celeste_spades\",\n    suit = \"Spades\",\n    loc_txt = \"Celeste\",\n    palettes = {\n        {\n            key = 'lc',\n            ranks = { 'Jack', 'Queen', 'King', 'Ace' },\n            display_ranks = { 'Ace', 'King', 'Queen', 'Jack' },\n            pos_style = 'ranks',\n            atlas = 'fmod_celeste_spades_lc'\n        },\n        {\n            key = 'hc',\n            ranks = { 'Jack', 'Queen', 'King', 'Ace' },\n            display_ranks = { 'Ace', 'King', 'Queen', 'Jack' },\n            pos_style = 'ranks',\n            atlas = 'fmod_celeste_spades_hc'\n        }\n    },"
    },
    {
      "type": "Atlas",
      "key": "peppered_stars_lc",
      "atlas": null,
      "pos": null,
      "raw": "key = \"peppered_stars_lc\",\n        path = \"collabs/peppered_stars_lc.png\",\n        px = 71,\n        py = 95"
    },
    {
      "type": "Atlas",
      "key": "peppered_stars_hc",
      "atlas": null,
      "pos": null,
      "raw": "key = \"peppered_stars_hc\",\n        path = \"collabs/peppered_stars_hc.png\",\n        px = 71,\n        py = 95"
    },
    {
      "type": "Atlas",
      "key": "yttd_crowns_lc",
      "atlas": null,
      "pos": null,
      "raw": "key = \"yttd_crowns_lc\",\n        path = \"collabs/yttd_crowns_lc.png\",\n        px = 71,\n        py = 95"
    },
    {
      "type": "Atlas",
      "key": "yttd_crowns_hc",
      "atlas": null,
      "pos": null,
      "raw": "key = \"yttd_crowns_hc\",\n        path = \"collabs/yttd_crowns_hc.png\",\n        px = 71,\n        py = 95"
    },
    {
      "type": "DeckSkin",
      "key": "peppered_paperback_stars",
      "atlas": "fmod_peppered_stars_lc",
      "pos": null,
      "raw": "key = \"peppered_paperback_stars\",\n        suit = \"paperback_Stars\",\n        loc_txt = \"PEPPERED\",\n        palettes = {\n            {\n                key = 'lc',\n                ranks = { '2', '3', '4', '5', '6', '7', '8', '9', '10', 'Jack', 'Queen', 'King', 'Ace' },\n                display_ranks = { 'Ace', 'King', 'Queen', 'Jack', '10' },\n                pos_style = 'ranks',\n                atlas = 'fmod_peppered_stars_lc'\n            },\n            {\n                key = 'hc',\n                ranks = { '2', '3', '4', '5', '6', '7', '8', '9', '10', 'Jack', 'Queen', 'King', 'Ace' },\n                display_ranks = { 'Ace', 'King', 'Queen', 'Jack', '10' },\n                pos_style = 'ranks',\n                atlas = 'fmod_peppered_stars_hc'\n            }\n        },"
    },
    {
      "type": "DeckSkin",
      "key": "yttd_paperback_crowns",
      "atlas": "fmod_yttd_crowns_lc",
      "pos": null,
      "raw": "key = \"yttd_paperback_crowns\",\n        suit = \"paperback_Crowns\",\n        loc_txt = \"Your Turn To Die\",\n        palettes = {\n            {\n                key = 'lc',\n                ranks = { 'Jack', 'Queen', 'King', 'Ace' },\n                display_ranks = { 'Ace', 'King', 'Queen', 'Jack' },\n                pos_style = 'ranks',\n                atlas = 'fmod_yttd_crowns_lc'\n            },\n            {\n                key = 'hc',\n                ranks = { 'Jack', 'Queen', 'King', 'Ace' },\n                display_ranks = { 'Ace', 'King', 'Queen', 'Jack' },\n                pos_style = 'ranks',\n                atlas = 'fmod_yttd_crowns_hc'\n            }\n        }"
    }
  ],
  "version": "v1.2.2"
}