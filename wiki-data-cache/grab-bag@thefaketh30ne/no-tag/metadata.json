{
  "locMap": {
    "gb_custom_music_name": {
      "name": "",
      "text": [
        "Enable Custom Music"
      ],
      "type": "dictionary"
    },
    "gb_custom_music_desc": {
      "name": "",
      "text": [
        "If enabled, play custom music"
      ],
      "type": "dictionary"
    },
    "gb_page": {
      "name": "\"Page\"\n        ",
      "text": [],
      "type": "dictionary"
    }
  },
  "atlases": {
    "gb_Boosters": {
      "path": "Boosters.png",
      "px": 71,
      "py": 95,
      "resolvedGitHubPath": "Boosters.png",
      "localPath": null
    },
    "gb_Cards": {
      "path": "Cards.png",
      "px": 71,
      "py": 95,
      "resolvedGitHubPath": "Cards.png",
      "localPath": null
    },
    "gb_Consumables": {
      "path": "Consumables.png",
      "px": 71,
      "py": 95,
      "resolvedGitHubPath": "Consumables.png",
      "localPath": null
    },
    "gb_Ephemerals": {
      "path": "Ephemerals.png",
      "px": 71,
      "py": 95,
      "resolvedGitHubPath": "Ephemerals.png",
      "localPath": null
    },
    "gb_Enhancements": {
      "path": "Enhancements.png",
      "px": 71,
      "py": 95,
      "resolvedGitHubPath": "Enhancements.png",
      "localPath": null
    },
    "gb_Jokers": {
      "path": "Jokers.png",
      "px": 71,
      "py": 95,
      "resolvedGitHubPath": "Jokers.png",
      "localPath": null
    },
    "gb_ShatteredJokers": {
      "path": "ShatteredJokers.png",
      "px": 71,
      "py": 95,
      "resolvedGitHubPath": "ShatteredJokers.png",
      "localPath": null
    },
    "gb_BossJokers": {
      "path": "BossJokers.png",
      "px": 71,
      "py": 95,
      "resolvedGitHubPath": "BossJokers.png",
      "localPath": null
    }
  },
  "cards": [
    {
      "type": "Blind",
      "key": "body",
      "atlas": "gb_Blinds",
      "pos": null,
      "raw": "key = \"body\",\n    loc_txt = {\n        name = \"The Body\",\n        text = {\n            \"Enhanced cards are\",\n            \"drawn face down\",\n        }\n    },\n    dollars = 5,\n    mult = 2,\n    atlas = \"gb_Blinds\",\n    pos = { y = 5 },\n    boss = { min = 6 },\n    boss_colour = HEX(\"35acbc\"),\n    calculate = function(self, blind, context)\n        if not blind.disabled then\n            if context.stay_flipped and context.to_area == G.hand and\n                next(SMODS.get_enhancements(context.other_card)) then\n                return {\n                    stay_flipped = true\n                }\n            end\n        end\n    end,\n    disable = function(self)\n        for i = 1, #G.hand.cards do\n            if G.hand.cards[i].facing == 'back' then\n                G.hand.cards[i]:flip()\n            end\n        end\n        for _, playing_card in pairs(G.playing_cards) do\n            playing_card.ability.wheel_flipped = nil\n        end\n    end"
    },
    {
      "type": "Blind",
      "key": "cross",
      "atlas": "gb_Blinds",
      "pos": null,
      "raw": "key = \"cross\",\n    loc_txt = {\n        name = \"The Cross\",\n        text = {\n            \"Divides all listed\",\n            \"probabilities by 10\",\n        }\n    },\n    dollars = 5,\n    mult = 2,\n    atlas = \"gb_Blinds\",\n    pos = { y = 9 },\n    boss = { min = 4 },\n    boss_colour = HEX(\"53c45c\"),\n    set_blind = function(self)\n        G.GAME.probabilities.normal = G.GAME.probabilities.normal * 0.1\n    end,\n    disable = function(self)\n        G.GAME.probabilities.normal = G.GAME.probabilities.normal * 10\n    end,\n    defeat = function(self)\n        G.GAME.probabilities.normal = G.GAME.probabilities.normal * 10\n    end"
    },
    {
      "type": "Blind",
      "key": "dread",
      "atlas": "gb_Blinds",
      "pos": null,
      "raw": "key = \"dread\",\n    loc_txt = {\n        name = \"The Dread\",\n        text = {\n            \"Cannot play more\",\n            \"than two suits\",\n        }\n    },\n    dollars = 5,\n    mult = 2,\n    atlas = \"gb_Blinds\",\n    pos = { y = 12 },\n    boss = { min = 6 },\n    boss_colour = HEX(\"5d6385\"),\n    debuff_hand = function(self, cards, hand, handname, check)\n        local scored_suits = {}\n        local suit_count = 0\n        for _, card in pairs(cards) do\n            if card.base.suit\n            and not SMODS.has_no_suit(card)\n            and not SMODS.has_any_suit(card)\n            and not scored_suits[card.base.suit] then\n                scored_suits[card.base.suit] = true\n            end  \n        end\n        for _, _ in pairs(scored_suits) do\n            suit_count = suit_count + 1\n        end\n        if suit_count > 2 then\n            return true\n        else\n            return false\n        end\n    end"
    },
    {
      "type": "Blind",
      "key": "flag",
      "atlas": "gb_Blinds",
      "pos": null,
      "raw": "key = \"flag\",\n    loc_txt = {\n        name = \"The Flag\",\n        text = {\n            \"Cards held in hand\",\n            \"at end of round are\",\n            \"permanently debuffed\",\n        }\n    },\n    dollars = 5,\n    mult = 2,\n    atlas = \"gb_Blinds\",\n    pos = { y = 7 },\n    boss = { min = 3 },\n    boss_colour = HEX(\"6d6b89\"),\n    calculate = function(self, blind, context)\n        if not blind.disabled and context.end_of_round and context.cardarea == G.hand then\n            for _, playing_card in pairs(G.hand.cards) do\n                playing_card.ability.perma_debuff = true\n                playing_card:juice_up()\n            end\n        end\n    end,"
    },
    {
      "type": "Blind",
      "key": "hand",
      "atlas": "gb_Blinds",
      "pos": null,
      "raw": "key = \"hand\",\n    loc_txt = {\n        name = \"The Hand\",\n        text = {\n            \"Permanently debuff\",\n            \"leftmost card\",\n            \"in played hand\",\n        }\n    },\n    dollars = 5,\n    mult = 2,\n    atlas = \"gb_Blinds\",\n    pos = { y = 4 },\n    boss = { min = 5 },\n    boss_colour = HEX(\"bc3535\"),\n    calculate = function(self, blind, context)\n        if not blind.disabled and context.final_scoring_step then\n            local first_scored_card = G.play.cards[1]\n            first_scored_card.ability.perma_debuff = true\n            first_scored_card:juice_up()\n        end\n    end,"
    },
    {
      "type": "Blind",
      "key": "lance",
      "atlas": "gb_Blinds",
      "pos": null,
      "raw": "key = \"lance\",\n    loc_txt = {\n        name = \"The Lance\",\n        text = {\n            \"All cards discarded\",\n            \"this ante are\",\n            \"drawn face down\",\n        }\n    },\n    dollars = 5,\n    mult = 2,\n    atlas = \"gb_Blinds\",\n    pos = { y = 14 },\n    boss = { min = 1 },\n    boss_colour = HEX(\"5d6d85\"),\n    calculate = function(self, blind, context)\n        if not blind.disabled then\n            if context.stay_flipped and context.to_area == G.hand and\n                context.other_card.ability.discarded_this_ante then\n                return {\n                    stay_flipped = true\n                }\n            end\n        end\n    end,\n    disable = function(self)\n        for i = 1, #G.hand.cards do\n            if G.hand.cards[i].facing == 'back' then\n                G.hand.cards[i]:flip()\n            end\n        end\n        for _, playing_card in pairs(G.playing_cards) do\n            playing_card.ability.wheel_flipped = nil\n        end\n    end"
    },
    {
      "type": "Blind",
      "key": "matchstick",
      "atlas": "gb_Blinds",
      "pos": null,
      "raw": "key = \"matchstick\",\n    loc_txt = {\n        name = \"The Matchstick\",\n        text = {\n            \"Start with half of\",\n            \"hands and discards\",\n        }\n    },\n    dollars = 5,\n    mult = 2,\n    atlas = \"gb_Blinds\",\n    pos = { y = 13 },\n    boss = { min = 3 },\n    boss_colour = HEX(\"85675d\"),\n    config = { extra = { discards_sub = 0, hands_sub = 0 } },\n    calculate = function(self, blind, context)\n        if context.setting_blind then\n            self.config.extra.discards_sub = math.floor(G.GAME.current_round.discards_left / 2)\n            self.config.extra.hands_sub = math.floor(G.GAME.current_round.hands_left / 2)\n        end\n        if not blind.disabled then\n            if context.setting_blind then\n                ease_discard(-self.config.extra.discards_sub)\n                ease_hands_played(-self.config.extra.hands_sub)\n            end\n        end\n    end,\n    disable = function(self)\n        if not self.config.extra.discards_sub and self.config.extra.hands_sub then\n            self.config.extra.discards_sub = math.floor(G.GAME.current_round.discards_left / 2)\n            self.config.extra.hands_sub = math.floor(G.GAME.current_round.hands_left / 2) \n        end\n        ease_discard(self.config.extra.discards_sub)\n        ease_hands_played(self.config.extra.hands_sub)\n    end"
    },
    {
      "type": "Blind",
      "key": "mind",
      "atlas": "gb_Blinds",
      "pos": null,
      "raw": "key = \"mind\",\n    loc_txt = {\n        name = \"The Mind\",\n        text = {\n            \"#1# in 3 chance\",\n            \"Hearts and Diamonds are\",\n            \"drawn face down\",\n        }\n    },\n    dollars = 5,\n    mult = 2,\n    atlas = \"gb_Blinds\",\n    pos = { y = 1 },\n    boss = { min = 3 },\n    boss_colour = HEX(\"bc7635\"),\n    loc_vars = function(self)\n        return { vars = { G.GAME.probabilities.normal or 1 } }\n    end,\n    collection_loc_vars = function(self)\n        return { vars = { '1' } }\n    end,\n    calculate = function(self, blind, context)\n        if not blind.disabled then\n            if context.stay_flipped and context.to_area == G.hand and\n                (context.other_card:is_suit(\"Hearts\") or context.other_card:is_suit(\"Diamonds\")) and\n                SMODS.pseudorandom_probability(blind, 'gb_mind', G.GAME.probabilities.normal, 3) then\n                return {\n                    stay_flipped = true\n                }\n            end\n        end\n    end,\n    disable = function(self)\n        for i = 1, #G.hand.cards do\n            if G.hand.cards[i].facing == 'back' then\n                G.hand.cards[i]:flip()\n            end\n        end\n        for _, playing_card in pairs(G.playing_cards) do\n            playing_card.ability.wheel_flipped = nil\n        end\n    end"
    },
    {
      "type": "Blind",
      "key": "mystic",
      "atlas": "gb_Blinds",
      "pos": null,
      "raw": "key = \"mystic\",\n    loc_txt = {\n        name = \"The Mystic\",\n        text = {\n            \"Played hand must\",\n            \"contain a Face Card\",\n        }\n    },\n    dollars = 5,\n    mult = 2,\n    atlas = \"gb_Blinds\",\n    pos = { y = 6 },\n    boss = { min = 1 },\n    boss_colour = HEX(\"8135bc\"),\n    debuff_hand = function(self, cards, hand, handname, check)\n        for _, card in pairs(cards) do\n            if card:is_face() then\n                return false\n            end\n        end\n        return true\n    end,\n    in_pool = function(self)\n        local face_cards = 0\n        for _, card in pairs(G.playing_cards or {}) do\n            if card:is_face() then\n                face_cards = face_cards + 1\n            end\n        end\n        if face_cards >= 10 then\n            return true\n        else\n            return false\n        end\n    end"
    },
    {
      "type": "Blind",
      "key": "piper",
      "atlas": "gb_Blinds",
      "pos": null,
      "raw": "key = \"piper\",\n    loc_txt = {\n        name = \"The Piper\",\n        text = {\n            \"One random played card\",\n            \"destroyed after scoring\",\n        }\n    },\n    dollars = 5,\n    mult = 2,\n    atlas = \"gb_Blinds\",\n    pos = { y = 2 },\n    boss = { min = 3 },\n    boss_colour = HEX(\"35bc4b\"),\n    calculate = function(self, blind, context)\n        if not blind.disabled then\n            if context.before then\n                local chosen_card = pseudorandom_element(context.full_hand, pseudoseed(\"gb_piper\"))\n                chosen_card.ability.piper_destroy = true\n            end\n            if context.destroy_card and context.destroy_card.ability.piper_destroy == true then\n                return {\n                    remove = true\n                }\n            end\n        end\n    end"
    },
    {
      "type": "Blind",
      "key": "shame",
      "atlas": "gb_Blinds",
      "pos": null,
      "raw": "key = \"shame\",\n    loc_txt = {\n        name = \"The Shame\",\n        text = {\n            \"All cards debuffed\",\n            \"if Blind not skipped\",\n            \"this ante\",\n        }\n    },\n    dollars = 5,\n    mult = 2,\n    atlas = \"gb_Blinds\",\n    pos = { y = 8 },\n    boss = { min = 1 },\n    boss_colour = HEX(\"6935bc\"),\n    calculate = function(self, blind, context)\n        if not blind.disabled then\n            if context.debuff_card and context.debuff_card.area ~= G.jokers and not blind_skipped_this_ante then\n                return {\n                    debuff = true\n                }\n            end\n        end\n    end"
    },
    {
      "type": "Blind",
      "key": "spirit",
      "atlas": "gb_Blinds",
      "pos": null,
      "raw": "key = \"spirit\",\n    loc_txt = {\n        name = \"The Spirit\",\n        text = {\n            \"#1# in 3 chance\",\n            \"Spades and Clubs are\",\n            \"drawn face down\",\n        }\n    },\n    dollars = 5,\n    mult = 2,\n    atlas = \"gb_Blinds\",\n    pos = { y = 0 },\n    boss = { min = 3 },\n    boss_colour = HEX(\"6035bc\"),\n    loc_vars = function(self)\n        return { vars = { G.GAME.probabilities.normal or 1 } }\n    end,\n    collection_loc_vars = function(self)\n        return { vars = { '1' } }\n    end,\n    calculate = function(self, blind, context)\n        if not blind.disabled then\n            if context.stay_flipped and context.to_area == G.hand and\n                (context.other_card:is_suit(\"Spades\") or context.other_card:is_suit(\"Clubs\")) and\n                SMODS.pseudorandom_probability(blind, 'gb_spirit', G.GAME.probabilities.normal, 3) then\n                return {\n                    stay_flipped = true\n                }\n            end\n        end\n    end,\n    disable = function(self)\n        for i = 1, #G.hand.cards do\n            if G.hand.cards[i].facing == 'back' then\n                G.hand.cards[i]:flip()\n            end\n        end\n        for _, playing_card in pairs(G.playing_cards) do\n            playing_card.ability.wheel_flipped = nil\n        end\n    end"
    },
    {
      "type": "Blind",
      "key": "storm",
      "atlas": "gb_Blinds",
      "pos": null,
      "raw": "key = \"storm\",\n    loc_txt = {\n        name = \"The Storm\",\n        text = {\n            \"+1 Ante if Blind not\",\n            \"won on final hand\",\n        }\n    },\n    dollars = 5,\n    mult = 2,\n    atlas = \"gb_Blinds\",\n    pos = { y = 11 },\n    boss = { min = 2 },\n    boss_colour = HEX(\"424d85\"),\n    config = { extra = { ante_skipped = false } },\n    calculate = function(self, blind, context)\n        if not blind.disabled then\n            if context.end_of_round and G.GAME.current_round.hands_left ~= 0 and not self.config.extra.ante_skipped then\n                ease_ante(1)\n                G.GAME.round_resets.blind_ante = G.GAME.round_resets.blind_ante or G.GAME.round_resets.ante\n                G.GAME.round_resets.blind_ante = G.GAME.round_resets.blind_ante + 1\n                self.config.extra.ante_skipped = true\n            end\n        end\n    end"
    },
    {
      "type": "Blind",
      "key": "trident",
      "atlas": "gb_Blinds",
      "pos": null,
      "raw": "key = \"trident\",\n    loc_txt = {\n        name = \"The Trident\",\n        text = {\n            \"Permanently debuffs\",\n            \"unscored cards\",\n        }\n    },\n    dollars = 5,\n    mult = 2,\n    atlas = \"gb_Blinds\",\n    pos = { y = 10 },\n    boss = { min = 4 },\n    boss_colour = HEX(\"35bc9c\"),\n    calculate = function(self, blind, context)\n        if not blind.disabled then\n            local triggered = false\n            if context.individual and context.cardarea == \"unscored\" then\n                context.other_card:juice_up()\n                context.other_card.ability.perma_debuff = true\n                triggered = true\n            end\n            if triggered then\n                blind.triggered = true\n            end\n        end\n    end"
    },
    {
      "type": "Blind",
      "key": "weave",
      "atlas": "gb_Blinds",
      "pos": null,
      "raw": "key = \"weave\",\n    loc_txt = {\n        name = \"The Weave\",\n        text = {\n            \"Halves current money\",\n            \"if played hand has\",\n            \"more than 3 cards\",\n        }\n    },\n    dollars = 5,\n    mult = 2,\n    atlas = \"gb_Blinds\",\n    pos = { y = 3 },\n    boss = { min = 4 },\n    boss_colour = HEX(\"bc35b7\"),\n    calculate = function(self, blind, context)\n        if not blind.disabled then\n            if context.debuff_hand then\n                blind.triggered = false\n                if #G.play.cards > 3 then\n                    blind.triggered = true\n                    local half_dollars = math.floor(G.GAME.dollars / 2)\n                    if half_dollars > 0 then\n                        if to_big(half_dollars) > to_big(0) then\n                            ease_dollars(-half_dollars, true)\n                        end\n                    end\n                end\n            end\n        end\n    end"
    },
    {
      "type": "Blind",
      "key": "final_baton",
      "atlas": "gb_Blinds",
      "pos": null,
      "raw": "key = \"final_baton\",\n    loc_txt = {\n        name = \"Wooden Baton\",\n        text = {\n            \"Debuffs all cards\",\n            \"until 1 hand remaining\",\n        }\n    },\n    dollars = 8,\n    mult = 3,\n    atlas = \"gb_Blinds\",\n    pos = { y = 15 },\n    boss = { showdown = true },\n    boss_colour = HEX(\"be7022\"),\n    calculate = function(self, blind, context)\n        if not blind.disabled then\n            if context.debuff_card and context.debuff_card.area ~= G.jokers then\n                if G.GAME.current_round.hands_left > 1 then\n                    return { debuff = true }\n                else\n                    G.GAME.blind:disable()\n                    return { debuff = false }\n                end\n            end\n            if context.after then\n                if G.GAME.current_round.hands_left <= 1 then\n                    G.GAME.blind:disable()\n                end\n            end\n        end\n    end"
    },
    {
      "type": "Blind",
      "key": "final_clover",
      "atlas": "gb_Blinds",
      "pos": null,
      "raw": "key = \"final_clover\",\n    loc_txt = {\n        name = \"Celadon Clover\",\n        text = {\n            \"Shuffles all Jokers\",\n            \"before scoring\",\n        }\n    },\n    dollars = 8,\n    mult = 2,\n    atlas = \"gb_Blinds\",\n    pos = { y = 17 },\n    boss = { showdown = true },\n    boss_colour = HEX(\"80d585\"),\n    calculate = function(self, blind, context)\n        if not blind.disabled then\n            if context.press_play then\n                if #G.jokers.cards > 1 then\n                    G.E_MANAGER:add_event(Event({\n                        trigger = 'after',\n                        delay = 0.2,\n                        func = function()\n                            for i = 1, 3 do\n                                G.E_MANAGER:add_event(Event({\n                                    func = function()\n                                        G.jokers:shuffle('gb_final_clover')\n                                        play_sound('cardSlide1', 0.85)\n                                        return true\n                                    end\n                                }))\n                                delay(0.15)\n                            end\n                            delay(0.35)\n                            return true\n                        end\n                    }))\n                end\n            end\n        end\n    end"
    },
    {
      "type": "Blind",
      "key": "final_pentacle",
      "atlas": "gb_Blinds",
      "pos": null,
      "raw": "key = \"final_pentacle\",\n    loc_txt = {\n        name = \"Golden Pentacle\",\n        text = {\n            \"Debuffs half\",\n            \"of played cards\",\n            \"before scoring\",\n        }\n    },\n    dollars = 8,\n    mult = 2,\n    atlas = \"gb_Blinds\",\n    pos = { y = 18 },\n    boss = { showdown = true },\n    boss_colour = HEX(\"f2cc00\"),\n    calculate = function(self, blind, context)\n        if not blind.disabled and context.before then\n            for _, playing_card in ipairs(context.scoring_hand) do\n                if SMODS.pseudorandom_probability(blind, 'gb_final_pentacle', 1, 2) then\n                    playing_card:juice_up()\n                    SMODS.debuff_card(playing_card, true, \"gb_final_pentacle\")\n                end\n            end\n        end\n    end"
    },
    {
      "type": "Blind",
      "key": "final_pike",
      "atlas": "gb_Blinds",
      "pos": null,
      "raw": "key = \"final_pike\",\n    loc_txt = {\n        name = \"Platinum Pike\",\n        text = {\n            \"On Play or Discard,\",\n            \"Discard all cards\",\n            \"held in hand\",\n        }\n    },\n    dollars = 8,\n    mult = 2,\n    atlas = \"gb_Blinds\",\n    pos = { y = 16 },\n    boss = { showdown = true },\n    boss_colour = HEX(\"a9b4b9\"),\n    calculate = function(self, blind, context)\n        if not blind.disabled then\n            if (context.pre_discard or context.before) and not context.hook then\n                local selection_limit = G.hand.config.highlighted_limit\n                G.hand.config.highlighted_limit = 1000\n                local any_selected = false\n                for _, playing_card in pairs(G.hand.cards) do\n                    if not playing_card.highlighted then\n                        G.hand:add_to_highlighted(playing_card, true)\n                        any_selected = true\n                    end\n                end\n                if any_selected then \n                    G.FUNCS.discard_cards_from_highlighted(nil, true) \n                end\n                G.hand.config.highlighted_limit = selection_limit\n                blind.triggered = true\n            end\n        end\n    end"
    },
    {
      "type": "Blind",
      "key": "final_tile",
      "atlas": "gb_Blinds",
      "pos": null,
      "raw": "key = \"final_tile\",\n    loc_txt = {\n        name = \"Tangerine Tile\",\n        text = {\n            \"Selling a Joker\",\n            \"reduces score\",\n            \"requirement by 2X Base\",\n        }\n    },\n    dollars = 8,\n    mult = 8,\n    atlas = \"gb_Blinds\",\n    pos = { y = 19 },\n    boss = { showdown = true },\n    boss_colour = HEX(\"f4a441\"),\n    config = { extra = { base_blind_chips = 0 } },\n    calculate = function(self, blind, context)\n        if context.setting_blind then\n            self.config.extra.base_blind_chips = G.GAME.blind.chips / G.GAME.blind.mult\n        end\n        if not blind.disabled\n        and context.selling_card\n        and context.card.ability.set == 'Joker' \n        and to_big(G.GAME.blind.chips) > to_big(self.config.extra.base_blind_chips * 2) then\n            G.GAME.blind.chips = G.GAME.blind.chips - self.config.extra.base_blind_chips * 2\n            G.GAME.blind.chip_text = number_format(G.GAME.blind.chips)\n        end\n    end,\n    disable = function(self)\n        G.GAME.blind.chips = self.config.extra.base_blind_chips * 2\n        G.GAME.blind.chip_text = number_format(G.GAME.blind.chips)\n    end"
    },
    {
      "type": "Booster",
      "key": "ephemeral_small_1",
      "atlas": "gb_Boosters",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"ephemeral_small_1\",\n    loc_txt = {\n        name = \"Ephemeral Pack\",\n        group_name = \"Ephemeral Pack\",\n        text = {\n            \"Choose {C:attention}#1#{} of up to\",\n            \"{C:attention}#2# {V:1}Ephemeral{} cards to\",\n            \"be added to consumables\"\n        }\n    },\n    config = { extra = 3, choose = 1 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.choose, card.ability.extra, colours = {HEX(\"8ea4b3\")} } }\n    end,\n    cost = 4,\n    atlas = \"gb_Boosters\",\n    weight = 1.5,\n    pos = { x = 0, y = 0 },\n    draw_hand = false,\n    select_card = \"consumeables\",\n    kind = \"Ephemeral\",\n    create_card = function(self, card, i)\n        return SMODS.create_card({set = \"Ephemeral\", skip_materialize = true, area = G.pack_cards})\n    end,\n    ease_background_colour = function(self)\n        ease_colour(G.C.DYN_UI.MAIN, HEX(\"8ea4b3\"))\n        ease_background_colour({ new_colour = HEX('59778c'), special_colour = HEX(\"8ea4b3\"), contrast = 2 })\n    end"
    },
    {
      "type": "Booster",
      "key": "ephemeral_small_2",
      "atlas": "gb_Boosters",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"ephemeral_small_2\",\n    loc_txt = {\n        name = \"Ephemeral Pack\",\n        group_name = \"Ephemeral Pack\",\n        text = {\n            \"Choose {C:attention}#1#{} of up to\",\n            \"{C:attention}#2# {V:1}Ephemeral{} cards to\",\n            \"be added to consumables\"\n        }\n    },\n    config = { extra = 3, choose = 1 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.choose, card.ability.extra, colours = {HEX(\"8ea4b3\")} } }\n    end,\n    cost = 4,\n    atlas = \"gb_Boosters\",\n    weight = 1.5,\n    pos = { x = 1, y = 0 },\n    draw_hand = false,\n    select_card = \"consumeables\",\n    kind = \"Ephemeral\",\n    create_card = function(self, card, i)\n        return SMODS.create_card({set = \"Ephemeral\", skip_materialize = true, area = G.pack_cards})\n    end,\n    ease_background_colour = function(self)\n        ease_colour(G.C.DYN_UI.MAIN, HEX(\"8ea4b3\"))\n        ease_background_colour({ new_colour = HEX('59778c'), special_colour = HEX(\"8ea4b3\"), contrast = 2 })\n    end"
    },
    {
      "type": "Booster",
      "key": "ephemeral_jumbo",
      "atlas": "gb_Boosters",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"ephemeral_jumbo\",\n    loc_txt = {\n        name = \"Jumbo Ephemeral Pack\",\n        group_name = \"Ephemeral Pack\",\n        text = {\n            \"Choose {C:attention}#1#{} of up to\",\n            \"{C:attention}#2# {V:1}Ephemeral{} cards to\",\n            \"be added to consumables\"\n        }\n    },\n    config = { extra = 5, choose = 1 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.choose, card.ability.extra, colours = {HEX(\"8ea4b3\")} } }\n    end,\n    cost = 6,\n    atlas = \"gb_Boosters\",\n    weight = 0.5,\n    pos = { x = 2, y = 0 },\n    draw_hand = false,\n    select_card = \"consumeables\",\n    kind = \"Ephemeral\",\n    create_card = function(self, card, i)\n        return SMODS.create_card({set = \"Ephemeral\", skip_materialize = true, area = G.pack_cards})\n    end,\n    ease_background_colour = function(self)\n        ease_colour(G.C.DYN_UI.MAIN, HEX(\"8ea4b3\"))\n        ease_background_colour({ new_colour = HEX('59778c'), special_colour = HEX(\"8ea4b3\"), contrast = 2 })\n    end"
    },
    {
      "type": "Booster",
      "key": "ephemeral_mega",
      "atlas": "gb_Boosters",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"ephemeral_mega\",\n    loc_txt = {\n        name = \"Mega Ephemeral Pack\",\n        group_name = \"Ephemeral Pack\",\n        text = {\n            \"Choose {C:attention}#1#{} of up to\",\n            \"{C:attention}#2# {V:1}Ephemeral{} cards to\",\n            \"be added to consumables\"\n        }\n    },\n    config = { extra = 5, choose = 2 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.choose, card.ability.extra, colours = {HEX(\"8ea4b3\")} } }\n    end,\n    cost = 8,\n    atlas = \"gb_Boosters\",\n    weight = 0.2,\n    pos = { x = 3, y = 0 },\n    draw_hand = false,\n    select_card = \"consumeables\",\n    kind = \"Ephemeral\",\n    create_card = function(self, card, i)\n        return SMODS.create_card({set = \"Ephemeral\", skip_materialize = true, area = G.pack_cards})\n    end,\n    ease_background_colour = function(self)\n        ease_colour(G.C.DYN_UI.MAIN, HEX(\"8ea4b3\"))\n        ease_background_colour({ new_colour = HEX('59778c'), special_colour = HEX(\"8ea4b3\"), contrast = 2 })\n    end"
    },
    {
      "type": "Challenge",
      "key": "hit_the_slots",
      "atlas": null,
      "pos": null,
      "raw": "key = 'hit_the_slots',\n    loc_txt = {\n        name = \"Hit The Slots!\"\n    },\n    jokers = {\n        { id = 'j_gb_jackpot', eternal = true },\n        { id = 'j_gb_misfortune', eternal = true },\n    },\n    rules = {\n        modifiers = {\n            { id = 'discards', value = 0 },\n        }\n    }"
    },
    {
      "type": "Challenge",
      "key": "madman",
      "atlas": null,
      "pos": null,
      "raw": "key = 'madman',\n    loc_txt = {\n        name = \"Madman\"\n    },\n    jokers = {\n        { id = 'j_madness', eternal = true },\n    },\n    rules = {\n        modifiers = {\n            { id = 'joker_slots', value = 4 },\n        }\n    },"
    },
    {
      "type": "Challenge",
      "key": "socialism",
      "atlas": null,
      "pos": null,
      "raw": "key = 'socialism',\n    loc_txt = {\n        name = \"Socialism\"\n    },\n    jokers = {\n        { id = 'j_gb_taxman', eternal = true },\n        { id = 'j_raised_fist', eternal = true },\n    },\n    rules = {\n        custom = {\n            { id = 'no_interest' },\n        }\n    }"
    },
    {
      "type": "Challenge",
      "key": "tiny_hands",
      "atlas": null,
      "pos": null,
      "raw": "key = 'tiny_hands',\n    loc_txt = {\n        name = \"Tiny Hands\"\n    },\n    jokers = {\n        { id = 'j_half', eternal = true },\n    },\n    rules = {\n        modifiers = {\n                { id = 'discards', value = 2 },\n                { id = 'hands', value = 2 },\n            }\n        },\n    deck = {\n        cards = {\n            { s = 'C', r = '5' },\n            { s = 'D', r = '5' },\n            { s = 'H', r = '5' },\n            { s = 'S', r = '5' },\n            { s = 'C', r = '4' },\n            { s = 'D', r = '4' },\n            { s = 'H', r = '4' },\n            { s = 'S', r = '4' },\n            { s = 'C', r = '3' },\n            { s = 'D', r = '3' },\n            { s = 'H', r = '3' },\n            { s = 'S', r = '3' },\n            { s = 'C', r = '2' },\n            { s = 'D', r = '2' },\n            { s = 'H', r = '2' },\n            { s = 'S', r = '2' },\n            { s = 'C', r = 'A' },\n            { s = 'D', r = 'A' },\n            { s = 'H', r = 'A' },\n            { s = 'S', r = 'A' },\n        }\n    }"
    },
    {
      "type": "Consumable",
      "key": "chain",
      "atlas": "gb_Ephemerals",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"chain\",\n    set = \"Ephemeral\",\n    loc_txt = {\n        name = 'Chain',\n        text = {\n            \"Adds {C:attention}#1#{} {C:dark_edition}Temporary{}\",\n            \"{C:attention}ascending-rank{} cards to hand\",\n        }\n    },\n    config = {extra = { cards_to_create = 5 }},\n    atlas = 'gb_Ephemerals',\n    pos = { x = 0, y = 1 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.cards_to_create } }\n    end,\n    use = function(self, card, area, copier)\n        local starting_id = pseudorandom_element({2, 3, 4, 5, 6, 7, 8, 9, 10}, pseudoseed(\"gb_group\"))\n        for k = 1, self.config.extra.cards_to_create do\n            local playing_card = SMODS.create_card {\n                rank = id_to_rank(starting_id),\n                set = \"Base\",\n                edition = \"e_gb_temporary\",\n                area = G.discard\n            }\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    playing_card:start_materialize({ G.C.SECONDARY_SET.Enhanced })\n                    G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                    playing_card.playing_card = G.playing_card\n                    G.hand:emplace(playing_card)\n                    SMODS.debuff_card(playing_card, \"prevent_debuff\", \"source\")\n                    return true\n                end\n            }))\n            starting_id = starting_id + 1\n        end\n    end,\n    can_use = function(self, card)\n        if G.hand and G.GAME.blind.in_blind then\n            return true\n        else\n            return false\n        end\n    end,"
    },
    {
      "type": "Consumable",
      "key": "collapse",
      "atlas": "gb_Ephemerals",
      "pos": {
        "x": 6,
        "y": 0
      },
      "raw": "key = \"collapse\",\n    set = \"Ephemeral\",\n    loc_txt = {\n        name = 'Collapse',\n        text = {\n            \"Adds {C:attention}#1#{} {C:dark_edition}Temporary{}\",\n            \"same-suited {C:attention}Aces{} to hand\",\n        }\n    },\n    config = {extra = { cards_to_create = 2 }},\n    atlas = 'gb_Ephemerals',\n    pos = { x = 6, y = 0 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.cards_to_create } }\n    end,\n    use = function(self, card, area, copier)\n        local suit = pseudorandom_element({\"S\", \"H\", \"C\", \"D\"}, pseudoseed(\"gb_collapse\"))\n        for k = 1, self.config.extra.cards_to_create do\n            local playing_card = SMODS.create_card {\n                suit = suit,\n                set = \"Base\",\n                edition = \"e_gb_temporary\",\n                rank = \"Ace\",\n                area = G.discard\n            }\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    playing_card:start_materialize({ G.C.SECONDARY_SET.Enhanced })\n                    G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                    playing_card.playing_card = G.playing_card\n                    G.hand:emplace(playing_card)\n                    SMODS.debuff_card(playing_card, \"prevent_debuff\", \"source\")\n                    return true\n                end\n            }))\n        end\n    end,\n    can_use = function(self, card)\n        if G.hand and G.GAME.blind.in_blind then\n            return true\n        else\n            return false\n        end\n    end,"
    },
    {
      "type": "Consumable",
      "key": "comet",
      "atlas": "gb_Ephemerals",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"comet\",\n    set = \"Ephemeral\",\n    loc_txt = {\n        name = 'Comet',\n        text = {\n            \"Adds {C:attention}#1#{} {C:dark_edition}Temporary{} cards\",\n            \"with {C:blue}Blue Seals{} to hand\",\n        }\n    },\n    config = {extra = { cards_to_create = 2 }},\n    atlas = 'gb_Ephemerals',\n    pos = { x = 3, y = 1 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.cards_to_create } }\n    end,\n    use = function(self, card, area, copier)\n        for k = 1, self.config.extra.cards_to_create do\n            local playing_card = SMODS.create_card {\n                set = \"Base\",\n                seal = \"Blue\",\n                edition = \"e_gb_temporary\",\n                area = G.discard\n            }\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                    playing_card.playing_card = G.playing_card\n                    playing_card:start_materialize({ G.C.SECONDARY_SET.Enhanced })\n                    G.hand:emplace(playing_card)\n                    SMODS.debuff_card(playing_card, \"prevent_debuff\", \"source\")\n                    return true\n                end\n            }))\n        end\n    end,\n    can_use = function(self, card)\n        if G.hand and G.GAME.blind.in_blind then\n            return true\n        else\n            return false\n        end\n    end,"
    },
    {
      "type": "Consumable",
      "key": "diffusion",
      "atlas": "gb_Ephemerals",
      "pos": {
        "x": 6,
        "y": 1
      },
      "raw": "key = \"diffusion\",\n    set = \"Ephemeral\",\n    loc_txt = {\n        name = 'Diffusion',\n        text = {\n            \"Adds {C:dark_edition}Temporary{} copies\",\n            \"of {C:green}#1# in #2#{} cards\",\n            \"in hand to hand\",\n        }\n    },\n    config = {extra = { odds = 2 } },\n    atlas = 'gb_Ephemerals',\n    pos = { x = 6, y = 1 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { G.GAME.probabilities.normal or 1, self.config.extra.odds } }\n    end,\n    use = function(self, card, area, copier)\n        local eligible_cards = {}\n        for _, playing_card in ipairs(G.hand.cards) do\n            table.insert(eligible_cards, playing_card)\n        end\n        for _, v in ipairs(eligible_cards) do\n            if SMODS.pseudorandom_probability(blind, 'gb_mind', G.GAME.probabilities.normal, 2) then\n                G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                local copy_card = copy_card(v, nil, nil, G.playing_card)\n                copy_card.playing_card = G.playing_card\n                copy_card:add_to_deck()\n                G.deck.config.card_limit = G.deck.config.card_limit + 1\n                table.insert(G.playing_cards, copy_card)\n                copy_card:start_materialize({ G.C.SECONDARY_SET.Enhanced })\n                G.hand:emplace(copy_card)\n                copy_card:set_edition('e_gb_temporary', true, true)\n                SMODS.debuff_card(copy_card, \"prevent_debuff\", \"source\")\n            end\n        end\n    end,\n    can_use = function(self, card)\n        if G.hand and G.GAME.blind.in_blind then\n            return true\n        else\n            return false\n        end\n    end"
    },
    {
      "type": "Consumable",
      "key": "gold_dust",
      "atlas": "gb_Ephemerals",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"gold_dust\",\n    set = \"Ephemeral\",\n    loc_txt = {\n        name = 'Gold Dust',\n        text = {\n            \"Adds {C:attention}#1#{} {C:dark_edition}Temporary{}\",\n            \"{C:attention}Gold Cards{} to hand\",\n        }\n    },\n    config = {extra = { cards_to_create = 3 }},\n    atlas = 'gb_Ephemerals',\n    pos = { x = 2, y = 0 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.cards_to_create } }\n    end,\n    use = function(self, card, area, copier)\n        for k = 1, self.config.extra.cards_to_create do\n            local playing_card = SMODS.create_card {\n                set = \"Base\",\n                enhancement = \"m_gold\",\n                edition = \"e_gb_temporary\",\n                area = G.discard\n            }\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    playing_card:start_materialize({ G.C.SECONDARY_SET.Enhanced })\n                    G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                    playing_card.playing_card = G.playing_card\n                    G.hand:emplace(playing_card)\n                    SMODS.debuff_card(playing_card, \"prevent_debuff\", \"source\")\n                    return true\n                end\n            }))\n        end\n    end,\n    can_use = function(self, card)\n        if G.hand and G.GAME.blind.in_blind then\n            return true\n        else\n            return false\n        end\n    end,"
    },
    {
      "type": "Consumable",
      "key": "group",
      "atlas": "gb_Ephemerals",
      "pos": {
        "x": 7,
        "y": 0
      },
      "raw": "key = \"group\",\n    set = \"Ephemeral\",\n    loc_txt = {\n        name = 'Group',\n        text = {\n            \"Adds {C:attention}#1#{} {C:dark_edition}Temporary{}\",\n            \"same-suited cards to hand\",\n        }\n    },\n    config = {extra = { cards_to_create = 5 }},\n    atlas = 'gb_Ephemerals',\n    pos = { x = 7, y = 0 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.cards_to_create } }\n    end,\n    use = function(self, card, area, copier)\n        local suit = pseudorandom_element({\"S\", \"H\", \"C\", \"D\"}, pseudoseed(\"gb_collapse\"))\n        for k = 1, self.config.extra.cards_to_create do\n            local playing_card = SMODS.create_card {\n                suit = suit,\n                set = \"Base\",\n                edition = \"e_gb_temporary\",\n                area = G.discard\n            }\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    playing_card:start_materialize({ G.C.SECONDARY_SET.Enhanced })\n                    G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                    playing_card.playing_card = G.playing_card\n                    G.hand:emplace(playing_card)\n                    SMODS.debuff_card(playing_card, \"prevent_debuff\", \"source\")\n                    return true\n                end\n            }))\n        end\n    end,\n    can_use = function(self, card)\n        if G.hand and G.GAME.blind.in_blind then\n            return true\n        else\n            return false\n        end\n    end,"
    },
    {
      "type": "Consumable",
      "key": "harlequin",
      "atlas": "gb_Ephemerals",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "key = \"harlequin\",\n    set = \"Ephemeral\",\n    loc_txt = {\n        name = 'Harlequin',\n        text = {\n            \"Adds a {C:dark_edition}Temporary{}\",\n            \"{C:rare}Rare {C:attention}Joker{} to Jokers\",\n        }\n    },\n    config = {extra = { cards_to_create = 3 }},\n    atlas = 'gb_Ephemerals',\n    pos = { x = 2, y = 2 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.cards_to_create } }\n    end,\n    use = function(self, card, area, copier)\n        SMODS.add_card {\n            set = \"Joker\",\n            rarity = 'Rare',\n            edition = 'e_gb_temporary',\n            key_append = 'gb_harlequin'\n        }\n        G.GAME.joker_buffer = 0\n    end,\n    can_use = function(self, card)\n        if G.hand and G.GAME.blind.in_blind then\n            return true\n        else\n            return false\n        end\n    end,"
    },
    {
      "type": "Consumable",
      "key": "hourglass",
      "atlas": "gb_Ephemerals",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"hourglass\",\n    set = \"Ephemeral\",\n    loc_txt = {\n        name = 'Hourglass',\n        text = {\n            \"Adds {C:attention}#1#{} {C:dark_edition}Temporary{}\",\n            \"{C:attention}Glass Cards{} to hand\",\n        }\n    },\n    config = {extra = { cards_to_create = 3 }},\n    atlas = 'gb_Ephemerals',\n    pos = { x = 1, y = 0 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.cards_to_create } }\n    end,\n    use = function(self, card, area, copier)\n        for k = 1, self.config.extra.cards_to_create do\n            local playing_card = SMODS.create_card {\n                set = \"Base\",\n                enhancement = \"m_glass\",\n                edition = \"e_gb_temporary\",\n                area = G.discard\n            }\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    playing_card:start_materialize({ G.C.SECONDARY_SET.Enhanced })\n                    G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                    playing_card.playing_card = G.playing_card\n                    G.hand:emplace(playing_card)\n                    SMODS.debuff_card(playing_card, \"prevent_debuff\", \"source\")\n                    return true\n                end\n            }))\n        end\n    end,\n    can_use = function(self, card)\n        if G.hand and G.GAME.blind.in_blind then\n            return true\n        else\n            return false\n        end\n    end,"
    },
    {
      "type": "Consumable",
      "key": "incense",
      "atlas": "gb_Ephemerals",
      "pos": {
        "x": 7,
        "y": 1
      },
      "raw": "key = \"incense\",\n    set = \"Ephemeral\",\n    loc_txt = {\n        name = 'Incense',\n        text = {\n            \"{C:blue}+#1#{} hands for this blind\",\n        }\n    },\n    config = {extra = { hands = 2 }},\n    atlas = 'gb_Ephemerals',\n    pos = { x = 7, y = 1 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.hands } }\n    end,\n    use = function(self, card, area, copier)\n        ease_hands_played(self.config.extra.hands)\n    end,\n    can_use = function(self, card)\n        if G.hand and G.GAME.blind.in_blind then\n            return true\n        else\n            return false\n        end\n    end,"
    },
    {
      "type": "Consumable",
      "key": "magic",
      "atlas": "gb_Ephemerals",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"magic\",\n    set = \"Ephemeral\",\n    loc_txt = {\n        name = 'Magic',\n        text = {\n            \"Adds {C:attention}#1#{} {C:dark_edition}Temporary{}\",\n            \"{C:attention}Lucky Cards{} to hand\",\n        }\n    },\n    config = {extra = { cards_to_create = 3 }},\n    atlas = 'gb_Ephemerals',\n    pos = { x = 3, y = 0 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.cards_to_create } }\n    end,\n    use = function(self, card, area, copier)\n        for k = 1, self.config.extra.cards_to_create do\n            local playing_card = SMODS.create_card {\n                set = \"Base\",\n                enhancement = \"m_lucky\",\n                edition = \"e_gb_temporary\",\n                area = G.discard\n            }\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    playing_card:start_materialize({ G.C.SECONDARY_SET.Enhanced })\n                    G.hand:emplace(playing_card)\n                    playing_card.playing_card = G.playing_card\n                    G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                    playing_card.playing_card = G.playing_card\n                    SMODS.debuff_card(playing_card, \"prevent_debuff\", \"source\")\n                    return true\n                end\n            }))\n        end\n    end,\n    can_use = function(self, card)\n        if G.hand and G.GAME.blind.in_blind then\n            return true\n        else\n            return false\n        end\n    end,"
    },
    {
      "type": "Consumable",
      "key": "mirage",
      "atlas": "gb_Ephemerals",
      "pos": {
        "x": 5,
        "y": 1
      },
      "raw": "key = \"mirage\",\n    set = \"Ephemeral\",\n    loc_txt = {\n        name = 'Mirage',\n        text = {\n            \"Adds {C:attention}#1#{} {C:dark_edition}Temporary{} copies\",\n            \"of a random card in hand to hand\",\n        }\n    },\n    config = {extra = { cards_to_create = 3 }},\n    atlas = 'gb_Ephemerals',\n    pos = { x = 5, y = 1 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.cards_to_create } }\n    end,\n    use = function(self, card, area, copier)\n        local card_to_copy = pseudorandom_element(G.hand.cards, pseudoseed(\"gb_mirage\"))\n        for k = 1, self.config.extra.cards_to_create do\n            G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n            local copy_card = copy_card(card_to_copy, nil, nil, G.playing_card)\n            copy_card.playing_card = G.playing_card\n            copy_card:add_to_deck()\n            G.deck.config.card_limit = G.deck.config.card_limit + 1\n            table.insert(G.playing_cards, copy_card)\n            copy_card:start_materialize({ G.C.SECONDARY_SET.Enhanced })\n            G.hand:emplace(copy_card)\n            copy_card:set_edition('e_gb_temporary', true, true)\n            SMODS.debuff_card(copy_card, \"prevent_debuff\", \"source\")\n        end\n    end,\n    can_use = function(self, card)\n        if G.hand and G.GAME.blind.in_blind then\n            return true\n        else\n            return false\n        end\n    end,"
    },
    {
      "type": "Consumable",
      "key": "motley",
      "atlas": "gb_Ephemerals",
      "pos": {
        "x": 3,
        "y": 2
      },
      "raw": "key = \"motley\",\n    set = \"Ephemeral\",\n    loc_txt = {\n        name = 'Motley',\n        text = {\n            \"Adds {C:attention}#1#{} {C:dark_edition}Temporary{}\",\n            \"{C:common}Common {C:attention}Jokers{} to Jokers\",\n        }\n    },\n    config = {extra = { cards_to_create = 3 }},\n    atlas = 'gb_Ephemerals',\n    pos = { x = 3, y = 2 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.cards_to_create } }\n    end,\n    use = function(self, card, area, copier)\n        for k = 1, self.config.extra.cards_to_create do\n            local playing_card = SMODS.add_card {\n                set = \"Joker\",\n                rarity = 'Common',\n                edition = 'e_gb_temporary',\n                key_append = 'gb_motley'\n            }\n            G.GAME.joker_buffer = 0\n        end\n    end,\n    can_use = function(self, card)\n        if G.hand and G.GAME.blind.in_blind then\n            return true\n        else\n            return false\n        end\n    end,"
    },
    {
      "type": "Consumable",
      "key": "plasma",
      "atlas": "gb_Ephemerals",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"plasma\",\n    set = \"Ephemeral\",\n    loc_txt = {\n        name = 'Plasma',\n        text = {\n            \"Adds {C:attention}#1#{} {C:dark_edition}Temporary{} cards\",\n            \"with {C:purple}Purple Seals{} to hand\",\n        }\n    },\n    config = {extra = { cards_to_create = 2 }},\n    atlas = 'gb_Ephemerals',\n    pos = { x = 2, y = 1 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.cards_to_create } }\n    end,\n    use = function(self, card, area, copier)\n        for k = 1, self.config.extra.cards_to_create do\n            local playing_card = SMODS.create_card {\n                set = \"Base\",\n                seal = \"Purple\",\n                edition = \"e_gb_temporary\",\n                area = G.discard\n            }\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    playing_card:start_materialize({ G.C.SECONDARY_SET.Enhanced })\n                    G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                    playing_card.playing_card = G.playing_card\n                    G.hand:emplace(playing_card)\n                    SMODS.debuff_card(playing_card, \"prevent_debuff\", \"source\")\n                    return true\n                end\n            }))\n        end\n    end,\n    can_use = function(self, card)\n        if G.hand and G.GAME.blind.in_blind then\n            return true\n        else\n            return false\n        end\n    end,"
    },
    {
      "type": "Consumable",
      "key": "portal",
      "atlas": "gb_Ephemerals",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"portal\",\n    set = \"Ephemeral\",\n    loc_txt = {\n        name = 'Portal',\n        text = {\n            \"Adds {C:attention}#1#{} {C:dark_edition}Temporary{}\",\n            \"same-suited {C:attention}numbered{} cards to hand\",\n        }\n    },\n    config = {extra = { cards_to_create = 4 }},\n    atlas = 'gb_Ephemerals',\n    pos = { x = 1, y = 1 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.cards_to_create } }\n    end,\n    use = function(self, card, area, copier)\n        local suit = pseudorandom_element({\"S\", \"H\", \"C\", \"D\"}, pseudoseed(\"gb_collapse\"))\n        for k = 1, self.config.extra.cards_to_create do\n            local playing_card = SMODS.create_card {\n                set = \"Base\",\n                suit = suit,\n                edition = \"e_gb_temporary\",\n                rank = pseudorandom_element(\n                    {\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"T\"},\n                    pseudoseed(\"gb_portal\")\n                ),\n                area = G.discard\n            }\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    playing_card:start_materialize({ G.C.SECONDARY_SET.Enhanced })\n                    G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                    playing_card.playing_card = G.playing_card\n                    G.hand:emplace(playing_card)\n                    SMODS.debuff_card(playing_card, \"prevent_debuff\", \"source\")\n                    return true\n                end\n            }))\n        end\n    end,\n    can_use = function(self, card)\n        if G.hand and G.GAME.blind.in_blind then\n            return true\n        else\n            return false\n        end\n    end,"
    },
    {
      "type": "Consumable",
      "key": "rust",
      "atlas": "gb_Ephemerals",
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "key = \"rust\",\n    set = \"Ephemeral\",\n    loc_txt = {\n        name = 'Rust',\n        text = {\n            \"Adds {C:attention}#1#{} {C:dark_edition}Temporary{}\",\n            \"{C:attention}Steel Cards{} to hand\",\n        }\n    },\n    config = {extra = { cards_to_create = 3 }},\n    atlas = 'gb_Ephemerals',\n    pos = { x = 4, y = 0 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.cards_to_create } }\n    end,\n    use = function(self, card, area, copier)\n        for k = 1, self.config.extra.cards_to_create do\n            local playing_card = SMODS.create_card {\n                set = \"Base\",\n                enhancement = \"m_steel\",\n                edition = \"e_gb_temporary\",\n                area = G.discard\n            }\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    playing_card:start_materialize({ G.C.SECONDARY_SET.Enhanced })\n                    G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                    playing_card.playing_card = G.playing_card\n                    G.hand:emplace(playing_card)\n                    SMODS.debuff_card(playing_card, \"prevent_debuff\", \"source\")\n                    return true\n                end\n            }))\n        end\n    end,\n    can_use = function(self, card)\n        if G.hand and G.GAME.blind.in_blind then\n            return true\n        else\n            return false\n        end\n    end,"
    },
    {
      "type": "Consumable",
      "key": "sculpture",
      "atlas": "gb_Ephemerals",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"sculpture\",\n    set = \"Ephemeral\",\n    loc_txt = {\n        name = 'Sculpture',\n        text = {\n            \"Adds {C:attention}#1#{} {C:dark_edition}Temporary{}\",\n            \"{C:attention}Stone Cards{} to hand\",\n        }\n    },\n    config = {extra = { cards_to_create = 5 }},\n    atlas = 'gb_Ephemerals',\n    pos = { x = 0, y = 0 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.cards_to_create } }\n    end,\n    use = function(self, card, area, copier)\n        for k = 1, self.config.extra.cards_to_create do\n            local playing_card = SMODS.create_card {\n                set = \"Base\",\n                enhancement = \"m_stone\",\n                edition = \"e_gb_temporary\",\n                area = G.discard\n            }\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    playing_card:start_materialize({ G.C.SECONDARY_SET.Enhanced })\n                    G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                    playing_card.playing_card = G.playing_card\n                    G.hand:emplace(playing_card)\n                    SMODS.debuff_card(playing_card, \"prevent_debuff\", \"source\")\n                    return true\n                end\n            }))\n        end\n    end,\n    can_use = function(self, card)\n        if G.hand and G.GAME.blind.in_blind then\n            return true\n        else\n            return false\n        end\n    end,"
    },
    {
      "type": "Consumable",
      "key": "spark",
      "atlas": "gb_Ephemerals",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "key = \"spark\",\n    set = \"Ephemeral\",\n    loc_txt = {\n        name = 'Spark',\n        text = {\n            \"Adds {C:attention}20%{} of blind\",\n            \"requirement to current score\",\n        }\n    },\n    atlas = 'gb_Ephemerals',\n    pos = { x = 1, y = 2 },\n    use = function(self, card, area, copier)\n        G.GAME.chips = G.GAME.chips + (G.GAME.blind.chips * 0.2)\n    end,\n    can_use = function(self, card)\n        if G.hand and G.GAME.blind.in_blind then\n            return true\n        else\n            return false\n        end\n    end"
    },
    {
      "type": "Consumable",
      "key": "spirit",
      "atlas": "gb_Ephemerals",
      "pos": {
        "x": 5,
        "y": 0
      },
      "raw": "key = \"spirit\",\n    set = \"Ephemeral\",\n    loc_txt = {\n        name = 'Spirit',\n        text = {\n            \"Adds {C:attention}#1#{} {C:dark_edition}Temporary{}\",\n            \"same-suited {C:attention}Face{} cards to hand\",\n        }\n    },\n    config = {extra = { cards_to_create = 3 }},\n    atlas = 'gb_Ephemerals',\n    pos = { x = 5, y = 0 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.cards_to_create } }\n    end,\n    use = function(self, card, area, copier)\n        local suit = pseudorandom_element({\"S\", \"H\", \"C\", \"D\"}, pseudoseed(\"gb_collapse\"))\n        for k = 1, self.config.extra.cards_to_create do\n            local playing_card = SMODS.create_card {\n                set = \"Base\",\n                suit = suit,\n                edition = \"e_gb_temporary\",\n                rank = pseudorandom_element(\n                    {\"K\", \"Q\", \"J\"},\n                    pseudoseed(\"gb_spirit\")\n                ),\n                area = G.discard\n            }\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    playing_card:start_materialize({ G.C.SECONDARY_SET.Enhanced })\n                    G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                    playing_card.playing_card = G.playing_card\n                    G.hand:emplace(playing_card)\n                    SMODS.debuff_card(playing_card, \"prevent_debuff\", \"source\")\n                    return true\n                end\n            }))\n        end\n    end,\n    can_use = function(self, card)\n        if G.hand and G.GAME.blind.in_blind then\n            return true\n        else\n            return false\n        end\n    end,"
    },
    {
      "type": "Consumable",
      "key": "vanish",
      "atlas": "gb_Ephemerals",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = \"vanish\",\n    set = \"Ephemeral\",\n    loc_txt = {\n        name = 'Vanish',\n        text = {\n            \"{C:red}+#1#{} discards for this blind\",\n        }\n    },\n    config = {extra = { discards = 2 }},\n    atlas = 'gb_Ephemerals',\n    pos = { x = 0, y = 2 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.discards } }\n    end,\n    use = function(self, card, area, copier)\n        ease_discard(self.config.extra.discards)\n    end,\n    can_use = function(self, card)\n        if G.hand and G.GAME.blind.in_blind then\n            return true\n        else\n            return false\n        end\n    end,"
    },
    {
      "type": "Consumable",
      "key": "wish",
      "atlas": "gb_Ephemerals",
      "pos": {
        "x": 4,
        "y": 1
      },
      "raw": "key = \"wish\",\n    set = \"Ephemeral\",\n    loc_txt = {\n        name = 'Wish',\n        text = {\n            \"Adds {C:attention}#1#{} {C:dark_edition}Temporary{} cards\",\n            \"with {C:money}Gold Seals{} to hand\",\n        }\n    },\n    config = {extra = { cards_to_create = 3 }},\n    atlas = 'gb_Ephemerals',\n    pos = { x = 4, y = 1 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.cards_to_create } }\n    end,\n    use = function(self, card, area, copier)\n        for k = 1, self.config.extra.cards_to_create do\n            local playing_card = SMODS.create_card {\n                set = \"Base\",\n                seal = \"Gold\",\n                edition = \"e_gb_temporary\",\n                area = G.discard\n            }\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    playing_card:start_materialize({ G.C.SECONDARY_SET.Enhanced })\n                    G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                    playing_card.playing_card = G.playing_card\n                    G.hand:emplace(playing_card)\n                    SMODS.debuff_card(playing_card, \"prevent_debuff\", \"source\")\n                    return true\n                end\n            }))\n        end\n    end,\n    can_use = function(self, card)\n        if G.hand and G.GAME.blind.in_blind then\n            return true\n        else\n            return false\n        end\n    end,"
    },
    {
      "type": "Consumable",
      "key": "dualism",
      "atlas": "gb_Consumables",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = 'dualism',\n    loc_txt = {\n        name = \"Dualism\",\n        text = {\n            \"Add a {V:1}Dual Seal{}\",\n            \"to {C:attention}1{} selected\",\n            \"card in your hand\",\n        },\n    },\n    set = 'Spectral',\n    atlas = 'gb_Consumables',\n    pos = { x = 2, y = 1 },\n    config = { extra = { seal = 'gb_dual' }, max_highlighted = 1 },\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue + 1] = G.P_SEALS[card.ability.extra.seal]\n        return { vars = { card.ability.max_highlighted, colours = { HEX(\"6E89C2\") } } }\n    end,\n    use = function(self, card, area, copier)\n        local conv_card = G.hand.highlighted[1]\n        G.E_MANAGER:add_event(Event({\n            func = function()\n                play_sound('tarot1')\n                card:juice_up(0.3, 0.5)\n                return true\n            end\n        }))\n\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.1,\n            func = function()\n                conv_card:set_seal(card.ability.extra.seal, nil, true)\n                return true\n            end\n        }))\n\n        delay(0.5)\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.2,\n            func = function()\n                G.hand:unhighlight_all()\n                return true\n            end\n        }))\n    end"
    },
    {
      "type": "Consumable",
      "key": "gambit",
      "atlas": "gb_Consumables",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = 'gambit',\n    loc_txt = {\n        name = \"Gambit\",\n        text = {\n            \"Add a {V:1}Fortune Seal{}\",\n            \"to {C:attention}1{} selected\",\n            \"card in your hand\",\n        },\n    },\n    set = 'Spectral',\n    atlas = 'gb_Consumables',\n    pos = { x = 1, y = 1 },\n    config = { extra = { seal = 'gb_fortune' }, max_highlighted = 1 },\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue + 1] = G.P_SEALS[card.ability.extra.seal]\n        return { vars = { card.ability.max_highlighted, colours = { HEX(\"CAB785\") } } }\n    end,\n    use = function(self, card, area, copier)\n        local conv_card = G.hand.highlighted[1]\n        G.E_MANAGER:add_event(Event({\n            func = function()\n                play_sound('tarot1')\n                card:juice_up(0.3, 0.5)\n                return true\n            end\n        }))\n\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.1,\n            func = function()\n                conv_card:set_seal(card.ability.extra.seal, nil, true)\n                return true\n            end\n        }))\n\n        delay(0.5)\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.2,\n            func = function()\n                G.hand:unhighlight_all()\n                return true\n            end\n        }))\n    end"
    },
    {
      "type": "Consumable",
      "key": "lotus",
      "atlas": "gb_Consumables",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = 'lotus',\n    loc_txt = {\n        name = \"Lotus\",\n        text = {\n            \"Add an {V:1}Infinite Seal{}\",\n            \"to {C:attention}1{} selected\",\n            \"card in your hand\",\n        },\n    },\n    set = 'Spectral',\n    atlas = 'gb_Consumables',\n    pos = { x = 0, y = 1 },\n    config = { extra = { seal = 'gb_infinite' }, max_highlighted = 1 },\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue + 1] = G.P_SEALS[card.ability.extra.seal]\n        return { vars = { card.ability.max_highlighted, colours = { HEX(\"A1A5A6\") } } }\n    end,\n    use = function(self, card, area, copier)\n        local conv_card = G.hand.highlighted[1]\n        G.E_MANAGER:add_event(Event({\n            func = function()\n                play_sound('tarot1')\n                card:juice_up(0.3, 0.5)\n                return true\n            end\n        }))\n\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.1,\n            func = function()\n                conv_card:set_seal(card.ability.extra.seal, nil, true)\n                return true\n            end\n        }))\n\n        delay(0.5)\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.2,\n            func = function()\n                G.hand:unhighlight_all()\n                return true\n            end\n        }))\n    end"
    },
    {
      "type": "Consumable",
      "key": "shatter",
      "atlas": "gb_Consumables",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"shatter\",\n    set = \"Spectral\",\n    loc_txt = {\n        name = 'Shatter',\n        text = {\n            \"{C:attention}Shatters{} one random\",\n            \"{C:attention}eligible{} Joker\",\n        }\n    },\n    hidden = true,\n    soul_set = \"Tarot\",\n    soul_rate = 0.04,\n    atlas = 'gb_Consumables',\n    pos = { x = 0, y = 0 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { colours = { HEX(\"6A4C77\") } } }\n    end,\n    can_use = function(self, card)\n        -- Check if the player has any eligible jokers to shatter\n        for i, joker in ipairs(G.jokers.cards) do\n            for i = 1, #GB.G.SHATTERED_TABLE do\n                if GB.G.SHATTERED_TABLE[i][1] == joker.config.center.key then\n                    return true\n                end\n            end\n        end\n        return false\n    end,\n    use = function(self, card, area, copier)\n        local eligible_jokers = {}\n        -- Check currently owned Jokers for eligibility\n        for i, joker in ipairs(G.jokers.cards) do\n            for i = 1, #GB.G.SHATTERED_TABLE do\n                if GB.G.SHATTERED_TABLE[i][1] == joker.config.center.key and not joker.ability.eternal then\n                    table.insert(eligible_jokers, GB.G.SHATTERED_TABLE[i][1])\n                end\n            end\n        end\n        -- Randomly select a joker to shatter\n        local outgoing_joker_key = eligible_jokers[math.random(#eligible_jokers)]\n        local outgoing_joker = SMODS.find_card(outgoing_joker_key)[1]\n        -- Find the corresponding shattered joker\n        for i = 1, #GB.G.SHATTERED_TABLE do\n            if GB.G.SHATTERED_TABLE[i][1] == outgoing_joker_key then\n                local incoming_joker_key = GB.G.SHATTERED_TABLE[i][2]\n                -- Remove the original joker and add the shattered one\n                G.E_MANAGER:add_event(Event({\n                trigger = 'after',\n                delay = 0.4,\n                func = function()\n                    attention_text({\n                        text = \"Shatter!\",\n                        scale = 1.3,\n                        hold = 1.4,\n                        major = card,\n                        backdrop_colour = HEX(\"673E79\"),\n                        align = (G.STATE == G.STATES.TAROT_PACK or G.STATE == G.STATES.SPECTRAL_PACK or G.STATE == G.STATES.SMODS_BOOSTER_OPENED) and\n                            'tm' or 'cm',\n                        offset = { x = 0, y = (G.STATE == G.STATES.TAROT_PACK or G.STATE == G.STATES.SPECTRAL_PACK or G.STATE == G.STATES.SMODS_BOOSTER_OPENED) and -0.2 or 0 },\n                        silent = true\n                    })\n                    G.E_MANAGER:add_event(Event({\n                        trigger = 'after',\n                        delay = 0.15 * G.SETTINGS.GAMESPEED,\n                        blockable = false,\n                        blocking = false,\n                        func = function()\n                        outgoing_joker:start_dissolve()\n                        SMODS.add_card{\n                        set = 'Joker',\n                        key = incoming_joker_key,\n                        no_edition = true\n                        }\n                        return true\n                        end\n                    }))\n                    card:juice_up(0.3, 0.5)\n                    return true\n                end\n                }))\n                break\n            end\n        end\n    end,\n    in_pool = function(self, args)\n        local eligible_jokers = {}\n        -- Check currently owned Jokers for eligibility\n        for i, joker in ipairs(G.jokers.cards) do\n            for i = 1, #GB.G.SHATTERED_TABLE do\n                if GB.G.SHATTERED_TABLE[i][1] == joker.config.center.key and not joker.ability.eternal then\n                    table.insert(eligible_jokers, GB.G.SHATTERED_TABLE[i][1])\n                end\n            end\n        end\n        if #eligible_jokers > 0 then\n            return true\n        else\n            return false\n        end\n    end"
    },
    {
      "type": "Consumable",
      "key": "life",
      "atlas": "gb_Consumables",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = 'life',\n    set = 'Tarot',\n    atlas = \"gb_Consumables\",\n    pos = { x = 2, y = 0 },\n    config = { max_highlighted = 1, mod_conv = 'm_gb_wooden' },\n    loc_txt = {\n        name = \"Life\",\n        text = {\n            \"Enhances {C:attention}#1#{}\",\n            \"selected card to a\",\n            \"{C:attention}#2#\",\n        },\n    },\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue + 1] = G.P_CENTERS[card.ability.mod_conv]\n        return { vars = { card.ability.max_highlighted, localize { type = 'name_text', set = 'Enhanced', key = card.ability.mod_conv } } }\n    end"
    },
    {
      "type": "Consumable",
      "key": "panacea",
      "atlas": "gb_Consumables",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = 'panacea',\n    set = 'Tarot',\n    atlas = \"gb_Consumables\",\n    pos = { x = 3, y = 0 },\n    config = { max_highlighted = 2, mod_conv = 'm_gb_honey' },\n    loc_txt = {\n        name = \"The Panacea\",\n        text = {\n            \"Enhances {C:attention}#1#{}\",\n            \"selected cards to\",\n            \"{C:attention}#2#s\",\n        },\n    },\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue + 1] = G.P_CENTERS[card.ability.mod_conv]\n        return { vars = { card.ability.max_highlighted, localize { type = 'name_text', set = 'Enhanced', key = card.ability.mod_conv } } }\n    end"
    },
    {
      "type": "Consumable",
      "key": "river",
      "atlas": "gb_Consumables",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = 'river',\n    set = 'Tarot',\n    atlas = \"gb_Consumables\",\n    pos = { x = 1, y = 0 },\n    loc_txt = {\n        name = \"The River\",\n        text = {\n            \"Enhances {C:attention}#1#{}\",\n            \"selected cards to\",\n            \"{C:attention}#2#s\",\n        },\n    },\n    config = { max_highlighted = 2, mod_conv = 'm_gb_river' },\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue + 1] = G.P_CENTERS[card.ability.mod_conv]\n        return { vars = { card.ability.max_highlighted, localize { type = 'name_text', set = 'Enhanced', key = card.ability.mod_conv } } }\n    end"
    },
    {
      "type": "Back",
      "key": "enhanced",
      "atlas": "gb_Cards",
      "pos": {
        "x": 5,
        "y": 0
      },
      "raw": "key = \"enhanced\",\n    loc_txt = {\n        name = \"Enhanced Deck\",\n        text = {\n            \"When {C:attention}Blind{} is selected,\",\n            \"enhance up to {C:attention}#1#{}\",\n            \"random cards in full deck\",\n            \"{C:red}X#2#{} base Blind size\"\n        }\n    },\n    atlas = \"gb_Cards\",\n    pos = { x = 5, y = 0 },\n    config = { extra = { enhancements = 2, ante_scaling = 1.5 } },\n    loc_vars = function(self, info_queue, back)\n        return { vars = { self.config.extra.enhancements, self.config.extra.ante_scaling } }\n    end,\n    calculate = function(self, back, context)\n        if context.setting_blind then\n            local valid_keys = {}\n            for _, enhancement_center in pairs(G.P_CENTER_POOLS[\"Enhanced\"]) do\n                if enhancement_center.key ~= {\n                    'm_stone',\n                    'm_gb_honey'\n                    }\n                    and not enhancement_center.overrides_base_rank then\n                    valid_keys[#valid_keys + 1] = enhancement_center.key\n                end\n            end\n            for i = 1, self.config.extra.enhancements do\n                local unenhanced_cards = {}\n                for _, playing_card in ipairs(G.playing_cards) do\n                    if not next(SMODS.get_enhancements(playing_card)) then\n                        table.insert(unenhanced_cards, playing_card)\n                    end\n                end\n                local card_to_enhance = pseudorandom_element(unenhanced_cards, pseudoseed(\"gb_enhanced\"))\n                if card_to_enhance then\n                    card_to_enhance:set_ability(pseudorandom_element(valid_keys, pseudoseed('gb_enhanced')), nil, nil)\n                end\n            end\n        end\n    end,\n    apply = function(self, back)\n        G.GAME.starting_params.ante_scaling = self.config.extra.ante_scaling\n    end,"
    },
    {
      "type": "Back",
      "key": "gem",
      "atlas": "gb_Cards",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"gem\",\r\n    loc_txt = {\r\n        name = \"Gem Deck\",\r\n        text = {\r\n            \"Start with an extra {C:money}$#1#{}\",\r\n            \"and {C:money,T:v_clearance_sale}Clearance Sale{}\",\r\n            \"{s:0.85,C:inactive}Thank you to @squidguset\",\r\n            \"{s:0.85,C:inactive} for the deck effect!\",\r\n\r\n        }\r\n    },\r\n    atlas = \"gb_Cards\",\r\n    pos = { x = 1, y = 0 },\r\n    config = { dollars = 5, voucher = 'v_clearance_sale' },\r\n    loc_vars = function(self, info_queue, back)\r\n        return { vars = { self.config.dollars } }\r\n    end"
    },
    {
      "type": "Back",
      "key": "mathematical",
      "atlas": "gb_Cards",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"mathematical\",\r\n    loc_txt = {\r\n        name = \"Mathematical Deck\",\r\n        text = {\r\n            \"Swap {C:chips}Chips{} and {C:mult}Mult{} before scoring\",\r\n            \"{C:red}X#1#{} base Blind size\",\r\n        }\r\n    },\r\n    atlas = \"gb_Cards\",\r\n    pos = { x = 0, y = 0 },\r\n    config = { extra = { ante_scaling = 2 } },\r\n    loc_vars = function(self, info_queue, back)\r\n        return { vars = { self.config.extra.ante_scaling } }\r\n    end,\r\n    calculate = function(self, back, context)\r\n        if context.modify_hand then\r\n            local temp = mult\r\n            mult = hand_chips\r\n            hand_chips = temp\r\n            update_hand_text({delay = 0}, {chips = hand_chips, mult = mult})\r\n            G.E_MANAGER:add_event(Event({\r\n                func = function()\r\n                    play_sound('gong', 0.94, 0.3)\r\n                    play_sound('gong', 0.94*1.5, 0.2)\r\n                    play_sound('tarot1', 1.5)\r\n                    return true\r\n                end\r\n            }))\r\n        delay(0.6)\r\n        end\r\n    end,\r\n    apply = function(self, back)\r\n        G.GAME.starting_params.ante_scaling = self.config.extra.ante_scaling\r\n    end,"
    },
    {
      "type": "Back",
      "key": "modulo",
      "atlas": "gb_Cards",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"modulo\",\n    loc_txt = {\n        name = \"Modulo Deck\",\n        text = {\n            \"Start with two of every\",\n            \"odd {C:clubs}Club{} and {C:diamonds}Diamond{}\",\n            \"and two of every\",\n            \"even {C:spades}Spade{} and {C:hearts}Heart{}\",\n        }\n    },\n    atlas = \"gb_Cards\",\n    pos = { x = 0, y = 1 },\n    apply = function(self, back)\n        G.E_MANAGER:add_event(Event({\n            func = function()\n                local cards_to_remove = {}\n                for _, playing_card in ipairs(G.playing_cards) do\n                    if playing_card:is_suit('Clubs')\n                        or playing_card:is_suit('Diamonds') then\n                        if not (\n                           playing_card:get_id() == 3 \n                           or playing_card:get_id() == 5\n                           or playing_card:get_id() == 7\n                           or playing_card:get_id() == 9\n                           or playing_card:get_id() == 14\n                        ) then\n                            table.insert(cards_to_remove, playing_card)\n                        end\n                    elseif playing_card:is_suit('Hearts')\n                        or playing_card:is_suit('Spades') then\n                        if not (\n                           playing_card:get_id() == 2\n                           or playing_card:get_id() == 4\n                           or playing_card:get_id() == 6\n                           or playing_card:get_id() == 8\n                           or playing_card:get_id() == 10\n                        ) then\n                            table.insert(cards_to_remove, playing_card)\n                        end\n                    else\n                        table.insert(cards_to_remove, playing_card)\n                    end\n                end\n                for _, card_to_remove in ipairs(cards_to_remove) do\n                    card_to_remove:remove()\n                end\n                local cards_to_add = {}\n                for _, dupe_card in ipairs(G.playing_cards) do\n                    G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                    local _card = copy_card(dupe_card, nil, nil, G.playing_card)\n                    table.insert(cards_to_add, _card)\n                end\n                for _, card_to_add in ipairs(cards_to_add) do\n                    card_to_add:add_to_deck()\n                    G.deck.config.card_limit = G.deck.config.card_limit + 1\n                    table.insert(G.playing_cards, card_to_add)\n                    G.deck:emplace(card_to_add)\n                end\n                G.GAME.starting_deck_size = 40\n                return true\n            end\n        }))\n    end"
    },
    {
      "type": "Back",
      "key": "negative",
      "atlas": "gb_Cards",
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "key = \"negative\",\r\n    atlas = \"gb_Cards\",\r\n    pos = { x = 4, y = 0 },\r\n    loc_txt = {\r\n        name = \"Negative Deck\",\r\n        text = {\r\n            \"After defeating each\",\r\n            \"{C:attention}Boss Blind{}, gain a\",\r\n            \"{C:attention,T:tag_negative}#1#\",\r\n            \"{C:red}#2#{} Joker slots\",\r\n        },\r\n    },\r\n    config = { extra = { joker_slot = -2 } },\r\n    loc_vars = function(self, info_queue, back)\r\n        return { vars = { localize { type = 'name_text', key = 'tag_negative', set = 'Tag' }, self.config.extra.joker_slot }}\r\n    end,\r\n    apply = function(self, back)\r\n        G.GAME.starting_params.joker_slots = G.GAME.starting_params.joker_slots + self.config.extra.joker_slot\r\n    end,\r\n    calculate = function(self, back, context)\r\n        if context.context == 'eval' and G.GAME.last_blind and G.GAME.last_blind.boss then\r\n            G.E_MANAGER:add_event(Event({\r\n                func = function()\r\n                    add_tag(Tag('tag_negative'))\r\n                    play_sound('generic1', 0.9 + math.random() * 0.1, 0.8)\r\n                    play_sound('holo1', 1.2 + math.random() * 0.1, 0.4)\r\n                    return true\r\n                end\r\n            }))\r\n        end\r\n    end"
    },
    {
      "type": "DrawStep",
      "key": "negative_deck",
      "atlas": null,
      "pos": null,
      "raw": "key = \"negative_deck\",\r\n    order = 5,\r\n    func = function(self)\r\n        if self.area and self.area.config and self.area.config.type == \"deck\" then\r\n            -- following here is a horrendous mod compatability line\r\n            local currentBack = not self.params.galdur_selector\r\n                    and ((Galdur and Galdur.config.use and type(self.params.galdur_back) == \"table\" and self.params.galdur_back) or type(\r\n                        self.params.viewed_back\r\n                    ) == \"table\" and self.params.viewed_back or (self.params.viewed_back and G.GAME.viewed_back or G.GAME.selected_back))\r\n                or Back(G.P_CENTERS[\"b_red\"])\r\n            if currentBack.effect.center.key == 'b_gb_negative' then\r\n                self.children.back:draw_shader(\r\n                    'negative',\r\n                    nil,\r\n                    self.ARGS.send_to_shader,\r\n                    true\r\n                )\r\n                self.children.back:draw_shader(\r\n                    'negative_shine',\r\n                    nil,\r\n                    self.ARGS.send_to_shader,\r\n                    true\r\n                )\r\n            end\r\n        end\r\n    end"
    },
    {
      "type": "Back",
      "key": "tech",
      "atlas": "gb_Cards",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"tech\",\r\n    atlas = \"gb_Cards\",\r\n    pos = { x = 3, y = 0 },\r\n    loc_txt = {\r\n        name = \"Tech Deck\",\r\n        text = {\r\n            \"{C:attention}+#1#{} Joker slots\",\r\n            \"Win on {C:attention}Ante #2#{}\",\r\n        },\r\n    },\r\n    config = { extra = { joker_slot = 2, ante = 10 } },\r\n      loc_vars = function(self, info_queue, card)\r\n        return { vars = { self.config.extra.joker_slot, self.config.extra.ante } }\r\n    end,\r\n    apply = function(self, back)\r\n        G.GAME.starting_params.joker_slots = G.GAME.starting_params.joker_slots + self.config.extra.joker_slot\r\n        G.GAME.win_ante = self.config.extra.ante\r\n    end"
    },
    {
      "type": "Back",
      "key": "waxen",
      "atlas": "gb_Cards",
      "pos": {
        "x": 6,
        "y": 0
      },
      "raw": "key = \"waxen\",\n    loc_txt = {\n        name = \"Waxen Deck\",\n        text = {\n            \"When {C:attention}Boss Blind{} is selected,\",\n            \"give {C:attention}#1#{} random cards\",\n            \"in hand random {C:attention}Seals{}\",\n            \"{C:red}X#2#{} base Blind size\"\n        }\n    },\n    atlas = \"gb_Cards\",\n    pos = { x = 6, y = 0 },\n    config = { extra = { seals = 2, ante_scaling = 1.5 } },\n    loc_vars = function(self, info_queue, back)\n        return { vars = { self.config.extra.seals, self.config.extra.ante_scaling } }\n    end,\n    calculate = function(self, back, context)\n        if context.first_hand_drawn and G.GAME.blind.boss then\n            local valid_keys = {}\n            for _, seal_center in pairs(G.P_CENTER_POOLS[\"Seal\"]) do\n                valid_keys[#valid_keys + 1] = seal_center.key\n            end\n            for i = 1, self.config.extra.seals do\n                local unsealed_cards = {}\n                for _, playing_card in ipairs(G.hand.cards) do\n                    if not playing_card.seal then\n                        table.insert(unsealed_cards, playing_card)\n                    end\n                end\n                local card_to_enhance = pseudorandom_element(unsealed_cards, pseudoseed(\"gb_waxen\"))\n                if card_to_enhance then\n                    card_to_enhance:set_seal(pseudorandom_element(valid_keys, pseudoseed(\"gb_waxen\")))\n                end\n            end\n        end\n    end,\n    apply = function(self, back)\n        G.GAME.starting_params.ante_scaling = self.config.extra.ante_scaling\n    end"
    },
    {
      "type": "Edition",
      "key": "temporary",
      "atlas": null,
      "pos": null,
      "raw": "key = 'temporary',\n    shader = 'voucher',\n    loc_txt = {\n        name = \"Temporary\",\n        text = {\n            \"{C:attention}Destroyed{} at end of round\",\n            \"Cannot be debuffed\",\n        },\n        label = \"Temporary\",\n    },\n    prefix_config = {\n        -- This allows using the vanilla shader\n        -- Not needed when using your own\n        shader = false\n    },\n    in_shop = false,\n    weight = 0,\n    extra_cost = 0,\n    sound = { sound = \"foil1\", per = 1.2, vol = 0.4 },\n    get_weight = function(self)\n        return 0\n    end,\n    calculate = function(self, card, context)\n        if context.end_of_round and not card.ability.getting_destroyed then\n            card.ability.getting_destroyed = true\n            G.E_MANAGER:add_event(Event({\n                trigger = 'after',\n                delay = 0.2,\n                blockable = false,\n                func = function()\n                    card:start_dissolve()\n                    return true\n                end\n            }))\n        end\n    end,\n    in_pool = function(self, args)\n        return false\n    end"
    },
    {
      "type": "Enhancement",
      "key": "honey",
      "atlas": "gb_Enhancements",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = 'honey',\r\n    loc_txt = {\r\n\t\tname = 'Honey Card',\r\n\t\ttext = {\r\n\t\t\t\"When drawn, {C:green}#1# in #2#{} chance\",\r\n            \"to draw another {C:attention}Honey Card{}\",\r\n\t\t}\r\n\t},\r\n    atlas = 'gb_Enhancements',\r\n    pos = { x = 2, y = 0 },\r\n    config = { extra = { odds = 2 } },\r\n    loc_vars = function(self, info_queue, card)\r\n        return { vars = { G.GAME.probabilities.normal or 1, card.ability.extra.odds } }\r\n    end,\r\n    calculate = function(self, card, context)\r\n        if context.hand_drawn then\r\n            for _, search_card in ipairs(context.hand_drawn) do\r\n                if search_card == card then\r\n                    if SMODS.pseudorandom_probability(card, 'gb_honey', G.GAME.probabilities.normal, card.ability.extra.odds) then\r\n                        local honey_cards = {}\r\n                        for _, playing_card in ipairs(G.deck.cards) do\r\n                            if SMODS.has_enhancement(playing_card, 'm_gb_honey')\r\n                            and not playing_card.ability.honey_drawn then\r\n                                honey_cards[#honey_cards + 1] = playing_card\r\n                            end\r\n                        end\r\n                        if honey_cards and #honey_cards > 0 then\r\n                            local chosen_card = pseudorandom_element(honey_cards, pseudoseed('gb_honey'))\r\n                            if chosen_card then\r\n                                chosen_card.ability.honey_drawn = true\r\n                                draw_card(G.deck, G.hand, 100, 'up', true, chosen_card)\r\n                                SMODS.calculate_context({hand_drawn = { chosen_card }})\r\n                            end\r\n                        end\r\n                    end\r\n                break\r\n                end\r\n            end\r\n        end\r\n        if context.end_of_round then\r\n            card.ability.already_drawn = nil\r\n        end\r\n    end"
    },
    {
      "type": "Enhancement",
      "key": "river",
      "atlas": "gb_Enhancements",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = 'river',\r\n    loc_txt = {\r\n\t\tname = 'River Card',\r\n\t\ttext = {\r\n\t\t\t\"Gains {C:chips}+#1#{} Chips\",\r\n\t\t\t\"when played\",\r\n\t\t}\r\n\t},\r\n    atlas = 'gb_Enhancements',\r\n    pos = { x = 0, y = 0 },\r\n    config = { bonus = 0, extra = { bonus_mod = 10 } },\r\n    loc_vars = function(self, info_queue, card)\r\n        return { vars = { card.ability.extra.bonus_mod } }\r\n    end,\r\n    calculate = function(self, card, context)    \r\n        if context.before and context.cardarea == G.play then\r\n            card.ability.bonus = card.ability.bonus + card.ability.extra.bonus_mod\r\n            return {\r\n                message = localize('k_upgrade_ex'),\r\n                colour = G.C.CHIPS,\r\n                message_card = card\r\n            }\r\n        end\r\n    end"
    },
    {
      "type": "Enhancement",
      "key": "wooden",
      "atlas": "gb_Enhancements",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = 'wooden',\r\n    loc_txt = {\r\n\t\tname = 'Wooden Card',\r\n\t\ttext = {\r\n\t\t\t\"{X:mult,C:white}X#1#{} Mult\",\r\n            \"Destroys card if\",\r\n            \"played hand causes\",\r\n            \"{C:attention}score to catch fire{}\",\r\n\t\t}\r\n\t},\r\n    atlas = 'gb_Enhancements',\r\n    pos = { x = 1, y = 0 },\r\n    config = { Xmult = 2 },\r\n    loc_vars = function(self, info_queue, card)\r\n        return { vars = { card.ability.Xmult } }\r\n    end,\r\n    calculate = function(self, card, context)\r\n        if context.destroy_card and context.cardarea == G.play and context.destroy_card == card and G.GAME.blind.chips <= hand_chips * mult then\r\n            return { remove = true }\r\n        end\r\n    end"
    },
    {
      "type": "Joker",
      "key": "alien_joker",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 1,
        "y": 5
      },
      "raw": "key = 'alien_joker',\n\tloc_txt = {\n\t\tname = 'Alien Joker',\n\t\ttext = {\n\t\t\t\"Upgrade played {C:attention}poker hand{}\",\n\t\t\t\"every {C:attention}#1#{}th hand played\",\n            \"{C:inactive}({C:attention}#2#{C:inactive}/#1#)\",\n\t\t}\n\t},\n\tconfig = { extra = { hand_tally = 0, hands = 5 } },\n\trarity = 1,\n\tatlas = 'gb_Jokers',\n\tpos = { x = 1, y = 5 },\n\tcost = 4,\n\tblueprint_compat = true,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.hands, card.ability.extra.hand_tally } }\n\tend,\n    calculate = function(self, card, context)\n        if context.before then\n            card.ability.extra.hand_tally = card.ability.extra.hand_tally + 1\n            if card.ability.extra.hand_tally >= card.ability.extra.hands then\n                card.ability.extra.hand_tally = 0\n                return {\n                    level_up = true,\n                    message = \"Zorp!\",\n                    colour = G.C.FILTER\n                }\n            else\n                return {\n                    message = card.ability.extra.hand_tally .. '/' .. card.ability.extra.hands,\n                    colour = G.C.FILTER\n                }\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "bad_trip",
      "atlas": "Jokers",
      "pos": {
        "x": 6,
        "y": 0
      },
      "raw": "key = \"bad_trip\",\n    loc_txt = {\n        name = 'Bad Trip',\n        text = {\n            \"{C:chips}+#1#{} Chips\",\n            \"{C:chips}#2#{} Chips for each unique\",\n            \"poker hand played this run\",\n            \"{C:inactive}(Currently {C:chips}+#3#{C:inactive} Chips)\"\n        }\n    },\n    blueprint_compat = true,\n    eternal_compat = false,\n    rarity = 1,\n    cost = 4,\n    atlas = 'Jokers',\n    pos = { x = 6, y = 0 },\n    config = { extra = { base_chips = 100, chips_mod = -10, chips = 100 } },\n    loc_vars = function(self, info_queue, card)\n        if G.GAME.hands then\n            local unique_poker_hands = {}\n            for k, v in pairs(G.GAME.hands) do\n                if v.played ~= 0 and v.visible then\n                    table.insert(unique_poker_hands, k)\n                end\n            end\n            return { vars = { card.ability.extra.base_chips, card.ability.extra.chips_mod, math.max(card.ability.extra.base_chips + (card.ability.extra.chips_mod * #unique_poker_hands), 0) } }\n        else\n            return { vars = { card.ability.extra.base_chips, card.ability.extra.chips_mod, card.ability.extra.base_chips } }\n        end\n        \n    end,\n    calculate = function(self, card, context)\n        if context.before and context.main_eval and not context.blueprint then\n            local unique_poker_hands = {}\n            for k, v in pairs(G.GAME.hands) do\n                if v.played ~= 0 and v.visible then\n                    table.insert(unique_poker_hands, k)\n                end\n            card.ability.extra.chips = math.max(card.ability.extra.base_chips + (card.ability.extra.chips_mod * #unique_poker_hands), 0)\n            end\n            if G.GAME.hands[context.scoring_name] == 1 then\n                return {\n                    message = \"Downgraded!\",\n                    colour = G.C.CHIPS,\n                }\n            end\n        end\n        if context.joker_main then\n            return {\n                chips = card.ability.extra.chips\n            }\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "bait",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 7,
        "y": 4
      },
      "raw": "key = 'bait',\n    loc_txt = {\n        name = 'Bait',\n        text = {\n            \"{C:mult}+#1#{} Mult\",\n            \"{C:green}#2# in #3#{} chance at end of round to\",\n            \"{C:attention}reel something in{}\",\n        }\n    },\n    config = { extra = { mult = 8, odds = 6 } },\n    rarity = 1,\n    eternal_compat = false,\n    atlas = 'gb_Jokers',\n    pos = { x = 7, y = 4 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.mult, G.GAME.probabilities.normal or 1, card.ability.extra.odds } }\n    end,\n    calculate = function(self, card, context)\n        if context.joker_main then\n            return {\n                mult = card.ability.extra.mult\n            } \n        end\n        if context.end_of_round and context.game_over == false and context.main_eval and not context.blueprint then\n            if SMODS.pseudorandom_probability(card, 'gb_bait', G.GAME.probabilities.normal, card.ability.extra.odds) then\n                SMODS.add_card{\n                    set = 'Joker',\n                    key = \"j_gb_hadal_zone\",\n                    no_edition = true\n                }\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        play_sound('tarot1')\n                        card.T.r = -0.2\n                        card:juice_up(0.3, 0.4)\n                        card.states.drag.is = true\n                        card.children.center.pinch.x = true\n                        G.E_MANAGER:add_event(Event({\n                            trigger = 'after',\n                            delay = 0.3,\n                            blockable = false,\n                            func = function()\n                                card:remove()\n                                return true\n                            end\n                        }))\n                        return true\n                    end\n                }))            \n                return {\n                    message = 'Caught!',\n                    colour = G.C.FILTER\n                }\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "bold_and_brash",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 2,
        "y": 5
      },
      "raw": "key = 'bold_and_brash',\n    loc_txt = {\n        name = 'Bold and Brash',\n        text = {\n            \"{C:blue}+#1#{} hand if discarded hand\",\n            \"contains a {C:attention}#2#{}\", \n        }\n    },\n    config = { extra = { hands = 1, hand_to_discard = \"Two Pair\" } },\n\trarity = 1,\n\tatlas = 'gb_Jokers',\n\tpos = { x = 2, y = 5 },\n\tcost = 4,\n\tblueprint_compat = true,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.hands, card.ability.extra.hand_to_discard } }\n\tend,\n    calculate = function(self, card, context)\n        if context.pre_discard then\n            local _, _, poker_hands = G.FUNCS.get_poker_hand_info(G.hand.highlighted)\n\t\t\tif next(poker_hands[card.ability.extra.hand_to_discard]) then\n                ease_hands_played(card.ability.extra.hands)\n                return {\n                    message = \"+1 Hand\",\n                    colour = G.C.BLUE\n                }\n            end\n\t\tend\n    end"
    },
    {
      "type": "Joker",
      "key": "bullseye",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 5,
        "y": 4
      },
      "raw": "key = 'bullseye',\n\tloc_txt = {\n\t\tname = 'Bullseye',\n\t\ttext = {\n\t\t\t\"Earn {C:money}$#1#{} if there are\",\n            \"exactly {C:attention}#2#{} hands remaining\",\n            \"at end of round\",\n            \"{C:inactive,s:0.85}(Hands needed changes every round)\",\n\t\t}\n\t},\n\tconfig = { extra = { dollars = 8, hands_required = 0 } },\n\trarity = 1,\n\tatlas = 'gb_Jokers',\n\tpos = { x = 5, y = 4 },\n\tcost = 5,\n\tblueprint_compat = true,\n\tloc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.dollars, card.ability.extra.hands_required } }\n    end,\n    calculate = function(self, card, context)\n        if context.end_of_round and context.main_eval then\n            if G.GAME.current_round.hands_left == card.ability.extra.hands_required then\n                return {\n                    dollars = card.ability.extra.dollars\n                }\n            end\n            card.ability.extra.hands_required = math.floor(G.GAME.round_resets.hands * pseudorandom(\"gb_bullseye\"))\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "counterfeit_joker",
      "atlas": "Jokers",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "key = 'counterfeit_joker',\n\tloc_txt = {\n\t\tname = 'Counterfeit Joker',\n\t\ttext = {\n\t\t\t\"Gives {C:mult}+#1#{} Mult,\",\n\t\t\t\"lose {C:red}-$#2#{} at end of round\",\n\t\t}\n\t},\n\tconfig = { extra = { mult = 15, money = 1 } },\n\trarity = 1,\n\tatlas = 'Jokers',\n\tpos = { x = 2, y = 2 },\n\tcost = 2,\n\tblueprint_compat = true,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.mult, card.ability.extra.money } }\n\tend,\n    calculate = function(self, card, context)\n        if context.joker_main then\n            return {\n                mult = card.ability.extra.mult\n            }\n        end\n    end,\n\tcalc_dollar_bonus = function(self, card)\n        return -card.ability.extra.money\n    end"
    },
    {
      "type": "Joker",
      "key": "coupon",
      "atlas": "Jokers",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = 'coupon',\n\tloc_txt = {\n\t\tname = 'Coupon',\n\t\ttext = {\n\t\t\t\"{C:green}#1# in #2# chance{} to refund\",\n\t\t\t\"cards purchased in the {C:attention}Shop{}\",\n\t\t}\n\t},\n\tconfig = { extra = { odds = 3 } },\n\trarity = 1,\n\tatlas = 'Jokers',\n\tpos = { x = 1, y = 1 },\n\tcost = 6,\n\tblueprint_compat = true,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { G.GAME.probabilities.normal or 1, card.ability.extra.odds } }\n\tend,\n    calculate = function(self, card, context)\n        if context.buying_card and context.buying_card ~= card then\n            if SMODS.pseudorandom_probability(card, 'gb_coupon', G.GAME.probabilities.normal, card.ability.extra.odds) then\n                return {\n                    dollars = context.card.cost,\n                    message = \"Refunded!\",\n                    colour = G.C.MONEY\n                }\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "doner",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 5,
        "y": 5
      },
      "raw": "key = 'doner',\n    loc_txt = {\n        name = 'Doner',\n        text = {\n            \"This Joker gains {C:chips}+#1#{} Chips\",\n            \"after hand scored\",\n            \"{C:chips}-#2#{} chips when {C:attention}Blind{} is selected\",\n            \"{C:inactive}(Currently {C:chips}+#3#{C:inactive} Chips)\"\n        }\n    },\n    config = { extra = { chips = 0, chips_gain = 10, chips_loss = 20 } },\n\trarity = 1,\n\tatlas = 'gb_Jokers',\n\tpos = { x = 5, y = 5 },\n\tcost = 4,\n\tblueprint_compat = true,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.chips_gain, card.ability.extra.chips_loss, card.ability.extra.chips } }\n\tend,\n    calculate = function(self, card, context)\n        if context.joker_main then\n            return {\n                chips = card.ability.extra.chips,\n            }\n        end\n        if context.after and not context.blueprint then\n            card.ability.extra.chips = card.ability.extra.chips + card.ability.extra.chips_gain\n            return {\n                message = localize(\"k_upgrade_ex\"),\n                colour = G.C.CHIPS\n            }\n        end\n        if context.setting_blind and not context.blueprint then\n            if card.ability.extra.chips > 0 then\n                card.ability.extra.chips = math.max(0, card.ability.extra.chips - card.ability.extra.chips_loss)\n                return {\n                    message = \"Carved!\",\n                    colour = G.C.CHIPS\n                }\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "dunce",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 8,
        "y": 0
      },
      "raw": "key = 'dunce',\n    loc_txt = {\n        name = 'Dunce',\n        text = {\n            \"This Joker gains {C:chips}+#1#{} Chips\",\n            \"if {C:purple}Wheel of Fortune{}\",\n            \"fails to trigger\",\n            \"{C:inactive}(Currently {C:chips}+#2#{C:inactive} Chips)\",\n        }\n    },\n    config = { extra = { chips = 0, chips_mod = 20 } },\n    rarity = 1,\n    atlas = 'gb_Jokers',\n    pos = { x = 8, y = 0 },\n    cost = 3,\n    blueprint_compat = true,\n    perishable_compat = false,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.chips_mod, card.ability.extra.chips } }\n    end,\n    calculate = function(self, card, context)\n        if context.fortune_fail and not context.blueprint then\n            card.ability.extra.chips = card.ability.extra.chips + card.ability.extra.chips_mod\n            return {\n                message = localize('k_upgrade_ex'),\n                colour = G.C.CHIPS,\n                message_card = card\n            }\n        end\n        if context.joker_main then\n            return {\n                chips = card.ability.extra.chips,\n            }\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "gasoline",
      "atlas": "Jokers",
      "pos": {
        "x": 3,
        "y": 2
      },
      "raw": "key = 'gasoline',\n\tloc_txt = {\n\t\tname = 'Gasoline',\n\t\ttext = {\n\t\t\t\"Earn {C:money}$#1#{} if played hand\",\n\t\t\t\"causes score to {C:attention}catch fire{}\",\n\t\t}\n\t},\n\tconfig = { extra = { dollars = 6 } },\n\trarity = 1,\n\tatlas = 'Jokers',\n\tpos = { x = 3, y = 2 },\n\tcost = 6,\n\tblueprint_compat = true,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.dollars } }\n\tend,\n    calculate = function(self, card, context)\n        if context.final_scoring_step and G.GAME.blind.chips <= hand_chips * mult then\n\t\t\treturn {\n                dollars = card.ability.extra.dollars\n\t\t\t}\n\t\tend\n\tend"
    },
    {
      "type": "Joker",
      "key": "hadal_zone",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 9,
        "y": 5
      },
      "raw": "key = 'hadal_zone',\n    loc_txt = {\n        name = 'Hadal Zone',\n        text = {\n            \"When hand is played, {C:green}#3# in #4#{} chance\",\n            \"for this Joker to gain {X:mult,C:white}X#1#{} Mult\",\n            \"and {C:attention}destroy{} a random scoring card\",\n            \"{C:inactive}(Currently {X:mult,C:white}X#2#{C:inactive} Mult)\",\n        }\n    },\n    config = { extra = { xmult = 1, xmult_mod = 0.25, odds = 2, card_to_destroy = nil } },\n    rarity = 1,\n    atlas = 'gb_Jokers',\n    pos = { x = 9, y = 5 },\n    soul_pos = { x = 8, y = 5 },\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { \n            card.ability.extra.xmult_mod,\n            card.ability.extra.xmult,\n            G.GAME.probabilities.normal or 1, \n            card.ability.extra.odds \n        }}\n    end,\n    calculate = function(self, card, context)\n        if context.before and context.main_eval and not context.blueprint then\n            card.ability.extra.card_to_destroy = nil\n            if SMODS.pseudorandom_probability(card, 'gb_hadal_zone', G.GAME.probabilities.normal, card.ability.extra.odds) then\n                card.ability.extra.card_to_destroy = pseudorandom_element(context.scoring_hand, pseudoseed('gb_hadal_zone'))\n                card.ability.extra.xmult = card.ability.extra.xmult + card.ability.extra.xmult_mod\n                return {\n                    message = localize('k_upgrade_ex'),\n                    colour = G.C.MULT,\n                    message_card = card,\n                }\n            end\n        end \n        if context.joker_main then\n            return {\n                xmult = card.ability.extra.xmult\n            }\n        end\n        if context.destroy_card\n        and not context.blueprint \n        and card.ability.extra.card_to_destroy then\n            if context.destroy_card == card.ability.extra.card_to_destroy then\n                return {\n                    remove = true\n                }\n            end\n        end\n    end,\n    in_pool = function(self, args)\n        return false\n    end"
    },
    {
      "type": "Joker",
      "key": "hot_potato",
      "atlas": "Jokers",
      "pos": {
        "x": 7,
        "y": 2
      },
      "raw": "key = 'hot_potato',\n\tloc_txt = {\n\t\tname = 'Hot Potato',\n\t\ttext = {\n\t\t\t\"When {C:attention}Blind{} is skipped,\",\n\t\t\t\"this Joker gains {C:mult}+#2#{} Mult\",\n\t\t\t\"{C:green}#3# in #4# chance{} to {C:red}self-destruct{}\",\n\t\t\t\"at end of round\",\n\t\t\t\"{C:inactive}(Currently {C:mult}+#1#{C:inactive} Mult)\",\n\t\t}\n\t},\n\tconfig = { extra = { mult = 0, mult_mod = 12, odds = 8 } },\n\trarity = 1,\n\tatlas = 'Jokers',\n\tpos = { x = 7, y = 2 },\n\tcost = 4,\n\tblueprint_compat = true,\n    eternal_compat = false,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.mult, card.ability.extra.mult_mod, G.GAME.probabilities.normal or 1, card.ability.extra.odds } }\n\tend,\n\tcalculate = function(self, card, context)\n        if context.end_of_round and context.game_over == false and context.main_eval and not context.blueprint then\n            if pseudorandom('gb_hot_potato') < G.GAME.probabilities.normal / card.ability.extra.odds then\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        play_sound('tarot1')\n                        card.T.r = -0.2\n                        card:juice_up(0.3, 0.4)\n                        card.states.drag.is = true\n                        card.children.center.pinch.x = true\n                        G.E_MANAGER:add_event(Event({\n                            trigger = 'after',\n                            delay = 0.3,\n                            blockable = false,\n                            func = function()\n                                card:remove()\n                                return true\n                            end\n                        }))\n                        return true\n                    end\n                }))\n                return {\n                    message = 'Cooked!'\n                }\n            else\n                return {\n                    message = localize('k_safe_ex')\n                }\n            end\n        end\n        if context.skip_blind and not context.blueprint then\n\t\t\tcard.ability.extra.mult = card.ability.extra.mult + card.ability.extra.mult_mod\n            return {\n\t\t\t\tmessage = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult_mod } }\n\t\t\t}          \n        end\n        if context.joker_main then\n            return {\n                mult = card.ability.extra.mult\n\t\t\t}\n        end\n\tend"
    },
    {
      "type": "Joker",
      "key": "jackpot",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 1,
        "y": 3
      },
      "raw": "key = 'jackpot',\n\tloc_txt = {\n\t\tname = 'Jackpot',\n\t\ttext = {\n\t\t\t\"If {C:attention}scoring hand{} contains 3 {C:attention}7{}s,\",\n\t\t\t\"{C:attention}enhance{} all scoring {C:attention}7{}s\",\n            \"and earn {C:money}$#1#{}\"\n\t\t}\n\t},\n\trarity = 1,\n\tatlas = 'gb_Jokers',\n\tpos = { x = 1, y = 3 },\n\tcost = 4,\n\tblueprint_compat = false,\n    config = { extra = { dollars = 7 } },\n    loc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.dollars } }\n\tend,\n    calculate = function(self, card, context)\n        if context.before and context.main_eval then\n            local sevens = {}\n            for _, playing_card in ipairs(context.scoring_hand) do\n                if playing_card:get_id() == 7 then\n                    table.insert(sevens, playing_card)\n                end\n            end\n            if #sevens >= 3 then\n                local valid_keys = {}\n                for _, enhancement_center in pairs(G.P_CENTER_POOLS[\"Enhanced\"]) do\n                    if enhancement_center.key ~= 'm_stone' and not enhancement_center.overrides_base_rank then\n                        valid_keys[#valid_keys + 1] = enhancement_center.key\n                    end\n                end\n                for _, playing_card in ipairs(sevens) do\n                    playing_card:set_ability(pseudorandom_element(valid_keys, pseudoseed('jackpot')), nil, nil)\n                    playing_card:juice_up()\n                end\n                return {\n                    dollars = card.ability.extra.dollars,\n                    message = \"Enhanced!\",\n                    colour = G.C.FILTER\n                }\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "mist",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"mist\",\n    loc_txt = {\n        name = 'Mist',\n\t\ttext = {\n\t\t\t\"{C:chips}+#1#{} Chips for every\",\n            \"{V:1}Ephemeral Card{} used this run\",\n            \"{C:inactive}(Currently {C:chips}+#2#{C:inactive} Chips)\"\n\t\t}\n    },\n    config = { extra = { chips_mod = 10 } },\n\trarity = 1,\n\tatlas = 'gb_Jokers',\n\tpos = { x = 1, y = 0 },\n\tcost = 5,\n\tblueprint_compat = true,\n    loc_vars = function(self, info_queue, card)\n        return {\n            vars = {\n                card.ability.extra.chips_mod,\n                card.ability.extra.chips_mod * (G.GAME.consumeable_usage_total and G.GAME.consumeable_usage_total.ephemeral or 0),\n                colours = { HEX(\"8EA4B3\") }\n            }\n        }\n    end,\n    calculate = function(self, card, context)\n        if context.using_consumeable and not context.blueprint and context.consumeable.ability.set == \"Ephemeral\" then\n            return {\n                message = localize { type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips_mod * G.GAME.consumeable_usage_total.ephemeral } },\n            }\n        end\n        if context.joker_main then\n            return {\n                chips = card.ability.extra.chips_mod *\n                    (G.GAME.consumeable_usage_total and G.GAME.consumeable_usage_total.ephemeral or 0)\n            }\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "patience",
      "atlas": "Jokers",
      "pos": {
        "x": 7,
        "y": 3
      },
      "raw": "key = 'patience',\n\tloc_txt = {\n\t\tname = 'Patience',\n\t\ttext = {\n            \"This Joker gains {C:mult}+#1#{} Mult\",\n            \"for every played hand this round\",\n            \"{C:inactive}(Currently {C:mult}+#2#{C:inactive} Mult)\",\n\t\t}\n\t},\n\tconfig = { extra = { mult = 0, mult_mod = 5 } },\n\trarity = 1,\n\tatlas = 'Jokers',\n\tpos = { x = 7, y = 3 },\n\tcost = 4,\n\tblueprint_compat = true,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.mult_mod, card.ability.extra.mult } }\n\tend,\n\tcalculate = function(self, card, context)\n        if context.before and not context.blueprint then\n            card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.mult_mod\n        end\n        if context.joker_main then\n\t\t\treturn {\n\t\t\t\tmult = card.ability.extra.mult\n\t\t\t}\n\t\tend\n        if context.end_of_round and not context.blueprint then\n            card.ability.extra.mult = 0\n        end\n\tend"
    },
    {
      "type": "Joker",
      "key": "polariser",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "key = 'polariser',\n\tloc_txt = {\n\t\tname = 'Polariser',\n\t\ttext = {\n\t\t\t\"{C:mult}+#1#{} Mult if played hand\",\n\t\t\t\"contains a {C:attention}Bonus Card{}\",\n\t\t\t\"{C:chips}+#2#{} Chips if played hand\",\n\t\t\t\"contains a {C:attention}Mult Card{}\",\n\t\t}\n\t},\n\tconfig = { extra = { mult = 12, chips = 90 } },\n\trarity = 1,\n\tatlas = 'gb_Jokers',\n\tpos = { x = 4, y = 0 },\n\tcost = 4,\n\tblueprint_compat = true,\n\tloc_vars = function(self, info_queue, card)\n\t\tinfo_queue[#info_queue + 1] = G.P_CENTERS.m_bonus\n\t\tinfo_queue[#info_queue + 1] = G.P_CENTERS.m_mult\n\t\treturn { vars = { card.ability.extra.mult, card.ability.extra.chips } }\n\tend,\n    calculate = function(self, card, context)\n        if context.joker_main then\n\t\t\tlocal has_bonus = false\n\t\t\tlocal has_mult = false\n\t\t\tfor _, playing_card in ipairs(context.playing_cards or {}) do\n\t\t\t\tif SMODS.has_enhancement(playing_card, 'm_bonus') then\n\t\t\t\t\thas_bonus = true\n\t\t\t\tend\n\t\t\t\tif SMODS.has_enhancement(playing_card, 'm_mult') then\n\t\t\t\t\thas_mult = true\n\t\t\t\tend\n\t\t\tend\n\t\t\treturn {\n\t\t\t\tmult = has_bonus and card.ability.extra.mult or 0,\n\t\t\t\tchips = has_mult and card.ability.extra.chips or 0\n\t\t\t}\n\t\tend\n\tend,\n\tin_pool = function(self, args)\n        for _, playing_card in ipairs(G.playing_cards or {}) do\n            if SMODS.has_enhancement(playing_card, 'm_mult') or SMODS.has_enhancement(playing_card, 'm_bonus') then\n                return true\n            end\n        end\n        return false\n    end"
    },
    {
      "type": "Joker",
      "key": "pontoon",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 4,
        "y": 3
      },
      "raw": "key = \"pontoon\",\n    loc_txt = {\n        name = 'Pontoon',\n        -- formatting fuck storm\n\t\ttext = {\n\t\t\t\"{C:mult}+#1#{} Mult and {C:chips}+#2#{} Chips if\",\n            \"ranks of played cards {C:attention}add to #3#{}\",\n            \"{C:inactive,s:0.85}({C:attention,s:0.85}Kings{C:inactive,s:0.85}, {C:attention,s:0.85}Queens{C:inactive,s:0.85} and {C:attention,s:0.85}Jacks{C:inactive,s:0.85} count as {C:attention,s:0.85}10{C:inactive,s:0.85}){}\",\n            \"{C:inactive,s:0.85}({C:attention,s:0.85}Aces{C:inactive,s:0.85} count as both {C:attention,s:0.85}1{C:inactive,s:0.85} and {C:attention,s:0.85}11{C:inactive,s:0.85})\",\n\t\t}\n    },\n    config = { extra = { mult = 20, chips = 100, rank_count = 21 } },\n\trarity = 1,\n\tatlas = 'gb_Jokers',\n\tpos = { x = 4, y = 3 },\n\tcost = 4,\n\tblueprint_compat = true,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.mult, card.ability.extra.chips, card.ability.extra.rank_count } }\n\tend,\n    calculate = function(self, card, context)\n        if context.joker_main then\n            local rank_sum = 0\n            local ace_count = 0\n            for _, playing_card in pairs(context.full_hand) do\n                if not SMODS.has_no_rank(playing_card) then\n                    rank_sum = rank_sum + playing_card.base.nominal\n                end\n                if playing_card:get_id() == 14 then\n                    ace_count = ace_count + 1\n                end\n            end\n            for i = 1, ace_count + 1 do\n                if rank_sum < 21 then\n                    return {\n                        message = rank_sum .. \"\",\n                        colour = G.C.FILTER\n                    }\n                elseif rank_sum == 21 then\n                    return {\n                        chips = card.ability.extra.chips,\n                        mult = card.ability.extra.mult\n                    }\n                else\n                    rank_sum = rank_sum - 10\n                end\n            end\n            return \n                {\n                    message = \"Bust!\",\n                    colour = G.C.RED\n                }\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "qubits",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 8,
        "y": 1
      },
      "raw": "key = \"qubits\",\n    loc_txt = {\n\t\tname = 'Qubits',\n\t\ttext = {\n\t\t\t\"The first scored card\",\n            \"of each {C:attention}Suit{}\",\n            \"gives {C:mult}+#1#{} Mult\",\n\t\t}\n\t},\n    blueprint_compat = false,\n\tatlas = 'gb_Jokers',\n\tpos = { x = 8, y = 1 },\n    rarity = 1,\n    cost = 4,\n    config = { extra = { mult = 6, scored_suits = {} } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.mult } }\n    end,\n    calculate = function(self, card, context)\n        if context.before and context.main_eval then\n            card.ability.extra.scored_suits = {}\n        end\n        if context.individual and context.cardarea == G.play then\n            if context.other_card.base.suit \n            and not card.ability.extra.scored_suits[context.other_card.base.suit] \n            then \n                card.ability.extra.scored_suits[context.other_card.base.suit] = true \n                return {\n                    mult = card.ability.extra.mult\n                }\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "receipt",
      "atlas": "Jokers",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "key = 'receipt',\n\tloc_txt = {\n\t\tname = 'Receipt',\n\t\ttext = {\n\t\t\t\"This Joker gains {C:chips}+#1#{} Chips\",\n\t\t\t\"for every card purchased\",\n\t\t\t\"in the shop\",\n\t\t\t\"{C:inactive}(Currently {C:chips}+#2#{C:inactive} Chips)\"\n\t\t}\n\t},\n\tconfig = { extra = { chips = 0, chips_mod = 5 } },\n\trarity = 1,\n\tatlas = 'Jokers',\n\tpos = { x = 1, y = 2 },\n\tcost = 4,\n\tblueprint_compat = true,\n\tperishable_compat = false,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.chips_mod, card.ability.extra.chips } }\n\tend,\n\tcalculate = function(self, card, context)\n\t\tif context.buying_card and context.card ~= card then\n\t\t\tcard.ability.extra.chips = card.ability.extra.chips + card.ability.extra.chips_mod\n            return {\n                message = localize('k_upgrade_ex'),\n                colour = G.C.CHIPS\n            }\n\t\tend\n        if context.joker_main then\n\t\t\treturn {\n\t\t\t\tchips = card.ability.extra.chips\n\t\t\t}\n\t\tend\n\tend"
    },
    {
      "type": "Joker",
      "key": "sketchy_joker",
      "atlas": "Jokers",
      "pos": {
        "x": 3,
        "y": 3
      },
      "raw": "key = 'sketchy_joker',\n\tloc_txt = {\n\t\tname = 'Sketchy Joker',\n\t\ttext = {\n            \"This Joker gains {C:chips}+#1#{} Chips\",\n            \"for every {C:attention}#4#{} cards drawn\",\n            \"{C:inactive}(Currently {C:chips}+#2#{C:inactive} Chips) (#3#/#4#)\",\n\t\t}\n\t},\n\tconfig = { extra = { chips = 0, chips_mod = 3, draw_tally = 0, draws = 7 } },\n\trarity = 1,\n\tatlas = 'Jokers',\n\tpos = { x = 3, y = 3 },\n\tcost = 4,\n\tblueprint_compat = true,\n\tperishable_compat = false,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.chips_mod, card.ability.extra.chips, card.ability.extra.draw_tally, card.ability.extra.draws } }\n\tend,\n\tcalculate = function(self, card, context)\n\t\tif context.hand_drawn then\n\t\t\tlocal upgraded = false\n\t\t\tfor _, playing_card in ipairs(context.hand_drawn) do\n\t\t\t\tcard.ability.extra.draw_tally = card.ability.extra.draw_tally + 1\n\t\t\t\tif card.ability.extra.draw_tally >= card.ability.extra.draws then\n\t\t\t\t\tcard.ability.extra.chips = card.ability.extra.chips + card.ability.extra.chips_mod\n\t\t\t\t\tcard.ability.extra.draw_tally = card.ability.extra.draw_tally - card.ability.extra.draws\n\t\t\t\t\tupgraded = true\n\t\t\t\tend\n\t\t\tend\n\t\t\tif upgraded == true then\n\t\t\t\treturn {\n\t\t\t\t\tmessage = localize('k_upgrade_ex'),\n                \tcolour = G.C.CHIPS\n\t\t\t\t}\n\t\t\tend\n\t\tend\n\t\tif context.other_drawn then\n\t\t\tlocal upgraded = false\n\t\t\tfor _, playing_card in ipairs(context.other_drawn) do\n\t\t\t\tcard.ability.extra.draw_tally = card.ability.extra.draw_tally + 1\n\t\t\t\tif card.ability.extra.draw_tally >= card.ability.extra.draws then\n\t\t\t\t\tcard.ability.extra.chips = card.ability.extra.chips + card.ability.extra.chips_mod\n\t\t\t\t\tcard.ability.extra.draw_tally = card.ability.extra.draw_tally - card.ability.extra.draws\n\t\t\t\t\tupgraded = true\n\t\t\t\tend\n\t\t\tend\n\t\t\tif upgraded == true then\n\t\t\t\treturn {\n\t\t\t\t\tmessage = localize('k_upgrade_ex'),\n                \tcolour = G.C.CHIPS\n\t\t\t\t}\n\t\t\tend\n\t\tend\n\t\tif context.joker_main then\n\t\t\treturn {\n\t\t\t\tchips = card.ability.extra.chips\n\t\t\t}\n\t\tend\n\tend"
    },
    {
      "type": "Joker",
      "key": "torchlight",
      "atlas": "Jokers",
      "pos": {
        "x": 5,
        "y": 1
      },
      "raw": "key = 'torchlight',\n    loc_txt = {\n        name = 'Torchlight',\n        text = {\n            \"{C:mult}+#1#{} Mult for every\",\n            \"{C:attention}Joker{} to the left of this one\",\n            \"{C:inactive}(Currently {C:mult}+#2#{C:inactive} Mult)\",\n        }\n    },\n    config = { extra = { mult = 0, mult_mod = 5 } },\n    rarity = 1,\n    cost = 4,\n    atlas = 'Jokers',\n    pos = { x = 5, y = 1 },\n    blueprint_compat = true,\n    loc_vars = function(self, info_queue, card)\n        local position = 0\n        if card.area and card.area == G.jokers then\n            for k, joker in ipairs(G.jokers.cards) do\n                if joker == card then\n                    position = k - 1\n                    break\n                end\n            end\n            return { vars = { card.ability.extra.mult_mod, card.ability.extra.mult_mod * position } }\n        else\n            return { vars = { card.ability.extra.mult_mod, 0 } }\n        end\n            \n    end,\n    calculate = function(self, card, context)\n        if context.joker_main then\n            local position = 0\n            for k, joker in ipairs(G.jokers.cards) do\n                if joker == card then\n                    position = k - 1\n                    break\n                end\n            end\n            card.ability.extra.mult = card.ability.extra.mult_mod * position\n            return { \n                mult = card.ability.extra.mult\n            }\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "typograph",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = 'typograph',\n    loc_txt = {\n        name = 'Typograph',\n        text = {\n            \"{C:mult}+#1#{} Mult for every letter\",\n            \"in the rightmost Joker's name\",\n            \"{C:inactive}(Currently {C:mult}+#2#{C:inactive} Mult)\"\n        }\n    },\n    config = { extra = { mult = 1 } },\n    rarity = 1,\n    atlas = 'gb_Jokers',\n    pos = { x = 2, y = 1 },\n    cost = 4,\n    blueprint_compat = true,\n    loc_vars = function(self, info_queue, card)\n        local letter_count = 0\n        if G.jokers and G.jokers.cards[#G.jokers.cards] then\n            local joker_name = G.localization.descriptions.Joker[G.jokers.cards[#G.jokers.cards].config.center.key].name\n            if joker_name then\n                for i = 1, #joker_name do\n                    local c = joker_name:sub(i,i)\n                    if c ~= \" \" then\n                        letter_count = letter_count + 1\n                    end\n                end\n            end\n        end\n        return { vars = { card.ability.extra.mult, letter_count * card.ability.extra.mult } }\n    end,\n    calculate = function(self, card, context)\n        if context.joker_main then\n            local letter_count = 0\n            if G.jokers and G.jokers.cards[#G.jokers.cards] then\n                local joker_name = G.localization.descriptions.Joker[G.jokers.cards[#G.jokers.cards].config.center.key].name\n                if joker_name then\n                    for i = 1, #joker_name do\n                        local c = joker_name:sub(i,i)\n                        if c ~= \" \" then\n                            letter_count = letter_count + 1\n                        end\n                    end\n                end\n            end\n            return {\n                mult = letter_count * card.ability.extra.mult\n            }\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "boing_ball",
      "atlas": "Jokers",
      "pos": {
        "x": 6,
        "y": 3
      },
      "raw": "key = 'boing_ball',\n\tloc_txt = {\n\t\tname = 'Boing Ball',\n\t\ttext = {\n\t\t\t\"{C:green}#1# in #2# chance{} for\",\n\t\t\t\"played cards to retrigger\",\n\t\t}\n\t},\n\tconfig = { extra = { odds = 2, repetitions = 1 } },\n\trarity = 2,\n\tatlas = 'Jokers',\n\tpos = { x = 6, y = 3 },\n\tcost = 5,\n\tblueprint_compat = true,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { G.GAME.probabilities.normal or 1, card.ability.extra.odds } }\n\tend,\n    calculate = function(self, card, context)\n        if context.repetition and context.cardarea == G.play then\n\t\t\tif SMODS.pseudorandom_probability(card, 'gb_boing_ball', G.GAME.probabilities.normal, card.ability.extra.odds) then\t\t\n                return {\n                    repetitions = card.ability.extra.repetitions\n                }\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "calculator",
      "atlas": "Jokers",
      "pos": {
        "x": 6,
        "y": 1
      },
      "raw": "key = 'calculator',\n\tloc_txt = {\n\t\tname = 'Calculator',\n\t\ttext = {\n            \"This Joker gains {C:chips}+#1#{} Chips\",\n            \"for every scored {C:attention}numbered{} card\",\n            \"Resets when {C:attention}Boss Blind{} is defeated\",\n            \"{C:inactive}(Currently {C:chips}+#2#{C:inactive} Chips)\",\n\t\t}\n\t},\n\tconfig = { extra = { chips = 0, chips_mod = 7 } },\n\trarity = 2,\n\tatlas = 'Jokers',\n\tpos = { x = 6, y = 1 },\n\tcost = 6,\n\tblueprint_compat = true,\n    perishable_compat = false,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.chips_mod, card.ability.extra.chips } }\n\tend,\n\tcalculate = function(self, card, context)\n        if context.individual and context.cardarea == G.play and not context.blueprint then\n            if context.other_card:get_id() <= 10 and context.other_card:get_id() >= 2 then\n                card.ability.extra.chips = card.ability.extra.chips + card.ability.extra.chips_mod\n                return {\n                    message = localize('k_upgrade_ex'),\n                    colour = G.C.CHIPS,\n                    message_card = card\n                }\n            end\n        end\n        if context.joker_main then\n\t\t\treturn {\n\t\t\t\tchips = card.ability.extra.chips\n\t\t\t}\n\t\tend\n        if context.end_of_round and context.game_over == false and context.main_eval and not context.blueprint then\n            if G.GAME.blind.boss and card.ability.extra.chips > 0 then\n                card.ability.extra.chips = 0\n                return {\n                    message = 'AC',\n                    colour = G.C.RED\n                }\n            end\n        end\n\tend"
    },
    {
      "type": "Joker",
      "key": "candle",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 6,
        "y": 4
      },
      "raw": "key = 'candle',\n    loc_txt = {\n        name = 'Candle',\n        text = {\n            \"For the next {C:attention}#1#{} rounds, the first\",\n            \"scoring card of the round\",\n            \"gains a random {C:attention}Seal{}\",\n        }\n    },\n    config = { extra = { rounds_left = 5 } },\n    rarity = 2,\n    cost = 6,\n    blueprint_compat = false,\n    eternal_compat = false,\n    atlas = 'gb_Jokers',\n    pos = { x = 6, y = 4 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.rounds_left } }\n    end,\n    calculate = function(self, card, context)\n        if context.before and context.main_eval and G.GAME.current_round.hands_played == 0 and not context.blueprint then\n            context.scoring_hand[1]:set_seal(SMODS.poll_seal({ guaranteed = true, type_key = 'gb_candle' }))\n            context.scoring_hand[1]:juice_up()\n            card.ability.extra.rounds_left = card.ability.extra.rounds_left - 1\n            if card.ability.extra.rounds_left > 0 then\n                return {\n                    message = card.ability.extra.rounds_left .. '',\n                    colour = G.C.FILTER\n                }\n            else\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        play_sound('tarot1')\n                        card.T.r = -0.2\n                        card:juice_up(0.3, 0.4)\n                        card.states.drag.is = true\n                        card.children.center.pinch.x = true\n                        G.E_MANAGER:add_event(Event({\n                            trigger = 'after',\n                            delay = 0.3,\n                            blockable = false,\n                            func = function()\n                                card:remove()\n                                return true\n                            end\n                        }))\n                        return true\n                    end\n                }))\n                return {\n                    message = 'Melted!',\n                    colour = G.C.FILTER\n                }\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "cheque_stub",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 7,
        "y": 0
      },
      "raw": "key = 'cheque_stub',\n\tloc_txt = {\n\t\tname = 'Cheque Stub',\n\t\ttext = {\n            \"At end of round, earn {C:money}$#1#{}\",\n            \"and {C:attention}destroy{} leftmost\",\n            \"card held in hand\"\n\t\t}\n\t},\n\tconfig = { extra = { dollars = 4 } },\n    pixel_size = { w = 49 },\n\trarity = 2,\n\tatlas = 'gb_Jokers',\n\tpos = { x = 7, y = 0 },\n\tcost = 8,\n\tblueprint_compat = true,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.dollars } }\n\tend,\n    calc_dollar_bonus = function(self, card)\n        return card.ability.extra.dollars\n    end,\n    calculate = function(self, card, context)\n\t    if context.end_of_round and context.main_eval then\n            if G.hand.cards[1] then\n                G.hand.cards[1]:start_dissolve()\n                return { remove = true }\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "creepy_painting",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 4,
        "y": 5
      },
      "raw": "key = \"creepy_painting\",\n    loc_txt = {\n        name = 'Creepy Painting',\n\t\ttext = {\n            \"{X:mult,C:white}X#1#{} Mult\",\n            \"When {C:attention}Blind{} is selected, {C:green}#3# in #2# chance{}\",\n            \"to destroy a random {C:attention}Joker{}\",\n            \"and gain its sell value\"\n\t\t}\n    },\n    config = { extra = { xmult = 2, odds = 2 } },\n\trarity = 2,\n\tatlas = 'gb_Jokers',\n\tpos = { x = 4, y = 5 },\n\tcost = 6,\n\tblueprint_compat = true,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.xmult, card.ability.extra.odds, G.GAME.probabilities.normal or 1 } }\n\tend,\n    calculate = function(self, card, context)\n        if context.joker_main then\n            return {\n                xmult = card.ability.extra.xmult\n            }\n        end\n        if context.setting_blind \n            and not context.blueprint \n            and pseudorandom('gb_creepy_painting') >= G.GAME.probabilities.normal / card.ability.extra.odds then\n            local valid_targets = {}\n            for _, joker in pairs(G.jokers.cards) do\n                if joker ~= card\n                    and not joker.ability.eternal \n                    and not joker.getting_sliced then\n                    valid_targets[#valid_targets + 1] = joker\n                end\n            end\n            local joker_to_destroy = pseudorandom_element(valid_targets, pseudoseed('gb_creepy_painting'))\n            if joker_to_destroy then\n                joker_to_destroy.getting_sliced = true\n                local joker_sell_value = joker_to_destroy.sell_cost\n                card.sell_cost = card.sell_cost + joker_to_destroy.sell_cost\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        (context.blueprint_card or card):juice_up(0.8, 0.8)\n                        joker_to_destroy:start_dissolve({ G.C.RED }, nil, 1.6)\n                        return true\n                    end\n                }))\n                return {\n                    message = \"+$\" .. joker_sell_value,\n                    colour = G.C.MONEY\n                }\n            end\n            return {}\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "double_gulp",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 8,
        "y": 2
      },
      "raw": "key = 'double_gulp',\n    loc_txt = {\n        name = 'Double Gulp',\n        text = {\n            \"Creates {C:attention}#2#{} copies of\",\n            \"the next {C:attention}#1#{} cards destroyed\",\n        }\n    },\n    config = { extra = { copies = 2, cards_left = 5 } },\n    rarity = 2,\n    atlas = 'gb_Jokers',\n    pos = { x = 8, y = 2 },\n    cost = 5,\n    blueprint_compat = false,\n    eternal_compat = false,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.cards_left, card.ability.extra.copies } }\n    end,\n    calculate = function(self, card, context)\n        if context.remove_playing_cards and not context.blueprint then\n            for _, removed_card in ipairs(context.removed) do\n                card.ability.extra.cards_left = card.ability.extra.cards_left - 1\n                for i = 1, card.ability.extra.copies do\n                    G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                    local _card = copy_card(removed_card, nil, nil, G.playing_card)\n                    _card:add_to_deck()\n                    G.deck.config.card_limit = G.deck.config.card_limit + 1\n                    table.insert(G.playing_cards, _card)\n                    G.deck:emplace(_card)\n                end\n                if card.ability.extra.cards_left <= 0 then\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            play_sound('tarot1')\n                            card.T.r = -0.2\n                            card:juice_up(0.3, 0.4)\n                            card.states.drag.is = true\n                            card.children.center.pinch.x = true\n                            G.E_MANAGER:add_event(Event({\n                                trigger = 'after',\n                                delay = 0.3,\n                                blockable = false,\n                                func = function()\n                                    card:remove()\n                                    return true\n                                end\n                            }))\n                        return true\n                    end\n                }))\n                    return {\n                        message = 'Drank!',\n                        colour = G.C.FILTER\n                    }\n                else\n                    return {\n                        message = card.ability.extra.cards_left .. '',\n                        colour = G.C.FILTER\n                    }\n                end    \n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "escape_velocity",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 3,
        "y": 5
      },
      "raw": "key = 'escape_velocity',\n\tloc_txt = {\n\t\tname = 'Escape Velocity',\n\t\ttext = {\n            \"Level up played {C:attention}poker hand{}\",\n            \"if it has been played\",\n            \"{C:attention}#1#{} or fewer times this run\"\n\t\t}\n\t},\n\tconfig = { extra = { play_threshold = 3 } },\n\trarity = 2,\n\tatlas = 'gb_Jokers',\n\tpos = { x = 3, y = 5 },\n\tcost = 5,\n\tblueprint_compat = true,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.play_threshold } }\n\tend,\n    calculate = function(self, card, context)\n\t    if context.before then\n            if G.GAME.hands[context.scoring_name].played <= card.ability.extra.play_threshold then\n                return {\n                    level_up = true\n                }\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "first_strike",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 1,
        "y": 4
      },
      "raw": "key = 'first_strike',\n    loc_txt = {\n        name = 'First Strike',\n        text = {\n            \"This Joker gains {X:mult,C:white}X#1#{} Mult\",\n            \"for each {C:attention}Blind{} skipped\",\n            \"Resets when {C:attention}Boss Blind{} is defeated\",\n            \"{C:inactive}(Currently {X:mult,C:white}X#2#{C:inactive} Mult)\",\n        }\n    },\n    config = { extra = { xmult = 1, xmult_mod = 1 } },\n    rarity = 2,\n    atlas = 'gb_Jokers',\n    pos = { x = 1, y = 4 },\n    cost = 6,\n    blueprint_compat = true,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.xmult_mod, card.ability.extra.xmult } }\n    end,\n    calculate = function(self, card, context)\n        if context.skip_blind and not context.blueprint then\n            card.ability.extra.xmult = card.ability.extra.xmult + card.ability.extra.xmult_mod\n            return {\n                message = localize('k_upgrade_ex'),\n                colour = G.C.MULT,\n                message_card = card\n            }\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval and not context.blueprint then\n            if G.GAME.blind.boss then\n                card.ability.extra.xmult = 1\n                return {\n                    message = 'Reset',\n                    colour = G.C.RED\n                }\n            end\n        end\n        if context.joker_main then\n            return {\n                xmult = card.ability.extra.xmult\n            }   \n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "honeycomb",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 0,
        "y": 5
      },
      "raw": "key = \"honeycomb\",\n    loc_txt = {\n        name = 'Honeycomb',\n        text = {\n            \"This Joker gains {X:mult,C:white}X#1#{} Mult\",\n            \"for every {C:attention}#2# Honey Cards{} drawn\",\n            \"{C:inactive}(Currently {X:mult,C:white}X#3#{C:inactive} Mult)\",\n            \"{C:inactive}({C:attention}#4#{C:inactive}/#2#)\",\n        }\n    },\n    blueprint_compat = true,\n    perishable_compat = false,\n    rarity = 2,\n    cost = 6,\n    atlas = 'gb_Jokers',\n    pos = { x = 0, y = 5 },\n    config = { extra = { xmult = 1, xmult_mod = 0.5, draw_tally = 0, card_draws = 6 } },\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue + 1] = G.P_CENTERS.m_gb_honey\n        return { vars = { card.ability.extra.xmult_mod, card.ability.extra.card_draws, card.ability.extra.xmult, card.ability.extra.draw_tally } }\n    end,\n    calculate = function(self, card, context)\n        if context.hand_drawn then\n            for _, playing_card in ipairs(context.hand_drawn) do\n                if SMODS.has_enhancement(playing_card, 'm_gb_honey') then\n                    card.ability.extra.draw_tally = card.ability.extra.draw_tally + 1\n                    if card.ability.extra.draw_tally >= card.ability.extra.card_draws then\n                        card.ability.extra.draw_tally = 0\n                        card.ability.extra.xmult = card.ability.extra.xmult + card.ability.extra.xmult_mod\n                        return {\n                            message = localize('k_upgrade_ex'),\n                            colour = G.C.MULT,\n                            message_card = card\n                        }\n                    end\n                end\n            end\n        end\n        if context.joker_main then\n            return {\n                xmult = card.ability.extra.xmult,\n            }\n        end\n    end,\n    in_pool = function(self, args)\n        for _, playing_card in ipairs(G.playing_cards or {}) do\n            if SMODS.has_enhancement(playing_card, 'm_steel') then\n                return true\n            end\n        end\n        return false\n    end,"
    },
    {
      "type": "Joker",
      "key": "knight",
      "atlas": "Jokers",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = 'knight',\n\tloc_txt = {\n\t\tname = 'Knight',\n\t\ttext = {\n            \"{C:attention}Steel Cards{} give\",\n            \"{X:mult,C:white}X#1#{} Mult when scored\",\n\t\t}\n\t},\n\tconfig = { extra = { xmult = 1.5 } },\n\trarity = 2,\n\tatlas = 'Jokers',\n\tpos = { x = 0, y = 2 },\n\tcost = 5,\n\tblueprint_compat = true,\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue + 1] = G.P_CENTERS.m_steel\n        return { vars = { card.ability.extra.xmult } }\n    end,\n    calculate = function(self, card, context)\n        if context.individual and context.cardarea == G.play and\n            SMODS.has_enhancement(context.other_card, 'm_steel') then\n            return {\n                xmult = card.ability.extra.xmult\n\t\t\t}\n        end\n    end,\n    in_pool = function(self, args)\n        for _, playing_card in ipairs(G.playing_cards or {}) do\n            if SMODS.has_enhancement(playing_card, 'm_steel') then\n                return true\n            end\n        end\n        return false\n    end,"
    },
    {
      "type": "Joker",
      "key": "little_timbo",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"little_timbo\",\n    loc_txt = {\n        name = 'Little Timbo',\n\t\ttext = {\n\t\t\t\"{C:attention}#1#X{} Blind size\",\n            \"{C:red}#2#{} Joker slot\",\n\t\t}\n    },\n    config = { extra = { blind_size = 0.5, joker_slot = -1 } },\n\trarity = 2,\n\tatlas = 'gb_Jokers',\n\tpos = { x = 2, y = 0 },\n\tcost = 6,\n\tblueprint_compat = false,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.blind_size, card.ability.extra.joker_slot } }\n    end,\n    calculate = function(self, card, context)\n        if context.setting_blind then\n            G.GAME.blind.chips = G.GAME.blind.chips * card.ability.extra.blind_size\n            G.GAME.blind.chip_text = number_format(G.GAME.blind.chips)\n            play_sound(\"cancel\")\n            card:juice_up()\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        G.jokers.config.card_limit = G.jokers.config.card_limit + card.ability.extra.joker_slot\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        G.jokers.config.card_limit = G.jokers.config.card_limit - card.ability.extra.joker_slot\n    end"
    },
    {
      "type": "Joker",
      "key": "lovers_locket",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 2,
        "y": 4
      },
      "raw": "key = 'lovers_locket',\n    loc_txt = {\n        name = 'Lover\\'s Locket',\n        text = {\n            \"{C:attention}Wild Cards{} have a\",\n            \"{C:green}#3# in #2#{} chance to\",\n            \"give {X:mult,C:white}X#1#{} Mult when scored\",\t\n        }\n    },\n    config = { extra = { odds = 2, xmult = 2 } },\n    rarity = 2,\n    atlas = 'gb_Jokers',\n    pos = { x = 2, y = 4 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.xmult , card.ability.extra.odds, G.GAME.probabilities.normal or 1 } }\n    end,\n    calculate = function(self, card, context)\n        if context.individual and context.cardarea == G.play and SMODS.has_enhancement(context.other_card, \"m_wild\") and\n            SMODS.pseudorandom_probability(card, 'gb_lovers_locket', G.GAME.probabilities.normal, card.ability.extra.odds) then\n            return {\n                xmult = card.ability.extra.xmult\n            }\n        end\n    end,\n    in_pool = function(self, args)\n        for _, playing_card in ipairs(G.playing_cards or {}) do\n            if SMODS.has_enhancement(playing_card, 'm_wild') then\n                return true\n            end\n        end\n        return false\n    end"
    },
    {
      "type": "Joker",
      "key": "misfortune",
      "atlas": "Jokers",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = 'misfortune',\n\tloc_txt = {\n\t\tname = 'Wheel Of Misfortune',\n\t\ttext = {\n\t\t\t\"{X:mult,C:white}X#1#{} Mult, {C:green}#2# in #3# chance{}\",\n\t\t\t\"for played hand to score {C:attention}0{}\",\n\t\t\t\"and be {C:attention}refunded{}\",\n\t\t}\n\t},\n\tconfig = { extra = { xmult = 3, odds = 4 } },\n\trarity = 2,\n\tatlas = 'Jokers',\n\tpos = { x = 0, y = 1 },\n\tcost = 5,\n\tblueprint_compat = true,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.xmult, G.GAME.probabilities.normal or 1, card.ability.extra.odds } }\n\tend,\n\tcalculate = function(self, card, context)\n\t\tif context.joker_main then\n\t\t\treturn {\n\t\t\t\txmult = card.ability.extra.xmult\n\t\t\t}\n\t\tend\n\t\tif context.final_scoring_step then\n\t\t\tif SMODS.pseudorandom_probability(card, 'gb_misfortune', G.GAME.probabilities.normal, card.ability.extra.odds) then\t\t\n\t\t\t\thand_chips = 0\n\t\t\t\tmult = 0\n\t\t\t\tease_hands_played(1)\n\t\t\t\tSMODS.calculate_context{fortune_fail = true}\n\t\t\t\treturn {\n\t\t\t\t\tmessage = localize('k_nope_ex'),\n\t\t\t\t\tcolour = G.C.SECONDARY_SET.Tarot,\n\t\t\t\t\tsound = 'cancel'\n\t\t\t\t}\n\t\t\tend\n\t\tend\n\tend"
    },
    {
      "type": "Joker",
      "key": "paint_the_town_red",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 4,
        "y": 2
      },
      "raw": "key = 'paint_the_town_red',\n\tloc_txt = {\n\t\tname = 'Paint The Town Red',\n\t\ttext = {\n\t\t\t\"{C:mult}+#1#{} Mult for every\",\n            \"{C:hearts}Heart{} in {C:attention}full deck{}\",\n            \"{C:mult}-#1#{} Mult for every\",\n            \"{C:spades}Spade{} in {C:attention}full deck{}\",\n            \"{C:inactive}(Currently {C:mult}+#2#{}{C:inactive} Mult)\",\n\t\t}\n\t},\n    config = { extra = { mult_mod = 3, mult = 0 } },\n    rarity = 2,\n\tatlas = 'gb_Jokers',\n\tpos = { x = 4, y = 2 },\n\tcost = 6,\n\tblueprint_compat = true,\n    loc_vars = function(self, info_queue, card)\n        local cumulative_mult = 0\n        if G.playing_cards then\n            for _, playing_card in pairs(G.playing_cards) do\n                if playing_card:is_suit('Hearts') then\n                    cumulative_mult = cumulative_mult + card.ability.extra.mult_mod\n                end\n            end\n            for _, playing_card in pairs(G.playing_cards) do\n                if playing_card:is_suit('Spades') then\n                    cumulative_mult = cumulative_mult - card.ability.extra.mult_mod\n                end\n            end\n        end\n        return { vars = {\n            card.ability.extra.mult_mod,\n            math.max(0, cumulative_mult)\n        } }\n    end,\n    calculate = function(self, card, context)\n        if context.joker_main then \n            local cumulative_mult = 0\n            for _, playing_card in pairs(G.playing_cards) do\n                if playing_card:is_suit('Hearts') then\n                    cumulative_mult = cumulative_mult + card.ability.extra.mult_mod\n                end\n            end\n            for _, playing_card in pairs(G.playing_cards) do\n                if playing_card:is_suit('Spades') then\n                    cumulative_mult = cumulative_mult - card.ability.extra.mult_mod\n                end\n            end\n            card.ability.extra.mult = math.max(0, cumulative_mult)\n            return {\n                mult = card.ability.extra.mult\n            }\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "patchwork",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = 'patchwork',\n    loc_txt = {\n        name = 'Patchwork',\n        text = {\n            \"At start of shop,\",\n            \"create a random {C:dark_edition}Temporary{} Joker\",\n        }\n    },\n    rarity = 2,\n    atlas = 'gb_Jokers',\n    pos = { x = 0, y = 0 },\n    cost = 6,\n    blueprint_compat = true,\n    calculate = function(self, card, context)\n        if context.starting_shop then\n            SMODS.add_card {\n                set = \"Joker\",\n                edition = 'e_gb_temporary',\n                key_append = 'gb_patchwork'\n            }\n            card:juice_up()\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "taxman",
      "atlas": "Jokers",
      "pos": {
        "x": 5,
        "y": 0
      },
      "raw": "key = 'taxman',\n    loc_txt = {\n        name = 'Taxman',\n        text = {\n            \"{C:attention}Taxes half{} of your {C:attention}cashout\",\n            \"and gains {C:chips}+#2#{} Chips\",\n            \"for every {C:money}$1{} taken\",\n            \"{C:inactive}(Currently {C:chips}+#1#{C:inactive} Chips)\"\n        }\n    },\n    config = { extra = { chips = 0, chips_mod = 5 } },\n    rarity = 2,\n    cost = 8,\n    blueprint_compat = true,\n    atlas = 'Jokers',\n    pos = { x = 5, y = 0 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.chips, card.ability.extra.chips_mod } }\n    end,\n    calculate = function(self, card, context)\n        if context.cashed_out then\n            local tax = math.floor(context.cashout_dollars / 2)\n            if tax > 0 then\n                G.E_MANAGER:add_event(Event({\n                    trigger = 'after',\n                    delay = 0.5,\n                    blockable = false,\n                    func = function()\n                        card.ability.extra.chips = card.ability.extra.chips + card.ability.extra.chips_mod * tax\n                        ease_dollars(-tax)\n                        SMODS.calculate_effect({ message = \"Taxed!\", colour = G.C.MONEY }, card)\n                        return true\n                    end\n                }))\n            end\n        end\n        if context.joker_main then\n            return {\n                chips = card.ability.extra.chips\n            }\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "waterfall",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 9,
        "y": 3
      },
      "raw": "key = 'waterfall',\n    loc_txt = {\n        name = 'Waterfall',\n        text = {\n            \"This Joker gains {C:mult}+#1#{} Mult\",\n            \"for each scoring {C:attention}River Card{}\",\n            \"{C:inactive}(Currently {C:mult}+#2#{C:inactive} Mult)\",\n        }\n    },\n    config = { extra = { mult = 0, mult_mod = 3 } },\n    rarity = 2,\n    atlas = 'gb_Jokers',\n    pos = { x = 9, y = 3 },\n    cost = 5,\n    blueprint_compat = true,\n    perishable_compat = false,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.mult_mod, card.ability.extra.mult } }\n    end,\n    calculate = function(self, card, context)\n        if context.individual\n            and context.cardarea == G.play\n            and SMODS.has_enhancement(context.other_card, 'm_gb_river')\n            and not context.blueprint then\n            card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.mult_mod\n            return {\n                message = localize('k_upgrade_ex'),\n                colour = G.C.MULT,\n                message_card = card\n            }\n        end\n        if context.joker_main then\n            return {\n                mult = card.ability.extra.mult\n            }\n        end\n    end,\n    in_pool = function(self, args)\n        for _, playing_card in ipairs(G.playing_cards or {}) do\n            if SMODS.has_enhancement(playing_card, 'm_gb_river') then\n                return true\n            end\n        end\n        return false\n    end"
    },
    {
      "type": "Joker",
      "key": "yellow_pages",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 7,
        "y": 1
      },
      "raw": "key = 'yellow_pages',\n\tloc_txt = {\n\t\tname = 'Yellow Pages',\n\t\ttext = {\n\t\t\t\"The first {C:attention}#1#{} scoring\",\n\t\t\t\"{C:attention}numbered{} cards give\",\n\t\t\t\"{C:mult}Mult{} equal to their rank\",\n\t\t}\n\t},\n\tconfig = { extra = { scoring_tally = 0, cards_to_trigger = 3, trigger_cards = {} } },\n\trarity = 2,\n\tatlas = 'gb_Jokers',\n\tpos = { x = 7, y = 1 },\n\tcost = 5,\n\tblueprint_compat = true,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.cards_to_trigger } }\n\tend,\n    calculate = function(self, card, context)\n        if context.before then\n            card.ability.extra.scoring_tally = 0\n\t\t\tfor _, playing_card in ipairs(context.scoring_hand) do\n\t\t\t\tif not SMODS.has_no_rank(playing_card)\n\t\t\t\tand playing_card:get_id() >= 2\n\t\t\t\tand playing_card:get_id() <= 10 then\n\t\t\t\t\tif card.ability.extra.scoring_tally >= card.ability.extra.cards_to_trigger then\n\t\t\t\t\t\tbreak\n\t\t\t\t\telse\n\t\t\t\t\t\tcard.ability.extra.trigger_cards[#card.ability.extra.trigger_cards + 1] = playing_card\n\t\t\t\t\t\tcard.ability.extra.scoring_tally = card.ability.extra.scoring_tally + 1\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n        end\n\t\tif context.individual and context.cardarea == G.play then\n\t\t\tfor _, trigger_card in ipairs(card.ability.extra.trigger_cards) do\n\t\t\t\tif context.other_card == trigger_card then\n            \t\treturn {\n                \t\tmult = context.other_card.base.nominal\n\t\t\t\t\t}\n\t\t\t\tend\n\t\t\tend\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "d20",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 9,
        "y": 4
      },
      "raw": "key = 'd20',\n    loc_txt = {\n        name = 'D20',\n        text = {\n            \"{C:green}#2# in #1#{} chance to\",\n            \"{C:attention}enhance{} a drawn card\",\n        }\n    },\n    config = { extra = { odds = 20 } },\n    rarity = 3,\n    cost = 8,\n    atlas = 'gb_Jokers',\n    pos = { x = 9, y = 4 },\n    blueprint_compat = true,\n    soul_pos = { x = 8, y = 4 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.odds, G.GAME.probabilities.normal or 1 } }\n    end,\n    calculate = function(self, card, context)\n        if context.hand_drawn or context.other_drawn then\n\t\t    for _, playing_card in ipairs(context.hand_drawn or context.other_drawn) do\n\t\t\t    if SMODS.pseudorandom_probability(card, 'gb_d20', G.GAME.probabilities.normal, card.ability.extra.odds) then\n                    local valid_keys = {}\n                    for _, enhancement_center in pairs(G.P_CENTER_POOLS[\"Enhanced\"]) do\n                        if enhancement_center.key ~= 'm_stone' and not enhancement_center.overrides_base_rank then\n                            valid_keys[#valid_keys + 1] = enhancement_center.key\n                        end\n                    end\n                    playing_card:set_ability(\n                        pseudorandom_element(valid_keys, pseudoseed('d20')),\n                        nil,\n                        nil\n                    )\n                    playing_card:juice_up()\n                    return {\n                        message = \"Enhanced!\",\n                        colour = G.C.FILTER\n                    }\n                end\n\t\t    end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "double_king",
      "atlas": "Jokers",
      "pos": {
        "x": 5,
        "y": 2
      },
      "raw": "key = 'double_king',\n\tloc_txt = {\n\t\tname = 'Double King',\n\t\ttext = {\n\t\t\t\"If played hand contains two {C:attention}Kings{},\",\n\t\t\t\"this joker gains {X:mult,C:white}X#1#{} Mult and\",\n\t\t\t\"{C:red}destroys{} the leftmost {C:attention}King{}\",\n\t\t\t\"{C:inactive}(Currently {X:mult,C:white}X#2#{C:inactive} Mult)\"\n\t\t}\n\t},\n\tconfig = { extra = { xmult = 1, xmult_mod = 0.5, king_removed = false, activates = false } },\n\trarity = 3,\n\tatlas = 'Jokers',\n\tpos = { x = 5, y = 2 },\n\tcost = 7,\n\tblueprint_compat = true,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.xmult_mod, card.ability.extra.xmult } }\n\tend,\n    calculate = function(self, card, context)\n\t\tif context.before then\n\t\t\tcard.ability.extra.king_removed = false\n\t\t\tcard.ability.extra.activates = false\n\t\t\tlocal tally = 0\n            for _, playing_card in ipairs(context.scoring_hand) do\n                if playing_card:get_id() == 13 then\n\t\t\t\t\ttally = tally + 1\n\t\t\t\tend\n            end\n\t\t\tif tally >= 2 then\n\t\t\t\tcard.ability.extra.activates = true\n\t\t\t\tcard.ability.extra.xmult = card.ability.extra.xmult + card.ability.extra.xmult_mod\n\t\t\t\treturn {\n\t\t\t\t\tmessage = localize('k_upgrade_ex'),\n                \tcolour = G.C.MULT\n\t\t\t\t}\n\t\t\tend\n\t\tend\n        if context.joker_main then\n            return {\n                xmult = card.ability.extra.xmult\n\t\t\t}\n\t\tend\n\t\tif context.destroy_card then\n\t\t\tif card.ability.extra.activates then\n\t\t\t\tfor _, playing_card in ipairs(context.scoring_hand) do\n\t\t\t\t\tif playing_card:get_id() == 13 and context.destroy_card == playing_card and not card.ability.extra.king_removed then\n\t\t\t\t\t\tcard.ability.extra.king_removed = true\n\t\t\t\t\t\treturn { remove = true }\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend"
    },
    {
      "type": "Joker",
      "key": "forest_fire",
      "atlas": "Jokers",
      "pos": {
        "x": 5,
        "y": 3
      },
      "raw": "key = 'forest_fire',\n\tloc_txt = {\n\t\tname = 'Forest Fire',\n\t\ttext = {\n\t\t\t\"Enhances all played cards\",\n            \"in final hand into {C:attention}Wooden Cards{}\",\n\t\t}\n\t},\n\trarity = 3,\n\tatlas = 'Jokers',\n\tpos = { x = 5, y = 3 },\n\tcost = 7,\n\tblueprint_compat = false,\n\tloc_vars = function(self, info_queue, card)\n        info_queue[#info_queue + 1] = G.P_CENTERS.m_gb_wooden\n\tend,\n    calculate = function(self, card, context)\n        if context.before and context.main_eval and not context.blueprint and G.GAME.current_round.hands_left == 0 then\n            for _, scored_card in ipairs(context.full_hand) do\n                scored_card:set_ability('m_gb_wooden', nil, true)\n                 G.E_MANAGER:add_event(Event({\n                    func = function()\n                        scored_card:juice_up()\n                        return true\n                    end\n                }))\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "golden_cookie",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 0,
        "y": 4
      },
      "raw": "key = 'golden_cookie',\n    loc_txt = {\n        name = 'Golden Cookie',\n        text = {\n            \"{X:mult,C:white}X#1#{} Mult,\",\n            \"decreases by {X:mult,C:white}X#2#{} Mult\",\n            \"after hand scored\",\n        }\n    },\n    config = { extra = { xmult = 7, xmult_mod = 1.5 } },\n    rarity = 3,\n    atlas = 'gb_Jokers',\n    pos = { x = 0, y = 4 },\n    cost = 7,\n    blueprint_compat = true,\n    eternal_compat = false,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.xmult, card.ability.extra.xmult_mod } }\n    end,\n    calculate = function(self, card, context)\n        if context.joker_main then\n            return {\n                xmult = card.ability.extra.xmult,\n            }\n        end\n        if context.after and not context.blueprint then\n            card.ability.extra.xmult = card.ability.extra.xmult - card.ability.extra.xmult_mod\n            if card.ability.extra.xmult <= 1 then\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        play_sound('tarot1')\n                        card.T.r = -0.2\n                        card:juice_up(0.3, 0.4)\n                        card.states.drag.is = true\n                        card.children.center.pinch.x = true\n                        G.E_MANAGER:add_event(Event({\n                            trigger = 'after',\n                            delay = 0.3,\n                            blockable = false,\n                            func = function()\n                                card:remove()\n                                return true\n                            end\n                        }))\n                        return true\n                    end\n                }))\n                return {\n                    message = 'Eaten!',\n                    colour = G.C.FILTER\n                }\n            else           \n                return {\n                    message = 'Downgraded!',\n                    colour = G.C.FILTER\n                }\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "lobster_claw",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 9,
        "y": 1
      },
      "raw": "key = 'lobster_claw',\n    loc_txt = {\n        name = 'Lobster Claw',\n        text = {\n            \"Jokers give {C:mult}Mult{} equal to\",\n            \"the rank of a random\",\n            \"scoring card\",\n        }\n    },\n    rarity = 3,\n    atlas = 'gb_Jokers',\n    pos = { x = 9, y = 1 },\n    cost = 7,\n    blueprint_compat = true,\n    calculate = function(self, card, context)\n        if context.other_joker then\n            valid_cards = {}\n            for _, playing_card in ipairs(context.scoring_hand) do\n                if not SMODS.has_no_rank(playing_card) then\n                    table.insert(valid_cards, playing_card)\n                end\n            end\n            local random_card = pseudorandom_element(context.scoring_hand, pseudoseed('gb_lobster_claw'))\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    random_card:juice_up()\n                    return true\n                end\n            }))\n            return {\n                mult = random_card.base.nominal or 0,\n                message_card = context.other_joker\n            }\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "pentagram",
      "atlas": "Jokers",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = 'pentagram',\n\tloc_txt = {\n\t\tname = 'Pentagram',\n\t\ttext = {\n            \"This Joker gains {X:mult,C:white}X#1#{} Mult\",\n            \"for every {C:attention}consecutive{} hand with\",\n            \"{C:attention}five scoring cards{}\",\n            \"{C:inactive}(Currently {X:mult,C:white}X#2#{C:inactive} Mult)\",\n\t\t}\n\t},\n\tconfig = { extra = { xmult = 1, xmult_mod = 0.25 } },\n\trarity = 3,\n\tatlas = 'Jokers',\n\tpos = { x = 3, y = 0 },\n\tcost = 8,\n\tblueprint_compat = true,\n    perishable_compat = false,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.xmult_mod, card.ability.extra.xmult } }\n\tend,\n    calculate = function(self, card, context)\n        if context.before and context.main_eval and not context.blueprint then\n            local reset = true\n            if #context.scoring_hand >= 5 then\n                reset = false\n            end\n            if reset then\n                if card.ability.extra.xmult > 1 then\n                    card.ability.extra.xmult = 1\n                    return {\n                        message = localize('k_reset')\n                    }\n                end\n            else\n                card.ability.extra.xmult = card.ability.extra.xmult + card.ability.extra.xmult_mod\n                return {\n                    message = localize('k_upgrade_ex'),\n                    colour = G.C.MULT,\n                    message_card = card\n                }\n            end\n        end\n        if context.joker_main then\n            return {\n                xmult = card.ability.extra.xmult\n            }\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "the_moons_oceans",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 9,
        "y": 2
      },
      "raw": "key = 'the_moons_oceans',\n    loc_txt = {\n        name = 'The Moon\\'s Oceans',\n        text = {\n            \"Scored {C:attention}Aces{} retrigger once\",\n            \"and give {X:mult,C:white}X#1#{} Mult\",\n        }\n    },\n    config = { extra = { xmult = 1.5, retriggers = 1} },\n    rarity = 3,\n    atlas = 'gb_Jokers',\n    pos = { x = 9, y = 2 },\n    cost = 9,\n    blueprint_compat = true,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.xmult } }\n    end,\n    calculate = function(self, card, context)\n        if context.repetition and context.cardarea == G.play then\n            if context.other_card:get_id() == 14 then\n                return {\n                    repetitions = card.ability.extra.retriggers,\n                }\n            end\n            \n        end\n        if context.individual and context.cardarea == G.play and\n            context.other_card:get_id() == 14 then\n            return {\n                xmult = card.ability.extra.xmult,\n            }\n        end\n        \n    end"
    },
    {
      "type": "Joker",
      "key": "arm",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 7,
        "y": 1
      },
      "raw": "key = \"arm\",\n    loc_txt = {\n\t\tname = 'The Arm',\n\t\ttext = {\n\t\t\t\"Played poker hands either\",\n            \"lose {C:attention}#1#{} level or gain {C:attention}#2#{} levels\"\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 7, y = 1 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { level_loss = 1, level_gain = 2 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { \n            card.ability.extra.level_loss,\n            card.ability.extra.level_gain\n        } }\n    end,\n\n    calculate = function(self, card, context)\n        if context.before\n        and context.main_eval then\n            local level_choice = pseudorandom_element( { -card.ability.extra.level_loss, card.ability.extra.level_gain }, pseudoseed(\"gb_arm\") )\n            if G.GAME.HANDS[context.scoring_name].level > 1 and level_choice > 0 then\n                return {\n                    level_up = level_choice\n                }\n            end\n        end  \n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_arm\")\n    end"
    },
    {
      "type": "Joker",
      "key": "club",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"club\",\n    loc_txt = {\n\t\tname = 'The Club',\n\t\ttext = {\n            \"{C:clubs}Club{} cards give\",\n            \"{C:mult}+#1#{} Mult when scored\",\n            \"{V:1}#2#{} cards are {C:attention}debuffed\",\n            \"{C:inactive}(Changes at end of round)\",\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 2, y = 1 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { dollars = 2, debuffed_suit = \"Hearts\" } },\n    loc_vars = function(self, info_queue, card)\n        local suit = (G.GAME.current_round.gb_club_card or {}).suit or 'Spades'\n        return { vars = { \n            card.ability.extra.dollars,\n            localize(suit, 'suits_singular'),\n            colours = { G.C.SUITS[suit] }\n        } }\n    end,\n    calculate = function(self, card, context)\n        if context.ending_shop then\n            card.ability.extra.debuffed_suit = G.GAME.current_round.gb_club_card.suit\n        end\n        if context.individual\n        and context.other_card:is_suit(\"Clubs\")\n        and context.cardarea == G.play then\n            return {\n                dollars = card.ability.extra.dollars,\n                message_card = context.other_card\n            }\n        end\n        if context.debuff_card\n        and context.debuff_card.area ~= G.jokers\n        and context.debuff_card:is_suit(card.ability.extra.debuffed_suit) then\n            return {\n                debuff = true\n            }\n        end\n    end,\n\n    add_to_deck = function(self, card, from_debuff)\n        card.ability.extra.debuffed_suit = G.GAME.current_round.gb_club_card.suit\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_club\")\n    end"
    },
    {
      "type": "Joker",
      "key": "eye",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"eye\",\n    loc_txt = {\n\t\tname = 'The Eye',\n\t\ttext = {\n\t\t\t\"This Joker gains {X:mult,C:white}X#1#{} Mult for\",\n            \"every {C:attention}consecutive poker hand{}\",\n            \"that has not already been\",\n            \"played this round\",\n            \"{C:inactive}(Currently {X:mult,C:white}X#2#{C:inactive} Mult)\",\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 3, y = 0 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { xmult = 1, xmult_mod = 0.25 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.xmult_mod, card.ability.extra.xmult } }\n    end,\n    calculate = function(self, card, context)\n        if context.before\n        and context.main_eval\n        and not context.blueprint\n        and G.GAME.hands[context.scoring_name] and G.GAME.hands[context.scoring_name].played_this_round > 1 then\n            card.ability.extra.xmult = 1\n            return {\n                message = localize(\"k_reset\"),\n                colour = G.C.FILTER\n            }\n        end\n\n        if context.joker_main and context.main_eval and not G.GAME.hands[context.scoring_name].played_this_round > 1 then\n            card.ability.extra.xmult = card.ability.extra.xmult + card.ability.extra.xmult_mod\n            return {\n                xmult = card.ability.extra.xmult\n            }\n        end\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_eye\")\n    end"
    },
    {
      "type": "Joker",
      "key": "fish",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 8,
        "y": 1
      },
      "raw": "key = \"fish\",\n    loc_txt = {\n\t\tname = 'The Fish',\n\t\ttext = {\n\t\t\t\"Cards drawn after\",\n            \"a hand is played\",\n            \"{C:attention}permanently{} gain {C:chips}+#1#{} Chips\",\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 8, y = 1 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { chips = 10, prepped = nil, upgraded = nil } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { \n            card.ability.extra.chips\n        } }\n    end,\n\n    calculate = function(self, card, context)\n        if context.press_play then\n            card.ability.extra.prepped = true\n        end\n        if context.stay_flipped and context.to_area == G.hand and card.ability.extra.prepped then\n            context.other_card.ability.perma_bonus = (context.other_card.ability.perma_bonus or 0) + card.ability.extra.chips\n            card.ability.extra.upgraded = true\n        end\n        if context.setting_blind or context.hand_drawn then\n            card.ability.extra.prepped = nil\n            if card.ability.extra.upgraded then\n                card.ability.extra.upgraded = nil\n                return {\n                    message = localize(\"k_upgrade_ex\"),\n                    colour = G.C.CHIPS,\n                }\n            end\n        end\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_fish\")\n    end"
    },
    {
      "type": "Joker",
      "key": "flint",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "key = \"flint\",\n    loc_txt = {\n\t\tname = 'The Flint',\n\t\ttext = {\n\t\t\t\"Doubles {C:blue}Chips{} and {C:red}Mult{}\",\n            \"before scoring\",\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 4, y = 0 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    calculate = function(self, card, context)\n        if context.modify_hand then\n            mult = mult * 2\n            hand_chips = hand_chips * 2\n            update_hand_text({ sound = 'chips2', modded = true }, { chips = hand_chips, mult = mult })\n        end\n    end,\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_flint\")\n    end"
    },
    {
      "type": "Joker",
      "key": "goad",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"goad\",\n    loc_txt = {\n\t\tname = 'The Goad',\n\t\ttext = {\n            \"{C:spades}Spade{} cards give\",\n            \"{C:mult}+#1#{} Mult when scored\",\n            \"{V:1}#2#{} cards are {C:attention}debuffed\",\n            \"{C:inactive}(Changes at end of round)\",\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 0, y = 1 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { mult = 8, debuffed_suit = \"Hearts\" } },\n    loc_vars = function(self, info_queue, card)\n        local suit = (G.GAME.current_round.gb_goad_card or {}).suit or 'Hearts'\n        return { vars = { \n            card.ability.extra.mult,\n            localize(suit, 'suits_singular'),\n            colours = { G.C.SUITS[suit] }\n        } }\n    end,\n    calculate = function(self, card, context)\n        if context.ending_shop then\n            card.ability.extra.debuffed_suit = G.GAME.current_round.gb_goad_card.suit\n        end\n        if context.individual\n        and context.other_card:is_suit(\"Spades\")\n        and context.cardarea == G.play then\n            return {\n                mult = card.ability.extra.mult\n            }\n        end\n        if context.debuff_card\n        and context.debuff_card.area ~= G.jokers\n        and context.debuff_card:is_suit(card.ability.extra.debuffed_suit) then\n            return {\n                debuff = true\n            }\n        end\n    end,\n\n    add_to_deck = function(self, card, from_debuff)\n        card.ability.extra.debuffed_suit = G.GAME.current_round.gb_goad_card.suit\n    end,\n\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_goad\")\n    end"
    },
    {
      "type": "Joker",
      "key": "head",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"head\",\n    loc_txt = {\n\t\tname = 'The Head',\n\t\ttext = {\n            \"{C:hearts}Heart{} cards {C:attention}permanently\",\n            \"gain {C:chips}+#1#{} Chips when scored\",\n            \"{V:1}#2#{} cards are {C:attention}debuffed\",\n            \"{C:inactive}(Changes at end of round)\",\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 1, y = 1 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { chips = 20, debuffed_suit = \"Spades\" } },\n    loc_vars = function(self, info_queue, card)\n        local suit = (G.GAME.current_round.gb_head_card or {}).suit or 'Spades'\n        return { vars = { \n            card.ability.extra.chips,\n            localize(suit, 'suits_singular'),\n            colours = { G.C.SUITS[suit] }\n        } }\n    end,\n    calculate = function(self, card, context)\n        if context.ending_shop then\n            card.ability.extra.debuffed_suit = G.GAME.current_round.gb_head_card.suit\n        end\n        if context.individual\n        and context.other_card:is_suit(\"Hearts\") \n        and context.cardarea == G.play then\n            context.other_card.ability.perma_bonus = (context.other_card.ability.perma_bonus or 0) + card.ability.extra.chips\n            return {\n                message = localize('k_upgrade_ex'),\n                message_card = context.other_card,\n                colour = G.C.CHIPS\n            }\n        end\n        if context.debuff_card\n        and context.debuff_card.area ~= G.jokers\n        and context.debuff_card:is_suit(card.ability.extra.debuffed_suit) then\n            return {\n                debuff = true\n            }\n        end\n    end,\n\n    add_to_deck = function(self, card, from_debuff)\n        card.ability.extra.debuffed_suit = G.GAME.current_round.gb_head_card.suit\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_head\")\n    end"
    },
    {
      "type": "Joker",
      "key": "hook",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 4,
        "y": 1
      },
      "raw": "key = \"hook\",\n    loc_txt = {\n\t\tname = 'The Hook',\n\t\ttext = {\n\t\t\t\"When a {C:blue}Hand{} is played,\",\n\t\t\t\"{C:attention}#1#{} random card {C:attention}permanently\",\n            \"gains {C:mult}+#2#{} Mult and is {C:attention}discarded\",\n\t\t}\n\t},\n    blueprint_compat = false,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 4, y = 1 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { mult = 10, cards_discarded = 1 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.cards_discarded, card.ability.extra.mult } }\n    end,\n\n    calculate = function(self, card, context)\n        if context.press_play and #G.hand.cards > 0 then\n            local selected_card = nil\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    selected_card = pseudorandom_element(G.hand.cards, pseudoseed('gb_hook'))\n                    G.hand:add_to_highlighted(selected_card, true)\n                    play_sound('card1', 1)\n                    selected_card.ability.perma_mult = (selected_card.ability.perma_mult or 0) + card.ability.extra.mult\n                    SMODS.calculate_effect( {\n                        message = localize('k_upgrade_ex'),\n                        message_card = selected_card,\n                        colour = G.C.MULT\n                    }, card)\n                    G.FUNCS.discard_cards_from_highlighted(nil, true)\n                    return true\n                end\n            }))\n        end\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_hook\")\n    end"
    },
    {
      "type": "Joker",
      "key": "house",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 5,
        "y": 1
      },
      "raw": "key = \"house\",\n    loc_txt = {\n\t\tname = 'The House',\n\t\ttext = {\n\t\t\t\"Cards in first hand\",\n            \"are drawn {C:attention}face-down{} and\",\n            \"{C:attention}permanently{} gain {C:mult}+#1#{} Mult\",\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 5, y = 1 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { mult = 5 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.mult } }\n    end,\n\n    calculate = function(self, card, context)\n        if context.stay_flipped \n        and context.to_area == G.hand \n        and G.GAME.current_round.hands_played == 0 \n        and G.GAME.current_round.discards_used == 0 then\n            context.other_card.ability.perma_mult = (context.other_card.ability.perma_mult or 0) + card.ability.extra.mult\n            return {\n                stay_flipped = true\n            }\n        end\n        if context.first_hand_drawn then\n            return {\n                message = localize(\"k_upgrade_ex\"),\n                colour = G.C.MULT\n            }\n        end\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_house\")\n    end"
    },
    {
      "type": "Joker",
      "key": "mark",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "key = \"mark\",\n    loc_txt = {\n\t\tname = 'The Mark',\n\t\ttext = {\n\t\t\t\"All {C:attention}face{} cards are\",\n            \"drawn {C:attention}face-down{}\",\n            \"and give {X:mult,C:white}X#1#{} Mult when scored\"\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 2, y = 2 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { xmult = 1.5 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = {\n            card.ability.extra.xmult\n        } }\n    end,\n\n    calculate = function(self, card, context)\n        if context.stay_flipped and context.other_card:is_face() and context.to_area == G.hand then\n            return {\n                stay_flipped = true\n            }\n        end\n        if context.individual and context.other_card:is_face() and context.cardarea == G.play then\n            return {\n                xmult = card.ability.extra.xmult\n            }\n        end\n    end,\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_mark\")\n    end"
    },
    {
      "type": "Joker",
      "key": "mouth",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 9,
        "y": 0
      },
      "raw": "key = \"mouth\",\n    loc_txt = {\n\t\tname = 'The Mouth',\n\t\ttext = {\n            \"{C:attention}Retrigger{} all scoring cards\",\n            \"Must play {C:attention}most played poker hand\",\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 9, y = 0 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    calculate = function(self, card, context)\n        if context.repetition and context.cardarea == G.play then\n            return {\n                repetitions = 1\n            }\n        end\n        if context.debuff_hand then \n            local lower = false\n            local play_more_than = (G.GAME.hands[context.scoring_name].played or 0)\n            for k, v in pairs(G.GAME.hands) do\n                if k ~= context.scoring_name and v.played >= play_more_than and v.visible then\n                    lower = true\n                    break\n                end\n            end\n            if lower then\n                return {\n                    debuff = true,\n                    debuff_text = \"Must play most played poker hand\"\n                }\n            end\n        end\n    end,\n\n    remove_from_deck = function(self, card, from_debuff)\n        G.hand:change_size(-card.ability.extra.hand_size_tally)\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_mouth\")\n    end"
    },
    {
      "type": "Joker",
      "key": "needle",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"needle\",\n    loc_txt = {\n\t\tname = 'The Needle',\n\t\ttext = {\n\t\t\t\"{X:mult,C:white}X#1#{} on first hand of round\",\n\t\t\t\"{C:blue}#2#{} hand per round\",\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 0, y = 0 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { xmult = 4, hands = -1 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.xmult, card.ability.extra.hands } }\n    end,\n\n    calculate = function(self, card, context)\n        if context.setting_blind and not context.blueprint then\n           ease_hands_played(card.ability.extra.hands)\n        end\n        if context.joker_main\n        and context.main_eval\n        and G.GAME.current_round.hands_played == 0 then\n            return {\n                xmult = card.ability.extra.xmult\n            }\n        end\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_needle\")\n    end"
    },
    {
      "type": "Joker",
      "key": "ox",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"ox\",\n    loc_txt = {\n\t\tname = 'The Ox',\n\t\ttext = {\n\t\t\t\"Earn {C:money}$#1#{} at end of round\",\n\t\t\t\"{C:red}Lose $#2#{} if played hand is\",\n            \"your {C:attention}most played poker hand{}\",\n\t\t}\n\t},\n    blueprint_compat = false,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 1, y = 0 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { money = 10, dollars_loss = 5 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.money, card.ability.extra.dollars_loss } }\n    end,\n\n    calc_dollar_bonus = function(self, card)\n        return card.ability.extra.money\n    end,\n\n    calculate = function(self, card, context)\n        if context.before and context.main_eval and not context.blueprint then\n            local lower = false\n            local play_more_than = (G.GAME.hands[context.scoring_name].played or 0)\n            for k, v in pairs(G.GAME.hands) do\n                if k ~= context.scoring_name and v.played >= play_more_than and v.visible then\n                    lower = true\n                    break\n                end\n            end\n            if not lower then\n                return {\n                    dollars = -dollars_loss\n                }\n            end\n        end\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_ox\")\n    end"
    },
    {
      "type": "Joker",
      "key": "pillar",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 6,
        "y": 0
      },
      "raw": "key = \"pillar\",\n    loc_txt = {\n\t\tname = 'The Pillar',\n\t\ttext = {\n            \"Played cards previously\",\n            \"played this {C:attention}Ante permanently{}\",\n            \"gain {C:chips}+#1#{} Chips when scored\"\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 6, y = 0 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { chips = 20 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.chips } }\n    end,\n    calculate = function(self, card, context)\n        if context.individual\n        and context.main_eval\n        and context.cardarea == G.play\n        and context.other_card.played_this_ante == true then\n            context.other_card.ability.perma_bonus = (context.other_card.ability.perma_bonus or 0) + card.ability.extra.chips\n            return {\n                message = localize('k_upgrade_ex'),\n                message_card = context.other_card,\n                colour = G.C.CHIPS\n            }\n        end\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_pillar\")\n    end"
    },
    {
      "type": "Joker",
      "key": "plant",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 9,
        "y": 1
      },
      "raw": "key = \"plant\",\n    loc_txt = {\n\t\tname = 'The Plant',\n\t\ttext = {\n\t\t\t\"All {C:attention}face{} cards are {C:attention}debuffed\",\n            \"{X:mult,C:white}X#2#{} Mult for every\",\n            \"{C:attention}face{} card in {C:attention}full deck\",\n            \"{C:inactive}(Currently {X:mult,C:white}X#1#{C:inactive} Mult)\"\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 9, y = 1 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { xmult_mod = 0.25 } },\n    loc_vars = function(self, info_queue, card)\n        local face_tally = 0\n        for _, playing_card in pairs(G.playing_cards or {}) do\n            if playing_card:is_face(true) then\n                face_tally = face_tally + 1\n            end\n        end\n        return { vars = { \n            1 + card.ability.extra.xmult_mod * face_tally,\n            card.ability.extra.xmult_mod\n        } }\n    end,\n\n    calculate = function(self, card, context)\n        if context.debuff_card and context.debuff_card:is_face() then\n            return {\n                debuff_card = true\n            }\n        end\n        if context.joker_main then\n            local face_tally = 0\n            for _, playing_card in pairs(G.playing_cards or {}) do\n                if playing_card:is_face(true) then\n                    face_tally = face_tally + 1\n                end\n            end\n            return {\n                xmult = 1 + card.ability.extra.xmult_mod * face_tally\n            }\n        end\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_plant\")\n    end"
    },
    {
      "type": "Joker",
      "key": "psychic",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = \"psychic\",\n    loc_txt = {\n\t\tname = 'The Psychic',\n\t\ttext = {\n\t\t\t\"The {C:attention}fifth{} scoring card has a\",\n            \"{C:green}#1# in #2# chance{} to convert into\",\n            \"the {C:attention}first{} scoring card\"\n\t\t}\n\t},\n    blueprint_compat = false,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 0, y = 2 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { odds = 2 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { \n            G.GAME.probabilities.normal or 1,\n            card.ability.extra.odds\n        } }\n    end,\n\n    calculate = function(self, card, context)\n        if context.before\n        and context.scoring_hand[5]\n        and not context.blueprint\n        and SMODS.pseudorandom_probability(card, 'gb_psychic', G.GAME.probabilities.normal, card.ability.extra.odds) then\n            copy_card(context.scoring_hand[1], context.scoring_hand[5])\n            context.scoring_hand[5]:juice_up()\n            return {\n                message = \"Converted!\",\n                colour = G.C.FILTER\n            }\n        end\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_psychic\")\n    end"
    },
    {
      "type": "Joker",
      "key": "serpent",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 5,
        "y": 0
      },
      "raw": "key = \"serpent\",\n    loc_txt = {\n\t\tname = 'The Serpent',\n\t\ttext = {\n            \"{C:attention}+#1#{} hand size\",\n            \"Always draw {C:attention}#2#{} cards\",\n            \"after {C:blue}Play{} or {C:red}Discard{}\"\n\t\t}\n\t},\n    blueprint_compat = false,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 5, y = 0 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { hand_size = 2, cards_to_draw = 3 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.hand_size, card.ability.extra.cards_to_draw } }\n    end,\n    calculate = function(self, card, context)\n        if context.drawing_cards \n        and (G.GAME.current_round.hands_played ~= 0\n        or G.GAME.current_round.discards_used ~= 0)\n        and not context.blueprint then\n            return {\n                cards_to_draw = card.ability.extra.cards_to_draw\n            }\n        end\n    end,\n\n    add_to_deck = function(self, card, from_debuff)\n        G.hand:change_size(card.ability.extra.hand_size)\n    end,\n\n    remove_from_deck = function(self, card, from_debuff)\n        G.hand:change_size(-card.ability.extra.hand_size)\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_serpent\")\n    end"
    },
    {
      "type": "Joker",
      "key": "tooth",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "key = \"tooth\",\n    loc_txt = {\n\t\tname = 'The Tooth',\n\t\ttext = {\n\t\t\t\"Earn {C:money}$#1#{} for every card played\",\n            \"Lose {C:red}$#2#{} at end of round\"\n\t\t}\n\t},\n    blueprint_compat = false,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 1, y = 2 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { money = 6, dollars = 1 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = {\n            card.ability.extra.dollars,\n            card.ability.extra.money\n        } }\n    end,\n\n    calc_dollar_bonus = function(self, card)\n        return -card.ability.extra.money\n    end,\n\n    calculate = function(self, card, context)\n        if context.press_play and not context.blueprint then\n            G.E_MANAGER:add_event(Event({\n                trigger = 'after',\n                delay = 0.2,\n                func = function()\n                    for i = 1, #G.play.cards do\n                        G.E_MANAGER:add_event(Event({\n                            func = function()\n                                G.play.cards[i]:juice_up()\n                                return true\n                            end,\n                        }))\n                        ease_dollars(card.ability.extra.dollars)\n                        delay(0.23)\n                    end\n                    return true\n                end\n            }))\n            delay(0.4)\n        end\n    end,\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_tooth\")\n    end"
    },
    {
      "type": "Joker",
      "key": "wall",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"wall\",\n    loc_txt = {\n\t\tname = 'The Wall',\n\t\ttext = {\n\t\t\t\"{C:red}X#1#{C:attention} Boss Blind{} size\",\n            \"{X:mult,C:white}X#2#{} Mult for every {C:attention}Stone{} card\",\n            \"in {C:attention}full deck{}\",\n            \"{C:inactive}(Currently {X:mult,C:white}X#3#{C:inactive} Mult)\"\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 2, y = 0 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { boss_blind_size = 2, xmult_mod = 0.25 } },\n    loc_vars = function(self, info_queue, card)\n        local stone_tally = 0\n        if G.playing_cards then\n            for _, playing_card in ipairs(G.playing_cards) do\n                if SMODS.has_enhancement(playing_card, 'm_stone') then stone_tally = stone_tally + 1 end\n            end\n        end\n        return { vars = { card.ability.extra.boss_blind_size, card.ability.extra.xmult_mod, 1 + card.ability.extra.xmult_mod * stone_tally } }\n    end,\n\n    calculate = function(self, card, context)\n        if context.setting_blind and G.GAME.blind.boss then\n            G.GAME.blind.chips = G.GAME.blind.chips * card.ability.extra.boss_blind_size\n            G.GAME.blind.chip_text = number_format(G.GAME.blind.chips)\n            play_sound(\"cancel\")\n            card:juice_up()\n        end\n        if context.joker_main and context.main_eval then\n            local stone_tally = 0\n            if G.playing_cards then\n                for _, playing_card in ipairs(G.playing_cards) do\n                    if SMODS.has_enhancement(playing_card, 'm_stone') then stone_tally = stone_tally + 1 end\n                end\n            end\n            if stone_tally > 0 then\n                return {\n                    xmult = 1 + card.ability.extra.xmult_mod * stone_tally\n                }\n            end\n        end\n    end,\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_wall\")\n    end"
    },
    {
      "type": "Joker",
      "key": "water",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 8,
        "y": 0
      },
      "raw": "key = \"water\",\n    loc_txt = {\n\t\tname = 'The Water',\n\t\ttext = {\n            \"When {C:attention}Blind{} is selected,\",\n            \"lose all {C:red}discards{}\",\n            \"{C:attention}+#1#{} hand size for\",\n            \"every {C:attention}#4# {C:red}discards{} lost\",\n            \"{C:inactive}(Currently {C:attention}+#3#{C:inactive} hand size)\",\n            \"{C:inactive}({C:attention}#2#{C:inactive}/#4#)\"\n\t\t}\n\t},\n    blueprint_compat = false,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 8, y = 0 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { hand_size_mod = 1, hand_size_tally = 0, discard_tally = 0, discards = 7 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = {\n            card.ability.extra.hand_size_mod,\n            card.ability.extra.discard_tally,\n            card.ability.extra.hand_size_tally,\n            card.ability.extra.discards\n        } }\n    end,\n    calculate = function(self, card, context)\n        if context.setting_blind and not context.blueprint then\n            card.ability.extra.discard_tally = card.ability.extra.discard_tally + G.GAME.current_round.discards_left\n            ease_discard(-G.GAME.current_round.discards_left, nil, true)\n            if card.ability.extra.discard_tally >= card.ability.extra.discards then\n                card.ability.extra.discard_tally = card.ability.extra.discard_tally - card.ability.extra.discards\n                G.hand:change_size(card.ability.extra.hand_size_mod)\n                card.ability.extra.hand_size_tally = card.ability.extra.hand_size_tally + card.ability.extra.hand_size_mod\n                return {\n                    message = \"+\" .. card.ability.extra.hand_size_mod,\n                    colour = G.C.FILTER\n                }\n            else\n                return {\n                    message = card.ability.extra.discard_tally .. \"/\" .. card.ability.extra.discards,\n                    colour = G.C.FILTER\n                }\n            end\n        end\n    end,\n\n    remove_from_deck = function(self, card, from_debuff)\n        G.hand:change_size(-card.ability.extra.hand_size_tally)\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_water\")\n    end"
    },
    {
      "type": "Joker",
      "key": "wheel",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 6,
        "y": 1
      },
      "raw": "key = \"wheel\",\n    loc_txt = {\n\t\tname = 'The Wheel',\n\t\ttext = {\n\t\t\t\"{C:green}#4# in #3# chance{} to\",\n            \"draw a card {C:attention}face-down{} and\",\n            \"give this Joker {X:mult,C:white}X#2#{} Mult\",\n            \"{C:inactive}(Currently {X:mult,C:white}X#1#{C:inactive} Mult)\",\n\n\t\t}\n\t},\n    blueprint_compat = false,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 6, y = 1 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { odds = 7, xmult = 1, xmult_mod = 0.1, flipped_cards = false } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { \n            card.ability.extra.xmult,\n            card.ability.extra.xmult_mod,\n            card.ability.extra.odds,\n            G.GAME.probabilities.normal or 1\n        } }\n    end,\n\n    calculate = function(self, card, context)\n        if context.stay_flipped \n        and context.to_area == G.hand \n        and not context.blueprint\n        and SMODS.pseudorandom_probability(card, 'gb_wheel', G.GAME.probabilities.normal, card.ability.extra.odds) then\n            card.ability.extra.xmult = card.ability.extra.xmult + card.ability.extra.xmult_mod\n            card.ability.extra.flipped_cards = true\n            return {\n                stay_flipped = true\n            }\n        end\n        if context.hand_drawn and card.ability.extra.flipped_cards == true then\n            card.ability.extra.flipped_cards = false\n            return {\n                message = localize(\"k_upgrade_ex\"),\n                colour = G.C.MULT\n            }\n        end\n        if context.joker_main then\n            return {\n                xmult = card.ability.extra.xmult\n            }\n        end\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_wheel\")\n    end"
    },
    {
      "type": "Joker",
      "key": "window",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"window\",\n    loc_txt = {\n\t\tname = 'The Window',\n\t\ttext = {\n            \"{C:diamonds}Diamond{} cards retrigger {C:attention}#1#{} time\",\n            \"{V:1}#2#{} cards are {C:attention}debuffed\",\n            \"{C:inactive}(Changes at end of round)\",\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 3, y = 1 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { retriggers = 1, debuffed_suit = \"Hearts\" } },\n    loc_vars = function(self, info_queue, card)\n        local suit = (G.GAME.current_round.gb_window_card or {}).suit or 'Spades'\n        return { vars = { \n            card.ability.extra.retriggers,\n            localize(suit, 'suits_singular'),\n            colours = { G.C.SUITS[suit] }\n        } }\n    end,\n    calculate = function(self, card, context)\n        if context.ending_shop then\n            card.ability.extra.debuffed_suit = G.GAME.current_round.gb_window_card.suit\n        end\n        if context.repetition\n        and not context.other_card.debuff\n        and context.other_card:is_suit(\"Diamonds\") \n        and context.cardarea == G.play then\n            context.other_card.ability.perma_bonus = (context.other_card.ability.perma_bonus or 0) + card.ability.extra.chips\n            return {\n                repetitons = card.ability.extra.retriggers,\n            }\n        end\n        if context.debuff_card\n        and context.debuff_card.area ~= G.jokers\n        and context.debuff_card:is_suit(card.ability.extra.debuffed_suit) then\n            return {\n                debuff = true\n            }\n        end\n    end,\n\n    add_to_deck = function(self, card, from_debuff)\n        card.ability.extra.debuffed_suit = G.GAME.current_round.gb_window_card.suit\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_window\")\n    end"
    },
    {
      "type": "Joker",
      "key": "cosmic_diamond",
      "atlas": "gb_ShatteredJokers",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"cosmic_diamond\",\n    loc_txt = {\n\t\tname = 'Cosmic Diamond',\n\t\ttext = {\n\t\t\t\"Earn {C:money}$#1#{} at end of round\",\n\t\t\t\"Payout increases by {C:money}$#2#{} for every\",\n            \"{C:attention}#4#{} scored {C:diamonds}Diamonds{} {C:inactive}(#3#/#4#)\"\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_ShatteredJokers',\n\tpos = { x = 0, y = 1 },\n    rarity = \"gb_shattered\",\n    cost = 10,\n    config = { extra = { dollars = 1, dollars_mod = 1, diamond_tally = 0, diamonds = 5 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.dollars, card.ability.extra.dollars_mod, card.ability.extra.diamond_tally, card.ability.extra.diamonds } }\n    end,\n    calc_dollar_bonus = function(self, card)\n        return card.ability.extra.dollars\n    end,\n    calculate = function(self, card, context)\n         if context.individual and context.cardarea == G.play and context.other_card:is_suit(\"Diamonds\") and not context.blueprint then\n            card.ability.extra.diamond_tally = card.ability.extra.diamond_tally + 1\n            if card.ability.extra.diamond_tally >= card.ability.extra.diamonds then\n                card.ability.extra.dollars = card.ability.extra.dollars + card.ability.extra.dollars_mod\n                card.ability.extra.diamond_tally = card.ability.extra.diamond_tally - card.ability.extra.diamonds\n                return {\n                    message = localize('k_upgrade_ex'),\n                    colour = G.C.MONEY,\n                    message_card = card\n                }\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "divination",
      "atlas": "gb_ShatteredJokers",
      "pos": {
        "x": 5,
        "y": 0
      },
      "raw": "key = 'divination',\n    loc_txt = {\n        name = 'Divination',\n        text = {\n            \"{C:green}#1# in #2#{} chance to create\",\n            \"a random {C:spectral}Spectral{} card when\",\n            \"any {C:attention}Booster Pack{} is skipped\",\n        }\n    },\n    blueprint_compat = true,\n\tatlas = 'gb_ShatteredJokers',\n\tpos = { x = 5, y = 0 },\n    rarity = \"gb_shattered\",\n    cost = 10,\n    config = { extra = { odds = 2 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { G.GAME.probabilities.normal or 1, card.ability.extra.odds } }\n    end,\n    calculate = function(self, card, context)\n        if context.skipping_booster then\n            if SMODS.pseudorandom_probability(card, 'gb_divination', G.GAME.probabilities.normal, card.ability.extra.odds) then\n                G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1\n                G.E_MANAGER:add_event(Event({\n                    trigger = 'before',\n                    delay = 0.0,\n                    func = (function()\n                        SMODS.add_card {\n                            set = 'Spectral',\n                            key_append = 'gb_divination'\n                        }\n                        G.GAME.consumeable_buffer = 0\n                        return true\n                    end)\n                }))\n                return {\n                    message = \"+1 Spectral\",\n                    colour = G.C.SECONDARY_SET.Spectral,\n                }\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "golden_ratio",
      "atlas": "gb_ShatteredJokers",
      "pos": {
        "x": 4,
        "y": 1
      },
      "raw": "key = \"golden_ratio\",\n    loc_txt = {\n\t\tname = 'Golden Ratio',\n\t\ttext = {\n\t\t\t\"Scored {C:attention}Ace{}s, {C:attention}3{}s, {C:attention}6{}s and {C:attention}8{}s\",\n\t\t\t\"are enhanced to {C:attention}Gold Cards{}\",\n            \"and give {X:mult,C:white}X#1#{} Mult\",\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_ShatteredJokers',\n\tpos = { x = 4, y = 1 },\n    rarity = \"gb_shattered\",\n    cost = 10,\n    config = { extra = { xmult = 1.5 } },\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue + 1] = G.P_CENTERS.m_gold\n        return { vars = { card.ability.extra.xmult } }\n    end,\n    calculate = function(self, card, context)\n        if context.before and context.main_eval and not context.blueprint then\n            local cards = 0\n            for _, scored_card in ipairs(context.scoring_hand) do\n                if (\n                scored_card:get_id() == 3\n                or scored_card:get_id() == 6\n                or scored_card:get_id() == 8\n                or scored_card:get_id() == 14\n                ) then\n                    cards = cards + 1\n                    scored_card:set_ability('m_gold', nil, true)\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            scored_card:juice_up()\n                            return true\n                        end\n                    }))\n                end\n            end\n            if cards > 0 then\n                return {\n                    message = localize('k_gold'),\n                    colour = G.C.MONEY\n                }\n            end\n        end\n        if context.individual and context.cardarea == G.play and\n            (\n                context.other_card:get_id() == 3\n                or context.other_card:get_id() == 6\n                or context.other_card:get_id() == 8\n                or context.other_card:get_id() == 14\n            ) then\n            return {\n                xmult = card.ability.extra.xmult\n\t\t\t}\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "jimbo",
      "atlas": "gb_ShatteredJokers",
      "pos": {
        "x": 7,
        "y": 0
      },
      "raw": "key = 'jimbo',\n\tloc_txt = {\n\t\tname = 'Jimbo',\n\t\ttext = {\n\t\t\t\"{X:mult,C:white}X#1#{} Mult\",\n\t\t}\n\t},\n\tconfig = { extra = { xmult = 4 } },\n\tblueprint_compat = true,\n\tatlas = 'gb_ShatteredJokers',\n\tpos = { x = 7, y = 0 },\n    soul_pos = { x = 7, y = 2 },\n    rarity = \"gb_shattered\",\n    cost = 10,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.xmult } }\n\tend,\n    calculate = function(self, card, context)\n        if context.joker_main then\n            return {\n                xmult = card.ability.extra.xmult\n            }\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "lighthouse",
      "atlas": "gb_ShatteredJokers",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = 'lighthouse',\n    loc_txt = {\n        name = 'Lighthouse',\n        text = {\n            \"{X:mult,C:white}X#1#{} Mult for every\",\n            \"{C:attention}Joker{} to the right of this one\",\n            \"{C:inactive}(Currently {X:mult,C:white}X#2#{C:inactive} Mult)\",\n        }\n    },\n    config = { extra = { xmult = 1, xmult_mod = 0.75 } },\n    blueprint_compat = true,\n\tatlas = 'gb_ShatteredJokers',\n\tpos = { x = 2, y = 0 },\n    rarity = \"gb_shattered\",\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        local position = 0\n        if card.area and card.area == G.jokers then\n            for k, joker in ipairs(G.jokers.cards) do\n                if joker == card then\n                    position = #G.jokers.cards - k\n                    break\n                end\n            end\n            return { vars = { card.ability.extra.xmult_mod, 1 + card.ability.extra.xmult_mod * position} }\n        else\n            return { vars = { card.ability.extra.xmult_mod, 1 } }\n        end\n            \n    end,\n    calculate = function(self, card, context)\n        if context.joker_main then\n            local position = 0\n            for k, joker in ipairs(G.jokers.cards) do\n                if joker == card then\n                    position = #G.jokers.cards - k\n                    break\n                end\n            end\n            card.ability.extra.xmult = 1 + card.ability.extra.xmult_mod * position\n            return { \n                xmult = card.ability.extra.xmult\n            }\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "lovecraftian_horror",
      "atlas": "gb_ShatteredJokers",
      "pos": {
        "x": 5,
        "y": 2
      },
      "raw": "key = 'lovecraftian_horror',\n    loc_txt = {\n        name = 'Lovecraftian Horror',\n        text = {\n            \"When a card is discarded, {C:green}#3# in #4#{} chance\",\n            \"for this Joker to gain {X:mult,C:white}X#2#{} Mult\",\n            \"and {C:attention}destroy{} the discarded card\",\n            \"{C:inactive}(Currently {X:mult,C:white}X#1#{C:inactive} Mult)\",\n        }\n    },\n    config = { extra = { xmult = 1, xmult_mod = 0.25, odds = 6 } },\n    blueprint_compat = true,\n\tatlas = 'gb_ShatteredJokers',\n\tpos = { x = 5, y = 2 },\n    soul_pos = { x = 6, y = 2 },\n    rarity = \"gb_shattered\",\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        return { vars = {\n            card.ability.extra.xmult,\n            card.ability.extra.xmult_mod,\n            G.GAME.probabilities.normal or 1,\n            card.ability.extra.odds\n        } }\n    end,\n    calculate = function(self, card, context)\n        if context.discard then\n            if SMODS.pseudorandom_probability(card, 'gb_lovecraftian_horror', G.GAME.probabilities.normal, card.ability.extra.odds) then\n                card.ability.extra.xmult = card.ability.extra.xmult + card.ability.extra.xmult_mod\n                return {\n                    message = localize('k_upgrade_ex'),\n                    colour = G.C.MULT,\n                    remove = true\n                }\n            end\n        end\n        if context.joker_main and context.main_eval then\n            return {\n                xmult = card.ability.extra.xmult\n            }\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "lure",
      "atlas": "gb_ShatteredJokers",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = 'lure',\n    loc_txt = {\n        name = 'Lure',\n        text = {\n            \"{X:mult,C:white}X#1#{} Mult\",\n            \"{C:green}#2# in #3#{} chance at end of round to\",\n            \"{C:attention}reel something in{}\",\n        }\n    },\n    config = { extra = { xmult = 1.5, odds = 6 } },\n    blueprint_compat = true,\n\tatlas = 'gb_ShatteredJokers',\n\tpos = { x = 0, y = 2 },\n    rarity = \"gb_shattered\",\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.xmult, G.GAME.probabilities.normal or 1, card.ability.extra.odds } }\n    end,\n    calculate = function(self, card, context)\n        if context.joker_main and context.main_eval then\n            return {\n                xmult = card.ability.extra.xmult\n            }\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval and not context.blueprint then\n            if SMODS.pseudorandom_probability(card, 'gb_lure', G.GAME.probabilities.normal, card.ability.extra.odds) then\n                SMODS.add_card{\n                    set = 'Joker',\n                    key = \"j_gb_lovecraftian_horror\",\n                    no_edition = true\n                }\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        play_sound('tarot1')\n                        card.T.r = -0.2\n                        card:juice_up(0.3, 0.4)\n                        card.states.drag.is = true\n                        card.children.center.pinch.x = true\n                        G.E_MANAGER:add_event(Event({\n                            trigger = 'after',\n                            delay = 0.3,\n                            blockable = false,\n                            func = function()\n                                card:remove()\n                                return true\n                            end\n                        }))\n                        return true\n                    end\n                }))            \n                return {\n                    message = 'Caught!',\n                    colour = G.C.FILTER\n                }\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "melting_face",
      "atlas": "gb_ShatteredJokers",
      "pos": {
        "x": 6,
        "y": 0
      },
      "raw": "key = 'melting_face',\n\tloc_txt = {\n\t\tname = 'Melting Face',\n\t\ttext = {\n\t\t\t\"{C:attention}Face{} cards give\",\n            \"{C:chips}+#1#{} Chips and {C:mult}+#2#{} Mult\",\n            \"for every scoring {C:attention}face{} card\",\n\t\t}\n\t},\n\tconfig = { extra = { mult = 4, chips = 20, faces = 0} },\n\tblueprint_compat = true,\n\tatlas = 'gb_ShatteredJokers',\n\tpos = { x = 6, y = 0 },\n    rarity = \"gb_shattered\",\n    cost = 10,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.chips, card.ability.extra.mult } }\n\tend,\n    calculate = function(self, card, context)\n        if context.before and context.main_eval then\n            card.ability.extra.faces = 0\n            for _, playing_card in ipairs(context.scoring_hand) do\n                if playing_card:is_face() then\n                    card.ability.extra.faces = card.ability.extra.faces + 1\n                end\n            end\n        end\n        if context.individual and context.cardarea == G.play and context.other_card:is_face() then\n            return {\n                chips = card.ability.extra.chips * card.ability.extra.faces,\n                mult = card.ability.extra.mult * card.ability.extra.faces\n            }\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "memory_leak",
      "atlas": "gb_ShatteredJokers",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "key = 'memory_leak',\n    loc_txt = {\n        name = 'Memory Leak',\n        text = {\n            \"Gives between {X:mult,C:white}X#1#{} and {X:mult,C:white}X#2#{} Mult\",\n            \"{C:attention}Maximum{} value {C:attention}increases{} by {X:mult,C:white}X#3#{}\",\n            \"before hand scored\"\n        }\n    },\n    config = { extra = { xmult_min = 1, xmult_max = 1, xmult_mod = 0.2 } },\n    blueprint_compat = true,\n\tatlas = 'gb_ShatteredJokers',\n\tpos = { x = 1, y = 2 },\n    rarity = \"gb_shattered\",\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.xmult_min, card.ability.extra.xmult_max, card.ability.extra.xmult_mod } }\n    end,\n    calculate = function(self, card, context)\n        if context.joker_main then\n            card.ability.extra.xmult_max = card.ability.extra.xmult_max + card.ability.extra.xmult_mod\n            local random_mult = pseudorandom('gb_memory_leak', card.ability.extra.xmult_min * 10, card.ability.extra.xmult_max * 10) * 0.1\n            return {\n                xmult = random_mult\n            }\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "monolith",
      "atlas": "gb_ShatteredJokers",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"monolith\",\n    loc_txt = {\n\t\tname = 'Monolith',\n\t\ttext = {\n\t\t\t\"{X:mult,C:white}X#2#{} Mult, loses {X:mult,C:white}X#1#{} Mult\",\n\t\t\t\"if played hand is not \",\n            \"{C:attention}most played poker hand{}\",\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_ShatteredJokers',\n\tpos = { x = 0, y = 0 },\n    rarity = \"gb_shattered\",\n    cost = 10,\n    config = { extra = { xmult_loss = 0.25, xmult = 4 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.xmult_loss, card.ability.extra.xmult } }\n    end,\n    calculate = function(self, card, context)\n        if context.before and context.main_eval and not context.blueprint then\n            local lower = false\n            local play_more_than = (G.GAME.hands[context.scoring_name].played or 0)\n            for k, v in pairs(G.GAME.hands) do\n                if k ~= context.scoring_name and v.played >= play_more_than and v.visible then\n                    lower = true\n                    break\n                end\n            end\n            if lower then\n                card.ability.extra.xmult = card.ability.extra.xmult - card.ability.extra.xmult_loss\n                if card.ability.extra.xmult <= 1 then\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            play_sound('tarot1')\n                            card.T.r = -0.2\n                            card:juice_up(0.3, 0.4)\n                            card.states.drag.is = true\n                            card.children.center.pinch.x = true\n                            G.E_MANAGER:add_event(Event({\n                                trigger = 'after',\n                                delay = 0.3,\n                                blockable = false,\n                                func = function()\n                                    card:remove()\n                                    return true\n                                end\n                            }))\n                            return true\n                        end\n                    }))\n                    return {\n                    message = \"Shattered!\",\n                    colour = G.C.RED\n                    }\n                else\n                    return {\n                        message = \"Downgraded!\",\n                        colour = G.C.MULT\n                    }\n                end\n            end\n        end\n        if context.joker_main then\n            return {\n                xmult = card.ability.extra.xmult\n            }\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "ornate_vase",
      "atlas": "gb_ShatteredJokers",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"ornate_vase\",\n    loc_txt = {\n\t\tname = 'Ornate Vase',\n\t\ttext = {\n\t\t\t\"This Joker gains {X:mult,C:white}X#1#{} Mult if\",\n\t\t\t\"played hand contains scoring cards\",\n            \"of {C:attention}3 or more{} different suits\",\n            \"{C:inactive}(Currently {X:mult,C:white}X#2#{C:inactive} Mult)\"\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_ShatteredJokers',\n\tpos = { x = 1, y = 0 },\n    rarity = \"gb_shattered\",\n    cost = 10,\n    config = { extra = { xmult_mod = 0.25, xmult = 1 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.xmult_mod, card.ability.extra.xmult } }\n    end,\n    calculate = function(self, card, context)\n        if context.before and context.main_eval and not context.blueprint then\n            local scored_suits = {}\n            for _, c in ipairs(context.scoring_hand) do\n                if c.base.suit and not scored_suits[c.base.suit] then scored_suits[c.base.suit] = true end\n            end\n\n            local suitamt = 0\n            for _, _ in pairs(scored_suits) do\n                suitamt = suitamt + 1\n            end\n\n            if suitamt >= 3 then\n                card.ability.extra.xmult = card.ability.extra.xmult + card.ability.extra.xmult_mod\n                return {\n                    message = localize('k_upgrade_ex'),\n                    colour = G.C.MULT,\n                    message_card = card\n                }\n            end\n        end\n        if context.joker_main then\n            return {\n                xmult = card.ability.extra.xmult\n            }\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "phase_charts",
      "atlas": "gb_ShatteredJokers",
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "key = 'phase_charts',\n\tloc_txt = {\n\t\tname = 'Phase Charts',\n\t\ttext = {\n\t\t\t\"This Joker gains {X:mult,C:white}X#1#{} Mult\",\n            \"at end of round, {C:attention}resets{} at {X:mult,C:white}X#3#{}\",\n            \"{C:inactive}(Currently {X:mult,C:white}X#2#{C:inactive} Mult)\"\n\t\t}\n\t},\n\tconfig = { extra = { xmult = 1, xmult_mod = 1, xmult_limit = 5 } },\n\tblueprint_compat = true,\n\tatlas = 'gb_ShatteredJokers',\n\tpos = { x = 4, y = 0 },\n    rarity = \"gb_shattered\",\n    cost = 10,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.xmult_mod, card.ability.extra.xmult, card.ability.extra.xmult_limit } }\n\tend,\n    calculate = function(self, card, context)\n        if context.joker_main then\n            return {\n                xmult = card.ability.extra.xmult\n            }\n        end\n        if context.end_of_round and not context.blueprint then\n            card.ability.extra.xmult = card.ability.extra.xmult + card.ability.extra.xmult_mod\n            if card.ability.extra.xmult > card.ability.extra.xmult_limit then\n                card.ability.extra.xmult = 1\n                return {\n                    message = localize('k_reset'),\n                    colour = G.C.MULT\n                }\n            else\n                return {\n                    message = localize('k_upgrade_ex'),\n                    colour = G.C.MULT\n                }\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "pure_essence",
      "atlas": "gb_ShatteredJokers",
      "pos": {
        "x": 7,
        "y": 0
      },
      "raw": "key = 'pure_essence',\n\tloc_txt = {\n\t\tname = 'Pure Essence',\n\t\ttext = {\n\t\t\t\"Sell this Joker to create\",\n            \"a random {C:legendary,E:1}Legendary{} Joker\",\n\t\t}\n\t},\n\tblueprint_compat = false,\n\tatlas = 'gb_ShatteredJokers',\n\tpos = { x = 7, y = 0 },\n    soul_pos = { x = 7, y = 1 },\n    rarity = \"gb_shattered\",\n    cost = 10,\n    calculate = function(self, card, context)\n        if context.selling_self and not context.blueprint then\n            G.E_MANAGER:add_event(Event({\n                trigger = 'after',\n                delay = 0.4,\n                func = function()\n                    play_sound('timpani')\n                    SMODS.add_card({ set = 'Joker', legendary = true })\n                    check_for_unlock { type = 'spawn_legendary' }\n                    card:juice_up(0.3, 0.5)\n                    return true\n                end\n            }))\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "purple_rain",
      "atlas": "gb_ShatteredJokers",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"purple_rain\",\n    loc_txt = {\n\t\tname = 'Purple Rain',\n\t\ttext = {\n\t\t\t\"Retriggers every {C:attention}scoring card{} once\",\n            \"for every {C:attention}non-scoring card{}\",\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_ShatteredJokers',\n\tpos = { x = 3, y = 0 },\n    rarity = \"gb_shattered\",\n    cost = 10,\n    config = { extra = { repetitions = 0 } },\n    calculate = function(self, card, context)\n        if context.before and context.main_eval then\n            card.ability.extra.repetitions = 0\n            for _, _ in ipairs(context.full_hand) do\n                card.ability.extra.repetitions = card.ability.extra.repetitions + 1\n            end\n            for _, _ in ipairs(context.scoring_hand) do\n                card.ability.extra.repetitions = card.ability.extra.repetitions - 1\n            end\n        end\n        if context.repetition and context.cardarea == G.play then\t\n            return {\n                repetitions = card.ability.extra.repetitions\n            }\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "supercharger",
      "atlas": "gb_ShatteredJokers",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = 'supercharger',\n\tloc_txt = {\n\t\tname = 'Supercharger',\n\t\ttext = {\n\t\t\t\"{C:attention}Bonus Cards{} and {C:attention}Mult Cards{}\",\n\t\t\t\"give {X:mult,C:white}X#1#{} Mult when scored\",\n\t\t}\n\t},\n\tconfig = { extra = { xmult = 1.5 } },\n\tblueprint_compat = true,\n\tatlas = 'gb_ShatteredJokers',\n\tpos = { x = 3, y = 1 },\n    rarity = \"gb_shattered\",\n    cost = 10,\n\tloc_vars = function(self, info_queue, card)\n\t\tinfo_queue[#info_queue + 1] = G.P_CENTERS.m_bonus\n\t\tinfo_queue[#info_queue + 1] = G.P_CENTERS.m_mult\n\t\treturn { vars = { card.ability.extra.xmult } }\n\tend,\n    calculate = function(self, card, context)\n        if context.individual and context.cardarea == G.play and\n            SMODS.has_enhancement(context.other_card, 'm_bonus') then\n            return {\n                xmult = card.ability.extra.xmult\n\t\t\t}\n        end\n        if context.individual and context.cardarea == G.play and\n            SMODS.has_enhancement(context.other_card, 'm_mult') then\n            return {\n                chips = card.ability.extra.chips\n\t\t\t}\n        end\n    end"
    },
    {
      "type": "Seal",
      "key": "dual",
      "atlas": "gb_Cards",
      "pos": {
        "x": 7,
        "y": 0
      },
      "raw": "key = 'dual',\n    loc_txt = {\n        name = \"Dual Seal\",\n        label = \"Dual Seal\",\n        text = {\n            \"{C:green}#2# in #1#{} chance to\",\n            \"{C:attention}duplicate{} this card\",\n            \"to hand if scoring\",\n        }\n    },\n    atlas = \"gb_Cards\",\n    pos = { x = 7, y = 0 },\n    config = { extra = { odds = 4 } },\n    badge_colour = HEX('6E89C2'),\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.odds, G.GAME.probabilities.normal or 1 } }\n    end,\n    calculate = function(self, card, context)\n        if context.before \n        and context.cardarea == G.play then\n            if SMODS.pseudorandom_probability(card, 'gb_dual', G.GAME.probabilities.normal, self.config.extra.odds) then\n                G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                local copy_card = copy_card(card, nil, nil, G.playing_card)\n                copy_card:add_to_deck()\n                G.deck.config.card_limit = G.deck.config.card_limit + 1\n                table.insert(G.playing_cards, copy_card)\n                G.hand:emplace(copy_card)\n                copy_card.states.visible = nil\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        copy_card:start_materialize()\n                        return true\n                    end\n                }))\n                return {\n                    message = localize('k_copied_ex'),\n                    colour = HEX(\"6E89C2\"),\n                    func = function()\n                        G.E_MANAGER:add_event(Event({\n                            func = function()\n                                SMODS.calculate_context({ playing_card_added = true, cards = { copy_card } })\n                                return true\n                            end\n                        }))\n                    end\n                }\n            end\n        end\n    end"
    },
    {
      "type": "Seal",
      "key": "fortune",
      "atlas": "gb_Cards",
      "pos": {
        "x": 7,
        "y": 1
      },
      "raw": "key = 'fortune',\n    loc_txt = {\n        name = \"Fortune Seal\",\n        label = \"Fortune Seal\",\n        text = {\n            \"{C:green}#2# in #1#{} chance to\",\n            \"give an {C:dark_edition}Edition{} to\",\n            \"a random played card\",\n            \"if scoring\",\n        }\n    },\n    atlas = \"gb_Cards\",\n    pos = { x = 7, y = 1 },\n    config = { extra = { odds = 4 } },\n    badge_colour = HEX('CAB785'),\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.odds, G.GAME.probabilities.normal or 1 } }\n    end,\n    calculate = function(self, card, context)\n        if context.before \n        and context.cardarea == G.play then    \n            if SMODS.pseudorandom_probability(card, 'gb_fortune', G.GAME.probabilities.normal, self.config.extra.odds) then\n                -- TODO: exclude cards with an edition\n                local eligible_card = pseudorandom_element(context.scoring_hand, pseudoseed('gb_fortune'))\n                local edition = poll_edition('gb_fortune', nil, true, true,\n                    { 'e_polychrome', 'e_holo', 'e_foil' })\n                if eligible_card then\n                    eligible_card:set_edition(edition, true)\n                end\n            else\n                SMODS.calculate_context{fortune_fail = true}\n                return {\n                    message = localize(\"k_nope_ex\"),\n                    colour = G.C.SECONDARY_SET.Tarot,\n\t\t\t\t\tsound = 'cancel'\n                }\n            end\n        end\n    end"
    },
    {
      "type": "Seal",
      "key": "infinite",
      "atlas": "gb_Cards",
      "pos": {
        "x": 7,
        "y": 2
      },
      "raw": "key = 'infinite',\n    loc_txt = {\n        name = \"Infinite Seal\",\n        label = \"Infinite Seal\",\n        text = {\n            \"If this card is {C:attention}destroyed{},\",\n            \"{C:attention}duplicate{} it and earn {C:money}$#1#{}\",\n        }\n    },\n    atlas = \"gb_Cards\",\n    pos = { x = 7, y = 2 },\n    config = { extra = { odds = 4, dollars = 5 } },\n    badge_colour = HEX('A1A5A6'),\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.dollars } }\n    end,\n    calculate = function(self, card, context)\n        if context.remove_playing_cards then\n            local being_removed = false\n            for _, playing_card in ipairs(context.removed) do\n                if playing_card == card then\n                    being_removed = true\n                end\n            end\n            if being_removed then\n                G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                local copy_card = copy_card(card, nil, nil, G.playing_card)\n                copy_card:add_to_deck()\n                G.deck.config.card_limit = G.deck.config.card_limit + 1\n                table.insert(G.playing_cards, copy_card)\n                if G.hand then\n                    G.hand:emplace(copy_card)\n                else\n                    G.deck:emplace(copy_card)\n                end\n                copy_card.states.visible = nil\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        copy_card:start_materialize()\n                        return true\n                    end\n                }))\n                ease_dollars(self.config.extra.dollars)\n                return {\n                    func = function()\n                        G.E_MANAGER:add_event(Event({\n                            func = function()\n                                SMODS.calculate_context({ playing_card_added = true, cards = { copy_card } })\n                                return true\n                            end\n                        }))\n                    end\n                }\n            end\n        end\n    end"
    },
    {
      "type": "Rarity",
      "key": "shattered",
      "atlas": null,
      "pos": null,
      "raw": "key = \"shattered\",\n    loc_txt = {name = \"Shattered\"},\n    badge_colour = HEX(\"673E79\")"
    },
    {
      "type": "Rarity",
      "key": "boss",
      "atlas": null,
      "pos": null,
      "raw": "key = \"boss\",\n    loc_txt = {name = \"Boss\"},\n    badge_colour = HEX(\"EFC03C\"),\n\tpools = { [\"Joker\"] = { rate = 0.02 } },\n    default_weight = 0.02"
    },
    {
      "type": "ConsumableType",
      "key": "Ephemeral",
      "atlas": null,
      "pos": null,
      "raw": "key = 'Ephemeral',\n    shader = 'spectral',\n    primary_colour = HEX('59778c'),\n    secondary_colour = HEX('8ea4b3'),\n    collection_rows = { 5, 5 },\n    default = 'c_gb_sculpture',\n    shop_rate = 1,\n    cards = {\n        ['c_gb_chain'] = true,\n\t\t['c_gb_collapse'] = true,\n\t\t['c_gb_comet'] = true,\n\t\t['c_gb_diffusion'] = true,\n\t\t['c_gb_gold_dust'] = true,\n\t\t['c_gb_group'] = true,\n\t\t['c_gb_harlequin'] = true,\n\t\t['c_gb_hourglass'] = true,\n\t\t['c_gb_incense'] = true,\n\t\t['c_gb_magic'] = true,\n\t\t['c_gb_mirage'] = true,\n\t\t['c_gb_motley'] = true,\n\t\t['c_gb_plasma'] = true,\n\t\t['c_gb_portal'] = true,\n\t\t['c_gb_rust'] = true,\n\t\t['c_gb_sculpture'] = true,\n\t\t['c_gb_spark'] = true,\n\t\t['c_gb_spirit'] = true,\n\t\t['c_gb_vanish'] = true,\n\t\t['c_gb_wish'] = true,\n        },\n    loc_txt = {\n        name = \"Ephemeral\",\n        collection = \"Ephemeral Cards\",\n        undiscovered = {\n            name = \"Not Discovered\",\n            text = {\n                \"Purchase or use\",\n                \"this card in an\",\n                \"unseeded run to\",\n                \"learn what it does\"\n                }\n            }\n        },"
    },
    {
      "type": "UndiscoveredSprite",
      "key": "Ephemeral",
      "atlas": "Consumables",
      "pos": {
        "x": 3,
        "y": 2
      },
      "raw": "key = 'Ephemeral',\n    atlas = 'Consumables',\n    pos = { x = 3, y = 2 },"
    },
    {
      "type": "DrawStep",
      "key": "Ephemeral",
      "atlas": null,
      "pos": null,
      "raw": "key = \"Ephemeral\",\n    order = 0,\n    func = function(card, layer)\n        if card.ability.set == 'Ephemeral'\n        and (layer == 'card' or layer == 'both')\n        and card.sprite_facing == 'front'\n        and (card.config.center.discovered or card.bypass_discovery_center) then\n            card.children.center:draw_shader('voucher', nil, card.ARGS.send_to_shader)\n        end\n    end"
    },
    {
      "type": "Atlas",
      "key": "gb_Blinds",
      "atlas": null,
      "pos": null,
      "raw": "key = 'gb_Blinds',\n    path = 'Blinds.png',\n    atlas_table = 'ANIMATION_ATLAS',\n    frames = 21,\n    px = 34,\n    py = 34"
    },
    {
      "type": "Atlas",
      "key": "gb_Boosters",
      "atlas": null,
      "pos": null,
      "raw": "key = \"gb_Boosters\",\n\tpath = \"Boosters.png\",\n\tpx = 71,\n\tpy = 95"
    },
    {
      "type": "Atlas",
      "key": "gb_Cards",
      "atlas": null,
      "pos": null,
      "raw": "key = \"gb_Cards\",\n\tpath = \"Cards.png\",\n\tpx = 71,\n\tpy = 95"
    },
    {
      "type": "Atlas",
      "key": "gb_Consumables",
      "atlas": null,
      "pos": null,
      "raw": "key = \"gb_Consumables\",\n\tpath = \"Consumables.png\",\n\tpx = 71,\n\tpy = 95"
    },
    {
      "type": "Atlas",
      "key": "gb_Ephemerals",
      "atlas": null,
      "pos": null,
      "raw": "key = \"gb_Ephemerals\",\n\tpath = \"Ephemerals.png\",\n\tpx = 71,\n\tpy = 95"
    },
    {
      "type": "Atlas",
      "key": "gb_Enhancements",
      "atlas": null,
      "pos": null,
      "raw": "key = \"gb_Enhancements\",\n\tpath = \"Enhancements.png\",\n\tpx = 71,\n\tpy = 95"
    },
    {
      "type": "Atlas",
      "key": "gb_Jokers",
      "atlas": null,
      "pos": null,
      "raw": "key = \"gb_Jokers\",\n\tpath = \"Jokers.png\",\n\tpx = 71,\n\tpy = 95"
    },
    {
      "type": "Atlas",
      "key": "gb_ShatteredJokers",
      "atlas": null,
      "pos": null,
      "raw": "key = \"gb_ShatteredJokers\",\n\tpath = \"ShatteredJokers.png\",\n\tpx = 71,\n\tpy = 95"
    },
    {
      "type": "Atlas",
      "key": "gb_BossJokers",
      "atlas": null,
      "pos": null,
      "raw": "key = \"gb_BossJokers\",\n\tpath = \"BossJokers.png\",\n\tpx = 71,\n\tpy = 95"
    },
    {
      "type": "Atlas",
      "key": "gb_modicon",
      "atlas": null,
      "pos": null,
      "raw": "key = \"gb_modicon\",\n\tpath = \"icon.png\",\n\tpx = 34,\n\tpy = 34,"
    },
    {
      "type": "Sound",
      "key": "gb_music1",
      "atlas": null,
      "pos": null,
      "raw": "vol = music_volume,\n    pitch = music_pitch,\n    key = \"gb_music1\",\n    path = \"gb_music1.ogg\",\n    select_music_track = function()\n        return (gb_config.custom_music == true and 10 ) or false\n    end,"
    },
    {
      "type": "Sound",
      "key": "gb_music2",
      "atlas": null,
      "pos": null,
      "raw": "vol = music_volume,\n    pitch = music_pitch,\n    key = \"gb_music2\",\n    path = \"gb_music2.ogg\",\n    select_music_track = function()\n        return (gb_config.custom_music == true and G.booster_pack_sparkles and not G.booster_pack_sparkles.REMOVED and 11) or false\n    end,"
    },
    {
      "type": "Sound",
      "key": "gb_music3",
      "atlas": null,
      "pos": null,
      "raw": "vol = music_volume,\n    pitch = music_pitch,\n    key = \"gb_music3\",\n    path = \"gb_music3.ogg\",\n    select_music_track = function()\n        return (gb_config.custom_music == true and G.booster_pack_meteors and not G.booster_pack_meteors.REMOVED and 11) or false\n    end,"
    },
    {
      "type": "Sound",
      "key": "gb_music4",
      "atlas": null,
      "pos": null,
      "raw": "vol = music_volume,\n    pitch = music_pitch,\n    key = \"gb_music4\",\n    path = \"gb_music4.ogg\",\n    select_music_track = function()\n        return (gb_config.custom_music == true and G.shop and not G.shop.REMOVED and 11) or false\n    end,"
    },
    {
      "type": "Sound",
      "key": "gb_music5",
      "atlas": null,
      "pos": null,
      "raw": "vol = music_volume,\n    pitch = music_pitch,\n    key = \"gb_music5\",\n    path = \"gb_music5.ogg\",\n    select_music_track = function()\n        return (gb_config.custom_music == true and G.GAME.blind and G.GAME.blind.boss and 11) or false\n    end,"
    }
  ],
  "version": "no-tag"
}