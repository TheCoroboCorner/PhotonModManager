{
  "locMap": {
    "gb_custom_music_name": {
      "name": "",
      "text": [
        "Enable Custom Music"
      ],
      "type": "dictionary"
    },
    "gb_custom_music_desc": {
      "name": "",
      "text": [
        "If enabled, play custom music"
      ],
      "type": "dictionary"
    },
    "card_mult": {
      "name": "",
      "text": [
        "{C:mult}+#1#{} Mult"
      ],
      "type": "Other"
    },
    "gb_page": {
      "name": "\"Page\"\n        ",
      "text": [],
      "type": "dictionary"
    },
    "gb_Eyes": {
      "name": "\"Eye\"",
      "text": [],
      "type": "suits_singular"
    }
  },
  "atlases": {
    "gb_Boosters": {
      "path": "Boosters.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/grab-bag@thefaketh30ne/v0.8p1/Boosters.png",
      "resolvedGitHubPath": "assets/1x/Boosters.png"
    },
    "gb_Consumables": {
      "path": "Consumables.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/grab-bag@thefaketh30ne/v0.8p1/Consumables.png",
      "resolvedGitHubPath": "assets/1x/Consumables.png"
    },
    "gb_Decks": {
      "path": "Decks.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/grab-bag@thefaketh30ne/v0.8p1/Decks.png",
      "resolvedGitHubPath": "assets/1x/Decks.png"
    },
    "gb_Ephemerals": {
      "path": "Ephemerals.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/grab-bag@thefaketh30ne/v0.8p1/Ephemerals.png",
      "resolvedGitHubPath": "assets/1x/Ephemerals.png"
    },
    "gb_Enhancements": {
      "path": "Enhancements.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/grab-bag@thefaketh30ne/v0.8p1/Enhancements.png",
      "resolvedGitHubPath": "assets/1x/Enhancements.png"
    },
    "gb_Jokers": {
      "path": "Jokers.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/grab-bag@thefaketh30ne/v0.8p1/Jokers.png",
      "resolvedGitHubPath": "assets/1x/Jokers.png"
    },
    "gb_Seals": {
      "path": "Seals.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/grab-bag@thefaketh30ne/v0.8p1/Seals.png",
      "resolvedGitHubPath": "assets/1x/Seals.png"
    },
    "gb_ShatteredJokers": {
      "path": "ShatteredJokers.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/grab-bag@thefaketh30ne/v0.8p1/ShatteredJokers.png",
      "resolvedGitHubPath": "assets/1x/ShatteredJokers.png"
    },
    "gb_BossJokers": {
      "path": "BossJokers.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/grab-bag@thefaketh30ne/v0.8p1/BossJokers.png",
      "resolvedGitHubPath": "assets/1x/BossJokers.png"
    }
  },
  "cards": [
    {
      "type": "Blind",
      "key": "body",
      "name": "The Body",
      "atlas": "gb_Blinds",
      "pos": null,
      "raw": "key = \"body\",\n    loc_txt = {\n        name = \"The Body\",\n        text = {\n            \"Enhanced cards are\",\n            \"drawn face down\",\n        }\n    },\n    dollars = 5,\n    mult = 2,\n    atlas = \"gb_Blinds\",\n    pos = { y = 5 },\n    boss = { min = 6 },\n    boss_colour = HEX(\"35acbc\"),\n    calculate = function(self, blind, context)\n        if not blind.disabled then\n            if context.stay_flipped and context.to_area == G.hand and\n                next(SMODS.get_enhancements(context.other_card)) then\n                return {\n                    stay_flipped = true\n                }\n            end\n        end\n    end,\n    disable = function(self)\n        for i = 1, #G.hand.cards do\n            if G.hand.cards[i].facing == 'back' then\n                G.hand.cards[i]:flip()\n            end\n        end\n        for _, playing_card in pairs(G.playing_cards) do\n            playing_card.ability.wheel_flipped = nil\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "cross",
      "name": "The Cross",
      "atlas": "gb_Blinds",
      "pos": null,
      "raw": "key = \"cross\",\n    loc_txt = {\n        name = \"The Cross\",\n        text = {\n            \"Sets all listed\",\n            \"probabilities to 0\",\n        }\n    },\n    dollars = 5,\n    mult = 2,\n    atlas = \"gb_Blinds\",\n    pos = { y = 9 },\n    boss = { min = 5 },\n    boss_colour = HEX(\"53c45c\"),\n    calculate = function(self, blind, context)\n        if not blind.disabled and context.fix_probability then\n            return {\n                numerator = 0\n            }\n        end\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "dread",
      "name": "The Dread",
      "atlas": "gb_Blinds",
      "pos": null,
      "raw": "key = \"dread\",\n    loc_txt = {\n        name = \"The Dread\",\n        text = {\n            \"Cannot play more\",\n            \"than two suits\",\n        }\n    },\n    dollars = 5,\n    mult = 2,\n    atlas = \"gb_Blinds\",\n    pos = { y = 12 },\n    boss = { min = 2 },\n    boss_colour = HEX(\"5d6385\"),\n    debuff_hand = function(self, cards, hand, handname, check)\n        if gb_count_suits(cards) > 2 then\n            return true\n        else\n            return false\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "flag",
      "name": "The Flag",
      "atlas": "gb_Blinds",
      "pos": null,
      "raw": "key = \"flag\",\n    loc_txt = {\n        name = \"The Flag\",\n        text = {\n            \"Cards held in hand\",\n            \"at end of round are\",\n            \"permanently debuffed\",\n        }\n    },\n    dollars = 5,\n    mult = 2,\n    atlas = \"gb_Blinds\",\n    pos = { y = 7 },\n    boss = { min = 3 },\n    boss_colour = HEX(\"6d6b89\"),\n    calculate = function(self, blind, context)\n        if not blind.disabled and context.end_of_round and context.cardarea == G.hand then\n            for _, playing_card in pairs(G.hand.cards) do\n                playing_card.ability.perma_debuff = true\n                playing_card:juice_up()\n            end\n        end\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "hand",
      "name": "The Hand",
      "atlas": "gb_Blinds",
      "pos": null,
      "raw": "key = \"hand\",\n    loc_txt = {\n        name = \"The Hand\",\n        text = {\n            \"Permanently debuff\",\n            \"leftmost card\",\n            \"in played hand\",\n        }\n    },\n    dollars = 5,\n    mult = 2,\n    atlas = \"gb_Blinds\",\n    pos = { y = 4 },\n    boss = { min = 5 },\n    boss_colour = HEX(\"bc3535\"),\n    calculate = function(self, blind, context)\n        if not blind.disabled and context.final_scoring_step then\n            local first_scored_card = G.play.cards[1]\n            first_scored_card.ability.perma_debuff = true\n            first_scored_card:juice_up()\n        end\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "lance",
      "name": "The Lance",
      "atlas": "gb_Blinds",
      "pos": null,
      "raw": "key = \"lance\",\n    loc_txt = {\n        name = \"The Lance\",\n        text = {\n            \"All cards discarded\",\n            \"this ante are\",\n            \"drawn face down\",\n        }\n    },\n    dollars = 5,\n    mult = 2,\n    atlas = \"gb_Blinds\",\n    pos = { y = 14 },\n    boss = { min = 1 },\n    boss_colour = HEX(\"5d6d85\"),\n    calculate = function(self, blind, context)\n        if not blind.disabled then\n            if context.stay_flipped and context.to_area == G.hand and\n                context.other_card.ability.discarded_this_ante then\n                return {\n                    stay_flipped = true\n                }\n            end\n        end\n    end,\n    disable = function(self)\n        for i = 1, #G.hand.cards do\n            if G.hand.cards[i].facing == 'back' then\n                G.hand.cards[i]:flip()\n            end\n        end\n        for _, playing_card in pairs(G.playing_cards) do\n            playing_card.ability.wheel_flipped = nil\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "matchstick",
      "name": "The Matchstick",
      "atlas": "gb_Blinds",
      "pos": null,
      "raw": "key = \"matchstick\",\n    loc_txt = {\n        name = \"The Matchstick\",\n        text = {\n            \"Start with half of\",\n            \"hands and discards\",\n        }\n    },\n    dollars = 5,\n    mult = 2,\n    atlas = \"gb_Blinds\",\n    pos = { y = 13 },\n    boss = { min = 3 },\n    boss_colour = HEX(\"85675d\"),\n    config = { extra = { discards_sub = 0, hands_sub = 0 } },\n    calculate = function(self, blind, context)\n        if context.setting_blind then\n            self.config.extra.discards_sub = math.floor(G.GAME.current_round.discards_left / 2)\n            self.config.extra.hands_sub = math.floor(G.GAME.current_round.hands_left / 2)\n        end\n        if not blind.disabled then\n            if context.setting_blind then\n                ease_discard(-self.config.extra.discards_sub)\n                ease_hands_played(-self.config.extra.hands_sub)\n            end\n        end\n    end,\n    disable = function(self)\n        if not self.config.extra.discards_sub and self.config.extra.hands_sub then\n            self.config.extra.discards_sub = math.floor(G.GAME.current_round.discards_left / 2)\n            self.config.extra.hands_sub = math.floor(G.GAME.current_round.hands_left / 2) \n        end\n        ease_discard(self.config.extra.discards_sub)\n        ease_hands_played(self.config.extra.hands_sub)\n    end",
      "config": {
        "extra": {
          "discards_sub": 0,
          "hands_sub": 0
        }
      },
      "ability": {
        "extra": {
          "discards_sub": 0,
          "hands_sub": 0
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "mind",
      "name": "The Mind",
      "atlas": "gb_Blinds",
      "pos": null,
      "raw": "key = \"mind\",\n    loc_txt = {\n        name = \"The Mind\",\n        text = {\n            \"#1# in #2# chance\",\n            \"Hearts and Diamonds are\",\n            \"drawn face down\",\n        }\n    },\n    dollars = 5,\n    mult = 2,\n    atlas = \"gb_Blinds\",\n    pos = { y = 1 },\n    boss = { min = 3 },\n    boss_colour = HEX(\"bc7635\"),\n    loc_vars = function(self)\n        local new_numerator, new_denominator = SMODS.get_probability_vars(self, 1, 3)\n        return { vars = { new_numerator, new_denominator } }\n    end,\n    collection_loc_vars = function(self)\n        return { vars = { '1' } }\n    end,\n    calculate = function(self, blind, context)\n        if not blind.disabled then\n            if context.stay_flipped and context.to_area == G.hand and\n                (context.other_card:is_suit(\"Hearts\") or context.other_card:is_suit(\"Diamonds\")) and\n                SMODS.pseudorandom_probability(blind, 'gb_mind', 1, 3) then\n                return {\n                    stay_flipped = true\n                }\n            end\n        end\n    end,\n    disable = function(self)\n        for i = 1, #G.hand.cards do\n            if G.hand.cards[i].facing == 'back' then\n                G.hand.cards[i]:flip()\n            end\n        end\n        for _, playing_card in pairs(G.playing_cards) do\n            playing_card.ability.wheel_flipped = nil\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "mystic",
      "name": "The Mystic",
      "atlas": "gb_Blinds",
      "pos": null,
      "raw": "key = \"mystic\",\n    loc_txt = {\n        name = \"The Mystic\",\n        text = {\n            \"Played hand must\",\n            \"contain a Face Card\",\n        }\n    },\n    dollars = 5,\n    mult = 2,\n    atlas = \"gb_Blinds\",\n    pos = { y = 6 },\n    boss = { min = 1 },\n    boss_colour = HEX(\"8135bc\"),\n    debuff_hand = function(self, cards, hand, handname, check)\n        for _, card in pairs(cards) do\n            if card:is_face() then\n                return false\n            end\n        end\n        return true\n    end,\n    in_pool = function(self)\n        local face_cards = 0\n        for _, card in pairs(G.playing_cards or {}) do\n            if card:is_face() then\n                face_cards = face_cards + 1\n            end\n        end\n        if face_cards >= 10 then\n            return true\n        else\n            return false\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "piper",
      "name": "The Piper",
      "atlas": "gb_Blinds",
      "pos": null,
      "raw": "key = \"piper\",\n    loc_txt = {\n        name = \"The Piper\",\n        text = {\n            \"One random played card\",\n            \"destroyed after scoring\",\n        }\n    },\n    dollars = 5,\n    mult = 2,\n    atlas = \"gb_Blinds\",\n    pos = { y = 2 },\n    boss = { min = 3 },\n    boss_colour = HEX(\"35bc4b\"),\n    calculate = function(self, blind, context)\n        if not blind.disabled then\n            if context.before then\n                local chosen_card = pseudorandom_element(context.full_hand, pseudoseed(\"gb_piper\"))\n                chosen_card.ability.piper_destroy = true\n            end\n            if context.destroy_card and context.destroy_card.ability.piper_destroy == true then\n                return {\n                    remove = true\n                }\n            end\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "shame",
      "name": "The Shame",
      "atlas": "gb_Blinds",
      "pos": null,
      "raw": "key = \"shame\",\n    loc_txt = {\n        name = \"The Shame\",\n        text = {\n            \"All cards debuffed\",\n            \"if Blind not skipped\",\n            \"this ante\",\n        }\n    },\n    dollars = 5,\n    mult = 2,\n    atlas = \"gb_Blinds\",\n    pos = { y = 8 },\n    boss = { min = 2 },\n    boss_colour = HEX(\"6935bc\"),\n    calculate = function(self, blind, context)\n        if not blind.disabled then\n            if context.debuff_card and context.debuff_card.area ~= G.jokers then\n                if not G.GAME.GB_BLINDS_SKIPPED_THIS_ANTE then\n                    return {\n                        debuff = true\n                    }\n                elseif G.GAME.GB_BLINDS_SKIPPED_THIS_ANTE <= 0 then\n                    return {\n                        debuff = true\n                    }\n                end\n            end\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "spirit",
      "name": "The Spirit",
      "atlas": "gb_Blinds",
      "pos": null,
      "raw": "key = \"spirit\",\n    loc_txt = {\n        name = \"The Spirit\",\n        text = {\n            \"#1# in #2# chance\",\n            \"Spades and Clubs are\",\n            \"drawn face down\",\n        }\n    },\n    dollars = 5,\n    mult = 2,\n    atlas = \"gb_Blinds\",\n    pos = { y = 0 },\n    boss = { min = 3 },\n    boss_colour = HEX(\"6035bc\"),\n    loc_vars = function(self)\n        local new_numerator, new_denominator = SMODS.get_probability_vars(self, 1, 3)\n        return { vars = { new_numerator, new_denominator } }\n    end,\n    collection_loc_vars = function(self)\n        return { vars = { '1' } }\n    end,\n    calculate = function(self, blind, context)\n        if not blind.disabled then\n            if context.stay_flipped and context.to_area == G.hand and\n                (context.other_card:is_suit(\"Spades\") or context.other_card:is_suit(\"Clubs\")) and\n                SMODS.pseudorandom_probability(blind, 'gb_spirit', 1, 3) then\n                return {\n                    stay_flipped = true\n                }\n            end\n        end\n    end,\n    disable = function(self)\n        for i = 1, #G.hand.cards do\n            if G.hand.cards[i].facing == 'back' then\n                G.hand.cards[i]:flip()\n            end\n        end\n        for _, playing_card in pairs(G.playing_cards) do\n            playing_card.ability.wheel_flipped = nil\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "storm",
      "name": "The Storm",
      "atlas": "gb_Blinds",
      "pos": null,
      "raw": "key = \"storm\",\n    loc_txt = {\n        name = \"The Storm\",\n        text = {\n            \"+1 Ante if Blind not\",\n            \"won on final hand\",\n        }\n    },\n    dollars = 5,\n    mult = 2,\n    atlas = \"gb_Blinds\",\n    pos = { y = 11 },\n    boss = { min = 4 },\n    boss_colour = HEX(\"424d85\"),\n    config = { extra = { ante_skipped = false } },\n    calculate = function(self, blind, context)\n        if not blind.disabled then\n            if context.end_of_round and G.GAME.current_round.hands_left ~= 0 and not self.config.extra.ante_skipped then\n                ease_ante(1)\n                G.GAME.round_resets.blind_ante = G.GAME.round_resets.blind_ante or G.GAME.round_resets.ante\n                G.GAME.round_resets.blind_ante = G.GAME.round_resets.blind_ante + 1\n                self.config.extra.ante_skipped = true\n            end\n        end\n    end",
      "config": {
        "extra": {
          "ante_skipped": false
        }
      },
      "ability": {
        "extra": {
          "ante_skipped": false
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "trident",
      "name": "The Trident",
      "atlas": "gb_Blinds",
      "pos": null,
      "raw": "key = \"trident\",\n    loc_txt = {\n        name = \"The Trident\",\n        text = {\n            \"Permanently debuffs\",\n            \"unscored cards\",\n        }\n    },\n    dollars = 5,\n    mult = 2,\n    atlas = \"gb_Blinds\",\n    pos = { y = 10 },\n    boss = { min = 3 },\n    boss_colour = HEX(\"35bc9c\"),\n    calculate = function(self, blind, context)\n        if not blind.disabled then\n            local triggered = false\n            if context.individual and context.cardarea == \"unscored\" then\n                context.other_card:juice_up()\n                context.other_card.ability.perma_debuff = true\n                triggered = true\n            end\n            if triggered then\n                blind.triggered = true\n            end\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "weave",
      "name": "The Weave",
      "atlas": "gb_Blinds",
      "pos": null,
      "raw": "key = \"weave\",\n    loc_txt = {\n        name = \"The Weave\",\n        text = {\n            \"Halves current money\",\n            \"if played hand has\",\n            \"more than 3 cards\",\n        }\n    },\n    dollars = 5,\n    mult = 2,\n    atlas = \"gb_Blinds\",\n    pos = { y = 3 },\n    boss = { min = 4 },\n    boss_colour = HEX(\"bc35b7\"),\n    calculate = function(self, blind, context)\n        if not blind.disabled then\n            if context.debuff_hand then\n                blind.triggered = false\n                if #G.play.cards > 3 then\n                    blind.triggered = true\n                    local half_dollars = math.floor(G.GAME.dollars / 2)\n                    if to_big(half_dollars) > to_big(0) then\n                        ease_dollars(-half_dollars, true)\n                    end\n                end\n            end\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "final_baton",
      "name": "Wooden Baton",
      "atlas": "gb_Blinds",
      "pos": null,
      "raw": "key = \"final_baton\",\n    loc_txt = {\n        name = \"Wooden Baton\",\n        text = {\n            \"Debuffs all cards\",\n            \"until 1 hand remaining\",\n        }\n    },\n    dollars = 8,\n    mult = 3,\n    atlas = \"gb_Blinds\",\n    pos = { y = 15 },\n    boss = { showdown = true },\n    boss_colour = HEX(\"be7022\"),\n    calculate = function(self, blind, context)\n        if not blind.disabled then\n            if context.debuff_card and context.debuff_card.area ~= G.jokers then\n                if G.GAME.current_round.hands_left > 1 then\n                    return { debuff = true }\n                else\n                    G.GAME.blind:disable()\n                    return { debuff = false }\n                end\n            end\n            if context.after then\n                if G.GAME.current_round.hands_left <= 1 then\n                    G.GAME.blind:disable()\n                end\n            end\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "final_clover",
      "name": "Celadon Clover",
      "atlas": "gb_Blinds",
      "pos": null,
      "raw": "key = \"final_clover\",\n    loc_txt = {\n        name = \"Celadon Clover\",\n        text = {\n            \"Shuffles all Jokers\",\n            \"before scoring\",\n        }\n    },\n    dollars = 8,\n    mult = 2,\n    atlas = \"gb_Blinds\",\n    pos = { y = 17 },\n    boss = { showdown = true },\n    boss_colour = HEX(\"80d585\"),\n    calculate = function(self, blind, context)\n        if not blind.disabled then\n            if context.press_play then\n                if #G.jokers.cards > 1 then\n                    G.E_MANAGER:add_event(Event({\n                        trigger = 'after',\n                        delay = 0.2,\n                        func = function()\n                            for i = 1, 3 do\n                                G.E_MANAGER:add_event(Event({\n                                    func = function()\n                                        G.jokers:shuffle('gb_final_clover')\n                                        play_sound('cardSlide1', 0.85)\n                                        return true\n                                    end\n                                }))\n                                delay(0.15)\n                            end\n                            delay(0.35)\n                            return true\n                        end\n                    }))\n                end\n            end\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "final_pentacle",
      "name": "Golden Pentacle",
      "atlas": "gb_Blinds",
      "pos": null,
      "raw": "key = \"final_pentacle\",\n    loc_txt = {\n        name = \"Golden Pentacle\",\n        text = {\n            \"Debuffs #1# in #2#\",\n            \"played cards\",\n            \"before scoring\",\n        }\n    },\n    dollars = 8,\n    mult = 2,\n    atlas = \"gb_Blinds\",\n    pos = { y = 18 },\n    boss = { showdown = true },\n    boss_colour = HEX(\"f2cc00\"),\n    loc_vars = function(self)\n        local new_numerator, new_denominator = SMODS.get_probability_vars(self, 1, 2)\n        return { vars = { new_numerator, new_denominator } }\n    end,\n    calculate = function(self, blind, context)\n        if not blind.disabled and context.before then\n            for _, playing_card in ipairs(context.scoring_hand) do\n                if SMODS.pseudorandom_probability(blind, 'gb_final_pentacle', 1, 2) then\n                    playing_card:juice_up()\n                    SMODS.debuff_card(playing_card, true, \"gb_final_pentacle\")\n                end\n            end\n        end\n        if context.end_of_round then\n            for _, playing_card in ipairs(G.playing_cards) do\n                SMODS.debuff_card(playing_card, false, \"gb_final_pentacle\")\n            end\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "final_pike",
      "name": "Platinum Pike",
      "atlas": "gb_Blinds",
      "pos": null,
      "raw": "key = \"final_pike\",\n    loc_txt = {\n        name = \"Platinum Pike\",\n        text = {\n            \"On Play or Discard,\",\n            \"Discard all cards\",\n            \"held in hand\",\n        }\n    },\n    dollars = 8,\n    mult = 2,\n    atlas = \"gb_Blinds\",\n    pos = { y = 16 },\n    boss = { showdown = true },\n    boss_colour = HEX(\"a9b4b9\"),\n    calculate = function(self, blind, context)\n        if not blind.disabled then\n            if (context.pre_discard or context.before) and not context.hook then\n                local selection_limit = G.hand.config.highlighted_limit\n                G.hand.config.highlighted_limit = 1000\n                local any_selected = false\n                for _, playing_card in pairs(G.hand.cards) do\n                    if not playing_card.highlighted then\n                        G.hand:add_to_highlighted(playing_card, true)\n                        any_selected = true\n                    end\n                end\n                if any_selected then \n                    G.FUNCS.discard_cards_from_highlighted(nil, true) \n                end\n                G.hand.config.highlighted_limit = selection_limit\n                blind.triggered = true\n            end\n        end\n    end",
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "final_tile",
      "name": "Tangerine Tile",
      "atlas": "gb_Blinds",
      "pos": null,
      "raw": "key = \"final_tile\",\n    loc_txt = {\n        name = \"Tangerine Tile\",\n        text = {\n            \"Selling a Joker\",\n            \"reduces score\",\n            \"requirement by 2X Base\",\n        }\n    },\n    dollars = 8,\n    mult = 8,\n    atlas = \"gb_Blinds\",\n    pos = { y = 19 },\n    boss = { showdown = true },\n    boss_colour = HEX(\"f4a441\"),\n    config = { extra = { base_blind_chips = 0 } },\n    calculate = function(self, blind, context)\n        if context.setting_blind then\n            self.config.extra.base_blind_chips = G.GAME.blind.chips / G.GAME.blind.mult\n        end\n        if not blind.disabled\n        and context.selling_card\n        and context.card.ability.set == 'Joker' \n        and to_big(G.GAME.blind.chips) > to_big(self.config.extra.base_blind_chips * 2) then\n            G.GAME.blind.chips = G.GAME.blind.chips - self.config.extra.base_blind_chips * 2\n            G.GAME.blind.chip_text = number_format(G.GAME.blind.chips)\n        end\n    end,\n    disable = function(self)\n        G.GAME.blind.chips = self.config.extra.base_blind_chips * 2\n        G.GAME.blind.chip_text = number_format(G.GAME.blind.chips)\n    end",
      "config": {
        "extra": {
          "base_blind_chips": 0
        }
      },
      "ability": {
        "extra": {
          "base_blind_chips": 0
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "ephemeral_small_1",
      "name": "Ephemeral Pack",
      "atlas": "gb_Boosters",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"ephemeral_small_1\",\n    loc_txt = {\n        name = \"Ephemeral Pack\",\n        group_name = \"Ephemeral Pack\",\n        text = {\n            \"Choose {C:attention}#1#{} of up to\",\n            \"{C:attention}#2# {V:1}Ephemeral{} cards to\",\n            \"be added to consumables\"\n        }\n    },\n    config = { extra = 3, choose = 1 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.choose, card.ability.extra, colours = {HEX(\"8ea4b3\")} } }\n    end,\n    cost = 4,\n    atlas = \"gb_Boosters\",\n    weight = 1.5,\n    pos = { x = 0, y = 0 },\n    draw_hand = false,\n    select_card = \"consumeables\",\n    kind = \"Ephemeral\",\n    create_card = function(self, card, i)\n        return SMODS.create_card({set = \"Ephemeral\", skip_materialize = true, area = G.pack_cards})\n    end,\n    ease_background_colour = function(self)\n        ease_colour(G.C.DYN_UI.MAIN, HEX(\"8ea4b3\"))\n        ease_background_colour({ new_colour = HEX('59778c'), special_colour = HEX(\"8ea4b3\"), contrast = 2 })\n    end",
      "config": {
        "extra": 3,
        "choose": 1
      },
      "ability": {
        "extra": 3,
        "choose": 1
      },
      "vars": [
        1,
        3,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "ephemeral_small_2",
      "name": "Ephemeral Pack",
      "atlas": "gb_Boosters",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"ephemeral_small_2\",\n    loc_txt = {\n        name = \"Ephemeral Pack\",\n        group_name = \"Ephemeral Pack\",\n        text = {\n            \"Choose {C:attention}#1#{} of up to\",\n            \"{C:attention}#2# {V:1}Ephemeral{} cards to\",\n            \"be added to consumables\"\n        }\n    },\n    config = { extra = 3, choose = 1 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.choose, card.ability.extra, colours = {HEX(\"8ea4b3\")} } }\n    end,\n    cost = 4,\n    atlas = \"gb_Boosters\",\n    weight = 1.5,\n    pos = { x = 1, y = 0 },\n    draw_hand = false,\n    select_card = \"consumeables\",\n    kind = \"Ephemeral\",\n    create_card = function(self, card, i)\n        return SMODS.create_card({set = \"Ephemeral\", skip_materialize = true, area = G.pack_cards})\n    end,\n    ease_background_colour = function(self)\n        ease_colour(G.C.DYN_UI.MAIN, HEX(\"8ea4b3\"))\n        ease_background_colour({ new_colour = HEX('59778c'), special_colour = HEX(\"8ea4b3\"), contrast = 2 })\n    end",
      "config": {
        "extra": 3,
        "choose": 1
      },
      "ability": {
        "extra": 3,
        "choose": 1
      },
      "vars": [
        1,
        3,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "ephemeral_jumbo",
      "name": "Jumbo Ephemeral Pack",
      "atlas": "gb_Boosters",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"ephemeral_jumbo\",\n    loc_txt = {\n        name = \"Jumbo Ephemeral Pack\",\n        group_name = \"Ephemeral Pack\",\n        text = {\n            \"Choose {C:attention}#1#{} of up to\",\n            \"{C:attention}#2# {V:1}Ephemeral{} cards to\",\n            \"be added to consumables\"\n        }\n    },\n    config = { extra = 5, choose = 1 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.choose, card.ability.extra, colours = {HEX(\"8ea4b3\")} } }\n    end,\n    cost = 6,\n    atlas = \"gb_Boosters\",\n    weight = 0.5,\n    pos = { x = 2, y = 0 },\n    draw_hand = false,\n    select_card = \"consumeables\",\n    kind = \"Ephemeral\",\n    create_card = function(self, card, i)\n        return SMODS.create_card({set = \"Ephemeral\", skip_materialize = true, area = G.pack_cards})\n    end,\n    ease_background_colour = function(self)\n        ease_colour(G.C.DYN_UI.MAIN, HEX(\"8ea4b3\"))\n        ease_background_colour({ new_colour = HEX('59778c'), special_colour = HEX(\"8ea4b3\"), contrast = 2 })\n    end",
      "config": {
        "extra": 5,
        "choose": 1
      },
      "ability": {
        "extra": 5,
        "choose": 1
      },
      "vars": [
        1,
        5,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "ephemeral_mega",
      "name": "Mega Ephemeral Pack",
      "atlas": "gb_Boosters",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"ephemeral_mega\",\n    loc_txt = {\n        name = \"Mega Ephemeral Pack\",\n        group_name = \"Ephemeral Pack\",\n        text = {\n            \"Choose {C:attention}#1#{} of up to\",\n            \"{C:attention}#2# {V:1}Ephemeral{} cards to\",\n            \"be added to consumables\"\n        }\n    },\n    config = { extra = 5, choose = 2 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.choose, card.ability.extra, colours = {HEX(\"8ea4b3\")} } }\n    end,\n    cost = 8,\n    atlas = \"gb_Boosters\",\n    weight = 0.2,\n    pos = { x = 3, y = 0 },\n    draw_hand = false,\n    select_card = \"consumeables\",\n    kind = \"Ephemeral\",\n    create_card = function(self, card, i)\n        return SMODS.create_card({set = \"Ephemeral\", skip_materialize = true, area = G.pack_cards})\n    end,\n    ease_background_colour = function(self)\n        ease_colour(G.C.DYN_UI.MAIN, HEX(\"8ea4b3\"))\n        ease_background_colour({ new_colour = HEX('59778c'), special_colour = HEX(\"8ea4b3\"), contrast = 2 })\n    end",
      "config": {
        "extra": 5,
        "choose": 2
      },
      "ability": {
        "extra": 5,
        "choose": 2
      },
      "vars": [
        2,
        5,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "hex_small_1",
      "name": "Hex Pack",
      "atlas": "gb_Boosters",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"hex_small_1\",\n    loc_txt = {\n        name = \"Hex Pack\",\n        group_name = \"Hex Pack\",\n        text = {\n            \"Choose {C:attention}#1#{} of up to\",\n            \"{C:attention}#2# {V:1}Hex{} cards to\",\n            \"use immediately\"\n        }\n    },\n    config = { extra = 2, choose = 1 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.choose, card.ability.extra, colours = {HEX(\"9493aa\")} } }\n    end,\n    cost = 5,\n    atlas = \"gb_Boosters\",\n    weight = 1.0,\n    pos = { x = 0, y = 1 },\n    draw_hand = true,\n    kind = \"Hex\",\n    create_card = function(self, card, i)\n        return SMODS.create_card({set = \"Hex\", skip_materialize = true, area = G.pack_cards})\n    end,\n    ease_background_colour = function(self)\n        ease_colour(G.C.DYN_UI.MAIN, HEX(\"9493aa\"))\n        ease_background_colour({ new_colour = HEX('4f5767'), special_colour = HEX(\"9493aa\"), contrast = 2 })\n    end",
      "config": {
        "extra": 2,
        "choose": 1
      },
      "ability": {
        "extra": 2,
        "choose": 1
      },
      "vars": [
        1,
        2,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "hex_small_2",
      "name": "Hex Pack",
      "atlas": "gb_Boosters",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"hex_small_2\",\n    loc_txt = {\n        name = \"Hex Pack\",\n        group_name = \"Hex Pack\",\n        text = {\n            \"Choose {C:attention}#1#{} of up to\",\n            \"{C:attention}#2# {V:1}Hex{} cards to\",\n            \"use immediately\"\n        }\n    },\n    config = { extra = 2, choose = 1 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.choose, card.ability.extra, colours = {HEX(\"9493aa\")} } }\n    end,\n    cost = 5,\n    atlas = \"gb_Boosters\",\n    weight = 1.0,\n    pos = { x = 1, y = 1 },\n    draw_hand = true,\n    kind = \"Hex\",\n    create_card = function(self, card, i)\n        return SMODS.create_card({set = \"Hex\", skip_materialize = true, area = G.pack_cards})\n    end,\n    ease_background_colour = function(self)\n        ease_colour(G.C.DYN_UI.MAIN, HEX(\"9493aa\"))\n        ease_background_colour({ new_colour = HEX('4f5767'), special_colour = HEX(\"9493aa\"), contrast = 2 })\n    end",
      "config": {
        "extra": 2,
        "choose": 1
      },
      "ability": {
        "extra": 2,
        "choose": 1
      },
      "vars": [
        1,
        2,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "hex_jumbo",
      "name": "Jumbo Hex Pack",
      "atlas": "gb_Boosters",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"hex_jumbo\",\n    loc_txt = {\n        name = \"Jumbo Hex Pack\",\n        group_name = \"Hex Pack\",\n        text = {\n            \"Choose {C:attention}#1#{} of up to\",\n            \"{C:attention}#2# {V:1}Hex{} cards to\",\n            \"use immediately\"\n        }\n    },\n    config = { extra = 4, choose = 1 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.choose, card.ability.extra, colours = {HEX(\"9493aa\")} } }\n    end,\n    cost = 7,\n    atlas = \"gb_Boosters\",\n    weight = 0.3,\n    pos = { x = 2, y = 1 },\n    draw_hand = true,\n    kind = \"Hex\",\n    create_card = function(self, card, i)\n        return SMODS.create_card({set = \"Hex\", skip_materialize = true, area = G.pack_cards})\n    end,\n    ease_background_colour = function(self)\n        ease_colour(G.C.DYN_UI.MAIN, HEX(\"9493aa\"))\n        ease_background_colour({ new_colour = HEX('4f5767'), special_colour = HEX(\"9493aa\"), contrast = 2 })\n    end",
      "config": {
        "extra": 4,
        "choose": 1
      },
      "ability": {
        "extra": 4,
        "choose": 1
      },
      "vars": [
        1,
        4,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "hex_mega",
      "name": "Mega Hex Pack",
      "atlas": "gb_Boosters",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"hex_mega\",\n    loc_txt = {\n        name = \"Mega Hex Pack\",\n        group_name = \"Hex Pack\",\n        text = {\n            \"Choose {C:attention}#1#{} of up to\",\n            \"{C:attention}#2# {V:1}Hex{} cards to\",\n            \"use immediately\"\n        }\n    },\n    config = { extra = 4, choose = 2 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.choose, card.ability.extra, colours = {HEX(\"9493aa\")} } }\n    end,\n    cost = 10,\n    atlas = \"gb_Boosters\",\n    weight = 0.1,\n    pos = { x = 3, y = 1 },\n    draw_hand = true,\n    kind = \"Hex\",\n    create_card = function(self, card, i)\n        return SMODS.create_card({set = \"Hex\", skip_materialize = true, area = G.pack_cards})\n    end,\n    ease_background_colour = function(self)\n        ease_colour(G.C.DYN_UI.MAIN, HEX(\"9493aa\"))\n        ease_background_colour({ new_colour = HEX('4f5767'), special_colour = HEX(\"9493aa\"), contrast = 2 })\n    end",
      "config": {
        "extra": 4,
        "choose": 2
      },
      "ability": {
        "extra": 4,
        "choose": 2
      },
      "vars": [
        2,
        4,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Challenge",
      "key": "boxbreaker",
      "name": "Boxbreaker",
      "atlas": null,
      "pos": null,
      "raw": "key = 'boxbreaker',\n    loc_txt = {\n        name = \"Boxbreaker\"\n    },\n    jokers = {\n        { id = 'j_gb_secret_box' },\n        { id = 'j_gb_secret_box' },\n        { id = 'j_gb_secret_box' },\n        { id = 'j_gb_secret_box' },\n        { id = 'j_gb_secret_box' },\n        { id = 'j_gb_secret_box' },\n        { id = 'j_gb_secret_box' },\n        { id = 'j_gb_secret_box' },\n    },\n    rules = {\n        modifiers = {\n            { id = 'joker_slots', value = 8 },\n        },\n        custom = {\n            { id = 'no_shop_jokers' },\n        },\n    },\n    restrictions = {\n        banned_cards = {\n            { id = 'c_judgement' },\n            { id = 'c_wraith' },\n            { id = 'c_soul' },\n            { id = 'p_buffoon_normal_1', ids = {\n                'p_buffoon_normal_1', 'p_buffoon_normal_2',\n                'p_buffoon_normal_3', 'p_buffoon_normal_4',\n                'p_buffoon_jumbo_1', 'p_buffoon_jumbo_2',\n                'p_buffoon_mega_1', 'p_buffoon_mega_2' }\n            },\n        },\n        banned_tags = {\n            { id = 'tag_uncommon' },\n            { id = 'tag_rare' },\n            { id = 'tag_negative' },\n            { id = 'tag_foil' },\n            { id = 'tag_holographic' },\n            { id = 'tag_polychrome' },\n            { id = 'tag_buffoon' },\n            { id = 'tag_top_up' },\n        },\n    }",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Challenge",
      "key": "hit_the_slots",
      "name": "Hit The Slots!",
      "atlas": null,
      "pos": null,
      "raw": "key = 'hit_the_slots',\n    loc_txt = {\n        name = \"Hit The Slots!\"\n    },\n    jokers = {\n        { id = 'j_gb_jackpot', eternal = true },\n        { id = 'j_gb_misfortune', eternal = true },\n    },\n    rules = {\n        modifiers = {\n            { id = 'discards', value = 0 },\n        }\n    }",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Challenge",
      "key": "madman",
      "name": "Madman",
      "atlas": null,
      "pos": null,
      "raw": "key = 'madman',\n    loc_txt = {\n        name = \"Madman\"\n    },\n    jokers = {\n        { id = 'j_madness', eternal = true },\n    },\n    rules = {\n        modifiers = {\n            { id = 'joker_slots', value = 4 },\n        }\n    },",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Challenge",
      "key": "socialism",
      "name": "Socialism",
      "atlas": null,
      "pos": null,
      "raw": "key = 'socialism',\n    loc_txt = {\n        name = \"Socialism\"\n    },\n    jokers = {\n        { id = 'j_gb_taxman', eternal = true },\n        { id = 'j_raised_fist', eternal = true },\n    },\n    rules = {\n        custom = {\n            { id = 'no_interest' },\n        }\n    }",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Challenge",
      "key": "tiny_hands",
      "name": "Tiny Hands",
      "atlas": null,
      "pos": null,
      "raw": "key = 'tiny_hands',\n    loc_txt = {\n        name = \"Tiny Hands\"\n    },\n    jokers = {\n        { id = 'j_half', eternal = true },\n    },\n    rules = {\n        modifiers = {\n                { id = 'discards', value = 2 },\n                { id = 'hands', value = 2 },\n            }\n        },\n    deck = {\n        cards = {\n            { s = 'C', r = '5' },\n            { s = 'D', r = '5' },\n            { s = 'H', r = '5' },\n            { s = 'S', r = '5' },\n            { s = 'C', r = '4' },\n            { s = 'D', r = '4' },\n            { s = 'H', r = '4' },\n            { s = 'S', r = '4' },\n            { s = 'C', r = '3' },\n            { s = 'D', r = '3' },\n            { s = 'H', r = '3' },\n            { s = 'S', r = '3' },\n            { s = 'C', r = '2' },\n            { s = 'D', r = '2' },\n            { s = 'H', r = '2' },\n            { s = 'S', r = '2' },\n            { s = 'C', r = 'A' },\n            { s = 'D', r = 'A' },\n            { s = 'H', r = 'A' },\n            { s = 'S', r = 'A' },\n        }\n    }",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "chain",
      "name": "Chain",
      "atlas": "gb_Ephemerals",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"chain\",\n    set = \"Ephemeral\",\n    loc_txt = {\n        name = 'Chain',\n        text = {\n            \"Adds {C:attention}#1#{} {C:dark_edition}Temporary{}\",\n            \"{C:attention}ascending-rank{} cards to hand\",\n        }\n    },\n    config = {extra = { cards_to_create = 5 }},\n    atlas = 'gb_Ephemerals',\n    pos = { x = 0, y = 1 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.cards_to_create } }\n    end,\n    use = function(self, card, area, copier)\n        local starting_id = pseudorandom_element({2, 3, 4, 5, 6, 7, 8, 9, 10}, pseudoseed(\"gb_group\"))\n        for k = 1, self.config.extra.cards_to_create do\n            local playing_card = SMODS.create_card {\n                rank = id_to_rank(starting_id),\n                set = \"Base\",\n                edition = \"e_gb_temporary\",\n                area = G.discard\n            }\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    playing_card:start_materialize({ G.C.SECONDARY_SET.Enhanced })\n                    G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                    playing_card.playing_card = G.playing_card\n                    G.hand:emplace(playing_card)\n                    SMODS.debuff_card(playing_card, \"prevent_debuff\", \"source\")\n                    return true\n                end\n            }))\n            starting_id = starting_id + 1\n        end\n    end,\n    can_use = function(self, card)\n        if G.hand and G.GAME.blind.in_blind then\n            return true\n        else\n            return false\n        end\n    end,",
      "config": {
        "extra": {
          "cards_to_create": 5
        }
      },
      "ability": {
        "extra": {
          "cards_to_create": 5
        }
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "collapse",
      "name": "Collapse",
      "atlas": "gb_Ephemerals",
      "pos": {
        "x": 6,
        "y": 0
      },
      "raw": "key = \"collapse\",\n    set = \"Ephemeral\",\n    loc_txt = {\n        name = 'Collapse',\n        text = {\n            \"Adds {C:attention}#1#{} {C:dark_edition}Temporary{}\",\n            \"same-suited {C:attention}Aces{} to hand\",\n        }\n    },\n    config = {extra = { cards_to_create = 2 }},\n    atlas = 'gb_Ephemerals',\n    pos = { x = 6, y = 0 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.cards_to_create } }\n    end,\n    use = function(self, card, area, copier)\n        local suit = pseudorandom_element({\"S\", \"H\", \"C\", \"D\"}, pseudoseed(\"gb_collapse\"))\n        for k = 1, self.config.extra.cards_to_create do\n            local playing_card = SMODS.create_card {\n                suit = suit,\n                set = \"Base\",\n                edition = \"e_gb_temporary\",\n                rank = \"Ace\",\n                area = G.discard\n            }\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    playing_card:start_materialize({ G.C.SECONDARY_SET.Enhanced })\n                    G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                    playing_card.playing_card = G.playing_card\n                    G.hand:emplace(playing_card)\n                    SMODS.debuff_card(playing_card, \"prevent_debuff\", \"source\")\n                    return true\n                end\n            }))\n        end\n    end,\n    can_use = function(self, card)\n        if G.hand and G.GAME.blind.in_blind then\n            return true\n        else\n            return false\n        end\n    end,",
      "config": {
        "extra": {
          "cards_to_create": 2
        }
      },
      "ability": {
        "extra": {
          "cards_to_create": 2
        }
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "comet",
      "name": "Comet",
      "atlas": "gb_Ephemerals",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"comet\",\n    set = \"Ephemeral\",\n    loc_txt = {\n        name = 'Comet',\n        text = {\n            \"Adds {C:attention}#1#{} {C:dark_edition}Temporary{} cards\",\n            \"with {C:blue}Blue Seals{} to hand\",\n        }\n    },\n    config = {extra = { cards_to_create = 2 }},\n    atlas = 'gb_Ephemerals',\n    pos = { x = 3, y = 1 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.cards_to_create } }\n    end,\n    use = function(self, card, area, copier)\n        for k = 1, self.config.extra.cards_to_create do\n            local playing_card = SMODS.create_card {\n                set = \"Base\",\n                seal = \"Blue\",\n                edition = \"e_gb_temporary\",\n                area = G.discard\n            }\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                    playing_card.playing_card = G.playing_card\n                    playing_card:start_materialize({ G.C.SECONDARY_SET.Enhanced })\n                    G.hand:emplace(playing_card)\n                    SMODS.debuff_card(playing_card, \"prevent_debuff\", \"source\")\n                    return true\n                end\n            }))\n        end\n    end,\n    can_use = function(self, card)\n        if G.hand and G.GAME.blind.in_blind then\n            return true\n        else\n            return false\n        end\n    end,",
      "config": {
        "extra": {
          "cards_to_create": 2
        }
      },
      "ability": {
        "extra": {
          "cards_to_create": 2
        }
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "diffusion",
      "name": "Diffusion",
      "atlas": "gb_Ephemerals",
      "pos": {
        "x": 6,
        "y": 1
      },
      "raw": "key = \"diffusion\",\n    set = \"Ephemeral\",\n    loc_txt = {\n        name = 'Diffusion',\n        text = {\n            \"Adds {C:dark_edition}Temporary{} copies\",\n            \"of {C:green}#1# in #2#{} cards\",\n            \"in hand to hand\",\n        }\n    },\n    config = {extra = { odds = 2 } },\n    atlas = 'gb_Ephemerals',\n    pos = { x = 6, y = 1 },\n    loc_vars = function(self, info_queue, card)\n        local new_numerator, new_denominator = SMODS.get_probability_vars(self, 1, card.ability.extra.odds)\n        return { vars = { new_numerator, new_denominator } }\n    end,\n    use = function(self, card, area, copier)\n        local eligible_cards = {}\n        for _, playing_card in ipairs(G.hand.cards) do\n            table.insert(eligible_cards, playing_card)\n        end\n        for _, v in ipairs(eligible_cards) do\n            if SMODS.pseudorandom_probability(blind, 'gb_diffusion', 1, card.ability.extra.odds) then\n                G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                local copy_card = copy_card(v, nil, nil, G.playing_card)\n                copy_card.playing_card = G.playing_card\n                copy_card:add_to_deck()\n                G.deck.config.card_limit = G.deck.config.card_limit + 1\n                table.insert(G.playing_cards, copy_card)\n                copy_card:start_materialize({ G.C.SECONDARY_SET.Enhanced })\n                G.hand:emplace(copy_card)\n                copy_card:set_edition('e_gb_temporary', true, true)\n                SMODS.debuff_card(copy_card, \"prevent_debuff\", \"source\")\n            end\n        end\n    end,\n    can_use = function(self, card)\n        if G.hand and G.GAME.blind.in_blind then\n            return true\n        else\n            return false\n        end\n    end",
      "config": {
        "extra": {
          "odds": 2
        }
      },
      "ability": {
        "extra": {
          "odds": 2
        }
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "gold_dust",
      "name": "Gold Dust",
      "atlas": "gb_Ephemerals",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"gold_dust\",\n    set = \"Ephemeral\",\n    loc_txt = {\n        name = 'Gold Dust',\n        text = {\n            \"Adds {C:attention}#1#{} {C:dark_edition}Temporary{}\",\n            \"{C:attention}Gold Cards{} to hand\",\n        }\n    },\n    config = {extra = { cards_to_create = 3 }},\n    atlas = 'gb_Ephemerals',\n    pos = { x = 2, y = 0 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.cards_to_create } }\n    end,\n    use = function(self, card, area, copier)\n        for k = 1, self.config.extra.cards_to_create do\n            local playing_card = SMODS.create_card {\n                set = \"Base\",\n                enhancement = \"m_gold\",\n                edition = \"e_gb_temporary\",\n                area = G.discard\n            }\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    playing_card:start_materialize({ G.C.SECONDARY_SET.Enhanced })\n                    G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                    playing_card.playing_card = G.playing_card\n                    G.hand:emplace(playing_card)\n                    SMODS.debuff_card(playing_card, \"prevent_debuff\", \"source\")\n                    return true\n                end\n            }))\n        end\n    end,\n    can_use = function(self, card)\n        if G.hand and G.GAME.blind.in_blind then\n            return true\n        else\n            return false\n        end\n    end,",
      "config": {
        "extra": {
          "cards_to_create": 3
        }
      },
      "ability": {
        "extra": {
          "cards_to_create": 3
        }
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "group",
      "name": "Group",
      "atlas": "gb_Ephemerals",
      "pos": {
        "x": 7,
        "y": 0
      },
      "raw": "key = \"group\",\n    set = \"Ephemeral\",\n    loc_txt = {\n        name = 'Group',\n        text = {\n            \"Adds {C:attention}#1#{} {C:dark_edition}Temporary{}\",\n            \"same-suited cards to hand\",\n        }\n    },\n    config = {extra = { cards_to_create = 5 }},\n    atlas = 'gb_Ephemerals',\n    pos = { x = 7, y = 0 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.cards_to_create } }\n    end,\n    use = function(self, card, area, copier)\n        local suit = pseudorandom_element({\"S\", \"H\", \"C\", \"D\"}, pseudoseed(\"gb_collapse\"))\n        for k = 1, self.config.extra.cards_to_create do\n            local playing_card = SMODS.create_card {\n                suit = suit,\n                set = \"Base\",\n                edition = \"e_gb_temporary\",\n                area = G.discard\n            }\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    playing_card:start_materialize({ G.C.SECONDARY_SET.Enhanced })\n                    G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                    playing_card.playing_card = G.playing_card\n                    G.hand:emplace(playing_card)\n                    SMODS.debuff_card(playing_card, \"prevent_debuff\", \"source\")\n                    return true\n                end\n            }))\n        end\n    end,\n    can_use = function(self, card)\n        if G.hand and G.GAME.blind.in_blind then\n            return true\n        else\n            return false\n        end\n    end,",
      "config": {
        "extra": {
          "cards_to_create": 5
        }
      },
      "ability": {
        "extra": {
          "cards_to_create": 5
        }
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "harlequin",
      "name": "Harlequin",
      "atlas": "gb_Ephemerals",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "key = \"harlequin\",\n    set = \"Ephemeral\",\n    loc_txt = {\n        name = 'Harlequin',\n        text = {\n            \"Adds a {C:dark_edition}Temporary{}\",\n            \"{C:rare}Rare {C:attention}Joker{} to Jokers\",\n        }\n    },\n    config = {extra = { cards_to_create = 3 }},\n    atlas = 'gb_Ephemerals',\n    pos = { x = 2, y = 2 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.cards_to_create } }\n    end,\n    use = function(self, card, area, copier)\n        SMODS.add_card {\n            set = \"Joker\",\n            rarity = 'Rare',\n            edition = 'e_gb_temporary',\n            key_append = 'gb_harlequin'\n        }\n        G.GAME.joker_buffer = 0\n    end,\n    can_use = function(self, card)\n        if G.hand and G.GAME.blind.in_blind then\n            return true\n        else\n            return false\n        end\n    end,",
      "config": {
        "extra": {
          "cards_to_create": 3
        }
      },
      "ability": {
        "extra": {
          "cards_to_create": 3
        }
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "hourglass",
      "name": "Hourglass",
      "atlas": "gb_Ephemerals",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"hourglass\",\n    set = \"Ephemeral\",\n    loc_txt = {\n        name = 'Hourglass',\n        text = {\n            \"Adds {C:attention}#1#{} {C:dark_edition}Temporary{}\",\n            \"{C:attention}Glass Cards{} to hand\",\n        }\n    },\n    config = {extra = { cards_to_create = 3 }},\n    atlas = 'gb_Ephemerals',\n    pos = { x = 1, y = 0 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.cards_to_create } }\n    end,\n    use = function(self, card, area, copier)\n        for k = 1, self.config.extra.cards_to_create do\n            local playing_card = SMODS.create_card {\n                set = \"Base\",\n                enhancement = \"m_glass\",\n                edition = \"e_gb_temporary\",\n                area = G.discard\n            }\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    playing_card:start_materialize({ G.C.SECONDARY_SET.Enhanced })\n                    G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                    playing_card.playing_card = G.playing_card\n                    G.hand:emplace(playing_card)\n                    SMODS.debuff_card(playing_card, \"prevent_debuff\", \"source\")\n                    return true\n                end\n            }))\n        end\n    end,\n    can_use = function(self, card)\n        if G.hand and G.GAME.blind.in_blind then\n            return true\n        else\n            return false\n        end\n    end,",
      "config": {
        "extra": {
          "cards_to_create": 3
        }
      },
      "ability": {
        "extra": {
          "cards_to_create": 3
        }
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "incense",
      "name": "Incense",
      "atlas": "gb_Ephemerals",
      "pos": {
        "x": 7,
        "y": 1
      },
      "raw": "key = \"incense\",\n    set = \"Ephemeral\",\n    loc_txt = {\n        name = 'Incense',\n        text = {\n            \"{C:blue}+#1#{} hands for this blind\",\n        }\n    },\n    config = {extra = { hands = 2 }},\n    atlas = 'gb_Ephemerals',\n    pos = { x = 7, y = 1 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.hands } }\n    end,\n    use = function(self, card, area, copier)\n        ease_hands_played(self.config.extra.hands)\n    end,\n    can_use = function(self, card)\n        if G.hand and G.GAME.blind.in_blind then\n            return true\n        else\n            return false\n        end\n    end,",
      "config": {
        "extra": {
          "hands": 2
        }
      },
      "ability": {
        "extra": {
          "hands": 2
        }
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "magic",
      "name": "Magic",
      "atlas": "gb_Ephemerals",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"magic\",\n    set = \"Ephemeral\",\n    loc_txt = {\n        name = 'Magic',\n        text = {\n            \"Adds {C:attention}#1#{} {C:dark_edition}Temporary{}\",\n            \"{C:attention}Lucky Cards{} to hand\",\n        }\n    },\n    config = {extra = { cards_to_create = 3 }},\n    atlas = 'gb_Ephemerals',\n    pos = { x = 3, y = 0 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.cards_to_create } }\n    end,\n    use = function(self, card, area, copier)\n        for k = 1, self.config.extra.cards_to_create do\n            local playing_card = SMODS.create_card {\n                set = \"Base\",\n                enhancement = \"m_lucky\",\n                edition = \"e_gb_temporary\",\n                area = G.discard\n            }\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    playing_card:start_materialize({ G.C.SECONDARY_SET.Enhanced })\n                    G.hand:emplace(playing_card)\n                    playing_card.playing_card = G.playing_card\n                    G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                    playing_card.playing_card = G.playing_card\n                    SMODS.debuff_card(playing_card, \"prevent_debuff\", \"source\")\n                    return true\n                end\n            }))\n        end\n    end,\n    can_use = function(self, card)\n        if G.hand and G.GAME.blind.in_blind then\n            return true\n        else\n            return false\n        end\n    end,",
      "config": {
        "extra": {
          "cards_to_create": 3
        }
      },
      "ability": {
        "extra": {
          "cards_to_create": 3
        }
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "mirage",
      "name": "Mirage",
      "atlas": "gb_Ephemerals",
      "pos": {
        "x": 5,
        "y": 1
      },
      "raw": "key = \"mirage\",\n    set = \"Ephemeral\",\n    loc_txt = {\n        name = 'Mirage',\n        text = {\n            \"Adds {C:attention}#1#{} {C:dark_edition}Temporary{} copies\",\n            \"of a random card in hand to hand\",\n        }\n    },\n    config = {extra = { cards_to_create = 3 }},\n    atlas = 'gb_Ephemerals',\n    pos = { x = 5, y = 1 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.cards_to_create } }\n    end,\n    use = function(self, card, area, copier)\n        local card_to_copy = pseudorandom_element(G.hand.cards, pseudoseed(\"gb_mirage\"))\n        for k = 1, self.config.extra.cards_to_create do\n            G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n            local copy_card = copy_card(card_to_copy, nil, nil, G.playing_card)\n            copy_card.playing_card = G.playing_card\n            copy_card:add_to_deck()\n            G.deck.config.card_limit = G.deck.config.card_limit + 1\n            table.insert(G.playing_cards, copy_card)\n            copy_card:start_materialize({ G.C.SECONDARY_SET.Enhanced })\n            G.hand:emplace(copy_card)\n            copy_card:set_edition('e_gb_temporary', true, true)\n            SMODS.debuff_card(copy_card, \"prevent_debuff\", \"source\")\n        end\n    end,\n    can_use = function(self, card)\n        if G.hand and G.GAME.blind.in_blind then\n            return true\n        else\n            return false\n        end\n    end,",
      "config": {
        "extra": {
          "cards_to_create": 3
        }
      },
      "ability": {
        "extra": {
          "cards_to_create": 3
        }
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "motley",
      "name": "Motley",
      "atlas": "gb_Ephemerals",
      "pos": {
        "x": 3,
        "y": 2
      },
      "raw": "key = \"motley\",\n    set = \"Ephemeral\",\n    loc_txt = {\n        name = 'Motley',\n        text = {\n            \"Adds {C:attention}#1#{} {C:dark_edition}Temporary{}\",\n            \"{C:common}Common {C:attention}Jokers{} to Jokers\",\n        }\n    },\n    config = {extra = { cards_to_create = 3 }},\n    atlas = 'gb_Ephemerals',\n    pos = { x = 3, y = 2 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.cards_to_create } }\n    end,\n    use = function(self, card, area, copier)\n        for k = 1, self.config.extra.cards_to_create do\n            local playing_card = SMODS.add_card {\n                set = \"Joker\",\n                rarity = 'Common',\n                edition = 'e_gb_temporary',\n                key_append = 'gb_motley'\n            }\n            G.GAME.joker_buffer = 0\n        end\n    end,\n    can_use = function(self, card)\n        if G.hand and G.GAME.blind.in_blind then\n            return true\n        else\n            return false\n        end\n    end,",
      "config": {
        "extra": {
          "cards_to_create": 3
        }
      },
      "ability": {
        "extra": {
          "cards_to_create": 3
        }
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "plasma",
      "name": "Plasma",
      "atlas": "gb_Ephemerals",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"plasma\",\n    set = \"Ephemeral\",\n    loc_txt = {\n        name = 'Plasma',\n        text = {\n            \"Adds {C:attention}#1#{} {C:dark_edition}Temporary{} cards\",\n            \"with {C:purple}Purple Seals{} to hand\",\n        }\n    },\n    config = {extra = { cards_to_create = 2 }},\n    atlas = 'gb_Ephemerals',\n    pos = { x = 2, y = 1 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.cards_to_create } }\n    end,\n    use = function(self, card, area, copier)\n        for k = 1, self.config.extra.cards_to_create do\n            local playing_card = SMODS.create_card {\n                set = \"Base\",\n                seal = \"Purple\",\n                edition = \"e_gb_temporary\",\n                area = G.discard\n            }\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    playing_card:start_materialize({ G.C.SECONDARY_SET.Enhanced })\n                    G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                    playing_card.playing_card = G.playing_card\n                    G.hand:emplace(playing_card)\n                    SMODS.debuff_card(playing_card, \"prevent_debuff\", \"source\")\n                    return true\n                end\n            }))\n        end\n    end,\n    can_use = function(self, card)\n        if G.hand and G.GAME.blind.in_blind then\n            return true\n        else\n            return false\n        end\n    end,",
      "config": {
        "extra": {
          "cards_to_create": 2
        }
      },
      "ability": {
        "extra": {
          "cards_to_create": 2
        }
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "portal",
      "name": "Portal",
      "atlas": "gb_Ephemerals",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"portal\",\n    set = \"Ephemeral\",\n    loc_txt = {\n        name = 'Portal',\n        text = {\n            \"Adds {C:attention}#1#{} {C:dark_edition}Temporary{}\",\n            \"same-suited {C:attention}numbered{} cards to hand\",\n        }\n    },\n    config = {extra = { cards_to_create = 4 }},\n    atlas = 'gb_Ephemerals',\n    pos = { x = 1, y = 1 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.cards_to_create } }\n    end,\n    use = function(self, card, area, copier)\n        local suit = pseudorandom_element({\"S\", \"H\", \"C\", \"D\"}, pseudoseed(\"gb_collapse\"))\n        for k = 1, self.config.extra.cards_to_create do\n            local playing_card = SMODS.create_card {\n                set = \"Base\",\n                suit = suit,\n                edition = \"e_gb_temporary\",\n                rank = pseudorandom_element(\n                    {\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"T\"},\n                    pseudoseed(\"gb_portal\")\n                ),\n                area = G.discard\n            }\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    playing_card:start_materialize({ G.C.SECONDARY_SET.Enhanced })\n                    G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                    playing_card.playing_card = G.playing_card\n                    G.hand:emplace(playing_card)\n                    SMODS.debuff_card(playing_card, \"prevent_debuff\", \"source\")\n                    return true\n                end\n            }))\n        end\n    end,\n    can_use = function(self, card)\n        if G.hand and G.GAME.blind.in_blind then\n            return true\n        else\n            return false\n        end\n    end,",
      "config": {
        "extra": {
          "cards_to_create": 4
        }
      },
      "ability": {
        "extra": {
          "cards_to_create": 4
        }
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "rust",
      "name": "Rust",
      "atlas": "gb_Ephemerals",
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "key = \"rust\",\n    set = \"Ephemeral\",\n    loc_txt = {\n        name = 'Rust',\n        text = {\n            \"Adds {C:attention}#1#{} {C:dark_edition}Temporary{}\",\n            \"{C:attention}Steel Cards{} to hand\",\n        }\n    },\n    config = {extra = { cards_to_create = 3 }},\n    atlas = 'gb_Ephemerals',\n    pos = { x = 4, y = 0 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.cards_to_create } }\n    end,\n    use = function(self, card, area, copier)\n        for k = 1, self.config.extra.cards_to_create do\n            local playing_card = SMODS.create_card {\n                set = \"Base\",\n                enhancement = \"m_steel\",\n                edition = \"e_gb_temporary\",\n                area = G.discard\n            }\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    playing_card:start_materialize({ G.C.SECONDARY_SET.Enhanced })\n                    G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                    playing_card.playing_card = G.playing_card\n                    G.hand:emplace(playing_card)\n                    SMODS.debuff_card(playing_card, \"prevent_debuff\", \"source\")\n                    return true\n                end\n            }))\n        end\n    end,\n    can_use = function(self, card)\n        if G.hand and G.GAME.blind.in_blind then\n            return true\n        else\n            return false\n        end\n    end,",
      "config": {
        "extra": {
          "cards_to_create": 3
        }
      },
      "ability": {
        "extra": {
          "cards_to_create": 3
        }
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "sculpture",
      "name": "Sculpture",
      "atlas": "gb_Ephemerals",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"sculpture\",\n    set = \"Ephemeral\",\n    loc_txt = {\n        name = 'Sculpture',\n        text = {\n            \"Adds {C:attention}#1#{} {C:dark_edition}Temporary{}\",\n            \"{C:attention}Stone Cards{} to hand\",\n        }\n    },\n    config = {extra = { cards_to_create = 5 }},\n    atlas = 'gb_Ephemerals',\n    pos = { x = 0, y = 0 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.cards_to_create } }\n    end,\n    use = function(self, card, area, copier)\n        for k = 1, self.config.extra.cards_to_create do\n            local playing_card = SMODS.create_card {\n                set = \"Base\",\n                enhancement = \"m_stone\",\n                edition = \"e_gb_temporary\",\n                area = G.discard\n            }\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    playing_card:start_materialize({ G.C.SECONDARY_SET.Enhanced })\n                    G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                    playing_card.playing_card = G.playing_card\n                    G.hand:emplace(playing_card)\n                    SMODS.debuff_card(playing_card, \"prevent_debuff\", \"source\")\n                    return true\n                end\n            }))\n        end\n    end,\n    can_use = function(self, card)\n        if G.hand and G.GAME.blind.in_blind then\n            return true\n        else\n            return false\n        end\n    end,",
      "config": {
        "extra": {
          "cards_to_create": 5
        }
      },
      "ability": {
        "extra": {
          "cards_to_create": 5
        }
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "spark",
      "name": "Spark",
      "atlas": "gb_Ephemerals",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "key = \"spark\",\n    set = \"Ephemeral\",\n    loc_txt = {\n        name = 'Spark',\n        text = {\n            \"Adds {C:attention}20%{} of blind\",\n            \"requirement to current score\",\n        }\n    },\n    atlas = 'gb_Ephemerals',\n    pos = { x = 1, y = 2 },\n    use = function(self, card, area, copier)\n        G.GAME.chips = G.GAME.chips + (G.GAME.blind.chips * 0.2)\n    end,\n    can_use = function(self, card)\n        if G.hand and G.GAME.blind.in_blind then\n            return true\n        else\n            return false\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "spirit",
      "name": "Spirit",
      "atlas": "gb_Ephemerals",
      "pos": {
        "x": 5,
        "y": 0
      },
      "raw": "key = \"spirit\",\n    set = \"Ephemeral\",\n    loc_txt = {\n        name = 'Spirit',\n        text = {\n            \"Adds {C:attention}#1#{} {C:dark_edition}Temporary{}\",\n            \"same-suited {C:attention}Face{} cards to hand\",\n        }\n    },\n    config = {extra = { cards_to_create = 3 }},\n    atlas = 'gb_Ephemerals',\n    pos = { x = 5, y = 0 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.cards_to_create } }\n    end,\n    use = function(self, card, area, copier)\n        local suit = pseudorandom_element({\"S\", \"H\", \"C\", \"D\"}, pseudoseed(\"gb_collapse\"))\n        for k = 1, self.config.extra.cards_to_create do\n            local playing_card = SMODS.create_card {\n                set = \"Base\",\n                suit = suit,\n                edition = \"e_gb_temporary\",\n                rank = pseudorandom_element(\n                    {\"K\", \"Q\", \"J\"},\n                    pseudoseed(\"gb_spirit\")\n                ),\n                area = G.discard\n            }\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    playing_card:start_materialize({ G.C.SECONDARY_SET.Enhanced })\n                    G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                    playing_card.playing_card = G.playing_card\n                    G.hand:emplace(playing_card)\n                    SMODS.debuff_card(playing_card, \"prevent_debuff\", \"source\")\n                    return true\n                end\n            }))\n        end\n    end,\n    can_use = function(self, card)\n        if G.hand and G.GAME.blind.in_blind then\n            return true\n        else\n            return false\n        end\n    end,",
      "config": {
        "extra": {
          "cards_to_create": 3
        }
      },
      "ability": {
        "extra": {
          "cards_to_create": 3
        }
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "vanish",
      "name": "Vanish",
      "atlas": "gb_Ephemerals",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = \"vanish\",\n    set = \"Ephemeral\",\n    loc_txt = {\n        name = 'Vanish',\n        text = {\n            \"{C:red}+#1#{} discards for this blind\",\n        }\n    },\n    config = {extra = { discards = 2 }},\n    atlas = 'gb_Ephemerals',\n    pos = { x = 0, y = 2 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.discards } }\n    end,\n    use = function(self, card, area, copier)\n        ease_discard(self.config.extra.discards)\n    end,\n    can_use = function(self, card)\n        if G.hand and G.GAME.blind.in_blind then\n            return true\n        else\n            return false\n        end\n    end,",
      "config": {
        "extra": {
          "discards": 2
        }
      },
      "ability": {
        "extra": {
          "discards": 2
        }
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "wish",
      "name": "Wish",
      "atlas": "gb_Ephemerals",
      "pos": {
        "x": 4,
        "y": 1
      },
      "raw": "key = \"wish\",\n    set = \"Ephemeral\",\n    loc_txt = {\n        name = 'Wish',\n        text = {\n            \"Adds {C:attention}#1#{} {C:dark_edition}Temporary{} cards\",\n            \"with {C:money}Gold Seals{} to hand\",\n        }\n    },\n    config = {extra = { cards_to_create = 3 }},\n    atlas = 'gb_Ephemerals',\n    pos = { x = 4, y = 1 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.cards_to_create } }\n    end,\n    use = function(self, card, area, copier)\n        for k = 1, self.config.extra.cards_to_create do\n            local playing_card = SMODS.create_card {\n                set = \"Base\",\n                seal = \"Gold\",\n                edition = \"e_gb_temporary\",\n                area = G.discard\n            }\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    playing_card:start_materialize({ G.C.SECONDARY_SET.Enhanced })\n                    G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                    playing_card.playing_card = G.playing_card\n                    G.hand:emplace(playing_card)\n                    SMODS.debuff_card(playing_card, \"prevent_debuff\", \"source\")\n                    return true\n                end\n            }))\n        end\n    end,\n    can_use = function(self, card)\n        if G.hand and G.GAME.blind.in_blind then\n            return true\n        else\n            return false\n        end\n    end,",
      "config": {
        "extra": {
          "cards_to_create": 3
        }
      },
      "ability": {
        "extra": {
          "cards_to_create": 3
        }
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "apparition",
      "name": "Apparition",
      "atlas": "gb_HexCards",
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "key = \"apparition\",\n    set = \"Hex\",\n    loc_txt = {\n        name = 'Apparition',\n        text = { {\n            \"Selected cards\",\n            \"become {C:attention}Macabre{} cards\",\n        },\n        {\n            \"An equal number of cards\",\n            \"in {C:attention}full deck{} become {C:attention}Haunted\"\n        } }\n    },\n    config = { extra = { mod_conv = 'm_gb_macabre', hex_to_apply = \"haunted\" } },\n    atlas = 'gb_HexCards',\n    pos = { x = 4, y = 0 },\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue + 1] = G.P_CENTERS[card.ability.extra.mod_conv]\n        info_queue[#info_queue + 1] = GB.hex_tooltip(card.ability.extra.hex_to_apply)\n    end,\n    use = function(self, card, area, copier)\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.4,\n            func = function()\n                play_sound('tarot1')\n                card:juice_up(0.3, 0.5)\n                return true\n            end\n        }))\n        for i = 1, #G.hand.highlighted do\n            local percent = 1.15 - (i - 0.999) / (#G.hand.highlighted - 0.998) * 0.3\n            G.E_MANAGER:add_event(Event({\n                trigger = 'after',\n                delay = 0.15,\n                func = function()\n                    G.hand.highlighted[i]:flip()\n                    play_sound('card1', percent)\n                    G.hand.highlighted[i]:juice_up(0.3, 0.3)\n                    return true\n                end\n            }))\n        end\n        delay(0.2)\n        for i = 1, #G.hand.highlighted do\n            G.E_MANAGER:add_event(Event({\n                trigger = 'after',\n                delay = 0.1,\n                func = function()\n                    G.hand.highlighted[i]:set_ability(G.P_CENTERS[card.ability.extra.mod_conv])\n                    return true\n                end\n            }))\n        end\n        for i = 1, #G.hand.highlighted do\n            local percent = 0.85 + (i - 0.999) / (#G.hand.highlighted - 0.998) * 0.3\n            G.E_MANAGER:add_event(Event({\n                trigger = 'after',\n                delay = 0.15,\n                func = function()\n                    G.hand.highlighted[i]:flip()\n                    play_sound('tarot2', percent, 0.6)\n                    G.hand.highlighted[i]:juice_up(0.3, 0.3)\n                    return true\n                end\n            }))\n        end\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.2,\n            func = function()\n                gb_apply_hex(G.playing_cards, card.ability.extra.hex_to_apply, #G.hand.highlighted)\n                G.hand:unhighlight_all()\n                return true\n            end\n        }))\n        delay(0.5)\n    end,\n    can_use = function(self, card)\n        return G.hand and #G.hand.highlighted > 0\n    end",
      "config": {
        "extra": {
          "mod_conv": "m_gb_macabre",
          "hex_to_apply": "haunted"
        }
      },
      "ability": {
        "extra": {
          "mod_conv": "m_gb_macabre",
          "hex_to_apply": "haunted"
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "blasphemy",
      "name": "Blasphemy",
      "atlas": "gb_HexCards",
      "pos": {
        "x": 7,
        "y": 0
      },
      "raw": "key = \"blasphemy\",\n    set = \"Hex\",\n    loc_txt = {\n        name = 'Blasphemy',\n        text = {\n            \"Selected cards\",\n            \"gain a random {C:attention}Seal\",\n            \"and become {C:attention}Inflexible\",\n        },\n    },\n    config = { extra = { hex_to_apply = \"inflexible\" } },\n    atlas = 'gb_HexCards',\n    pos = { x = 7, y = 0 },\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue + 1] = GB.hex_tooltip(card.ability.extra.hex_to_apply)\n    end,\n    use = function(self, card, area, copier)\n        for _, playing_card in ipairs(G.hand.highlighted) do\n            playing_card:set_seal(SMODS.poll_seal({ guaranteed = true, type_key = 'gb_candle' }))\n            GB.set_hex(playing_card, \"inflexible\")\n            playing_card:juice_up()\n        end\n    end,\n    can_use = function(self, card)\n        return G.hand and #G.hand.highlighted > 0\n    end",
      "config": {
        "extra": {
          "hex_to_apply": "inflexible"
        }
      },
      "ability": {
        "extra": {
          "hex_to_apply": "inflexible"
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "chaos",
      "name": "Chaos",
      "atlas": "gb_HexCards",
      "pos": {
        "x": 5,
        "y": 0
      },
      "raw": "key = \"chaos\",\n    set = \"Hex\",\n    loc_txt = {\n        name = 'Chaos',\n        text = { {\n            \"Selected cards gain\",\n            \"a random {C:attention}Hex Enhancement{}\",\n        },\n        {\n            \"An equal number of cards\",\n            \"in {C:attention}full deck{} gain\",\n            \"a random {C:attention}Curse\"\n        } }\n    },\n    atlas = 'gb_HexCards',\n    pos = { x = 5, y = 0 },\n    use = function(self, card, area, copier)\n        local enhancement_keys = {\n            \"ripple\",\n            \"rotten\",\n            \"macabre\",\n            \"chained\",\n            \"ashen\",\n            \"alloyed\"\n        }\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.4,\n            func = function()\n                play_sound('tarot1')\n                card:juice_up(0.3, 0.5)\n                return true\n            end\n        }))\n        for i = 1, #G.hand.highlighted do\n            local percent = 1.15 - (i - 0.999) / (#G.hand.highlighted - 0.998) * 0.3\n            G.E_MANAGER:add_event(Event({\n                trigger = 'after',\n                delay = 0.15,\n                func = function()\n                    G.hand.highlighted[i]:flip()\n                    play_sound('card1', percent)\n                    G.hand.highlighted[i]:juice_up(0.3, 0.3)\n                    return true\n                end\n            }))\n        end\n        delay(0.2)\n        for i = 1, #G.hand.highlighted do\n            G.E_MANAGER:add_event(Event({\n                trigger = 'after',\n                delay = 0.1,\n                func = function()\n                    local chosen_enhancement = pseudorandom_element(enhancement_keys, pseudoseed(\"gb_chaos\"))\n                    chosen_enhancement = \"m_gb_\" .. chosen_enhancement\n                    G.hand.highlighted[i]:set_ability(G.P_CENTERS[chosen_enhancement])\n                    return true\n                end\n            }))\n        end\n        for i = 1, #G.hand.highlighted do\n            local percent = 0.85 + (i - 0.999) / (#G.hand.highlighted - 0.998) * 0.3\n            G.E_MANAGER:add_event(Event({\n                trigger = 'after',\n                delay = 0.15,\n                func = function()\n                    G.hand.highlighted[i]:flip()\n                    play_sound('tarot2', percent, 0.6)\n                    G.hand.highlighted[i]:juice_up(0.3, 0.3)\n                    return true\n                end\n            }))\n        end\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.2,\n            func = function()\n                for i = 1, #G.hand.highlighted do\n                    gb_apply_hex(\n                        G.playing_cards,\n                        pseudorandom_element(GB.HEX_KEYS, \"gb_chaos_hexes\"),\n                        1\n                    )\n                end\n                G.hand:unhighlight_all()\n                return true\n            end\n        }))\n        delay(0.5)\n    end,\n    can_use = function(self, card)\n        return G.hand and #G.hand.highlighted > 0\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "conceit",
      "name": "Conceit",
      "atlas": "gb_HexCards",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"conceit\",\n    set = \"Hex\",\n    loc_txt = {\n        name = 'Conceit',\n        text = { {\n            \"Selected cards\",\n            \"become {C:attention}Ripple{} cards\"\n        },\n        {\n            \"An equal number of cards\",\n            \"in {C:attention}full deck{} become {C:attention}Egoistic\"\n        } }\n    },\n    config = { extra = { mod_conv = 'm_gb_ripple', hex_to_apply = \"egoistic\" } },\n    atlas = 'gb_HexCards',\n    pos = { x = 1, y = 1 },\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue + 1] = G.P_CENTERS[card.ability.extra.mod_conv]\n        info_queue[#info_queue + 1] = GB.hex_tooltip(card.ability.extra.hex_to_apply)\n    end,\n    use = function(self, card, area, copier)\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.4,\n            func = function()\n                play_sound('tarot1')\n                card:juice_up(0.3, 0.5)\n                return true\n            end\n        }))\n        for i = 1, #G.hand.highlighted do\n            local percent = 1.15 - (i - 0.999) / (#G.hand.highlighted - 0.998) * 0.3\n            G.E_MANAGER:add_event(Event({\n                trigger = 'after',\n                delay = 0.15,\n                func = function()\n                    G.hand.highlighted[i]:flip()\n                    play_sound('card1', percent)\n                    G.hand.highlighted[i]:juice_up(0.3, 0.3)\n                    return true\n                end\n            }))\n        end\n        delay(0.2)\n        for i = 1, #G.hand.highlighted do\n            G.E_MANAGER:add_event(Event({\n                trigger = 'after',\n                delay = 0.1,\n                func = function()\n                    G.hand.highlighted[i]:set_ability(G.P_CENTERS[card.ability.extra.mod_conv])\n                    return true\n                end\n            }))\n        end\n        for i = 1, #G.hand.highlighted do\n            local percent = 0.85 + (i - 0.999) / (#G.hand.highlighted - 0.998) * 0.3\n            G.E_MANAGER:add_event(Event({\n                trigger = 'after',\n                delay = 0.15,\n                func = function()\n                    G.hand.highlighted[i]:flip()\n                    play_sound('tarot2', percent, 0.6)\n                    G.hand.highlighted[i]:juice_up(0.3, 0.3)\n                    return true\n                end\n            }))\n        end\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.2,\n            func = function()\n                gb_apply_hex(G.playing_cards, card.ability.extra.hex_to_apply, #G.hand.highlighted)\n                G.hand:unhighlight_all()\n                return true\n            end\n        }))\n        delay(0.5)\n    end,\n    can_use = function(self, card)\n        return G.hand and #G.hand.highlighted > 0\n    end",
      "config": {
        "extra": {
          "mod_conv": "m_gb_ripple",
          "hex_to_apply": "egoistic"
        }
      },
      "ability": {
        "extra": {
          "mod_conv": "m_gb_ripple",
          "hex_to_apply": "egoistic"
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "debauchery",
      "name": "Debauchery",
      "atlas": "gb_HexCards",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"debauchery\",\n    set = \"Hex\",\n    loc_txt = {\n        name = 'Debauchery',\n        text = { {\n            \"For each selected card,\",\n            \"create a {C:attention}Tag\",\n        },\n        {\n            \"An equal number of cards\",\n            \"in {C:attention}full deck{} become {C:attention}Slothful\"\n        } }\n    },\n    config = { extra = { hex_to_apply = \"slothful\" } },\n    atlas = 'gb_HexCards',\n    pos = { x = 0, y = 1 },\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue + 1] = GB.hex_tooltip(card.ability.extra.hex_to_apply)\n    end,\n    use = function(self, card, area, copier)\n        for i = 1, #G.hand.highlighted do\n            local tag_pool = get_current_pool('Tag')\n            local selected_tag = pseudorandom_element(tag_pool, pseudoseed('gb_memphis'))\n            local it = 1\n            while selected_tag == 'UNAVAILABLE' do\n                it = it + 1\n                selected_tag = pseudorandom_element(tag_pool, pseudoseed('gb_memphis' .. it))\n            end\n            add_tag(Tag(selected_tag, false, 'Small'))\n        end\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.2,\n            func = function()\n                gb_apply_hex(G.playing_cards, card.ability.extra.hex_to_apply, #G.hand.highlighted)\n                G.hand:unhighlight_all()\n                return true\n            end\n        }))\n        delay(0.5)\n    end,\n    can_use = function(self, card)\n        return G.hand and #G.hand.highlighted > 0\n    end",
      "config": {
        "extra": {
          "hex_to_apply": "slothful"
        }
      },
      "ability": {
        "extra": {
          "hex_to_apply": "slothful"
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "evil_eye",
      "name": "Evil Eye",
      "atlas": "gb_HexCards",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"evil_eye\",\n    set = \"Hex\",\n    loc_txt = {\n        name = 'Evil Eye',\n        text = { {\n            \"Selected cards gain\",\n            \"the same random\",\n            \"{C:attention}Hex Enhancement{}\"\n        },\n        {\n            \"An equal number of cards\",\n            \"in {C:attention}full deck{} become {C:attention}Paranoid\"\n        } }\n    },\n    config = { extra = { hex_to_apply = \"paranoid\" } },\n    atlas = 'gb_HexCards',\n    pos = { x = 0, y = 0 },\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue + 1] = G.P_CENTERS[card.ability.extra.mod_conv]\n        info_queue[#info_queue + 1] = GB.hex_tooltip(card.ability.extra.hex_to_apply)\n    end,\n    use = function(self, card, area, copier)\n        local enhancement_keys = {\n            \"ripple\",\n            \"rotten\",\n            \"macabre\",\n            \"chained\",\n            \"ashen\",\n            \"alloyed\"\n        }\n        local chosen_enhancement = pseudorandom_element(enhancement_keys, pseudoseed(\"gb_evil_eye\"))\n        chosen_enhancement = \"m_gb_\" .. chosen_enhancement\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.4,\n            func = function()\n                play_sound('tarot1')\n                card:juice_up(0.3, 0.5)\n                return true\n            end\n        }))\n        for i = 1, #G.hand.highlighted do\n            local percent = 1.15 - (i - 0.999) / (#G.hand.highlighted - 0.998) * 0.3\n            G.E_MANAGER:add_event(Event({\n                trigger = 'after',\n                delay = 0.15,\n                func = function()\n                    G.hand.highlighted[i]:flip()\n                    play_sound('card1', percent)\n                    G.hand.highlighted[i]:juice_up(0.3, 0.3)\n                    return true\n                end\n            }))\n        end\n        delay(0.2)\n        for i = 1, #G.hand.highlighted do\n            G.E_MANAGER:add_event(Event({\n                trigger = 'after',\n                delay = 0.1,\n                func = function()\n                    G.hand.highlighted[i]:set_ability(G.P_CENTERS[chosen_enhancement])\n                    return true\n                end\n            }))\n        end\n        for i = 1, #G.hand.highlighted do\n            local percent = 0.85 + (i - 0.999) / (#G.hand.highlighted - 0.998) * 0.3\n            G.E_MANAGER:add_event(Event({\n                trigger = 'after',\n                delay = 0.15,\n                func = function()\n                    G.hand.highlighted[i]:flip()\n                    play_sound('tarot2', percent, 0.6)\n                    G.hand.highlighted[i]:juice_up(0.3, 0.3)\n                    return true\n                end\n            }))\n        end\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.2,\n            func = function()\n                gb_apply_hex(G.playing_cards, card.ability.extra.hex_to_apply, #G.hand.highlighted)\n                G.hand:unhighlight_all()\n                return true\n            end\n        }))\n        delay(0.5)\n    end,\n    can_use = function(self, card)\n        return G.hand and #G.hand.highlighted > 0\n    end",
      "config": {
        "extra": {
          "hex_to_apply": "paranoid"
        }
      },
      "ability": {
        "extra": {
          "hex_to_apply": "paranoid"
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "fealty",
      "name": "Fealty",
      "atlas": "gb_HexCards",
      "pos": {
        "x": 9,
        "y": 0
      },
      "raw": "key = \"fealty\",\n    set = \"Hex\",\n    loc_txt = {\n        name = 'Fealty',\n        text = {\n            \"Create {C:attention}Devoted{} copies\",\n            \"of all selected cards\"\n        },\n    },\n    config = { extra = { hex_to_apply = \"devoted\" } },\n    atlas = 'gb_HexCards',\n    pos = { x = 9, y = 0 },\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue + 1] = GB.hex_tooltip(card.ability.extra.hex_to_apply)\n    end,\n    use = function(self, card, area, copier)\n        G.E_MANAGER:add_event(Event({\n            func = function()\n                local first_dissolve = nil\n                local new_cards = {}\n                for i = 1, #G.hand.highlighted do\n                    G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                    local copy_card = copy_card(G.hand.highlighted[i], nil, nil, G.playing_card)\n                    copy_card:add_to_deck()\n                    GB.set_hex(copy_card, card.ability.extra.hex_to_apply)\n                    G.deck.config.card_limit = G.deck.config.card_limit + 1\n                    table.insert(G.playing_cards, copy_card)\n                    G.hand:emplace(copy_card)\n                    copy_card:start_materialize(nil, _first_dissolve)\n                    first_dissolve = true\n                    new_cards[#new_cards + 1] = copy_card\n                end\n                SMODS.calculate_context({ playing_card_added = true, cards = new_cards })\n                return true\n            end\n        }))\n    end,\n    can_use = function(self, card)\n        return G.hand and #G.hand.highlighted > 0\n    end",
      "config": {
        "extra": {
          "hex_to_apply": "devoted"
        }
      },
      "ability": {
        "extra": {
          "hex_to_apply": "devoted"
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "hunger",
      "name": "Hunger",
      "atlas": "gb_HexCards",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"hunger\",\n    set = \"Hex\",\n    loc_txt = {\n        name = 'Hunger',\n        text = {\n            \"Create {C:attention}Ravenous{} copies\",\n            \"of all selected cards\"\n        },\n    },\n    config = { extra = { hex_to_apply = \"ravenous\" } },\n    atlas = 'gb_HexCards',\n    pos = { x = 1, y = 0 },\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue + 1] = GB.hex_tooltip(card.ability.extra.hex_to_apply)\n    end,\n    use = function(self, card, area, copier)\n        G.E_MANAGER:add_event(Event({\n            func = function()\n                local first_dissolve = nil\n                local new_cards = {}\n                for i = 1, #G.hand.highlighted do\n                    G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                    local copy_card = copy_card(G.hand.highlighted[i], nil, nil, G.playing_card)\n                    copy_card:add_to_deck()\n                    GB.set_hex(copy_card, card.ability.extra.hex_to_apply)\n                    G.deck.config.card_limit = G.deck.config.card_limit + 1\n                    table.insert(G.playing_cards, copy_card)\n                    G.hand:emplace(copy_card)\n                    copy_card:start_materialize(nil, _first_dissolve)\n                    first_dissolve = true\n                    new_cards[#new_cards + 1] = copy_card\n                end\n                SMODS.calculate_context({ playing_card_added = true, cards = new_cards })\n                return true\n            end\n        }))\n    end,\n    can_use = function(self, card)\n        return G.hand and #G.hand.highlighted > 0\n    end",
      "config": {
        "extra": {
          "hex_to_apply": "ravenous"
        }
      },
      "ability": {
        "extra": {
          "hex_to_apply": "ravenous"
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "nihilism",
      "name": "Nihilism",
      "atlas": "gb_HexCards",
      "pos": {
        "x": 6,
        "y": 0
      },
      "raw": "key = \"nihilism\",\n    set = \"Hex\",\n    loc_txt = {\n        name = 'Nihilism',\n        text = { {\n            \"Selected cards\",\n            \"become {C:attention}Ashen{} cards\",\n        },\n        {\n            \"An equal number of cards\",\n            \"in {C:attention}full deck{} become {C:attention}Cowardly\"\n        } }\n    },\n    config = { extra = { mod_conv = 'm_gb_ashen', hex_to_apply = \"cowardly\" } },\n    atlas = 'gb_HexCards',\n    pos = { x = 6, y = 0 },\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue + 1] = G.P_CENTERS[card.ability.extra.mod_conv]\n        info_queue[#info_queue + 1] = GB.hex_tooltip(card.ability.extra.hex_to_apply)\n    end,\n    use = function(self, card, area, copier)\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.4,\n            func = function()\n                play_sound('tarot1')\n                card:juice_up(0.3, 0.5)\n                return true\n            end\n        }))\n        for i = 1, #G.hand.highlighted do\n            local percent = 1.15 - (i - 0.999) / (#G.hand.highlighted - 0.998) * 0.3\n            G.E_MANAGER:add_event(Event({\n                trigger = 'after',\n                delay = 0.15,\n                func = function()\n                    G.hand.highlighted[i]:flip()\n                    play_sound('card1', percent)\n                    G.hand.highlighted[i]:juice_up(0.3, 0.3)\n                    return true\n                end\n            }))\n        end\n        delay(0.2)\n        for i = 1, #G.hand.highlighted do\n            G.E_MANAGER:add_event(Event({\n                trigger = 'after',\n                delay = 0.1,\n                func = function()\n                    G.hand.highlighted[i]:set_ability(G.P_CENTERS[card.ability.extra.mod_conv])\n                    return true\n                end\n            }))\n        end\n        for i = 1, #G.hand.highlighted do\n            local percent = 0.85 + (i - 0.999) / (#G.hand.highlighted - 0.998) * 0.3\n            G.E_MANAGER:add_event(Event({\n                trigger = 'after',\n                delay = 0.15,\n                func = function()\n                    G.hand.highlighted[i]:flip()\n                    play_sound('tarot2', percent, 0.6)\n                    G.hand.highlighted[i]:juice_up(0.3, 0.3)\n                    return true\n                end\n            }))\n        end\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.2,\n            func = function()\n                gb_apply_hex(G.playing_cards, card.ability.extra.hex_to_apply, #G.hand.highlighted)\n                G.hand:unhighlight_all()\n                return true\n            end\n        }))\n        delay(0.5)\n    end,\n    can_use = function(self, card)\n        return G.hand and #G.hand.highlighted > 0\n    end",
      "config": {
        "extra": {
          "mod_conv": "m_gb_ashen",
          "hex_to_apply": "cowardly"
        }
      },
      "ability": {
        "extra": {
          "mod_conv": "m_gb_ashen",
          "hex_to_apply": "cowardly"
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "pestilence",
      "name": "Pestilence",
      "atlas": "gb_HexCards",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"pestilence\",\n    set = \"Hex\",\n    loc_txt = {\n        name = 'Pestilence',\n        text = { {\n            \"Selected cards\",\n            \"become {C:attention}Rotten{} cards\",\n        },\n        {\n            \"An equal number of cards\",\n            \"in {C:attention}full deck{} become {C:attention}Decaying\"\n        } }\n    },\n    config = { extra = { mod_conv = 'm_gb_rotten', hex_to_apply = \"decaying\" } },\n    atlas = 'gb_HexCards',\n    pos = { x = 2, y = 1 },\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue + 1] = G.P_CENTERS[card.ability.extra.mod_conv]\n        info_queue[#info_queue + 1] = GB.hex_tooltip(card.ability.extra.hex_to_apply)\n    end,\n    use = function(self, card, area, copier)\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.4,\n            func = function()\n                play_sound('tarot1')\n                card:juice_up(0.3, 0.5)\n                return true\n            end\n        }))\n        for i = 1, #G.hand.highlighted do\n            local percent = 1.15 - (i - 0.999) / (#G.hand.highlighted - 0.998) * 0.3\n            G.E_MANAGER:add_event(Event({\n                trigger = 'after',\n                delay = 0.15,\n                func = function()\n                    G.hand.highlighted[i]:flip()\n                    play_sound('card1', percent)\n                    G.hand.highlighted[i]:juice_up(0.3, 0.3)\n                    return true\n                end\n            }))\n        end\n        delay(0.2)\n        for i = 1, #G.hand.highlighted do\n            G.E_MANAGER:add_event(Event({\n                trigger = 'after',\n                delay = 0.1,\n                func = function()\n                    G.hand.highlighted[i]:set_ability(G.P_CENTERS[card.ability.extra.mod_conv])\n                    return true\n                end\n            }))\n        end\n        for i = 1, #G.hand.highlighted do\n            local percent = 0.85 + (i - 0.999) / (#G.hand.highlighted - 0.998) * 0.3\n            G.E_MANAGER:add_event(Event({\n                trigger = 'after',\n                delay = 0.15,\n                func = function()\n                    G.hand.highlighted[i]:flip()\n                    play_sound('tarot2', percent, 0.6)\n                    G.hand.highlighted[i]:juice_up(0.3, 0.3)\n                    return true\n                end\n            }))\n        end\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.2,\n            func = function()\n                gb_apply_hex(G.playing_cards, card.ability.extra.hex_to_apply, #G.hand.highlighted)\n                G.hand:unhighlight_all()\n                return true\n            end\n        }))\n        delay(0.5)\n    end,\n    can_use = function(self, card)\n        return G.hand and #G.hand.highlighted > 0\n    end",
      "config": {
        "extra": {
          "mod_conv": "m_gb_rotten",
          "hex_to_apply": "decaying"
        }
      },
      "ability": {
        "extra": {
          "mod_conv": "m_gb_rotten",
          "hex_to_apply": "decaying"
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "superstition",
      "name": "Superstition",
      "atlas": "gb_HexCards",
      "pos": {
        "x": 8,
        "y": 0
      },
      "raw": "key = \"superstition\",\n    set = \"Hex\",\n    loc_txt = {\n        name = 'Superstition',\n        text = { {\n            \"For each selected card,\",\n            \"level up {C:attention}most played poker hand{}\",\n        },\n        {\n            \"An equal number of cards\",\n            \"in {C:attention}full deck{} become {C:attention}Obsessive\"\n        } }\n    },\n    config = { extra = { hex_to_apply = \"obsessive\" } },\n    atlas = 'gb_HexCards',\n    pos = { x = 8, y = 0 },\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue + 1] = GB.hex_tooltip(card.ability.extra.hex_to_apply)\n    end,\n    use = function(self, card, area, copier)\n        local most_played_hand, play_tally = nil, 0\n        for _, handname in ipairs(G.handlist) do\n            if SMODS.is_poker_hand_visible(handname) and G.GAME.hands[handname].played > play_tally then\n                most_played_hand = handname\n                play_tally = G.GAME.hands[handname].played\n            end\n        end\n        if most_played_hand then\n            SMODS.smart_level_up_hand(card, most_played_hand, false, #G.hand.highlighted)\n        end\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.2,\n            func = function()\n                gb_apply_hex(G.playing_cards, card.ability.extra.hex_to_apply, #G.hand.highlighted)\n                G.hand:unhighlight_all()\n                return true\n            end\n        }))\n        delay(0.5)\n    end,\n    can_use = function(self, card)\n        return G.hand and #G.hand.highlighted > 0\n    end",
      "config": {
        "extra": {
          "hex_to_apply": "obsessive"
        }
      },
      "ability": {
        "extra": {
          "hex_to_apply": "obsessive"
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "tyranny",
      "name": "Tyranny",
      "atlas": "gb_HexCards",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"tyranny\",\n    set = \"Hex\",\n    loc_txt = {\n        name = 'Tyranny',\n        text = { {\n            \"Selected cards\",\n            \"become {C:attention}Chained{} cards\",\n        },\n        {\n            \"An equal number of cards\",\n            \"in {C:attention}full deck{} become {C:attention}Despot\"\n        } }\n    },\n    config = { extra = { mod_conv = 'm_gb_chained', hex_to_apply = \"despot\" } },\n    atlas = 'gb_HexCards',\n    pos = { x = 3, y = 0 },\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue + 1] = G.P_CENTERS[card.ability.extra.mod_conv]\n        info_queue[#info_queue + 1] = GB.hex_tooltip(card.ability.extra.hex_to_apply)\n    end,\n    use = function(self, card, area, copier)\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.4,\n            func = function()\n                play_sound('tarot1')\n                card:juice_up(0.3, 0.5)\n                return true\n            end\n        }))\n        for i = 1, #G.hand.highlighted do\n            local percent = 1.15 - (i - 0.999) / (#G.hand.highlighted - 0.998) * 0.3\n            G.E_MANAGER:add_event(Event({\n                trigger = 'after',\n                delay = 0.15,\n                func = function()\n                    G.hand.highlighted[i]:flip()\n                    play_sound('card1', percent)\n                    G.hand.highlighted[i]:juice_up(0.3, 0.3)\n                    return true\n                end\n            }))\n        end\n        delay(0.2)\n        for i = 1, #G.hand.highlighted do\n            G.E_MANAGER:add_event(Event({\n                trigger = 'after',\n                delay = 0.1,\n                func = function()\n                    G.hand.highlighted[i]:set_ability(G.P_CENTERS[card.ability.extra.mod_conv])\n                    return true\n                end\n            }))\n        end\n        for i = 1, #G.hand.highlighted do\n            local percent = 0.85 + (i - 0.999) / (#G.hand.highlighted - 0.998) * 0.3\n            G.E_MANAGER:add_event(Event({\n                trigger = 'after',\n                delay = 0.15,\n                func = function()\n                    G.hand.highlighted[i]:flip()\n                    play_sound('tarot2', percent, 0.6)\n                    G.hand.highlighted[i]:juice_up(0.3, 0.3)\n                    return true\n                end\n            }))\n        end\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.2,\n            func = function()\n                gb_apply_hex(G.playing_cards, card.ability.extra.hex_to_apply, #G.hand.highlighted)\n                G.hand:unhighlight_all()\n                return true\n            end\n        }))\n        delay(0.5)\n    end,\n    can_use = function(self, card)\n        return G.hand and #G.hand.highlighted > 0\n    end",
      "config": {
        "extra": {
          "mod_conv": "m_gb_chained",
          "hex_to_apply": "despot"
        }
      },
      "ability": {
        "extra": {
          "mod_conv": "m_gb_chained",
          "hex_to_apply": "despot"
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "war",
      "name": "War",
      "atlas": "gb_HexCards",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"war\",\n    set = \"Hex\",\n    loc_txt = {\n        name = 'War',\n        text = { {\n            \"Selected cards\",\n            \"become {C:attention}Alloyed{} cards\",\n        },\n        {\n            \"An equal number of cards\",\n            \"in {C:attention}full deck{} become {C:attention}Unstable\"\n        } }\n    },\n    config = { extra = { mod_conv = 'm_gb_alloyed', hex_to_apply = \"unstable\" } },\n    atlas = 'gb_HexCards',\n    pos = { x = 2, y = 0 },\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue + 1] = G.P_CENTERS[card.ability.extra.mod_conv]\n        info_queue[#info_queue + 1] = GB.hex_tooltip(card.ability.extra.hex_to_apply)\n    end,\n    use = function(self, card, area, copier)\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.4,\n            func = function()\n                play_sound('tarot1')\n                card:juice_up(0.3, 0.5)\n                return true\n            end\n        }))\n        for i = 1, #G.hand.highlighted do\n            local percent = 1.15 - (i - 0.999) / (#G.hand.highlighted - 0.998) * 0.3\n            G.E_MANAGER:add_event(Event({\n                trigger = 'after',\n                delay = 0.15,\n                func = function()\n                    G.hand.highlighted[i]:flip()\n                    play_sound('card1', percent)\n                    G.hand.highlighted[i]:juice_up(0.3, 0.3)\n                    return true\n                end\n            }))\n        end\n        delay(0.2)\n        for i = 1, #G.hand.highlighted do\n            G.E_MANAGER:add_event(Event({\n                trigger = 'after',\n                delay = 0.1,\n                func = function()\n                    G.hand.highlighted[i]:set_ability(G.P_CENTERS[card.ability.extra.mod_conv])\n                    return true\n                end\n            }))\n        end\n        for i = 1, #G.hand.highlighted do\n            local percent = 0.85 + (i - 0.999) / (#G.hand.highlighted - 0.998) * 0.3\n            G.E_MANAGER:add_event(Event({\n                trigger = 'after',\n                delay = 0.15,\n                func = function()\n                    G.hand.highlighted[i]:flip()\n                    play_sound('tarot2', percent, 0.6)\n                    G.hand.highlighted[i]:juice_up(0.3, 0.3)\n                    return true\n                end\n            }))\n        end\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.2,\n            func = function()\n                gb_apply_hex(G.playing_cards, card.ability.extra.hex_to_apply, #G.hand.highlighted)\n                G.hand:unhighlight_all()\n                return true\n            end\n        }))\n        delay(0.5)\n    end,\n    can_use = function(self, card)\n        return G.hand and #G.hand.highlighted > 0\n    end",
      "config": {
        "extra": {
          "mod_conv": "m_gb_alloyed",
          "hex_to_apply": "unstable"
        }
      },
      "ability": {
        "extra": {
          "mod_conv": "m_gb_alloyed",
          "hex_to_apply": "unstable"
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "dualism",
      "name": "Dualism",
      "atlas": "gb_Consumables",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = 'dualism',\n    loc_txt = {\n        name = \"Dualism\",\n        text = {\n            \"Add a {V:1}Dual Seal{}\",\n            \"to {C:attention}1{} selected\",\n            \"card in your hand\",\n        },\n    },\n    set = 'Spectral',\n    atlas = 'gb_Consumables',\n    pos = { x = 2, y = 1 },\n    config = { extra = { seal = 'gb_dual' }, max_highlighted = 1 },\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue + 1] = G.P_SEALS[card.ability.extra.seal]\n        return { vars = { card.ability.max_highlighted, colours = { HEX(\"6E89C2\") } } }\n    end,\n    use = function(self, card, area, copier)\n        local conv_card = G.hand.highlighted[1]\n        G.E_MANAGER:add_event(Event({\n            func = function()\n                play_sound('tarot1')\n                card:juice_up(0.3, 0.5)\n                return true\n            end\n        }))\n\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.1,\n            func = function()\n                conv_card:set_seal(card.ability.extra.seal, nil, true)\n                return true\n            end\n        }))\n\n        delay(0.5)\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.2,\n            func = function()\n                G.hand:unhighlight_all()\n                return true\n            end\n        }))\n    end",
      "config": {
        "extra": {
          "seal": "gb_dual"
        },
        "max_highlighted": 1
      },
      "ability": {
        "extra": {
          "seal": "gb_dual"
        },
        "max_highlighted": 1
      },
      "vars": [
        1,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "gambit",
      "name": "Gambit",
      "atlas": "gb_Consumables",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = 'gambit',\n    loc_txt = {\n        name = \"Gambit\",\n        text = {\n            \"Add a {V:1}Fortune Seal{}\",\n            \"to {C:attention}1{} selected\",\n            \"card in your hand\",\n        },\n    },\n    set = 'Spectral',\n    atlas = 'gb_Consumables',\n    pos = { x = 1, y = 1 },\n    config = { extra = { seal = 'gb_fortune' }, max_highlighted = 1 },\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue + 1] = G.P_SEALS[card.ability.extra.seal]\n        return { vars = { card.ability.max_highlighted, colours = { HEX(\"CAB785\") } } }\n    end,\n    use = function(self, card, area, copier)\n        local conv_card = G.hand.highlighted[1]\n        G.E_MANAGER:add_event(Event({\n            func = function()\n                play_sound('tarot1')\n                card:juice_up(0.3, 0.5)\n                return true\n            end\n        }))\n\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.1,\n            func = function()\n                conv_card:set_seal(card.ability.extra.seal, nil, true)\n                return true\n            end\n        }))\n\n        delay(0.5)\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.2,\n            func = function()\n                G.hand:unhighlight_all()\n                return true\n            end\n        }))\n    end",
      "config": {
        "extra": {
          "seal": "gb_fortune"
        },
        "max_highlighted": 1
      },
      "ability": {
        "extra": {
          "seal": "gb_fortune"
        },
        "max_highlighted": 1
      },
      "vars": [
        1,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "lotus",
      "name": "Lotus",
      "atlas": "gb_Consumables",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = 'lotus',\n    loc_txt = {\n        name = \"Lotus\",\n        text = {\n            \"Add an {V:1}Infinite Seal{}\",\n            \"to {C:attention}1{} selected\",\n            \"card in your hand\",\n        },\n    },\n    set = 'Spectral',\n    atlas = 'gb_Consumables',\n    pos = { x = 0, y = 1 },\n    config = { extra = { seal = 'gb_infinite' }, max_highlighted = 1 },\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue + 1] = G.P_SEALS[card.ability.extra.seal]\n        return { vars = { card.ability.max_highlighted, colours = { HEX(\"A1A5A6\") } } }\n    end,\n    use = function(self, card, area, copier)\n        local conv_card = G.hand.highlighted[1]\n        G.E_MANAGER:add_event(Event({\n            func = function()\n                play_sound('tarot1')\n                card:juice_up(0.3, 0.5)\n                return true\n            end\n        }))\n\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.1,\n            func = function()\n                conv_card:set_seal(card.ability.extra.seal, nil, true)\n                return true\n            end\n        }))\n\n        delay(0.5)\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.2,\n            func = function()\n                G.hand:unhighlight_all()\n                return true\n            end\n        }))\n    end",
      "config": {
        "extra": {
          "seal": "gb_infinite"
        },
        "max_highlighted": 1
      },
      "ability": {
        "extra": {
          "seal": "gb_infinite"
        },
        "max_highlighted": 1
      },
      "vars": [
        1,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "awaken",
      "name": "Awaken",
      "atlas": "gb_Consumables",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"awaken\",\n    set = \"Spectral\",\n    loc_txt = {\n        name = 'Awaken',\n        text = {\n            \"{C:attention}Convert{} up to {C:attention}#1#{} random cards\",\n            \"in {C:attention}full deck{} to {C:gb_eyes}Eyes{}\",\n        }\n    },\n    hidden = true,\n    soul_set = \"Planet\",\n    soul_rate = 0.025,\n    atlas = 'gb_Consumables',\n    pos = { x = 1, y = 0 },\n    config = { extra = { cards_to_convert = 10 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.cards_to_convert } }\n    end,\n    can_use = function(self, card)\n        return true\n    end,\n    use = function(self, card, area, copier)\n        local eligible_cards = {}\n        for _, playing_card in ipairs(G.playing_cards or {}) do\n            table.insert(eligible_cards, playing_card)\n        end\n        for i = 1, self.config.extra.cards_to_convert do\n            if eligible_cards[i] then\n                local selected_card, card_index = pseudorandom_element(eligible_cards, 'gb_awaken')\n                assert(SMODS.change_base(selected_card, \"gb_Eyes\", nil))\n                table.remove(eligible_cards, card_index)\n            end\n        end\n        G.E_MANAGER:add_event(Event({\n        trigger = 'after',\n        delay = 0.4,\n        func = function()\n            attention_text({\n                text = \"Awaken!\",\n                scale = 1.3,\n                hold = 1.4,\n                major = card,\n                backdrop_colour = HEX(\"673E79\"),\n                align = (G.STATE == G.STATES.TAROT_PACK or G.STATE == G.STATES.SPECTRAL_PACK or G.STATE == G.STATES.SMODS_BOOSTER_OPENED) and\n                    'tm' or 'cm',\n                offset = { x = 0, y = (G.STATE == G.STATES.TAROT_PACK or G.STATE == G.STATES.SPECTRAL_PACK or G.STATE == G.STATES.SMODS_BOOSTER_OPENED) and -0.2 or 0 },\n                silent = true\n            })\n            card:juice_up(0.3, 0.5)\n            return true\n        end\n        }))\n    end",
      "config": {
        "extra": {
          "cards_to_convert": 10
        }
      },
      "ability": {
        "extra": {
          "cards_to_convert": 10
        }
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "shatter",
      "name": "Shatter",
      "atlas": "gb_Consumables",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"shatter\",\n    set = \"Spectral\",\n    loc_txt = {\n        name = 'Shatter',\n        text = {\n            \"{V:1}Shatters{} one random\",\n            \"{C:attention}eligible{} Joker\",\n        }\n    },\n    hidden = true,\n    soul_set = \"Tarot\",\n    soul_rate = 0.04,\n    atlas = 'gb_Consumables',\n    pos = { x = 0, y = 0 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { colours = { HEX(\"834896\") } } }\n    end,\n\n    can_use = function(self, card)\n        return (#gb_find_eligible_shatters() > 0)\n    end,\n\n    in_pool = function(self, args)\n        return (#gb_find_eligible_shatters() > 0)\n    end,\n    \n    use = function(self, card, area, copier)\n        local outgoing_joker_key = pseudorandom_element(gb_find_eligible_shatters(), pseudoseed(\"gb_shatter\"))\n        local outgoing_joker = SMODS.find_card(outgoing_joker_key)[1]\n        -- Find the corresponding shattered joker\n        local incoming_joker_key = GB_SHATTERED_TABLE[outgoing_joker_key]\n        -- Remove the original joker and add the shattered one\n        G.E_MANAGER:add_event(Event({\n        trigger = 'after',\n        delay = 0.4,\n        func = function()\n            attention_text({\n                text = \"Shatter!\",\n                scale = 1.3,\n                hold = 1.4,\n                major = card,\n                backdrop_colour = HEX(\"673E79\"),\n                align = (G.STATE == G.STATES.TAROT_PACK or G.STATE == G.STATES.SPECTRAL_PACK or G.STATE == G.STATES.SMODS_BOOSTER_OPENED) and\n                    'tm' or 'cm',\n                offset = { x = 0, y = (G.STATE == G.STATES.TAROT_PACK or G.STATE == G.STATES.SPECTRAL_PACK or G.STATE == G.STATES.SMODS_BOOSTER_OPENED) and -0.2 or 0 },\n                silent = true\n            })\n            G.E_MANAGER:add_event(Event({\n                trigger = 'after',\n                delay = 0.15 * G.SETTINGS.GAMESPEED,\n                blockable = false,\n                blocking = false,\n                func = function()\n                    outgoing_joker:start_dissolve()\n                    SMODS.add_card{\n                    set = 'Joker',\n                    key = incoming_joker_key,\n                    edition = (outgoing_joker.edition and outgoing_joker.edition.key) or nil\n                }\n                return true\n                end\n                    }))\n            card:juice_up(0.3, 0.5)\n            return true\n            end\n        }))\n    end,\n\n    --thanks to SDM_0 for this\n    update = function(self, card, dt)\n        if card.gb_shatter_juice == nil then\n            card.gb_shatter_juice = false\n        end\n\n        if card.highlighted and not card.gb_shatter_juice and (G.jokers and G.jokers.cards) then\n            local eligible_jokers = {}\n            for _, v in ipairs(G.jokers.cards) do\n                if GB_SHATTERED_TABLE[v.config.center.key] then\n                    eligible_jokers[#eligible_jokers + 1] = v\n                end\n            end\n            if next(eligible_jokers) then\n                for _, v in ipairs(eligible_jokers) do\n                    if not v.juice then\n                        local eval = function() return (card.highlighted) end\n                        juice_card_until(v, eval, true)\n                    end\n                end\n                card.gb_shatter_juice = true\n            end\n        end\n\n        if not card.highlighted then\n            card.gb_shatter_juice = nil\n        end\n    end",
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "airline",
      "name": "Airline Deck",
      "atlas": "gb_Decks",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"airline\",\n    atlas = \"gb_Decks\",\n    pos = { x = 2, y = 1 },\n    loc_txt = {\n        name = \"Airline Deck\",\n        text = {\n            \"{C:attention}Big Blinds{} do not appear\",\n            \"Start with an extra {C:money}$#1#{},\",\n            \"{T:v_reroll_surplus,C:green}Reroll Surplus{} and {T:v_seed_money,C:money}Seed Money{}\"\n        },\n    },\n    config = { vouchers = {\"v_reroll_surplus\", \"v_seed_money\"}, dollars = 15 },\n    loc_vars = function(self, info_queue, back)\n        return { vars = { self.config.dollars } }\n    end,\n    apply = function(self, back)\n        G.GAME.round_resets.blind_states.Big = \"Hide\"\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "allstar",
      "name": "All-Star Deck",
      "atlas": "gb_Decks",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"allstar\",\n    atlas = \"gb_Decks\",\n    pos = { x = 0, y = 1 },\n    loc_txt = {\n        name = \"All-Star Deck\",\n        text = {\n            \"{C:blue}Common{} Jokers do not\",\n            \"spawn naturally\"\n        },\n    }",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "casino",
      "name": "Casino Deck",
      "atlas": "gb_Decks",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"casino\",\n    loc_txt = {\n        name = \"Casino Deck\",\n        text = {\n            \"{C:attention}Double{} all {C:green}listed probabilities{}\",\n            \"Earn no {C:attention}Interest\"\n        }\n    },\n    atlas = \"gb_Decks\",\n    config = { no_interest = true },\n    pos = { x = 3, y = 1 },\n    calculate = function(self, card, context)\n        if context.mod_probability and not context.blueprint then\n            return {\n                numerator = context.numerator * 2\n            }\n        end\n    end,",
      "config": {
        "no_interest": true
      },
      "ability": {
        "no_interest": true
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "crowded",
      "name": "Crowded Deck",
      "atlas": "gb_Decks",
      "pos": {
        "x": 7,
        "y": 0
      },
      "raw": "key = \"crowded\",\n    atlas = \"gb_Decks\",\n    pos = { x = 7, y = 0 },\n    loc_txt = {\n        name = \"Crowded Deck\",\n        text = {\n            \"{C:attention}3{} random {C:attention}numbered{} ranks\",\n            \"are converted to {C:attention}face{} cards\",\n            \"Start with {C:blue,T:v_magic_trick}Magic Trick\",\n            \"and {C:attention,T:v_overstock_norm}Overstock\"\n        },\n    },\n    config = { vouchers = {\"v_magic_trick\", \"v_overstock_norm\"} },\n    apply = function(self, back)\n        local valid_ranks = {}\n        for i = 2, 10 do\n            table.insert(valid_ranks, i)\n        end\n        pseudorandom('gb_crowded', 2, 10)\n        G.E_MANAGER:add_event(Event({\n            func = function()\n                for _, suit in ipairs({\"Jack\", \"Queen\", \"King\"}) do\n                    local chosen_rank = pseudorandom_element(valid_ranks, pseudoseed('gb_crowded'))\n                    table.remove(valid_ranks, chosen_rank - 1)\n                    for _, playing_card in ipairs(G.playing_cards) do\n                        if playing_card:get_id() == chosen_rank then\n                            assert(SMODS.change_base(playing_card, nil, suit))\n                        end\n                    end\n                end\n                return true\n            end\n        }))\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "durak",
      "name": "Durak Deck",
      "atlas": "gb_Decks",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"durak\",\n    atlas = \"gb_Decks\",\n    pos = { x = 1, y = 1 },\n    loc_txt = {\n        name = \"Durak Deck\",\n        text = {\n            \"Start with no cards\",\n            \"from {C:attention}2{} through {C:attention}5{}\",\n            \"A random {C:attention}Suit{} is {C:attention}Wild\"\n        },\n    },\n    apply = function(self, back)\n        G.E_MANAGER:add_event(Event({\n            func = function()\n                local cards_to_remove = {}\n                for _, playing_card in ipairs(G.playing_cards) do\n                    if playing_card:get_id() >= 2\n                    and playing_card:get_id() <= 5 then\n                        table.insert(cards_to_remove, playing_card)\n                    end\n                end\n                for _, card_to_remove in ipairs(cards_to_remove) do\n                    card_to_remove:remove()\n                end\n                local wild_suit = pseudorandom_element({ 'Spades', 'Hearts', 'Clubs', 'Diamonds' }, pseudoseed('gb_durak'))\n                for _, playing_card in ipairs(G.playing_cards) do\n                    if playing_card:is_suit(wild_suit) then\n                        playing_card:set_ability(\"m_wild\", nil, nil)\n                    end\n                end\n                G.GAME.starting_deck_size = #G.playing_cards\n                return true\n            end\n        }))\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "frankendeck",
      "name": "Frankendeck",
      "atlas": "gb_Decks",
      "pos": {
        "x": 5,
        "y": 0
      },
      "raw": "key = \"frankendeck\",\n    loc_txt = {\n        name = \"Frankendeck\",\n        text = {\n            \"Combine the first {C:attention}5 Vanilla{} decks\",\n            \"All shops cost {C:white,X:money}X1.5{} as much\"\n        }\n    },\n    -- TODO: SHOP COST MULTIPLIER\n    config = {\n        discards = 1,\n        dollars = 10,\n        extra_hand_bonus = 2,\n        extra_discard_bonus = 1,\n        no_interest = true,\n        joker_slot = 1\n    },\n    atlas = \"gb_Decks\",\n    pos = { x = 5, y = 0 },\n    apply = function(self, back)\n        G.GAME.gb_cost_multiplier = 1.5\n    end,",
      "config": {
        "discards": 1,
        "dollars": 10,
        "extra_hand_bonus": 2,
        "extra_discard_bonus": 1,
        "no_interest": true,
        "joker_slot": 1
      },
      "ability": {
        "discards": 1,
        "dollars": 10,
        "extra_hand_bonus": 2,
        "extra_discard_bonus": 1,
        "no_interest": true,
        "joker_slot": 1
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "gem",
      "name": "Gem Deck",
      "atlas": "gb_Decks",
      "pos": {
        "x": 8,
        "y": 0
      },
      "raw": "key = \"gem\",\r\n    loc_txt = {\r\n        name = \"Gem Deck\",\r\n        text = {\r\n            \"Start with an extra {C:money}$#1#{}\",\r\n            \"and {C:money,T:v_clearance_sale}Clearance Sale{}\",\r\n            \"{s:0.85,C:inactive}Thank you to @squidguset\",\r\n            \"{s:0.85,C:inactive} for the deck effect!\",\r\n\r\n        }\r\n    },\r\n    atlas = \"gb_Decks\",\r\n    pos = { x = 8, y = 0 },\r\n    config = { dollars = 5, voucher = 'v_clearance_sale' },\r\n    loc_vars = function(self, info_queue, back)\r\n        return { vars = { self.config.dollars } }\r\n    end",
      "config": {
        "dollars": 5,
        "voucher": "v_clearance_sale"
      },
      "ability": {
        "dollars": 5,
        "voucher": "v_clearance_sale"
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "illusion",
      "name": "Illusion Deck",
      "atlas": "gb_Decks",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"illusion\",\n    loc_txt = {\n        name = \"Illusion Deck\",\n        text = {\n            \"When {C:attention}Boss Blind{} is selected,\",\n            \"create a {C:dark_edition}Negative {V:1}Ephemeral{} card\"\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { colours = { HEX(\"8EA4B3\") } } }\n    end,\n    atlas = \"gb_Decks\",\n    pos = { x = 2, y = 0 },\n    calculate = function(self, card, context)\n        if context.setting_blind\n        and context.blind.boss then\n            G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1\n            G.E_MANAGER:add_event(Event({\n                func = (function()\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            SMODS.add_card {\n                                set = 'Ephemeral',\n                                key_append = 'gb_illusion',\n                                edition = 'e_negative'\n                            }\n                            G.GAME.consumeable_buffer = 0\n                            return true\n                        end\n                    }))\n                    return true\n                end)\n            }))\n            return nil, true\n        end\n    end,",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "memphis",
      "name": "Memphis Deck",
      "atlas": "gb_Decks",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"memphis\",\n    loc_txt = {\n        name = \"Memphis Deck\",\n        text = {\n            \"Create an additional random {C:attention}Tag{}\",\n            \"when a {C:attention}Blind{} is skipped\"\n        }\n    },\n    atlas = \"gb_Decks\",\n    pos = { x = 3, y = 0 },\n    calculate = function(self, back, context)\n        if context.skip_blind then\n            local tag_pool = get_current_pool('Tag')\n            local selected_tag = pseudorandom_element(tag_pool, pseudoseed('gb_memphis'))\n            local it = 1\n            while selected_tag == 'UNAVAILABLE' do\n                it = it + 1\n                selected_tag = pseudorandom_element(tag_pool, pseudoseed('gb_memphis' .. it))\n            end\n            add_tag(Tag(selected_tag, false, 'Small'))\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "rushdown",
      "name": "Rushdown Deck",
      "atlas": "gb_Decks",
      "pos": {
        "x": 6,
        "y": 0
      },
      "raw": "key = \"rushdown\",\n    atlas = \"gb_Decks\",\n    pos = { x = 6, y = 0 },\n    loc_txt = {\n        name = \"Rushdown Deck\",\n        text = {\n            \"Start on {C:attention}Ante #1#{}\",\n            \"All poker hands\",\n            \"start at {C:attention}Lv.#2#{}\"\n        },\n    },\n    config = { extra = { start_ante = 2, hand_level = 3 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.start_ante, self.config.extra.hand_level } }\n    end,\n    apply = function(self, back)\n        G.GAME.round_resets.ante = self.config.extra.start_ante\n        G.GAME.round_resets.blind_ante = G.GAME.round_resets.ante\n        for key, _ in pairs(G.GAME.hands) do\n            level_up_hand(nil, key, true, self.config.extra.hand_level - 1)\n        end\n    end",
      "config": {
        "extra": {
          "start_ante": 2,
          "hand_level": 3
        }
      },
      "ability": {
        "extra": {
          "start_ante": 2,
          "hand_level": 3
        }
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "switch",
      "name": "Switch Deck",
      "atlas": "gb_Decks",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"switch\",\n    loc_txt = {\n        name = \"Switch Deck\",\n        text = {\n            \"+#1# {C:blue}Hand{} on {C:attention}odd{} rounds\",\n            \"+#1# {C:red}Discard{} on {C:attention}even{} rounds\"\n        }\n    },\n    atlas = \"gb_Decks\",\n    pos = { x = 1, y = 0 },\n    config = { stat_boost = 1 },\n    loc_vars = function(self, info_queue, back)\n        return { vars = { self.config.stat_boost } }\n    end,\n    calculate = function(self, back, context)\n        if context.setting_blind then\n            if G.GAME.round % 2 == 1 then\n                ease_hands_played(self.config.stat_boost)\n            else\n                ease_discard(self.config.stat_boost)\n            end\n        end\n    end",
      "config": {
        "stat_boost": 1
      },
      "ability": {
        "stat_boost": 1
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "woven",
      "name": "Woven Deck",
      "atlas": "gb_Decks",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"woven\",\n    atlas = \"gb_Decks\",\n    pos = { x = 0, y = 0 },\n    loc_txt = {\n        name = \"Woven Deck\",\n        text = {\n            \"Start on {C:attention}Ante #1#{}\",\n            \"Win on {C:attention}Ante #2#{}\",\n            \"Start with {C:inactive,T:v_blank}Blank{}\"\n        },\n    },\n    config = { voucher = 'v_blank', extra = { start_ante = 0, win_ante = 9 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.start_ante, self.config.extra.win_ante } }\n    end,\n    apply = function(self, back)\n        G.GAME.win_ante = self.config.extra.win_ante\n        G.GAME.round_resets.ante = self.config.extra.start_ante\n        G.GAME.round_resets.blind_ante = G.GAME.round_resets.ante\n    end",
      "config": {
        "voucher": "v_blank",
        "extra": {
          "start_ante": 0,
          "win_ante": 9
        }
      },
      "ability": {
        "voucher": "v_blank",
        "extra": {
          "start_ante": 0,
          "win_ante": 9
        }
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Edition",
      "key": "temporary",
      "name": "Temporary",
      "atlas": null,
      "pos": null,
      "raw": "key = 'temporary',\n    shader = 'voucher',\n    loc_txt = {\n        name = \"Temporary\",\n        text = {\n            \"{C:attention}Destroyed{} at end of round\",\n            \"Cannot be debuffed\",\n        },\n        label = \"Temporary\",\n    },\n    prefix_config = {\n        -- This allows using the vanilla shader\n        -- Not needed when using your own\n        shader = false\n    },\n    in_shop = false,\n    weight = 0,\n    extra_cost = 0,\n    sound = { sound = \"foil1\", per = 1.2, vol = 0.4 },\n    get_weight = function(self)\n        return 0\n    end,\n    calculate = function(self, card, context)\n        if context.end_of_round and not card.ability.getting_destroyed then\n            card.ability.getting_destroyed = true\n            G.E_MANAGER:add_event(Event({\n                trigger = 'after',\n                delay = 0.2,\n                blockable = false,\n                func = function()\n                    card:start_dissolve()\n                    return true\n                end\n            }))\n        end\n    end,\n    on_remove = function(card)\n        if card.edition and card.edition.key ~= \"e_gb_temporary\" then\n            card:set_edition(\"e_gb_temporary\")\n        end\n    end,\n    in_pool = function(self, args)\n        return false\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "alloyed",
      "name": "Alloyed Card",
      "atlas": "gb_Enhancements",
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "key = 'alloyed',\n    loc_txt = {\n\t\tname = 'Alloyed Card',\n\t\ttext = {\n\t\t\t\"Gains {C:mult}+#1#{} Mult\",\n            \"held in hand\",\n\t\t\t\"when played\",\n            \"{C:inactive}(Currently {C:mult}+#2# {C:inactive}Mult)\"\n\t\t}\n\t},\n    atlas = 'gb_Enhancements',\n    pos = { x = 4, y = 0 },\n    config = { h_mult = 0, extra = { mult_mod = 10 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.mult_mod, card.ability.h_mult } }\n    end,\n    calculate = function(self, card, context)\n        if context.before and context.cardarea == G.play then\n            SMODS.scale_card(card, {\n                ref_table = card.ability,\n                ref_value = \"h_mult\",\n                scalar_table = card.ability.extra,\n                scalar_value = \"mult_mod\",\n                message_colour = G.C.SHIPS\n            })\n        end\n    end,\n    in_pool = function(self, args)\n        return false\n    end",
      "config": {
        "h_mult": 0,
        "extra": {
          "mult_mod": 10
        }
      },
      "ability": {
        "h_mult": 0,
        "extra": {
          "mult_mod": 10
        }
      },
      "vars": [
        10,
        0
      ],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "ashen",
      "name": "Ashen Card",
      "atlas": "gb_Enhancements",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = 'ashen',\n    loc_txt = {\n\t\tname = 'Ashen Card',\n\t\ttext = {\n\t\t\t\"{C:green}#1# in #2#{} chance to\",\n            \"{C:attention}level up{} played poker hand\",\n            \"if played and scoring\"\n\t\t}\n\t},\n    atlas = 'gb_Enhancements',\n    pos = { x = 2, y = 0 },\n    config = { extra = { odds = 3 } },\n    loc_vars = function(self, info_queue, card)\n        local new_numerator, new_denominator = SMODS.get_probability_vars(card, 1, card.ability.extra.odds)\n\t\treturn { vars = { new_numerator, new_denominator } }\n    end,\n    calculate = function(self, card, context)    \n        if context.before and context.cardarea == G.play then\n            if SMODS.pseudorandom_probability(card, 'gb_ashen', 1, card.ability.extra.odds) then\n                return {\n                    level_up = true\n                }\n            else\n                return {\n                    message = localize(\"k_nope_ex\"),\n                    colour = G.C.SECONDARY_SET.Tarot,\n\t\t\t\t\tsound = 'cancel'\n                }\n            end\n        end\n    end,\n    in_pool = function(self, args)\n        return false\n    end",
      "config": {
        "extra": {
          "odds": 3
        }
      },
      "ability": {
        "extra": {
          "odds": 3
        }
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "chained",
      "name": "Chained Card",
      "atlas": "gb_Enhancements",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = 'chained',\n    loc_txt = {\n\t\tname = 'Chained Card',\n\t\ttext = {\n\t\t\t\"{C:chips}+#1#{} Chips for every\",\n            \"{C:attention}Chained{} card in {C:attention}full deck\"\n\t\t}\n\t},\n    atlas = 'gb_Enhancements',\n    pos = { x = 1, y = 0 },\n    config = { bonus = 0, extra = { chips_mod = 20 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.chips_mod } }\n    end,\n    set_ability = function(self, card, initial, delay_sprites)\n        if G.deck then\n            card.ability.bonus = card.ability.extra.chips_mod * gb_tally_enhancements(G.playing_cards, \"m_gb_chained\")\n        end\n    end,\n    calculate = function(self, card, context)\n        if G.deck then\n            card.ability.bonus = card.ability.extra.chips_mod * gb_tally_enhancements(G.playing_cards, \"m_gb_chained\")\n        end\n    end,\n    in_pool = function(self, args)\n        return false\n    end",
      "config": {
        "bonus": 0,
        "extra": {
          "chips_mod": 20
        }
      },
      "ability": {
        "bonus": 0,
        "extra": {
          "chips_mod": 20
        }
      },
      "vars": [
        20
      ],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "macabre",
      "name": "Macabre Card",
      "atlas": "gb_Enhancements",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = 'macabre',\n    loc_txt = {\n\t\tname = 'Macabre Card',\n\t\ttext = {\n\t\t\t\"Gains {C:mult}+#1#{} Mult\",\n\t\t\t\"when discarded\",\n            \"{C:green}#2# in #3#{} chance to be\",\n            \"{C:attention}destroyed{} after playing\",\n\t\t}\n\t},\n    atlas = 'gb_Enhancements',\n    pos = { x = 0, y = 0 },\n    config = { mult = 0, extra = { mult_mod = 10, odds = 8 } },\n    loc_vars = function(self, info_queue, card)\n        local new_numerator, new_denominator = SMODS.get_probability_vars(card, 1, card.ability.extra.odds)\n\t\treturn { vars = { card.ability.extra.mult_mod, new_numerator, new_denominator } }\n    end,\n    calculate = function(self, card, context)\n        if context.discard and context.other_card == card then\n            SMODS.scale_card(card, {\n                ref_table = card.ability,\n                ref_value = \"mult\",\n                scalar_table = card.ability.extra,\n                scalar_value = \"mult_mod\",\n                message_colour = G.C.MULT\n            })\n        end\n        if context.destroy_card\n        and context.destroy_card == card\n        and context.card_area == G.play\n        and SMODS.pseudorandom_probability(card, 'gb_macabre', 1, card.ability.extra.odds) then\n            return {\n                remove = true\n            }\n        end\n    end,\n    in_pool = function(self, args)\n        return false\n    end",
      "config": {
        "mult": 0,
        "extra": {
          "mult_mod": 10,
          "odds": 8
        }
      },
      "ability": {
        "mult": 0,
        "extra": {
          "mult_mod": 10,
          "odds": 8
        }
      },
      "vars": [
        10,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "ripple",
      "name": "Ripple Card",
      "atlas": "gb_Enhancements",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = 'ripple',\n    loc_txt = {\n\t\tname = 'Ripple Card',\n\t\ttext = {\n            \"{C:attention}Always scores\",\n\t\t\t\"Gains {C:chips}+#1#{} Chips\",\n\t\t\t\"when played\",\n\t\t}\n\t},\n    always_scores = true,\n    atlas = 'gb_Enhancements',\n    pos = { x = 3, y = 0 },\n    config = { bonus = 0, extra = { chips_mod = 10 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.chips_mod } }\n    end,\n    calculate = function(self, card, context)    \n        if context.before and context.cardarea == G.play then\n            SMODS.scale_card(card, {\n                ref_table = card.ability,\n                ref_value = \"bonus\",\n                scalar_table = card.ability.extra,\n                scalar_value = \"chips_mod\",\n                message_colour = G.C.CHIPS\n            })\n        end\n    end,\n    in_pool = function(self, args)\n        return false\n    end",
      "config": {
        "bonus": 0,
        "extra": {
          "chips_mod": 10
        }
      },
      "ability": {
        "bonus": 0,
        "extra": {
          "chips_mod": 10
        }
      },
      "vars": [
        10
      ],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "rotten",
      "name": "Rotten Card",
      "atlas": "gb_Enhancements",
      "pos": {
        "x": 5,
        "y": 0
      },
      "raw": "key = 'rotten',\n    loc_txt = {\n\t\tname = 'Rotten Card',\n\t\ttext = {\n            \"{C:red}X#1# {C:attention}Blind{} size\",\n            \"if held in hand\"\n\t\t}\n\t},\n    atlas = 'gb_Enhancements',\n    pos = { x = 5, y = 0 },\n    config = { extra = { blind_size = 0.9 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.blind_size } }\n    end,\n    calculate = function(self, card, context)    \n        if context.before and context.cardarea == G.hand then\n            G.GAME.blind.chips = G.GAME.blind.chips * card.ability.extra.blind_size\n            G.GAME.blind.chip_text = number_format(G.GAME.blind.chips)\n            play_sound(\"cancel\")\n            card:juice_up()\n        end\n    end,\n    in_pool = function(self, args)\n        return false\n    end",
      "config": {
        "extra": {
          "blind_size": 0.9
        }
      },
      "ability": {
        "extra": {
          "blind_size": 0.9
        }
      },
      "vars": [
        0.9
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "24_carrots",
      "name": "24 Carrots",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 7,
        "y": 7
      },
      "raw": "key = '24_carrots',\n\tloc_txt = {\n\t\tname = '24 Carrots',\n\t\ttext = {\n\t\t\t\"The next {C:attention}#1#{} played cards\",\n            \"have a {C:green}#2# in #3# chance\",\n            \"to become {C:attention}Gold{} cards\"\n\t\t}\n\t},\n\tconfig = { extra = { cards_left = 24, odds = 4 } },\n\trarity = 1,\n\tatlas = 'gb_Jokers',\n\tpos = { x = 7, y = 7 },\n\tcost = 4,\n\tblueprint_compat = true,\n    eternal_compat = false,\n\tloc_vars = function(self, info_queue, card)\n        info_queue[#info_queue + 1] = G.P_CENTERS.m_gold\n        local new_numerator, new_denominator = SMODS.get_probability_vars(card, 1, card.ability.extra.odds)\n\t\treturn { vars = { card.ability.extra.cards_left, new_numerator, new_denominator } }\n\tend,\n    calculate = function(self, card, context)\n        if context.before and not context.blueprint and context.main_eval then\n            for _, playing_card in ipairs(context.full_hand) do\n                if SMODS.pseudorandom_probability(card, 'gb_24_carrots', 1, card.ability.extra.odds) then\n                    playing_card:set_ability('m_gold', nil, true)\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            card:juice_up()\n                            return true\n                        end\n                    }))\n                end\n                if not context.blueprint then\n                    card.ability.extra.cards_left = card.ability.extra.cards_left - 1\n                end\n                if card.ability.extra.cards_left <= 0 then\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            play_sound('tarot1')\n                            card.T.r = -0.2\n                            card:juice_up(0.3, 0.4)\n                            card.states.drag.is = true\n                            card.children.center.pinch.x = true\n                            G.E_MANAGER:add_event(Event({\n                                trigger = 'after',\n                                delay = 0.3,\n                                blockable = false,\n                                func = function()\n                                    card:remove()\n                                    return true\n                                end\n                            }))\n                            return true\n                        end\n                    }))\n                    return {\n                        message = 'Eaten!'\n                    }\n                end\n            end\n        end\n    end",
      "config": {
        "extra": {
          "cards_left": 24,
          "odds": 4
        }
      },
      "ability": {
        "extra": {
          "cards_left": 24,
          "odds": 4
        }
      },
      "vars": [
        24,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "alien_joker",
      "name": "Alien Joker",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 1,
        "y": 5
      },
      "raw": "key = 'alien_joker',\n\tloc_txt = {\n\t\tname = 'Alien Joker',\n\t\ttext = {\n\t\t\t\"Upgrade played {C:attention}poker hand{}\",\n\t\t\t\"every {C:attention}#1#{}th hand played\",\n            \"{C:inactive}({C:attention}#2#{C:inactive}/#1#)\",\n\t\t}\n\t},\n\tconfig = { extra = { hand_tally = 0, hands = 5 } },\n\trarity = 1,\n\tatlas = 'gb_Jokers',\n\tpos = { x = 1, y = 5 },\n\tcost = 4,\n\tblueprint_compat = false,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.hands, card.ability.extra.hand_tally } }\n\tend,\n    calculate = function(self, card, context)\n        if context.before and not context.blueprint and context.main_eval then\n            card.ability.extra.hand_tally = card.ability.extra.hand_tally + 1\n            if card.ability.extra.hand_tally >= card.ability.extra.hands then\n                card.ability.extra.hand_tally = 0\n                return {\n                    level_up = true,\n                    message = \"Zorp!\",\n                    colour = G.C.FILTER\n                }\n            else\n                return {\n                    message = card.ability.extra.hand_tally .. '/' .. card.ability.extra.hands,\n                    colour = G.C.FILTER\n                }\n            end\n        end\n    end",
      "config": {
        "extra": {
          "hand_tally": 0,
          "hands": 5
        }
      },
      "ability": {
        "extra": {
          "hand_tally": 0,
          "hands": 5
        }
      },
      "vars": [
        5,
        0
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "bad_trip",
      "name": "Bad Trip",
      "atlas": "Jokers",
      "pos": {
        "x": 6,
        "y": 0
      },
      "raw": "key = \"bad_trip\",\n    loc_txt = {\n        name = 'Bad Trip',\n        text = {\n            \"{C:chips}+#1#{} Chips\",\n            \"{C:chips}#2#{} Chips for each unique\",\n            \"poker hand played this run\",\n            \"{C:inactive}(Currently {C:chips}+#3#{C:inactive} Chips)\"\n        }\n    },\n    blueprint_compat = true,\n    eternal_compat = false,\n    rarity = 1,\n    cost = 4,\n    atlas = 'Jokers',\n    pos = { x = 6, y = 0 },\n    config = { extra = { base_chips = 100, chips_mod = -10, chips = 100 } },\n    loc_vars = function(self, info_queue, card)\n        if G.GAME.hands then\n            local unique_poker_hands = {}\n            for k, v in pairs(G.GAME.hands) do\n                if v.played ~= 0 and v.visible then\n                    table.insert(unique_poker_hands, k)\n                end\n            end\n            return { vars = { card.ability.extra.base_chips, card.ability.extra.chips_mod, math.max(card.ability.extra.base_chips + (card.ability.extra.chips_mod * #unique_poker_hands), 0) } }\n        else\n            return { vars = { card.ability.extra.base_chips, card.ability.extra.chips_mod, card.ability.extra.base_chips } }\n        end\n        \n    end,\n    calculate = function(self, card, context)\n        if context.before and context.main_eval and not context.blueprint then\n            local unique_poker_hands = {}\n            for k, v in pairs(G.GAME.hands) do\n                if v.played ~= 0 and v.visible then\n                    table.insert(unique_poker_hands, k)\n                end\n            card.ability.extra.chips = math.max(card.ability.extra.base_chips + (card.ability.extra.chips_mod * #unique_poker_hands), 0)\n            end\n            if G.GAME.hands[context.scoring_name] == 1 then\n                return {\n                    message = \"Downgraded!\",\n                    colour = G.C.CHIPS,\n                }\n            end\n        end\n        if context.joker_main then\n            return {\n                chips = card.ability.extra.chips\n            }\n        end\n    end",
      "config": {
        "extra": {
          "base_chips": 100,
          "chips_mod": -10,
          "chips": 100
        }
      },
      "ability": {
        "extra": {
          "base_chips": 100,
          "chips_mod": -10,
          "chips": 100
        }
      },
      "vars": [
        100,
        -10,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "bait",
      "name": "Bait",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 7,
        "y": 4
      },
      "raw": "key = 'bait',\n    loc_txt = {\n        name = 'Bait',\n        text = {\n            \"{C:mult}+#1#{} Mult\",\n            \"{C:green}#2# in #3#{} chance at\",\n            \"end of round to\",\n            \"{C:attention}reel something in{}\",\n        }\n    },\n    config = { extra = { odds = 6, mult = 8 } },\n    rarity = 1,\n    cost = 6,\n    eternal_compat = false,\n    atlas = 'gb_Jokers',\n    pos = { x = 7, y = 4 },\n    loc_vars = function(self, info_queue, card)\n        local new_numerator, new_denominator = SMODS.get_probability_vars(card, 1, card.ability.extra.odds)\n        return { vars = { card.ability.extra.mult, new_numerator, new_denominator } }\n    end,\n    calculate = function(self, card, context)\n        if context.joker_main then\n            return {\n                mult = card.ability.extra.mult\n            } \n        end\n        if context.end_of_round and context.game_over == false and context.main_eval and not context.blueprint then\n            if SMODS.pseudorandom_probability(card, 'gb_bait', 1, card.ability.extra.odds) then\n                SMODS.add_card{\n                    set = 'Joker',\n                    key = \"j_gb_hadal_zone\",\n                    edition = (card.edition and card.edition.key) or nil\n                }\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        play_sound('tarot1')\n                        card.T.r = -0.2\n                        card:juice_up(0.3, 0.4)\n                        card.states.drag.is = true\n                        card.children.center.pinch.x = true\n                        G.E_MANAGER:add_event(Event({\n                            trigger = 'after',\n                            delay = 0.3,\n                            blockable = false,\n                            func = function()\n                                card:remove()\n                                return true\n                            end\n                        }))\n                        return true\n                    end\n                }))            \n                return {\n                    message = 'Caught!',\n                    colour = G.C.FILTER\n                }\n            end\n        end\n    end,",
      "config": {
        "extra": {
          "odds": 6,
          "mult": 8
        }
      },
      "ability": {
        "extra": {
          "odds": 6,
          "mult": 8
        }
      },
      "vars": [
        8,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "binman",
      "name": "Binman",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 0,
        "y": 5
      },
      "raw": "key = 'binman',\n    loc_txt = {\n        name = 'Binman',\n        text = {\n            \"This Joker gains {C:mult}+#1#{} Mult\",\n            \"when {C:attention}#3#{} cards are\",\n            \"discarded at once\",\n            \"{C:inactive}(Currently {C:mult}+#2#{C:inactive} Mult)\"\n        }\n    },\n    config = { extra = { threshold = 5, mult = 0, mult_mod = 1 } },\n\trarity = 1,\n\tatlas = 'gb_Jokers',\n\tpos = { x = 0, y = 5 },\n\tcost = 4,\n\tblueprint_compat = true,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { \n            card.ability.extra.mult_mod,\n            card.ability.extra.mult,\n            card.ability.extra.threshold\n        } }\n\tend,\n    calculate = function(self, card, context)\n        if context.pre_discard and not context.blueprint then\n            if #G.hand.highlighted >= card.ability.extra.threshold then\n                SMODS.scale_card(card, {\n                    ref_table = card.ability.extra,\n                    ref_value = \"mult\",\n                    scalar_value = \"mult_mod\"\n                })\n            end\n\t\tend\n        if context.joker_main then\n            return {\n                mult = card.ability.extra.mult\n            }\n        end\n    end",
      "config": {
        "extra": {
          "threshold": 5,
          "mult": 0,
          "mult_mod": 1
        }
      },
      "ability": {
        "extra": {
          "threshold": 5,
          "mult": 0,
          "mult_mod": 1
        }
      },
      "vars": [
        1,
        0,
        5
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "bold_and_brash",
      "name": "Bold and Brash",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 2,
        "y": 5
      },
      "raw": "key = 'bold_and_brash',\n    loc_txt = {\n        name = 'Bold and Brash',\n        text = {\n            \"{C:blue}+#1#{} hand if discarded hand\",\n            \"contains a {C:attention}#2#{}\", \n        }\n    },\n    config = { extra = { hands = 1, hand_to_discard = \"Two Pair\" } },\n\trarity = 1,\n\tatlas = 'gb_Jokers',\n\tpos = { x = 2, y = 5 },\n\tcost = 4,\n\tblueprint_compat = true,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.hands, card.ability.extra.hand_to_discard } }\n\tend,\n    calculate = function(self, card, context)\n        if context.pre_discard then\n            local _, _, poker_hands = G.FUNCS.get_poker_hand_info(G.hand.highlighted)\n\t\t\tif next(poker_hands[card.ability.extra.hand_to_discard]) then\n                ease_hands_played(card.ability.extra.hands)\n                return {\n                    message = \"+1 Hand\",\n                    colour = G.C.BLUE\n                }\n            end\n\t\tend\n    end",
      "config": {
        "extra": {
          "hands": 1,
          "hand_to_discard": "Two Pair"
        }
      },
      "ability": {
        "extra": {
          "hands": 1,
          "hand_to_discard": "Two Pair"
        }
      },
      "vars": [
        1,
        "Two Pair"
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "bullseye",
      "name": "Bullseye",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 5,
        "y": 4
      },
      "raw": "key = 'bullseye',\n\tloc_txt = {\n\t\tname = 'Bullseye',\n\t\ttext = {\n\t\t\t\"Earn {C:money}$#1#{} if there are\",\n            \"exactly {C:attention}#2#{} hands remaining\",\n            \"at end of round\",\n            \"{C:inactive,s:0.85}(Hands needed changes every round)\",\n\t\t}\n\t},\n\tconfig = { extra = { dollars = 8, hands_required = 0 } },\n\trarity = 1,\n\tatlas = 'gb_Jokers',\n\tpos = { x = 5, y = 4 },\n\tcost = 5,\n\tblueprint_compat = true,\n\tloc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.dollars, card.ability.extra.hands_required } }\n    end,\n    calculate = function(self, card, context)\n        if context.end_of_round and context.main_eval then\n            if G.GAME.current_round.hands_left == card.ability.extra.hands_required then\n                return {\n                    dollars = card.ability.extra.dollars\n                }\n            end\n            card.ability.extra.hands_required = math.floor(G.GAME.round_resets.hands * pseudorandom(\"gb_bullseye\"))\n        end\n    end",
      "config": {
        "extra": {
          "dollars": 8,
          "hands_required": 0
        }
      },
      "ability": {
        "extra": {
          "dollars": 8,
          "hands_required": 0
        }
      },
      "vars": [
        8,
        0
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "counterfeit_joker",
      "name": "Counterfeit Joker",
      "atlas": "Jokers",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "key = 'counterfeit_joker',\n\tloc_txt = {\n\t\tname = 'Counterfeit Joker',\n\t\ttext = {\n\t\t\t\"Gives {C:mult}+#1#{} Mult,\",\n\t\t\t\"lose {C:red}-$#2#{} at end of round\",\n\t\t}\n\t},\n\tconfig = { extra = { mult = 15, money = 1 } },\n\trarity = 1,\n\tatlas = 'Jokers',\n\tpos = { x = 2, y = 2 },\n\tcost = 2,\n\tblueprint_compat = true,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.mult, card.ability.extra.money } }\n\tend,\n    calculate = function(self, card, context)\n        if context.joker_main then\n            return {\n                mult = card.ability.extra.mult\n            }\n        end\n    end,\n\tcalc_dollar_bonus = function(self, card)\n        return -card.ability.extra.money\n    end",
      "config": {
        "extra": {
          "mult": 15,
          "money": 1
        }
      },
      "ability": {
        "extra": {
          "mult": 15,
          "money": 1
        }
      },
      "vars": [
        15,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "coupon",
      "name": "Coupon",
      "atlas": "Jokers",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = 'coupon',\n\tloc_txt = {\n\t\tname = 'Coupon',\n\t\ttext = {\n\t\t\t\"{C:green}#1# in #2# chance{} to refund\",\n\t\t\t\"cards purchased in the {C:attention}Shop{}\",\n\t\t}\n\t},\n\tconfig = { extra = { odds = 3 } },\n\trarity = 1,\n\tatlas = 'Jokers',\n\tpos = { x = 1, y = 1 },\n\tcost = 6,\n\tblueprint_compat = true,\n\tloc_vars = function(self, info_queue, card)\n\t\tlocal new_numerator, new_denominator = SMODS.get_probability_vars(self, 1, card.ability.extra.odds)\n    \treturn { vars = { new_numerator, new_denominator } }\n\tend,\n    calculate = function(self, card, context)\n        if context.buying_card and context.card ~= card then\n            if SMODS.pseudorandom_probability(card, 'gb_coupon', 1, card.ability.extra.odds) then\n                return {\n                    dollars = context.card.cost,\n                    message = \"Refunded!\",\n                    colour = G.C.MONEY\n                }\n            end\n        end\n    end",
      "config": {
        "extra": {
          "odds": 3
        }
      },
      "ability": {
        "extra": {
          "odds": 3
        }
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "doner",
      "name": "Doner",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 5,
        "y": 5
      },
      "raw": "key = 'doner',\n    loc_txt = {\n        name = 'Doner',\n        text = {\n            \"This Joker gains {C:chips}+#1#{} Chips\",\n            \"after hand scored\",\n            \"{C:chips}-#2#{} chips when {C:attention}Blind{} is selected\",\n            \"{C:inactive}(Currently {C:chips}+#3#{C:inactive} Chips)\"\n        }\n    },\n    config = { extra = { chips = 0, chips_gain = 10, chips_loss = 20 } },\n\trarity = 1,\n\tatlas = 'gb_Jokers',\n\tpos = { x = 5, y = 5 },\n\tcost = 4,\n\tblueprint_compat = true,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.chips_gain, card.ability.extra.chips_loss, card.ability.extra.chips } }\n\tend,\n    calculate = function(self, card, context)\n        if context.joker_main then\n            return {\n                chips = card.ability.extra.chips,\n            }\n        end\n        if context.after and not context.blueprint then\n            SMODS.scale_card(card, {\n                ref_table = card.ability.extra,\n                ref_value = \"chips\",\n                scalar_value = \"chips_gain\",\n                message_colour = G.C.CHIPS\n            })\n        end\n        if context.setting_blind and not context.blueprint then\n            if card.ability.extra.chips > 0 then\n                SMODS.scale_card(card, {\n                    ref_table = card.ability.extra,\n                    ref_value = \"chips\",\n                    scalar_value = \"chips_loss\",\n                    operation = \"-\",\n                    no_message = true\n                })\n                card.ability.extra.chips = math.max(0, card.ability.extra.chips)\n                return {\n                    message = \"Carved!\",\n                    colour = G.C.FILTER\n                }\n            end\n        end\n    end",
      "config": {
        "extra": {
          "chips": 0,
          "chips_gain": 10,
          "chips_loss": 20
        }
      },
      "ability": {
        "extra": {
          "chips": 0,
          "chips_gain": 10,
          "chips_loss": 20
        }
      },
      "vars": [
        10,
        20,
        0
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "envious_joker",
      "name": "Envious Joker",
      "atlas": "Jokers",
      "pos": {
        "x": 0,
        "y": 6
      },
      "raw": "key = 'envious_joker',\n\tloc_txt = {\n\t\tname = 'Envious Joker',\n\t\ttext = {\n            \"Played cards with\",\n            \"{C:gb_eyes}Eyes{} suit give\",\n            \"{C:mult}+#1#{} Mult when scored\",\n\t\t}\n\t},\n\trarity = 1,\n\tatlas = 'Jokers',\n\tpos = { x = 0, y = 6 },\n\tcost = 5,\n\tblueprint_compat = true,\n    config = { extra = { mult = 5 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.mult } }\n    end,\n    calculate = function(self, card, context)\n        if context.individual and context.cardarea == G.play and\n            context.other_card:is_suit(\"gb_Eyes\") then\n            return {\n                mult = card.ability.extra.mult\n            }\n        end\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_suit_in_deck(\"gb_Eyes\")\n    end",
      "config": {
        "extra": {
          "mult": 5
        }
      },
      "ability": {
        "extra": {
          "mult": 5
        }
      },
      "vars": [
        5
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "gasoline",
      "name": "Gasoline",
      "atlas": "Jokers",
      "pos": {
        "x": 3,
        "y": 2
      },
      "raw": "key = 'gasoline',\n\tloc_txt = {\n\t\tname = 'Gasoline',\n\t\ttext = {\n\t\t\t\"Earn {C:money}$#1#{} if played hand\",\n\t\t\t\"causes score to {C:attention}catch fire{}\",\n\t\t}\n\t},\n\tconfig = { extra = { dollars = 6 } },\n\trarity = 1,\n\tatlas = 'Jokers',\n\tpos = { x = 3, y = 2 },\n\tcost = 6,\n\tblueprint_compat = true,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.dollars } }\n\tend,\n    calculate = function(self, card, context)\n        if context.final_scoring_step and gb_is_score_on_fire() then\n\t\t\treturn {\n                dollars = card.ability.extra.dollars\n\t\t\t}\n\t\tend\n\tend",
      "config": {
        "extra": {
          "dollars": 6
        }
      },
      "ability": {
        "extra": {
          "dollars": 6
        }
      },
      "vars": [
        6
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "hadal_zone",
      "name": "Hadal Zone",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 9,
        "y": 5
      },
      "raw": "key = 'hadal_zone',\n    loc_txt = {\n        name = 'Hadal Zone',\n        text = {\n            \"When hand is played, {C:green}#3# in #4#{} chance\",\n            \"for this Joker to gain {X:mult,C:white}X#1#{} Mult\",\n            \"and {C:attention}destroy{} a random scoring card\",\n            \"{C:inactive}(Currently {X:mult,C:white}X#2#{C:inactive} Mult)\",\n        }\n    },\n    config = { extra = { xmult = 1, xmult_mod = 0.25, card_to_destroy = nil } },\n    rarity = 1,\n    atlas = 'gb_Jokers',\n    pos = { x = 9, y = 5 },\n    soul_pos = { x = 8, y = 5 },\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        local new_numerator, new_denominator = SMODS.get_probability_vars(self, 1, 2)\n        return { vars = { \n            card.ability.extra.xmult_mod,\n            card.ability.extra.xmult,\n            new_numerator,\n            new_denominator\n        }}\n    end,\n    calculate = function(self, card, context)\n        if context.before and context.main_eval and not context.blueprint then\n            card.ability.extra.card_to_destroy = nil\n            if SMODS.pseudorandom_probability(card, 'gb_hadal_zone', 1, 2) then\n                card.ability.extra.card_to_destroy = pseudorandom_element(context.scoring_hand, pseudoseed('gb_hadal_zone'))\n                SMODS.scale_card(card, {\n                    ref_table = card.ability.extra,\n                    ref_value = \"xmult\",\n                    scalar_value = \"xmult_mod\",\n                    message_colour = G.C.MULT\n                })\n            end\n        end \n        if context.joker_main then\n            return {\n                xmult = card.ability.extra.xmult\n            }\n        end\n        if context.destroy_card\n        and not context.blueprint \n        and card.ability.extra.card_to_destroy then\n            if context.destroy_card == card.ability.extra.card_to_destroy then\n                return {\n                    remove = true\n                }\n            end\n        end\n    end,\n    in_pool = function(self, args)\n        return false\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null,
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "hot_potato",
      "name": "Hot Potato",
      "atlas": "Jokers",
      "pos": {
        "x": 7,
        "y": 2
      },
      "raw": "key = 'hot_potato',\n\tloc_txt = {\n\t\tname = 'Hot Potato',\n\t\ttext = {\n\t\t\t\"When {C:attention}Blind{} is skipped,\",\n\t\t\t\"this Joker gains {C:mult}+#2#{} Mult\",\n\t\t\t\"{C:green}#3# in #4# chance{} to {C:red}self-destruct{}\",\n\t\t\t\"at end of round\",\n\t\t\t\"{C:inactive}(Currently {C:mult}+#1#{C:inactive} Mult)\",\n\t\t}\n\t},\n\tconfig = { extra = { odds = 8, mult = 0, mult_mod = 12 } },\n\trarity = 1,\n\tatlas = 'Jokers',\n\tpos = { x = 7, y = 2 },\n\tcost = 4,\n\tblueprint_compat = true,\n    eternal_compat = false,\n\tloc_vars = function(self, info_queue, card)\n        local new_numerator, new_denominator = SMODS.get_probability_vars(card, 1, card.ability.extra.odds)\n\t\treturn { vars = { card.ability.extra.mult, card.ability.extra.mult_mod, new_numerator, new_denominator } }\n\tend,\n\tcalculate = function(self, card, context)\n        if context.end_of_round and context.game_over == false and context.main_eval and not context.blueprint then\n            if SMODS.pseudorandom_probability(card, 'gb_hot_potato', 1, card.ability.extra.odds) then\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        play_sound('tarot1')\n                        card.T.r = -0.2\n                        card:juice_up(0.3, 0.4)\n                        card.states.drag.is = true\n                        card.children.center.pinch.x = true\n                        G.E_MANAGER:add_event(Event({\n                            trigger = 'after',\n                            delay = 0.3,\n                            blockable = false,\n                            func = function()\n                                card:remove()\n                                return true\n                            end\n                        }))\n                        return true\n                    end\n                }))\n                return {\n                    message = 'Cooked!'\n                }\n            else\n                return {\n                    message = localize('k_safe_ex')\n                }\n            end\n        end\n        if context.skip_blind and not context.blueprint then\n\t\t\tSMODS.scale_card(card, {\n                ref_table = card.ability.extra,\n                ref_value = \"mult\",\n                scalar_value = \"mult_mod\",\n                message_colour = G.C.MULT\n            })\n        end\n        if context.joker_main then\n            return {\n                mult = card.ability.extra.mult\n\t\t\t}\n        end\n\tend",
      "config": {
        "extra": {
          "odds": 8,
          "mult": 0,
          "mult_mod": 12
        }
      },
      "ability": {
        "extra": {
          "odds": 8,
          "mult": 0,
          "mult_mod": 12
        }
      },
      "vars": [
        0,
        12,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "mist",
      "name": "Mist",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"mist\",\n    loc_txt = {\n        name = 'Mist',\n\t\ttext = {\n\t\t\t\"{C:chips}+#1#{} Chips for every\",\n            \"{V:1}Ephemeral Card{} used this run\",\n            \"{C:inactive}(Currently {C:chips}+#2#{C:inactive} Chips)\"\n\t\t}\n    },\n    config = { extra = { chips_mod = 20 } },\n\trarity = 1,\n\tatlas = 'gb_Jokers',\n\tpos = { x = 1, y = 0 },\n\tcost = 5,\n\tblueprint_compat = true,\n    loc_vars = function(self, info_queue, card)\n        return {\n            vars = {\n                card.ability.extra.chips_mod,\n                card.ability.extra.chips_mod * (G.GAME.consumeable_usage_total and G.GAME.consumeable_usage_total.ephemeral or 0),\n                colours = { HEX(\"8EA4B3\") }\n            }\n        }\n    end,\n    calculate = function(self, card, context)\n        if context.using_consumeable and not context.blueprint and context.consumeable.ability.set == \"Ephemeral\" and G.GAME.consumeable_usage_total.ephemeral then\n            return {\n                message = localize { type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips_mod * G.GAME.consumeable_usage_total.ephemeral } },\n            }\n        end\n        if context.joker_main then\n            return {\n                chips = card.ability.extra.chips_mod *\n                    (G.GAME.consumeable_usage_total and G.GAME.consumeable_usage_total.ephemeral or 0)\n            }\n        end\n    end,",
      "config": {
        "extra": {
          "chips_mod": 20
        }
      },
      "ability": {
        "extra": {
          "chips_mod": 20
        }
      },
      "vars": [
        20,
        0,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "mugshot",
      "name": "Mugshot",
      "atlas": "Jokers",
      "pos": {
        "x": 6,
        "y": 6
      },
      "raw": "key = 'mugshot',\n\tloc_txt = {\n\t\tname = 'Mugshot',\n\t\ttext = {\n            \"{C:attention}Face{} cards give {C:mult}Mult{} equal to\",\n            \"the rank of a random\",\n            \"scoring {C:attention}numbered{} card\"\n\t\t}\n\t},\n\trarity = 1,\n\tatlas = 'Jokers',\n\tpos = { x = 6, y = 6 },\n\tcost = 4,\n\tblueprint_compat = true,\n\tcalculate = function(self, card, context)\n        if context.individual\n        and context.cardarea == G.play\n        and context.other_card:is_face()\n        and not context.end_of_round then\n            local numbered_cards = {}\n            for _, playing_card in ipairs(context.scoring_hand) do\n                if playing_card:get_id() >= 2\n                and playing_card:get_id() <= 10 then\n                    table.insert(numbered_cards, playing_card)\n                end\n            end\n            if #numbered_cards > 0 then\n                local selected_card = pseudorandom_element(numbered_cards, pseudoseed(\"gb_mugshot\"))\n                return {\n                    mult = selected_card.base.nominal\n                }\n            end\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "patience",
      "name": "Patience",
      "atlas": "Jokers",
      "pos": {
        "x": 7,
        "y": 3
      },
      "raw": "key = 'patience',\n\tloc_txt = {\n\t\tname = 'Patience',\n\t\ttext = {\n            \"This Joker gains {C:mult}+#1#{} Mult\",\n            \"for every played hand this round\",\n            \"{C:inactive}(Currently {C:mult}+#2#{C:inactive} Mult)\",\n\t\t}\n\t},\n\tconfig = { extra = { mult = 0, mult_mod = 5 } },\n\trarity = 1,\n\tatlas = 'Jokers',\n\tpos = { x = 7, y = 3 },\n\tcost = 4,\n\tblueprint_compat = true,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.mult_mod, card.ability.extra.mult } }\n\tend,\n\tcalculate = function(self, card, context)\n        if context.before and not context.blueprint then\n            SMODS.scale_card(card, {\n                ref_table = card.ability.extra,\n                ref_value = \"mult\",\n                scalar_value = \"mult_mod\",\n                message_colour = G.C.MULT\n            })\n        end\n        if context.joker_main then\n\t\t\treturn {\n\t\t\t\tmult = card.ability.extra.mult\n\t\t\t}\n\t\tend\n        if context.end_of_round and not context.blueprint then\n            card.ability.extra.mult = 0\n        end\n\tend",
      "config": {
        "extra": {
          "mult": 0,
          "mult_mod": 5
        }
      },
      "ability": {
        "extra": {
          "mult": 0,
          "mult_mod": 5
        }
      },
      "vars": [
        5,
        0
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "polariser",
      "name": "Polariser",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "key = 'polariser',\n\tloc_txt = {\n\t\tname = 'Polariser',\n\t\ttext = {\n\t\t\t\"{C:mult}+#1#{} Mult if played hand\",\n\t\t\t\"contains a {C:attention}Bonus Card{}\",\n\t\t\t\"{C:chips}+#2#{} Chips if played hand\",\n\t\t\t\"contains a {C:attention}Mult Card{}\",\n\t\t}\n\t},\n\tconfig = { extra = { mult = 12, chips = 90 } },\n\trarity = 1,\n\tatlas = 'gb_Jokers',\n\tpos = { x = 4, y = 0 },\n\tcost = 4,\n\tblueprint_compat = true,\n\tloc_vars = function(self, info_queue, card)\n\t\tinfo_queue[#info_queue + 1] = G.P_CENTERS.m_bonus\n\t\tinfo_queue[#info_queue + 1] = G.P_CENTERS.m_mult\n\t\treturn { vars = { card.ability.extra.mult, card.ability.extra.chips } }\n\tend,\n    calculate = function(self, card, context)\n        if context.joker_main then\n\t\t\tlocal has_bonus = 0\n\t\t\tlocal has_mult = 0\n\t\t\tfor _, playing_card in ipairs(context.full_hand or {}) do\n\t\t\t\tif SMODS.has_enhancement(playing_card, 'm_bonus') then\n\t\t\t\t\thas_bonus = 1\n\t\t\t\tend\n\t\t\t\tif SMODS.has_enhancement(playing_card, 'm_mult') then\n\t\t\t\t\thas_mult = 1\n\t\t\t\tend\n\t\t\tend\n\t\t\treturn {\n\t\t\t\tmult = has_bonus * card.ability.extra.mult,\n\t\t\t\tchips = has_mult * card.ability.extra.chips\n\t\t\t}\n\t\tend\n\tend,\n\tin_pool = function(self, args)\n        for _, playing_card in ipairs(G.playing_cards or {}) do\n            if SMODS.has_enhancement(playing_card, 'm_mult') or SMODS.has_enhancement(playing_card, 'm_bonus') then\n                return true\n            end\n        end\n        return false\n    end",
      "config": {
        "extra": {
          "mult": 12,
          "chips": 90
        }
      },
      "ability": {
        "extra": {
          "mult": 12,
          "chips": 90
        }
      },
      "vars": [
        12,
        90
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "pontoon",
      "name": "Pontoon",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 4,
        "y": 3
      },
      "raw": "key = \"pontoon\",\n    loc_txt = {\n        name = 'Pontoon',\n        -- formatting fuck storm\n\t\ttext = {\n\t\t\t\"{C:mult}+#1#{} Mult and {C:chips}+#2#{} Chips if\",\n            \"ranks of played cards {C:attention}add to #3#{}\",\n            \"{C:inactive,s:0.85}({C:attention,s:0.85}Kings{C:inactive,s:0.85}, {C:attention,s:0.85}Queens{C:inactive,s:0.85} and {C:attention,s:0.85}Jacks{C:inactive,s:0.85} count as {C:attention,s:0.85}10{C:inactive,s:0.85}){}\",\n            \"{C:inactive,s:0.85}({C:attention,s:0.85}Aces{C:inactive,s:0.85} count as both {C:attention,s:0.85}1{C:inactive,s:0.85} and {C:attention,s:0.85}11{C:inactive,s:0.85})\",\n\t\t}\n    },\n    config = { extra = { mult = 20, chips = 100, rank_count = 21 } },\n\trarity = 1,\n\tatlas = 'gb_Jokers',\n\tpos = { x = 4, y = 3 },\n\tcost = 4,\n\tblueprint_compat = true,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.mult, card.ability.extra.chips, card.ability.extra.rank_count } }\n\tend,\n    calculate = function(self, card, context)\n        if context.joker_main then\n            local rank_sum = 0\n            local ace_count = 0\n            for _, playing_card in pairs(context.full_hand) do\n                if not SMODS.has_no_rank(playing_card) then\n                    rank_sum = rank_sum + playing_card.base.nominal\n                end\n                if playing_card:get_id() == 14 then\n                    ace_count = ace_count + 1\n                end\n            end\n            for i = 1, ace_count + 1 do\n                if rank_sum < 21 then\n                    return {\n                        message = rank_sum .. \"\",\n                        colour = G.C.FILTER\n                    }\n                elseif rank_sum == 21 then\n                    return {\n                        chips = card.ability.extra.chips,\n                        mult = card.ability.extra.mult\n                    }\n                else\n                    rank_sum = rank_sum - 10\n                end\n            end\n            return \n                {\n                    message = \"Bust!\",\n                    colour = G.C.RED\n                }\n        end\n    end",
      "config": {
        "extra": {
          "mult": 20,
          "chips": 100,
          "rank_count": 21
        }
      },
      "ability": {
        "extra": {
          "mult": 20,
          "chips": 100,
          "rank_count": 21
        }
      },
      "vars": [
        20,
        100,
        21
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "qubits",
      "name": "Qubits",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 8,
        "y": 1
      },
      "raw": "key = \"qubits\",\n    loc_txt = {\n\t\tname = 'Qubits',\n\t\ttext = {\n\t\t\t\"The first scored card\",\n            \"of each {C:attention}Suit{}\",\n            \"gives {C:mult}+#1#{} Mult\",\n\t\t}\n\t},\n    blueprint_compat = false,\n\tatlas = 'gb_Jokers',\n\tpos = { x = 8, y = 1 },\n    rarity = 1,\n    cost = 4,\n    config = { extra = { mult = 6, scored_suits = {} } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.mult } }\n    end,\n    calculate = function(self, card, context)\n        if context.before and context.main_eval then\n            card.ability.extra.scored_suits = {}\n        end\n        if context.individual and context.cardarea == G.play then\n            if context.other_card.base.suit \n            and not card.ability.extra.scored_suits[context.other_card.base.suit] \n            then \n                card.ability.extra.scored_suits[context.other_card.base.suit] = true \n                return {\n                    mult = card.ability.extra.mult\n                }\n            end\n        end\n    end",
      "config": {
        "extra": {
          "mult": 6,
          "scored_suits": {}
        }
      },
      "ability": {
        "extra": {
          "mult": 6,
          "scored_suits": {}
        }
      },
      "vars": [
        6
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "receipt",
      "name": "Receipt",
      "atlas": "Jokers",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "key = 'receipt',\n\tloc_txt = {\n\t\tname = 'Receipt',\n\t\ttext = {\n\t\t\t\"This Joker gains {C:chips}+#1#{} Chips\",\n\t\t\t\"for every card purchased\",\n\t\t\t\"in the shop\",\n\t\t\t\"{C:inactive}(Currently {C:chips}+#2#{C:inactive} Chips)\"\n\t\t}\n\t},\n\tconfig = { extra = { chips = 0, chips_mod = 5 } },\n\trarity = 1,\n\tatlas = 'Jokers',\n\tpos = { x = 1, y = 2 },\n\tcost = 4,\n\tblueprint_compat = true,\n\tperishable_compat = false,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.chips_mod, card.ability.extra.chips } }\n\tend,\n\tcalculate = function(self, card, context)\n\t\tif context.buying_card and context.card ~= card then\n\t\t\tSMODS.scale_card(card, {\n                ref_table = card.ability.extra,\n                ref_value = \"chips\",\n                scalar_value = \"chips_mod\",\n                message_colour = G.C.CHIPS\n            })\n\t\tend\n        if context.joker_main then\n\t\t\treturn {\n\t\t\t\tchips = card.ability.extra.chips\n\t\t\t}\n\t\tend\n\tend",
      "config": {
        "extra": {
          "chips": 0,
          "chips_mod": 5
        }
      },
      "ability": {
        "extra": {
          "chips": 0,
          "chips_mod": 5
        }
      },
      "vars": [
        5,
        0
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "secret_box",
      "name": "Secret Box",
      "atlas": "Jokers",
      "pos": {
        "x": 2,
        "y": 3
      },
      "raw": "key = 'secret_box',\n\tloc_txt = {\n\t\tname = 'Secret Box',\n\t\ttext = {\n            \"Sell this card to create\",\n            \"a random {V:1}#1#{} Joker\",\n            \"{C:inactive,s:0.85}(Changes to {V:2,s:0.85}#2#{C:inactive,s:0.85} in {C:attention,s:0.85}#3#{C:inactive,s:0.85} rounds)\"\n\t\t}\n\t},\n\tconfig = { extra = { current_rarity = 1, rounds_left = 2, round_total = 2 } },\n\trarity = 1,\n\tatlas = 'Jokers',\n\tpos = { x = 2, y = 3 },\n\tcost = 4,\n\tblueprint_compat = false,\n    eternal_compat = false,\n\tperishable_compat = false,\n    loc_vars = function(self, info_queue, card)\n        local rarities = {\n            {G.C.RARITY.Common, \"Common\"},\n            {G.C.RARITY.Uncommon, \"Uncommon\"},\n            {G.C.RARITY.Rare, \"Rare\"},\n            {G.C.RARITY.Legendary, \"Legendary\"}\n        }\n        local next_rarity_index = math.min(card.ability.extra.current_rarity + 1, 4)\n        return { vars = {\n            rarities[card.ability.extra.current_rarity][2],\n            rarities[next_rarity_index][2],\n            card.ability.extra.rounds_left,\n            colours = {\n                rarities[card.ability.extra.current_rarity][1],\n                rarities[next_rarity_index][1]\n            }\n        }}\n\tend,\n\tcalculate = function(self, card, context)\n        local rarities = { \"Common\", \"Uncommon\", \"Rare\", \"Legendary\" }\n        if context.end_of_round\n        and context.main_eval\n        and not context.blueprint then\n            if card.ability.extra.current_rarity < 4 then\n                card.ability.extra.rounds_left = math.max(card.ability.extra.rounds_left - 1, 0)\n                if card.ability.extra.rounds_left == 0 then\n                    if card.ability.extra.current_rarity < 4 then\n                        card.ability.extra.current_rarity = card.ability.extra.current_rarity + 1\n                        card.ability.extra.round_total = card.ability.extra.round_total + 1\n                        card.ability.extra.rounds_left = card.ability.extra.round_total\n                        if card.ability.extra.current_rarity == 4 then\n                            local eval = function(card) return not card.REMOVED end\n                            juice_card_until(card, eval, true)\n                            card.ability.extra.round_total = 0\n                        end\n                        return {\n                            message = localize('k_upgrade_ex'),\n                            colour = G.C.RARITY[card.ability.extra.current_rarity],\n                        }\n                    end\n                end\n            end\n        end\n\t\tif context.selling_self and not context.blueprint then\n        G.GAME.joker_buffer = G.GAME.joker_buffer + 1\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    SMODS.add_card {\n                        set = 'Joker',\n                        rarity = rarities[card.ability.extra.current_rarity],\n                        key_append = 'gb_secret_box'\n                    }\n                    G.GAME.joker_buffer = 0\n                    return true\n                end\n            }))\n            return {\n                message = localize('k_plus_joker'),\n                colour = G.C.RARITY[card.ability.extra.current_rarity],\n            }\n        end\n\tend",
      "config": {
        "extra": {
          "current_rarity": 1,
          "rounds_left": 2,
          "round_total": 2
        }
      },
      "ability": {
        "extra": {
          "current_rarity": 1,
          "rounds_left": 2,
          "round_total": 2
        }
      },
      "vars": [
        null,
        null,
        2,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "sketchy_joker",
      "name": "Sketchy Joker",
      "atlas": "Jokers",
      "pos": {
        "x": 3,
        "y": 3
      },
      "raw": "key = 'sketchy_joker',\n\tloc_txt = {\n\t\tname = 'Sketchy Joker',\n\t\ttext = {\n            \"This Joker gains {C:chips}+#1#{} Chips\",\n            \"for every {C:attention}#4#{} cards drawn\",\n            \"{C:inactive}(Currently {C:chips}+#2#{C:inactive} Chips) (#3#/#4#)\",\n\t\t}\n\t},\n\tconfig = { extra = { chips = 0, chips_mod = 3, draw_tally = 0, draws = 7 } },\n\trarity = 1,\n\tatlas = 'Jokers',\n\tpos = { x = 3, y = 3 },\n\tcost = 4,\n\tblueprint_compat = true,\n\tperishable_compat = false,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.chips_mod, card.ability.extra.chips, card.ability.extra.draw_tally, card.ability.extra.draws } }\n\tend,\n\tcalculate = function(self, card, context)\n\t\tif context.hand_drawn\n\t\tor context.other_drawn\n\t\tand not context.blueprint then\n\t\t\tfor _, playing_card in ipairs(context.hand_drawn or context.other_drawn) do\n\t\t\t\tcard.ability.extra.draw_tally = card.ability.extra.draw_tally + 1\n\t\t\t\tif card.ability.extra.draw_tally >= card.ability.extra.draws then\n\t\t\t\t\tSMODS.scale_card(card, {\n                \t\tref_table = card.ability.extra,\n                \t\tref_value = \"chips\",\n                \t\tscalar_value = \"chips_mod\",\n                \t\tmessage_colour = G.C.CHIPS\n            \t\t})\n\t\t\t\t\tcard.ability.extra.draw_tally = card.ability.extra.draw_tally - card.ability.extra.draws\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tif context.joker_main then \n\t\t\treturn {\n\t\t\t\tchips = card.ability.extra.chips\n\t\t\t}\n\t\tend\n\tend",
      "config": {
        "extra": {
          "chips": 0,
          "chips_mod": 3,
          "draw_tally": 0,
          "draws": 7
        }
      },
      "ability": {
        "extra": {
          "chips": 0,
          "chips_mod": 3,
          "draw_tally": 0,
          "draws": 7
        }
      },
      "vars": [
        3,
        0,
        0,
        7
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "torchlight",
      "name": "Torchlight",
      "atlas": "Jokers",
      "pos": {
        "x": 5,
        "y": 1
      },
      "raw": "key = 'torchlight',\n    loc_txt = {\n        name = 'Torchlight',\n        text = {\n            \"{C:mult}+#1#{} Mult for every\",\n            \"{C:attention}Joker{} to the left of this one\",\n            \"{C:inactive}(Currently {C:mult}+#2#{C:inactive} Mult)\",\n        }\n    },\n    config = { extra = { mult = 0, mult_mod = 5 } },\n    rarity = 1,\n    cost = 4,\n    atlas = 'Jokers',\n    pos = { x = 5, y = 1 },\n    blueprint_compat = true,\n    loc_vars = function(self, info_queue, card)\n        local position = 0\n        if card.area and card.area == G.jokers then\n            for k, joker in ipairs(G.jokers.cards) do\n                if joker == card then\n                    position = k - 1\n                    break\n                end\n            end\n            return { vars = { card.ability.extra.mult_mod, card.ability.extra.mult_mod * position } }\n        else\n            return { vars = { card.ability.extra.mult_mod, 0 } }\n        end\n            \n    end,\n    calculate = function(self, card, context)\n        if context.joker_main then\n            local position = 0\n            for k, joker in ipairs(G.jokers.cards) do\n                if joker == card then\n                    position = k - 1\n                    break\n                end\n            end\n            card.ability.extra.mult = card.ability.extra.mult_mod * position\n            return { \n                mult = card.ability.extra.mult\n            }\n        end\n    end,",
      "config": {
        "extra": {
          "mult": 0,
          "mult_mod": 5
        }
      },
      "ability": {
        "extra": {
          "mult": 0,
          "mult_mod": 5
        }
      },
      "vars": [
        5,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "typograph",
      "name": "Typograph",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = 'typograph',\n    loc_txt = {\n        name = 'Typograph',\n        text = {\n            \"{C:mult}+#1#{} Mult for every letter\",\n            \"in the rightmost Joker's name\",\n            \"{C:inactive}(Currently {C:mult}+#2#{C:inactive} Mult)\"\n        }\n    },\n    config = { extra = { mult = 1 } },\n    rarity = 1,\n    atlas = 'gb_Jokers',\n    pos = { x = 2, y = 1 },\n    cost = 4,\n    blueprint_compat = true,\n    loc_vars = function(self, info_queue, card)\n        local letter_count = 0\n        if G.jokers and G.jokers.cards[#G.jokers.cards] then\n            local joker_name = G.localization.descriptions.Joker[G.jokers.cards[#G.jokers.cards].config.center.key].name\n            if joker_name then\n                for i = 1, #joker_name do\n                    local c = joker_name:sub(i,i)\n                    if c ~= \" \" then\n                        letter_count = letter_count + 1\n                    end\n                end\n            end\n        end\n        return { vars = { card.ability.extra.mult, letter_count * card.ability.extra.mult } }\n    end,\n    calculate = function(self, card, context)\n        if context.joker_main then\n            local letter_count = 0\n            if G.jokers and G.jokers.cards[#G.jokers.cards] then\n                local joker_name = G.localization.descriptions.Joker[G.jokers.cards[#G.jokers.cards].config.center.key].name\n                if joker_name then\n                    for i = 1, #joker_name do\n                        local c = joker_name:sub(i,i)\n                        if c ~= \" \" then\n                            letter_count = letter_count + 1\n                        end\n                    end\n                end\n            end\n            return {\n                mult = letter_count * card.ability.extra.mult\n            }\n        end\n    end",
      "config": {
        "extra": {
          "mult": 1
        }
      },
      "ability": {
        "extra": {
          "mult": 1
        }
      },
      "vars": [
        1,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "wanted",
      "name": "Wanted",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"wanted\",\n    loc_txt = {\n        name = 'Wanted',\n\t\ttext = {\n            \"Earn {C:money}$#1#{} if played hand\",\n            \"contains a scoring {C:attention}#2#\",\n            \"{C:inactive}(Resets every trigger)\"\n\t\t}\n    },\n    config = { extra = { rank = \"Ace\", id = 14, money = 4 } },\n\trarity = 1,\n\tatlas = 'gb_Jokers',\n\tpos = { x = 3, y = 1 },\n\tcost = 4,\n\tblueprint_compat = false,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.money, localize((card.ability.extra.rank or 'Ace'), \"ranks\") } }\n    end,\n    calculate = function(self, card, context)\n        if context.joker_main and not context.blueprint then\n            for _, playing_card in ipairs(context.scoring_hand) do\n                if playing_card:get_id() == card.ability.extra.id then\n                    card.ability.extra.rank, card.ability.extra.id = reroll_gb_wanted_rank()\n                    return {\n                        dollars = card.ability.extra.money,\n                    }\n                end\n            end\n        end\n    end",
      "config": {
        "extra": {
          "rank": "Ace",
          "id": 14,
          "money": 4
        }
      },
      "ability": {
        "extra": {
          "rank": "Ace",
          "id": 14,
          "money": 4
        }
      },
      "vars": [
        4,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "amethyst_geode",
      "name": "Amethyst Geode",
      "atlas": "Jokers",
      "pos": {
        "x": 1,
        "y": 6
      },
      "raw": "key = 'amethyst_geode',\n\tloc_txt = {\n\t\tname = 'Amethyst Geode',\n\t\ttext = {\n            \"Played cards with\",\n            \"{C:gb_eyes}Eyes{} suit retrigger\",\n            \"{C:attention}#1#{} time when scored\",\n\t\t}\n\t},\n\trarity = 2,\n\tatlas = 'Jokers',\n\tpos = { x = 1, y = 6 },\n\tcost = 6,\n\tblueprint_compat = true,\n    config = { extra = { retriggers = 1 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.retriggers } }\n    end,\n    calculate = function(self, card, context)\n        if context.repetition and context.cardarea == G.play and\n            context.other_card:is_suit(\"gb_Eyes\") then\n            return {\n                repetitions = card.ability.extra.retriggers\n            }\n        end\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_suit_in_deck(\"gb_Eyes\")\n    end",
      "config": {
        "extra": {
          "retriggers": 1
        }
      },
      "ability": {
        "extra": {
          "retriggers": 1
        }
      },
      "vars": [
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "battery",
      "name": "Battery",
      "atlas": "Jokers",
      "pos": {
        "x": 8,
        "y": 7
      },
      "raw": "key = 'battery',\n\tloc_txt = {\n\t\tname = 'Battery',\n\t\ttext = {\n            \"This Joker gains {X:mult,C:white}X#1#{} Mult\",\n            \"if a hand is played with a\",\n            \"{C:attention}Gold{} or {C:attention}Steel{} card held in hand\",\n            \"{C:inactive}(Currently {X:mult,C:white}X#2#{C:inactive} Mult)\",\n            \"{C:inactive,s:0.85}(Locks at {X:mult,C:white,s:0.85}X#3#{C:inactive,s:0.85} Mult)\"\n\t\t}\n\t},\n\trarity = 2,\n\tatlas = 'Jokers',\n\tpos = { x = 8, y = 7 },\n\tcost = 5,\n    enhancement_gate = \"m_gb_charge\",\n\tblueprint_compat = true,\n    config = { extra = { xmult = 1, xmult_mod = 0.2, xmult_lock = 3, locked = false } },\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue + 1] = G.P_CENTERS.m_gb_charge\n        return { vars = {\n            card.ability.extra.xmult_mod,\n            card.ability.extra.xmult,\n            card.ability.extra.xmult_lock,\n        } }\n    end,\n    calculate = function(self, card, context)\n        if context.before\n        and not context.blueprint\n        and card.ability.extra.locked == false then\n            local active = false\n            for _, playing_card in ipairs(G.hand.cards) do\n                if SMODS.has_enhancement(playing_card, 'm_gold')\n                or SMODS.has_enhancement(playing_card, 'm_steel') then\n                    active = true\n                    break\n                end\n            end\n            if active == true then\n                card.ability.extra.xmult = math.min(\n                    card.ability.extra.xmult + card.ability.extra.xmult_mod,\n                    card.ability.extra.xmult_lock\n                )\n                if card.ability.extra.xmult >= card.ability.extra.xmult_lock then\n                    card.ability.extra.locked = true\n                    return {\n                        message = \"Fully Charged!\",\n                        colour = G.C.MULT\n                    }\n                else\n                    return {\n                        message = localize(\"k_upgrade_ex\"),\n                        colour = G.C.MULT\n                    }\n                end\n            end\n        end\n        if context.joker_main then\n            return {\n                xmult = card.ability.extra.xmult\n            }\n        end\n    end,",
      "config": {
        "extra": {
          "xmult": 1,
          "xmult_mod": 0.2,
          "xmult_lock": 3,
          "locked": false
        }
      },
      "ability": {
        "extra": {
          "xmult": 1,
          "xmult_mod": 0.2,
          "xmult_lock": 3,
          "locked": false
        }
      },
      "vars": [
        0.2,
        1,
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "boing_ball",
      "name": "Boing Ball",
      "atlas": "Jokers",
      "pos": {
        "x": 6,
        "y": 3
      },
      "raw": "key = 'boing_ball',\n\tloc_txt = {\n\t\tname = 'Boing Ball',\n\t\ttext = {\n\t\t\t\"{C:green}#1# in #2# chance{} for\",\n\t\t\t\"played cards to retrigger\",\n\t\t}\n\t},\n\tconfig = { extra = { odds = 2, repetitions = 1 } },\n\trarity = 2,\n\tatlas = 'Jokers',\n\tpos = { x = 6, y = 3 },\n\tcost = 5,\n\tblueprint_compat = true,\n\tloc_vars = function(self, info_queue, card)\n\t\tlocal new_numerator, new_denominator = SMODS.get_probability_vars(card, 1, card.ability.extra.odds)\n\t\treturn { vars = { new_numerator, new_denominator } }\n\tend,\n    calculate = function(self, card, context)\n        if context.repetition and context.cardarea == G.play then\n\t\t\tif SMODS.pseudorandom_probability(card, 'gb_boing_ball', 1, card.ability.extra.odds) then\t\t\n                return {\n                    repetitions = card.ability.extra.repetitions\n                }\n            end\n        end\n    end",
      "config": {
        "extra": {
          "odds": 2,
          "repetitions": 1
        }
      },
      "ability": {
        "extra": {
          "odds": 2,
          "repetitions": 1
        }
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "brass_horseshoe",
      "name": "Brass Horseshoe",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 4,
        "y": 6
      },
      "raw": "key = 'brass_horseshoe',\n\tloc_txt = {\n\t\tname = 'Brass Horseshoe',\n\t\ttext = {\n            \"This Joker gains {C:mult}+#2#{} Mult\",\n            \"when a {C:green}listed probability{C:attention} succeeds{}\",\n            \"{C:inactive}(Currently {C:mult}+#1#{C:inactive} Mult)\"\n\t\t}\n\t},\n\tconfig = { extra = { mult = 0, mult_mod = 3 } },\n\trarity = 2,\n\tatlas = 'gb_Jokers',\n\tpos = { x = 4, y = 6 },\n\tcost = 7,\n\tblueprint_compat = true,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.mult, card.ability.extra.mult_mod } }\n\tend,\n    calculate = function(self, card, context)\n        if context.pseudorandom_result and context.result and not context.blueprint then\n            SMODS.scale_card(card, {\n                ref_table = card.ability.extra,\n                ref_value = \"mult\",\n                scalar_value = \"mult_mod\",\n                message_colour = G.C.MULT\n            })\n        end\n\t    if context.joker_main then\n            return {\n                mult = card.ability.extra.mult\n            }\n        end\n    end",
      "config": {
        "extra": {
          "mult": 0,
          "mult_mod": 3
        }
      },
      "ability": {
        "extra": {
          "mult": 0,
          "mult_mod": 3
        }
      },
      "vars": [
        0,
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "buffet_ticket",
      "name": "Buffet Ticket",
      "atlas": "Jokers",
      "pos": {
        "x": 3,
        "y": 4
      },
      "raw": "key = 'buffet_ticket',\n\tloc_txt = {\n\t\tname = 'Buffet Ticket',\n\t\ttext = {\n            \"Upon defeating a {C:attention}Boss Blind{},\",\n            \"create a {C:attention}Coupon Tag\",\n\t\t}\n\t},\n\trarity = 2,\n\tatlas = 'Jokers',\n\tpos = { x = 3, y = 4 },\n    pixel_size = { w = 63 },\n\tcost = 8,\n\tblueprint_compat = false,\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue + 1] = { key = 'tag_coupon', set = 'Tag' }\n    end,\n    calculate = function(self, card, context)\n        if context.end_of_round\n        and context.game_over == false\n        and context.main_eval\n        and not context.blueprint\n        and G.GAME.blind.boss then\n            add_tag(Tag('tag_coupon'))\n            play_sound('generic1', 0.9 + math.random() * 0.1, 0.8)\n            play_sound('holo1', 1.2 + math.random() * 0.1, 0.4)\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "calculator",
      "name": "Calculator",
      "atlas": "Jokers",
      "pos": {
        "x": 6,
        "y": 1
      },
      "raw": "key = 'calculator',\n\tloc_txt = {\n\t\tname = 'Calculator',\n\t\ttext = {\n            \"This Joker gains {C:mult}+#1#{} Mult\",\n            \"if round is beaten with\",\n            \"exactly {C:attention}#4#{} played cards\",\n            \"{C:inactive}(Currently {C:mult}+#2#{C:inactive} Mult)\",\n            \"{C:inactive}({C:attention}#3#/#4#{C:inactive})\"\n\t\t}\n\t},\n\tconfig = { extra = {\n        mult = 0,\n        mult_mod = 10,\n        scored_cards = 0,\n        cards_to_score = 10,\n    } },\n\trarity = 2,\n\tatlas = 'Jokers',\n\tpos = { x = 6, y = 1 },\n\tcost = 6,\n\tblueprint_compat = true,\n    perishable_compat = false,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { \n            card.ability.extra.mult_mod,\n            card.ability.extra.mult,\n            card.ability.extra.scored_cards,\n            card.ability.extra.cards_to_score\n        } }\n\tend,\n\tcalculate = function(self, card, context)\n        if context.before \n        and context.main_eval \n        and not context.blueprint \n        and card.ability.extra.scored_cards <= card.ability.extra.cards_to_score then\n            card.ability.extra.scored_cards = card.ability.extra.scored_cards + #context.full_hand\n            if card.ability.extra.scored_cards <= card.ability.extra.cards_to_score then\n                return {\n                    message = card.ability.extra.scored_cards .. \"/\" .. card.ability.extra.cards_to_score,\n                    colour = G.C.FILTER\n                }\n            else\n                return {\n                    message = \"Bust!\",\n                    colour - G.C.FILTER\n                }\n            end\n        end\n        if context.joker_main then\n\t\t\treturn {\n\t\t\t\tmult = card.ability.extra.mult\n\t\t\t}\n\t\tend\n        if context.end_of_round \n        and context.game_over == false \n        and context.main_eval \n        and not context.blueprint then\n            if card.ability.extra.scored_cards == card.ability.extra.cards_to_score then\n                SMODS.scale_card(card, {\n                    ref_table = card.ability.extra,\n                    ref_value = \"mult\",\n                    scalar_value = \"mult_mod\",\n                    message_colour = G.C.MULT\n                })\n            end\n            card.ability.extra.scored_cards = 0\n        end\n\tend",
      "config": {
        "extra": {
          "mult": 0,
          "mult_mod": 10,
          "scored_cards": 0,
          "cards_to_score": 10
        }
      },
      "ability": {
        "extra": {
          "mult": 0,
          "mult_mod": 10,
          "scored_cards": 0,
          "cards_to_score": 10
        }
      },
      "vars": [
        10,
        0,
        0,
        10
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "candle",
      "name": "Candle",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 6,
        "y": 4
      },
      "raw": "key = 'candle',\n    loc_txt = {\n        name = 'Candle',\n        text = {\n            \"For the next {C:attention}#1#{} rounds, the first\",\n            \"scoring card of the round\",\n            \"gains a random {C:attention}Seal{}\",\n        }\n    },\n    config = { extra = { rounds_left = 5 } },\n    rarity = 2,\n    cost = 6,\n    blueprint_compat = false,\n    eternal_compat = false,\n    atlas = 'gb_Jokers',\n    pos = { x = 6, y = 4 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.rounds_left } }\n    end,\n    calculate = function(self, card, context)\n        if context.before and context.main_eval and G.GAME.current_round.hands_played == 0 and not context.blueprint then\n            context.scoring_hand[1]:set_seal(SMODS.poll_seal({ guaranteed = true, type_key = 'gb_candle' }))\n            context.scoring_hand[1]:juice_up()\n            card.ability.extra.rounds_left = card.ability.extra.rounds_left - 1\n            if card.ability.extra.rounds_left > 0 then\n                return {\n                    message = card.ability.extra.rounds_left .. '',\n                    colour = G.C.FILTER\n                }\n            else\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        play_sound('tarot1')\n                        card.T.r = -0.2\n                        card:juice_up(0.3, 0.4)\n                        card.states.drag.is = true\n                        card.children.center.pinch.x = true\n                        G.E_MANAGER:add_event(Event({\n                            trigger = 'after',\n                            delay = 0.3,\n                            blockable = false,\n                            func = function()\n                                card:remove()\n                                return true\n                            end\n                        }))\n                        return true\n                    end\n                }))\n                return {\n                    message = 'Melted!',\n                    colour = G.C.FILTER\n                }\n            end\n        end\n    end",
      "config": {
        "extra": {
          "rounds_left": 5
        }
      },
      "ability": {
        "extra": {
          "rounds_left": 5
        }
      },
      "vars": [
        5
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "cheque_stub",
      "name": "Cheque Stub",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 7,
        "y": 0
      },
      "raw": "key = 'cheque_stub',\n\tloc_txt = {\n\t\tname = 'Cheque Stub',\n\t\ttext = {\n            \"At end of round, earn {C:money}$#1#{}\",\n            \"and {C:attention}destroy{} leftmost\",\n            \"card held in hand\"\n\t\t}\n\t},\n\tconfig = { extra = { dollars = 4 } },\n    pixel_size = { w = 49 },\n\trarity = 2,\n\tatlas = 'gb_Jokers',\n\tpos = { x = 7, y = 0 },\n\tcost = 8,\n\tblueprint_compat = true,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.dollars } }\n\tend,\n    calc_dollar_bonus = function(self, card)\n        return card.ability.extra.dollars\n    end,\n    calculate = function(self, card, context)\n\t    if context.end_of_round and context.main_eval then\n            if G.hand.cards[1] then\n                G.hand.cards[1].getting_sliced = true\n                G.hand.cards[1]:start_dissolve()\n                return { remove = true }\n            end\n        end\n    end",
      "config": {
        "extra": {
          "dollars": 4
        }
      },
      "ability": {
        "extra": {
          "dollars": 4
        }
      },
      "vars": [
        4
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "creepy_painting",
      "name": "Creepy Painting",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 4,
        "y": 5
      },
      "raw": "key = \"creepy_painting\",\n    loc_txt = {\n        name = 'Creepy Painting',\n\t\ttext = {\n            \"{X:mult,C:white}X#1#{} Mult\",\n            \"When {C:attention}Blind{} is selected, {C:green}#2# in #3# chance{}\",\n            \"to {C:attention}destroy{} a random Joker\",\n            \"and create a {C:spectral}Spectral{} card\",\n            \"{C:inactive}(Must have room)\"\n\t\t}\n    },\n    config = { extra = { xmult = 2, odds = 2 } },\n\trarity = 2,\n\tatlas = 'gb_Jokers',\n\tpos = { x = 4, y = 5 },\n\tcost = 6,\n\tblueprint_compat = true,\n\tloc_vars = function(self, info_queue, card)\n        local new_numerator, new_denominator = SMODS.get_probability_vars(card, 1, card.ability.extra.odds)\n\t\treturn { vars = { card.ability.extra.xmult, new_numerator, new_denominator } }\n\tend,\n    calculate = function(self, card, context)\n        if context.joker_main then\n            return {\n                xmult = card.ability.extra.xmult\n            }\n        end\n        if context.setting_blind \n            and not context.blueprint \n            and SMODS.pseudorandom_probability(card, 'gb_creepy_painting', 1, card.ability.extra.odds) then\n            local valid_targets = {}\n            for _, joker in pairs(G.jokers.cards) do\n                if joker ~= card\n                    and not joker.ability.eternal\n                    and not joker.getting_sliced then\n                    valid_targets[#valid_targets + 1] = joker\n                end\n            end\n            local joker_to_destroy = pseudorandom_element(valid_targets, pseudoseed('gb_creepy_painting'))\n            if joker_to_destroy then\n                joker_to_destroy.getting_sliced = true\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        (context.blueprint_card or card):juice_up(0.8, 0.8)\n                        joker_to_destroy:start_dissolve({ G.C.RED }, nil, 1.6)\n                        return true\n                    end\n                }))\n                if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then\n                    G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1\n                    G.E_MANAGER:add_event(Event({\n                        func = (function()\n                            SMODS.add_card {\n                                set = 'Spectral',\n                                key_append = 'gb_creepy_painting'\n                            }\n                            G.GAME.consumeable_buffer = 0\n                            return true\n                        end)\n                    }))\n                    return {\n                        message = localize('k_plus_spectral'),\n                        colour = G.C.SECONDARY_SET.Spectral,\n                        remove = true\n                    }\n                end\n            end\n            return {}\n        end\n    end",
      "config": {
        "extra": {
          "xmult": 2,
          "odds": 2
        }
      },
      "ability": {
        "extra": {
          "xmult": 2,
          "odds": 2
        }
      },
      "vars": [
        2,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "escape_velocity",
      "name": "Escape Velocity",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 3,
        "y": 5
      },
      "raw": "key = 'escape_velocity',\n\tloc_txt = {\n\t\tname = 'Escape Velocity',\n\t\ttext = {\n            \"Level up played {C:attention}poker hand{}\",\n            \"if it has been played\",\n            \"{C:attention}#1#{} or fewer times this run\"\n\t\t}\n\t},\n\tconfig = { extra = { play_threshold = 3 } },\n\trarity = 2,\n\tatlas = 'gb_Jokers',\n\tpos = { x = 3, y = 5 },\n\tcost = 5,\n\tblueprint_compat = true,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.play_threshold } }\n\tend,\n    calculate = function(self, card, context)\n\t    if context.before then\n            if G.GAME.hands[context.scoring_name].played <= card.ability.extra.play_threshold then\n                return {\n                    level_up = true\n                }\n            end\n        end\n    end",
      "config": {
        "extra": {
          "play_threshold": 3
        }
      },
      "ability": {
        "extra": {
          "play_threshold": 3
        }
      },
      "vars": [
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "fault_line",
      "name": "Fault Line",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 2,
        "y": 6
      },
      "raw": "key = 'fault_line',\n\tloc_txt = {\n\t\tname = 'Fault Line',\n\t\ttext = {\n            \"{X:mult,C:white}X#1#{} Mult if played hand\",\n            \"contains a {C:attention}Stone{} card\",\n            \"{C:attention}Stone{} cards have a\",\n            \"{C:green}#2# in #3#{} chance to be\",\n            \"{C:attention}destroyed{} after scoring\"\n\t\t}\n\t},\n\tconfig = { extra = { xmult = 3, odds = 2 } },\n\trarity = 2,\n\tatlas = 'gb_Jokers',\n\tpos = { x = 2, y = 6 },\n\tcost = 6,\n\tblueprint_compat = true,\n    enhancement_gate = \"m_stone\",\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue + 1] = G.P_CENTERS.m_stone\n        local new_numerator, new_denominator = SMODS.get_probability_vars(card, 1, card.ability.extra.odds)\n        return { vars = { card.ability.extra.xmult, new_numerator, new_denominator } }\n\tend,\n    calculate = function(self, card, context)\n\t    if context.joker_main then\n            for _, playing_card in ipairs(context.scoring_hand) do\n                if SMODS.has_enhancement(playing_card, \"m_stone\") then\n                    return {\n                        xmult = card.ability.extra.xmult\n                    }\n                end\n            end\n        end\n        if context.destroy_card\n        and context.cardarea == G.play\n        and SMODS.has_enhancement(context.destroy_card, \"m_stone\")\n        and SMODS.pseudorandom_probability(card, 'gb_fault_line', 1, card.ability.extra.odds) then\n            return {\n                remove = true\n            }\n        end\n    end",
      "config": {
        "extra": {
          "xmult": 3,
          "odds": 2
        }
      },
      "ability": {
        "extra": {
          "xmult": 3,
          "odds": 2
        }
      },
      "vars": [
        3,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "first_strike",
      "name": "First Strike",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 1,
        "y": 4
      },
      "raw": "key = 'first_strike',\n    loc_txt = {\n        name = 'First Strike',\n        text = {\n            \"This Joker gains {X:mult,C:white}X#1#{} Mult\",\n            \"for each {C:attention}Blind{} skipped\",\n            \"Resets when {C:attention}Boss Blind{} is defeated\",\n            \"{C:inactive}(Currently {X:mult,C:white}X#2#{C:inactive} Mult)\",\n        }\n    },\n    config = { extra = { xmult = 1, xmult_mod = 1 } },\n    rarity = 2,\n    atlas = 'gb_Jokers',\n    pos = { x = 1, y = 4 },\n    cost = 6,\n    blueprint_compat = true,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.xmult_mod, card.ability.extra.xmult } }\n    end,\n    calculate = function(self, card, context)\n        if context.skip_blind and not context.blueprint then\n            SMODS.scale_card(card, {\n                ref_table = card.ability.extra,\n                ref_value = \"xmult\",\n                scalar_value = \"xmult_mod\",\n                message_colour = G.C.MULT\n            })\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval and not context.blueprint then\n            if G.GAME.blind.boss then\n                card.ability.extra.xmult = 1\n                return {\n                    message = 'Reset',\n                    colour = G.C.RED\n                }\n            end\n        end\n        if context.joker_main then\n            return {\n                xmult = card.ability.extra.xmult\n            }\n        end\n    end",
      "config": {
        "extra": {
          "xmult": 1,
          "xmult_mod": 1
        }
      },
      "ability": {
        "extra": {
          "xmult": 1,
          "xmult_mod": 1
        }
      },
      "vars": [
        1,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "floppy_disk",
      "name": "Floppy Disk",
      "atlas": "Jokers",
      "pos": {
        "x": 3,
        "y": 7
      },
      "raw": "key = 'floppy_disk',\n\tloc_txt = {\n\t\tname = 'Floppy Disk',\n\t\ttext = {\n            \"Sell this Joker to {C:attention}duplicate{}\",\n            \"the last {C:attention}#1#{} played cards and\",\n            \"add them to deck\"\n\t\t}\n\t},\n\trarity = 2,\n\tatlas = 'Jokers',\n    config = { extra = { saved_cards = {}, cards_to_save = 3 } },\n    pixel_size = { h = 72 },\n\tpos = { x = 3, y = 7 },\n\tcost = 6,\n\tblueprint_compat = false,\n    eternal_compat = false,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.cards_to_save } }\n    end,\n    calculate = function(self, card, context)\n        if context.individual\n        and context.cardarea == G.play\n        and not context.repetition\n        and not context.blueprint then\n            table.insert(card.ability.extra.saved_cards, context.other_card)\n            if #card.ability.extra.saved_cards > card.ability.extra.cards_to_save then\n                table.remove(card.ability.extra.saved_cards, 1)\n            end\n        end\n        if context.selling_self and not context.blueprint then\n            local copied_cards = {}\n            for _, saved_card in ipairs(card.ability.extra.saved_cards) do\n                G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                local copy_card = copy_card(saved_card, nil, nil, G.playing_card)\n                copy_card:add_to_deck()\n                G.deck.config.card_limit = G.deck.config.card_limit + 1\n                table.insert(G.playing_cards, copy_card)\n                G.deck:emplace(copy_card)\n                table.insert(copied_cards, copy_card)\n            end\n            return {\n                message = \"Copied \" .. #copied_cards .. \" Cards!\",\n                colour = G.C.FILTER,\n                func = function()\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            if #copied_cards > 0 then\n                                SMODS.calculate_context({ playing_card_added = true, cards = copied_cards })\n                            end\n                            return true\n                        end\n                    }))\n                end\n            }\n        end\n    end",
      "config": {
        "extra": {
          "saved_cards": {},
          "cards_to_save": 3
        }
      },
      "ability": {
        "extra": {
          "saved_cards": {},
          "cards_to_save": 3
        }
      },
      "vars": [
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "gamblers_fallacy",
      "name": "Gambler's Fallacy",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 0,
        "y": 7
      },
      "raw": "key = 'gamblers_fallacy',\n\tloc_txt = {\n\t\tname = 'Gambler\\'s Fallacy',\n\t\ttext = {\n            \"When a {C:green}probability roll {C:attention}fails,\",\n            \"add {C:green}+#2#{} to all {C:green}listed probabilites\",\n            \"{C:attention}Resets{} when one {C:attention}succeeds\",\n            \"{C:inactive}(Currently {C:green}+#1#{C:inactive})\"\n\t\t}\n\t},\n\tconfig = { extra = { fail_increase = 1, current_increase = 0 } },\n\trarity = 2,\n\tatlas = 'gb_Jokers',\n\tpos = { x = 0, y = 7 },\n\tcost = 7,\n\tblueprint_compat = false,\n    loc_vars = function(self, info_queue, card)\n        local fail_increase = card.ability.extra.fail_increase\n        return { vars = { \n            card.ability.extra.current_increase,\n            card.ability.extra.fail_increase\n    } }\n\tend,\n    calculate = function(self, card, context)\n        if context.fix_probability then\n            return {\n                numerator = context.numerator + card.ability.extra.current_increase\n            }\n        end\n        if context.pseudorandom_result and not context.blueprint then\n            if context.result then\n                card.ability.extra.current_increase = 0\n                return {\n                    message = localize(\"k_reset\"),\n                    colour = G.C.GREEN\n                }\n            else\n                SMODS.scale_card(card, {\n                    ref_table = card.ability.extra,\n                    ref_value = \"current_increase\",\n                    scalar_value = \"fail_increase\",\n                    message_colour = G.C.GREEN\n                })\n            end\n        end\n    end",
      "config": {
        "extra": {
          "fail_increase": 1,
          "current_increase": 0
        }
      },
      "ability": {
        "extra": {
          "fail_increase": 1,
          "current_increase": 0
        }
      },
      "vars": [
        0,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "hell_trees",
      "name": "Hell Trees",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 6,
        "y": 2
      },
      "raw": "key = \"hell_trees\",\n    loc_txt = {\n        name = 'Hell Trees',\n\t\ttext = {\n            \"Create an {V:1}Ephemeral{} card\",\n            \"when a hand is drawn\",\n            \"with {C:attention}1 hand remaining{}\"\n\t\t}\n    },\n\trarity = 2,\n\tatlas = 'gb_Jokers',\n\tpos = { x = 6, y = 2 },\n\tcost = 6,\n\tblueprint_compat = true,\n    loc_vars = function(self, info_queue, card)\n        return {\n            vars = {\n                colours = { HEX(\"8EA4B3\") }\n            }\n        }\n    end,\n    calculate = function(self, card, context)\n        if context.hand_drawn and G.GAME.current_round.hands_left == 1 then\n        G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1\n            G.E_MANAGER:add_event(Event({\n                func = (function()\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            SMODS.add_card {\n                                set = 'Ephemeral',\n                                key_append = 'gb_hell_trees'\n                            }\n                            G.GAME.consumeable_buffer = 0\n                            return true\n                        end\n                    }))\n                    SMODS.calculate_effect({ \n                        message = \"+1 Ephemeral\",\n                        colour = HEX(\"8EA4B3\")\n                    },\n                        context.blueprint_card or card)\n                    return true\n                end)\n            }))\n            return nil, true\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "indicator_paper",
      "name": "Indicator Paper",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 9,
        "y": 6
      },
      "raw": "key = 'indicator_paper',\n    loc_txt = {\n        name = 'Indicator Paper',\n        text = {\n            \"{X:mult,C:white}X#1#{} Mult if {C:attention}average{} rank\",\n            \"of played cards is {C:attention}#2#{} or less\",\n            \"{C:inactive,s:0.85}({C:attention,s:0.85}Kings{C:inactive,s:0.85}, {C:attention,s:0.85}Queens{C:inactive,s:0.85} and {C:attention,s:0.85}Jacks{C:inactive,s:0.85} count as {C:attention,s:0.85}10{C:inactive,s:0.85}){}\",\n            \"{C:inactive,s:0.85}({C:attention,s:0.85}Aces{C:inactive,s:0.85} count as {C:attention,s:0.85}1{C:inactive,s:0.85})\"\n\t\t}\n    },\n    config = { extra = { xmult = 2.5, threshold = 7 } },\n    rarity = 2,\n    cost = 7,\n    atlas = 'gb_Jokers',\n    pos = { x = 9, y = 6 },\n    soul_pos = { x = 8, y = 6 },\n       blueprint_compat = true,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.xmult, card.ability.extra.threshold } }\n    end,\n    calculate = function(self, card, context)\n        if context.joker_main then\n            local rank_sum = 0\n            for _, playing_card in pairs(context.full_hand) do\n                if not SMODS.has_no_rank(playing_card) then\n                    if playing_card:get_id() == 14 then\n                        rank_sum = rank_sum + 1\n                    end\n                    rank_sum = rank_sum + playing_card.base.nominal\n                end\n            end\n            local average_rank = rank_sum / #context.full_hand\n            if average_rank <= card.ability.extra.threshold then\n                return {\n                    xmult = card.ability.extra.xmult\n                }\n            else\n                return {\n                    message = string.format(\"%.1f\", average_rank),\n                    colour = G.C.FILTER\n                }\n            end\n        end\n    end",
      "config": {
        "extra": {
          "xmult": 2.5,
          "threshold": 7
        }
      },
      "ability": {
        "extra": {
          "xmult": 2.5,
          "threshold": 7
        }
      },
      "vars": [
        2.5,
        7
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "joker_boy",
      "name": "Joker Boy",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 7,
        "y": 6
      },
      "raw": "key = 'joker_boy',\n\tloc_txt = {\n\t\tname = 'Joker Boy',\n\t\ttext = {\n            \"Rounds {C:chips}Chips{} and {C:mult}Mult{} to\",\n            \"the next power of {C:attention}#1#{}\",\n\t\t}\n\t},\n\tconfig = { extra = { power = 2 } },\n\trarity = 2,\n\tatlas = 'gb_Jokers',\n\tpos = { x = 7, y = 6 },\n\tcost = 8,\n\tblueprint_compat = true,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.power } }\n\tend,\n    calculate = function(self, card, context)\n        local ln2_inverse = 1 / math.log(2)\n\t    if context.joker_main then\n            hand_chips = 2 ^ math.ceil(math.log(hand_chips) * ln2_inverse)\n            mult = 2 ^ math.ceil(math.log(mult) * ln2_inverse)\n            update_hand_text({delay = 0}, {chips = hand_chips, mult = mult})\n            return {\n                message = \"Retro!\",\n                colour = G.C.FILTER\n            }\n        end\n    end",
      "config": {
        "extra": {
          "power": 2
        }
      },
      "ability": {
        "extra": {
          "power": 2
        }
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "little_timbo",
      "name": "Little Timbo",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"little_timbo\",\n    loc_txt = {\n        name = 'Little Timbo',\n\t\ttext = {\n\t\t\t\"{C:attention}#1#X{} Blind size\",\n            \"{C:red}#2#{} Joker slot\",\n\t\t}\n    },\n    config = { extra = { blind_size = 0.5, joker_slot = -1 } },\n\trarity = 2,\n\tatlas = 'gb_Jokers',\n\tpos = { x = 2, y = 0 },\n\tcost = 6,\n\tblueprint_compat = false,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.blind_size, card.ability.extra.joker_slot } }\n    end,\n    calculate = function(self, card, context)\n        if context.setting_blind then\n            G.GAME.blind.chips = G.GAME.blind.chips * card.ability.extra.blind_size\n            G.GAME.blind.chip_text = number_format(G.GAME.blind.chips)\n            play_sound(\"cancel\")\n            card:juice_up()\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        G.jokers.config.card_limit = G.jokers.config.card_limit + card.ability.extra.joker_slot\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        G.jokers.config.card_limit = G.jokers.config.card_limit - card.ability.extra.joker_slot\n    end",
      "config": {
        "extra": {
          "blind_size": 0.5,
          "joker_slot": -1
        }
      },
      "ability": {
        "extra": {
          "blind_size": 0.5,
          "joker_slot": -1
        }
      },
      "vars": [
        0.5,
        -1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "lovers_locket",
      "name": "Lover's Locket",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 2,
        "y": 4
      },
      "raw": "key = 'lovers_locket',\n    loc_txt = {\n        name = 'Lover\\'s Locket',\n        text = {\n            \"{C:attention}Wild Cards{} have a\",\n            \"{C:green}#2# in #3#{} chance to\",\n            \"give {X:mult,C:white}X#1#{} Mult when scored\",\t\n        }\n    },\n    config = { extra = { odds = 2, xmult = 2 } },\n    rarity = 2,\n    cost = 6,\n    atlas = 'gb_Jokers',\n    pos = { x = 2, y = 4 },\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue + 1] = G.P_CENTERS.m_wild\n        local new_numerator, new_denominator = SMODS.get_probability_vars(card, 1, card.ability.extra.odds)\n        return { vars = { card.ability.extra.xmult, new_numerator, new_denominator } }\n    end,\n    calculate = function(self, card, context)\n        if context.individual and context.cardarea == G.play and SMODS.has_enhancement(context.other_card, \"m_wild\") and\n            SMODS.pseudorandom_probability(card, 'gb_lovers_locket', 1, card.ability.extra.odds) then\n            return {\n                xmult = card.ability.extra.xmult\n            }\n        end\n    end,\n    in_pool = function(self, args)\n        for _, playing_card in ipairs(G.playing_cards or {}) do\n            if SMODS.has_enhancement(playing_card, 'm_wild') then\n                return true\n            end\n        end\n        return false\n    end",
      "config": {
        "extra": {
          "odds": 2,
          "xmult": 2
        }
      },
      "ability": {
        "extra": {
          "odds": 2,
          "xmult": 2
        }
      },
      "vars": [
        2,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "misfortune",
      "name": "Wheel Of Misfortune",
      "atlas": "Jokers",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = 'misfortune',\n\tloc_txt = {\n\t\tname = 'Wheel Of Misfortune',\n\t\ttext = {\n\t\t\t\"{X:mult,C:white}X#1#{} Mult, {C:green}#2# in #3# chance{}\",\n\t\t\t\"for played hand to score {C:attention}0{}\",\n\t\t\t\"and be {C:attention}refunded{}\",\n\t\t}\n\t},\n\tconfig = { extra = { xmult = 3, odds = 4 } },\n\trarity = 2,\n\tatlas = 'Jokers',\n\tpos = { x = 0, y = 1 },\n\tcost = 5,\n\tblueprint_compat = true,\n\tloc_vars = function(self, info_queue, card)\n\t\tlocal new_numerator, new_denominator = SMODS.get_probability_vars(card, 1, card.ability.extra.odds)\n        return { vars = { card.ability.extra.xmult, new_numerator, new_denominator } }\n\tend,\n\tcalculate = function(self, card, context)\n\t\tif context.joker_main then\n\t\t\treturn {\n\t\t\t\txmult = card.ability.extra.xmult\n\t\t\t}\n\t\tend\n\t\tif context.final_scoring_step then\n\t\t\tif SMODS.pseudorandom_probability(card, 'gb_misfortune', 1, card.ability.extra.odds) then\t\t\n\t\t\t\thand_chips = 0\n\t\t\t\tmult = 0\n\t\t\t\tease_hands_played(1)\n\t\t\t\treturn {\n\t\t\t\t\tmessage = localize('k_nope_ex'),\n\t\t\t\t\tcolour = G.C.SECONDARY_SET.Tarot,\n\t\t\t\t\tsound = 'cancel'\n\t\t\t\t}\n\t\t\tend\n\t\tend\n\tend",
      "config": {
        "extra": {
          "xmult": 3,
          "odds": 4
        }
      },
      "ability": {
        "extra": {
          "xmult": 3,
          "odds": 4
        }
      },
      "vars": [
        3,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "paint_the_town_red",
      "name": "Paint The Town Red",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 4,
        "y": 2
      },
      "raw": "key = 'paint_the_town_red',\n\tloc_txt = {\n\t\tname = 'Paint The Town Red',\n\t\ttext = {\n\t\t\t\"{C:mult}+#1#{} Mult for every\",\n            \"{C:hearts}Heart{} in {C:attention}full deck{}\",\n            \"{C:mult}-#1#{} Mult for every\",\n            \"{C:spades}Spade{} in {C:attention}full deck{}\",\n            \"{C:inactive}(Currently {C:mult}+#2#{}{C:inactive} Mult)\",\n\t\t}\n\t},\n    config = { extra = { mult_mod = 4, mult = 0 } },\n    rarity = 2,\n\tatlas = 'gb_Jokers',\n\tpos = { x = 4, y = 2 },\n\tcost = 6,\n\tblueprint_compat = true,\n    loc_vars = function(self, info_queue, card)\n        local cumulative_mult = 0\n        if G.playing_cards then\n            for _, playing_card in pairs(G.playing_cards) do\n                if playing_card:is_suit('Hearts') then\n                    cumulative_mult = cumulative_mult + card.ability.extra.mult_mod\n                end\n            end\n            for _, playing_card in pairs(G.playing_cards) do\n                if playing_card:is_suit('Spades') then\n                    cumulative_mult = cumulative_mult - card.ability.extra.mult_mod\n                end\n            end\n        end\n        return { vars = {\n            card.ability.extra.mult_mod,\n            math.max(0, cumulative_mult)\n        } }\n    end,\n    calculate = function(self, card, context)\n        if context.joker_main then \n            local cumulative_mult = 0\n            for _, playing_card in pairs(G.playing_cards) do\n                if playing_card:is_suit('Hearts') then\n                    cumulative_mult = cumulative_mult + card.ability.extra.mult_mod\n                end\n            end\n            for _, playing_card in pairs(G.playing_cards) do\n                if playing_card:is_suit('Spades') then\n                    cumulative_mult = cumulative_mult - card.ability.extra.mult_mod\n                end\n            end\n            card.ability.extra.mult = math.max(0, cumulative_mult)\n            return {\n                mult = card.ability.extra.mult\n            }\n        end\n    end",
      "config": {
        "extra": {
          "mult_mod": 4,
          "mult": 0
        }
      },
      "ability": {
        "extra": {
          "mult_mod": 4,
          "mult": 0
        }
      },
      "vars": [
        4,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "patchwork",
      "name": "Patchwork",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = 'patchwork',\n    loc_txt = {\n        name = 'Patchwork',\n        text = {\n            \"At start of shop,\",\n            \"create a random {C:dark_edition}Temporary{} Joker\",\n        }\n    },\n    rarity = 2,\n    atlas = 'gb_Jokers',\n    pos = { x = 0, y = 0 },\n    cost = 6,\n    blueprint_compat = true,\n    calculate = function(self, card, context)\n        if context.starting_shop then\n            SMODS.add_card {\n                set = \"Joker\",\n                edition = 'e_gb_temporary',\n                key_append = 'gb_patchwork'\n            }\n            card:juice_up()\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "recursion",
      "name": "Recursion",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 5,
        "y": 7
      },
      "raw": "key = 'recursion',\n\tloc_txt = {\n\t\tname = 'Recursion',\n\t\ttext = {\n\t\t\t\"If played hand contains\",\n            \"{C:attention}#1#{} scoring {C:attention}2{}s, retrigger\",\n            \"all played {C:attention}2{}s {C:attention}#2#{} times\"\n\t\t}\n\t},\n    config = { extra = { threshold = 2, repetitions = 2 } },\n    rarity = 2,\n\tatlas = 'gb_Jokers',\n\tpos = { x = 5, y = 7 },\n\tcost = 8,\n\tblueprint_compat = true,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.threshold, card.ability.extra.repetitions } }\n    end,\n    calculate = function(self, card, context)\n        if context.repetition\n        and context.cardarea == G.play\n        and context.other_card:get_id() == 2 then\n            local twos = 0\n            for _, playing_card in ipairs(context.scoring_hand) do\n                if playing_card:get_id() == 2 then\n                    twos = twos + 1\n                end\n            end\n            if twos >= card.ability.extra.threshold then\n                return {\n                    repetitions = card.ability.extra.repetitions\n                }\n            end\n        end\n    end",
      "config": {
        "extra": {
          "threshold": 2,
          "repetitions": 2
        }
      },
      "ability": {
        "extra": {
          "threshold": 2,
          "repetitions": 2
        }
      },
      "vars": [
        2,
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "speculative_bubble",
      "name": "Speculative Bubble",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 8,
        "y": 0
      },
      "raw": "key = \"speculative_bubble\",\n    loc_txt = {\n        name = 'Speculative Bubble',\n\t\ttext = {\n            \"{C:green}#1# in #2# chance{} to set money to {C:money}$0\",\n            \"when sold or destroyed\",\n            \"Scored cards earn {C:money}$#3#\",\n            \"and increase this {C:green}probability{} by {C:attention}#4#\",\n            \"{C:inactive,s:0.85}(Self destructs at {C:green,s:0.85}#2# in #2# chance{C:inactive,s:0.85})\"\n\t\t}\n    },\n    config = { extra = {\n        base_numerator = 0,\n        numerator_increase = 1,\n        odds = 100,\n        money = 1,\n        popped = false\n    } },\n\trarity = 2,\n\tatlas = 'gb_Jokers',\n\tpos = { x = 8, y = 0 },\n\tcost = 7,\n\tblueprint_compat = false,\n        loc_vars = function(self, info_queue, card)\n        local new_numerator, new_denominator = SMODS.get_probability_vars(card, card.ability.extra.base_numerator, card.ability.extra.odds)\n        return {\n            vars = {\n                new_numerator,\n                new_denominator,\n                card.ability.extra.money,\n                card.ability.extra.numerator_increase\n            },\n        }\n    end,\n    calculate = function(self, card, context)\n        if context.individual\n        and context.cardarea == G.play\n        and not context.blueprint\n        and not card.ability.extra.popped == true then\n            if card.ability.extra.base_numerator < 100 then\n                card.ability.extra.base_numerator = card.ability.extra.base_numerator + card.ability.extra.numerator_increase\n                return {\n                    dollars = card.ability.extra.money,\n                    message_card = context.other_card\n                }\n            else\n                card.ability.extra.popped = true\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        play_sound('tarot1')\n                        card.T.r = -0.2\n                        card:juice_up(0.3, 0.4)\n                        card.states.drag.is = true\n                        card.children.center.pinch.x = true\n                        G.E_MANAGER:add_event(Event({\n                            trigger = 'after',\n                            delay = 0.3,\n                            blockable = false,\n                            func = function()\n                                card:remove()\n                                return true\n                            end\n                        }))\n                        return true\n                    end\n                }))\n                return {\n                    message = 'Popped!',\n                    colour = G.C.FILTER,\n                    message_card = card\n                }\n            end\n        end\n    end,\n\n    remove_from_deck = function(self, card, from_debuff)\n        if not from_debuff and SMODS.pseudorandom_probability(card, 'gb_speculative_bubble', card.ability.extra.base_numerator, card.ability.extra.odds) then\n            ease_dollars(-G.GAME.dollars, true)\n        end\n    end",
      "config": {
        "extra": {
          "base_numerator": 0,
          "numerator_increase": 1,
          "odds": 100,
          "money": 1,
          "popped": false
        }
      },
      "ability": {
        "extra": {
          "base_numerator": 0,
          "numerator_increase": 1,
          "odds": 100,
          "money": 1,
          "popped": false
        }
      },
      "vars": [
        null,
        null,
        1,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "taxman",
      "name": "Taxman",
      "atlas": "Jokers",
      "pos": {
        "x": 5,
        "y": 0
      },
      "raw": "key = 'taxman',\n    loc_txt = {\n        name = 'Taxman',\n        text = {\n            \"{C:attention}Taxes half{} of your {C:attention}cashout\",\n            \"and gains {C:chips}+#2#{} Chips\",\n            \"for every {C:money}$1{} taken\",\n            \"{C:inactive}(Currently {C:chips}+#1#{C:inactive} Chips)\"\n        }\n    },\n    config = { extra = { chips = 0, chips_mod = 5 } },\n    rarity = 2,\n    cost = 5,\n    blueprint_compat = true,\n    atlas = 'Jokers',\n    pos = { x = 5, y = 0 },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.chips, card.ability.extra.chips_mod } }\n    end,\n    calculate = function(self, card, context)\n        if context.cashed_out then\n            local tax = math.floor(context.cashout_dollars / 2)\n            if tax > to_big(0) then\n                G.E_MANAGER:add_event(Event({\n                    trigger = 'after',\n                    delay = 0.5,\n                    blockable = false,\n                    func = function()\n                        card.ability.extra.chips = card.ability.extra.chips + card.ability.extra.chips_mod * tax\n                        ease_dollars(-tax)\n                        SMODS.calculate_effect({ message = \"Taxed!\", colour = G.C.MONEY }, card)\n                        return true\n                    end\n                }))\n            end\n        end\n        if context.joker_main then\n            return {\n                chips = card.ability.extra.chips\n            }\n        end\n    end",
      "config": {
        "extra": {
          "chips": 0,
          "chips_mod": 5
        }
      },
      "ability": {
        "extra": {
          "chips": 0,
          "chips_mod": 5
        }
      },
      "vars": [
        0,
        5
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "ten_bob",
      "name": "Ten Bob",
      "atlas": "Jokers",
      "pos": {
        "x": 9,
        "y": 0
      },
      "raw": "key = 'ten_bob',\n\tloc_txt = {\n\t\tname = 'Ten Bob',\n\t\ttext = {\n            \"When {C:attention}Blind{} is selected,\",\n            \"set {C:attention}sell value{} of\",\n            \" a random held Joker to {C:money}$#1#{}\",\n            \"If all held Jokers {C:attention}sell{} for {C:money}$#1#{},\",\n            \"earn {C:money}$#1#{} at end of round\"\n\t\t}\n\t},\n\trarity = 2,\n\tatlas = 'Jokers',\n    config = { extra = { dollars = 10, all_jokers_ten = false } },\n    pixel_size = { w = 50 },\n\tpos = { x = 9, y = 0 },\n\tcost = 10,\n\tblueprint_compat = false,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.dollars } }\n    end,\n    calc_dollar_bonus = function(self, card)\n        return (card.ability.extra.all_jokers_ten and card.ability.extra.dollars or 0)\n    end,\n    calculate = function(self, card, context)\n        if context.end_of_round\n        and context.main_eval\n        and not context.blueprint then\n            local valid_targets = {}\n            for _, joker in pairs(G.jokers.cards) do\n                if joker.sell_cost ~= card.ability.extra.dollars then\n                    valid_targets[#valid_targets + 1] = joker\n                end\n            end\n            local selected_joker = pseudorandom_element(valid_targets, pseudoseed('gb_ten_bob'))\n            if selected_joker then\n                selected_joker.sell_cost = 10\n                card:juice_up()\n                return {\n                    message = \"Sell Value Set!\",\n                    colour = G.C.MONEY,\n                    message_card = selected_joker\n                }\n            else\n                card.ability.extra.all_jokers_ten = true\n            end\n        end\n        if context.starting_shop then\n            card.ability.extra.all_jokers_ten = false\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        sell_cost = card.ability.extra.dollars\n    end,",
      "config": {
        "extra": {
          "dollars": 10,
          "all_jokers_ten": false
        }
      },
      "ability": {
        "extra": {
          "dollars": 10,
          "all_jokers_ten": false
        }
      },
      "vars": [
        10
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "Triforce",
      "name": "Triforce",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 6,
        "y": 5
      },
      "raw": "key = \"Triforce\",\n    loc_txt = {\n        name = 'Triforce',\n\t\ttext = {\n            \"{X:mult,C:white}X#1#{} Mult if played hand\",\n            \"is a {C:attention}Three of a Kind\",\n            \"with {C:attention}#2#{} different suits\"\n\t\t}\n    },\n    config = { extra = { xmult = 3, suits = 3 } },\n\trarity = 2,\n\tatlas = 'gb_Jokers',\n\tpos = { x = 6, y = 5 },\n\tcost = 6,\n\tblueprint_compat = true,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.xmult, card.ability.extra.suits } }\n    end,\n    calculate = function(self, card, context)\n        if context.joker_main \n        and context.scoring_name == \"Three of a Kind\"\n        and gb_count_suits(context.scoring_hand) == card.ability.extra.suits then\n            return {\n                xmult = card.ability.extra.xmult\n            }\n        end\n    end",
      "config": {
        "extra": {
          "xmult": 3,
          "suits": 3
        }
      },
      "ability": {
        "extra": {
          "xmult": 3,
          "suits": 3
        }
      },
      "vars": [
        3,
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "yellow_pages",
      "name": "Yellow Pages",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 7,
        "y": 1
      },
      "raw": "key = 'yellow_pages',\n\tloc_txt = {\n\t\tname = 'Yellow Pages',\n\t\ttext = {\n\t\t\t\"The first {C:attention}#1#{} scoring\",\n\t\t\t\"{C:attention}numbered{} cards give\",\n\t\t\t\"{C:mult}Mult{} equal to their rank\",\n\t\t}\n\t},\n\tconfig = { extra = { scoring_tally = 0, cards_to_trigger = 3, trigger_cards = {} } },\n\trarity = 2,\n\tatlas = 'gb_Jokers',\n\tpos = { x = 7, y = 1 },\n\tcost = 5,\n\tblueprint_compat = true,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.cards_to_trigger } }\n\tend,\n    calculate = function(self, card, context)\n        if context.before then\n            card.ability.extra.scoring_tally = 0\n\t\t\tfor _, playing_card in ipairs(context.scoring_hand) do\n\t\t\t\tif not SMODS.has_no_rank(playing_card)\n\t\t\t\tand playing_card:get_id() >= 2\n\t\t\t\tand playing_card:get_id() <= 10 then\n\t\t\t\t\tif card.ability.extra.scoring_tally >= card.ability.extra.cards_to_trigger then\n\t\t\t\t\t\tbreak\n\t\t\t\t\telse\n\t\t\t\t\t\tcard.ability.extra.trigger_cards[#card.ability.extra.trigger_cards + 1] = playing_card\n\t\t\t\t\t\tcard.ability.extra.scoring_tally = card.ability.extra.scoring_tally + 1\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n        end\n\t\tif context.individual and context.cardarea == G.play then\n\t\t\tfor _, trigger_card in ipairs(card.ability.extra.trigger_cards) do\n\t\t\t\tif context.other_card == trigger_card then\n            \t\treturn {\n                \t\tmult = context.other_card.base.nominal\n\t\t\t\t\t}\n\t\t\t\tend\n\t\t\tend\n        end\n    end",
      "config": {
        "extra": {
          "scoring_tally": 0,
          "cards_to_trigger": 3,
          "trigger_cards": {}
        }
      },
      "ability": {
        "extra": {
          "scoring_tally": 0,
          "cards_to_trigger": 3,
          "trigger_cards": {}
        }
      },
      "vars": [
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "d20",
      "name": "D20",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 9,
        "y": 4
      },
      "raw": "key = 'd20',\n    loc_txt = {\n        name = 'D20',\n        text = {\n            \"{C:green}#1# in #2#{} chance to\",\n            \"{C:attention}enhance{} a drawn card\",\n        }\n    },\n    config = { extra = { odds = 20 } },\n    rarity = 3,\n    cost = 8,\n    atlas = 'gb_Jokers',\n    pos = { x = 9, y = 4 },\n    blueprint_compat = true,\n    soul_pos = { x = 8, y = 4 },\n    loc_vars = function(self, info_queue, card)\n        local new_numerator, new_denominator = SMODS.get_probability_vars(card, 1, card.ability.extra.odds)\n        return { vars = { new_numerator, new_denominator } }\n    end,\n    calculate = function(self, card, context)\n        if context.hand_drawn or context.other_drawn then\n\t\t    for _, playing_card in ipairs(context.hand_drawn or context.other_drawn) do\n\t\t\t    if SMODS.pseudorandom_probability(card, 'gb_d20', G.GAME.probabilities.normal, card.ability.extra.odds) then\n                    local valid_keys = {}\n                    for _, enhancement_center in pairs(G.P_CENTER_POOLS[\"Enhanced\"]) do\n                        if enhancement_center.key ~= 'm_stone' \n                        and (enhancement_center.in_pool() or true) then\n                            valid_keys[#valid_keys + 1] = enhancement_center.key\n                        end\n                    end\n                    playing_card:set_ability(\n                        pseudorandom_element(valid_keys, pseudoseed('d20'))\n                    )\n                    playing_card:juice_up()\n                    return {\n                        message = \"Enhanced!\",\n                        colour = G.C.FILTER\n                    }\n                end\n\t\t    end\n        end\n    end",
      "config": {
        "extra": {
          "odds": 20
        }
      },
      "ability": {
        "extra": {
          "odds": 20
        }
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "double_king",
      "name": "Double King",
      "atlas": "Jokers",
      "pos": {
        "x": 5,
        "y": 2
      },
      "raw": "key = 'double_king',\n\tloc_txt = {\n\t\tname = 'Double King',\n\t\ttext = {\n\t\t\t\"If played hand contains two {C:attention}Kings{},\",\n\t\t\t\"this joker gains {X:mult,C:white}X#1#{} Mult and\",\n\t\t\t\"{C:red}destroys{} the leftmost {C:attention}King{}\",\n\t\t\t\"{C:inactive}(Currently {X:mult,C:white}X#2#{C:inactive} Mult)\"\n\t\t}\n\t},\n\tconfig = { extra = { xmult = 1, xmult_mod = 0.5, king_removed = false, activates = false } },\n\trarity = 3,\n\tatlas = 'Jokers',\n\tpos = { x = 5, y = 2 },\n\tcost = 7,\n\tblueprint_compat = true,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.xmult_mod, card.ability.extra.xmult } }\n\tend,\n    calculate = function(self, card, context)\n\t\tif context.before then\n\t\t\tcard.ability.extra.king_removed = false\n\t\t\tcard.ability.extra.activates = false\n\t\t\tlocal tally = 0\n            for _, playing_card in ipairs(context.scoring_hand) do\n                if playing_card:get_id() == 13 then\n\t\t\t\t\ttally = tally + 1\n\t\t\t\tend\n            end\n\t\t\tif tally >= 2 then\n\t\t\t\tcard.ability.extra.activates = true\n\t\t\t\tSMODS.scale_card(card, {\n                \tref_table = card.ability.extra,\n                \tref_value = \"xmult\",\n                \tscalar_value = \"xmult_mod\",\n                \tmessage_colour = G.C.MULT\n            \t})\n\t\t\tend\n\t\tend\n        if context.joker_main then\n            return {\n                xmult = card.ability.extra.xmult\n\t\t\t}\n\t\tend\n\t\tif context.destroy_card then\n\t\t\tif card.ability.extra.activates then\n\t\t\t\tfor _, playing_card in ipairs(context.scoring_hand) do\n\t\t\t\t\tif playing_card:get_id() == 13 and context.destroy_card == playing_card and not card.ability.extra.king_removed then\n\t\t\t\t\t\tcard.ability.extra.king_removed = true\n\t\t\t\t\t\treturn { remove = true }\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend",
      "config": {
        "extra": {
          "xmult": 1,
          "xmult_mod": 0.5,
          "king_removed": false,
          "activates": false
        }
      },
      "ability": {
        "extra": {
          "xmult": 1,
          "xmult_mod": 0.5,
          "king_removed": false,
          "activates": false
        }
      },
      "vars": [
        0.5,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "dream_emulator",
      "name": "Dream Emulator",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 5,
        "y": 6
      },
      "raw": "key = 'dream_emulator',\n\tloc_txt = {\n\t\tname = 'Dream Emulator',\n\t\ttext = {\n            \"Create {C:attention}#1# {C:dark_edition}Temporary{} copies\",\n            \"of the first sold Joker\",\n            \"of the round\"\n\t\t}\n\t},\n\tconfig = { extra = { copies = 2, active = true } },\n\trarity = 3,\n\tatlas = 'gb_Jokers',\n\tpos = { x = 5, y = 6 },\n\tcost = 8,\n\tblueprint_compat = false,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.copies } }\n\tend,\n    calculate = function(self, card, context)\n        if context.selling_card\n        and not context.card == card\n        and context.card.ability.set == \"Joker\"\n        and card.ability.extra.active == true \n        and not context.blueprint then\n            card.ability.extra.active = false\n            for _ = 1, card.ability.extra.copies do\n                local copied_joker = copy_card(context.card)\n                copied_joker:set_edition(\"e_gb_temporary\")\n                copied_joker:add_to_deck()\n                G.jokers:emplace(copied_joker)\n            end\n            return {\n                message = \"Copied!\",\n                colour = G.C.FILTER\n            }\n        end\n        if context.starting_shop then\n            card.ability.extra.active = true\n            return {\n                message = localize(\"k_reset\"),\n                colour = G.C.FILTER\n            }\n        end\n    end",
      "config": {
        "extra": {
          "copies": 2,
          "active": true
        }
      },
      "ability": {
        "extra": {
          "copies": 2,
          "active": true
        }
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "eye_of_providence",
      "name": "Eye of Providence",
      "atlas": "Jokers",
      "pos": {
        "x": 3,
        "y": 6
      },
      "raw": "key = 'eye_of_providence',\n\tloc_txt = {\n\t\tname = 'Eye of Providence',\n\t\ttext = {\n            \"Balances {C:blue}Chips{} and {C:red}Mult{} by {V:1}#1#%{}\",\n            \"for every scoring {C:gb_eyes}Eye{} card\"\n\t\t}\n\t},\n\trarity = 3,\n\tatlas = 'Jokers',\n\tpos = { x = 3, y = 6 },\n\tcost = 6,\n\tblueprint_compat = true,\n    config = { extra = { balance_percent = 10 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.balance_percent, colours = { HEX(\"C82DFF\") } } }\n    end,\n    calculate = function(self, card, context)\n        if context.final_scoring_step then\n            local balance_value = 0\n            for _, playing_card in ipairs(context.scoring_hand) do\n                if playing_card:is_suit(\"gb_Eyes\") then\n                    balance_value = balance_value + card.ability.extra.balance_percent * 0.01\n                end\n            end\n            gb_partial_balance(hand_chips, mult, balance_value)\n        end\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_suit_in_deck(\"gb_Eyes\")\n    end",
      "config": {
        "extra": {
          "balance_percent": 10
        }
      },
      "ability": {
        "extra": {
          "balance_percent": 10
        }
      },
      "vars": [
        10,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "fuzzy_dice",
      "name": "Fuzzy Dice",
      "atlas": "Jokers",
      "pos": {
        "x": 9,
        "y": 7
      },
      "raw": "key = 'fuzzy_dice',\n\tloc_txt = {\n\t\tname = 'Fuzzy Dice',\n\t\ttext = {\n            \"Scored cards gain\",\n            \"{C:chips}+#1#{} Chips {C:attention}permanently{}\",\n            \"Increases by {C:chips}+#2#{} when\",\n            \"shop is {C:attention}rerolled\"\n\t\t}\n\t},\n\trarity = 3,\n\tatlas = 'Jokers',\n    config = { extra = { chips = 2, chips_mod = 2 } },\n\tpos = { x = 9, y = 7 },\n\tcost = 8,\n\tblueprint_compat = true,\n    eternal_compat = true,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.chips, card.ability.extra.chips_mod } }\n    end,\n    calculate = function(self, card, context)\n        if context.reroll_shop and not context.blueprint then\n            SMODS.scale_card(card, {\n                ref_table = card.ability.extra,\n                ref_value = \"chips\",\n                scalar_value = \"chips_mod\",\n                message_colour = G.C.CHIPS\n            })\n        end\n        if context.individual\n        and context.cardarea == G.play then\n            context.other_card.ability.perma_bonus = (context.other_card.ability.perma_bonus or 0) + card.ability.extra.chips\n            return {\n                message = localize('k_upgrade_ex'),\n                message_card = context.other_card,\n                colour = G.C.CHIPS\n            }\n        end\n    end,",
      "config": {
        "extra": {
          "chips": 2,
          "chips_mod": 2
        }
      },
      "ability": {
        "extra": {
          "chips": 2,
          "chips_mod": 2
        }
      },
      "vars": [
        2,
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "golden_cookie",
      "name": "Golden Cookie",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 0,
        "y": 4
      },
      "raw": "key = 'golden_cookie',\n    loc_txt = {\n        name = 'Golden Cookie',\n        text = {\n            \"{X:mult,C:white}X#1#{} Mult,\",\n            \"decreases by {X:mult,C:white}X#2#{} Mult\",\n            \"after hand scored\",\n        }\n    },\n    config = { extra = { xmult = 7, xmult_mod = 1.5 } },\n    rarity = 3,\n    atlas = 'gb_Jokers',\n    pos = { x = 0, y = 4 },\n    cost = 7,\n    blueprint_compat = true,\n    eternal_compat = false,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.xmult, card.ability.extra.xmult_mod } }\n    end,\n    calculate = function(self, card, context)\n        if context.joker_main then\n            return {\n                xmult = card.ability.extra.xmult,\n            }\n        end\n        if context.after and not context.blueprint then\n            SMODS.scale_card(card, {\n                    ref_table = card.ability.extra,\n                    ref_value = \"xmult\",\n                    scalar_value = \"xmult_mod\",\n                    operation = \"-\",\n                    no_message = true\n                })\n            if card.ability.extra.xmult <= 1 then\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        play_sound('tarot1')\n                        card.T.r = -0.2\n                        card:juice_up(0.3, 0.4)\n                        card.states.drag.is = true\n                        card.children.center.pinch.x = true\n                        G.E_MANAGER:add_event(Event({\n                            trigger = 'after',\n                            delay = 0.3,\n                            blockable = false,\n                            func = function()\n                                card:remove()\n                                return true\n                            end\n                        }))\n                        return true\n                    end\n                }))\n                return {\n                    message = 'Eaten!',\n                    colour = G.C.FILTER\n                }\n            else           \n                return {\n                    message = 'Downgraded!',\n                    colour = G.C.FILTER\n                }\n            end\n        end\n    end",
      "config": {
        "extra": {
          "xmult": 7,
          "xmult_mod": 1.5
        }
      },
      "ability": {
        "extra": {
          "xmult": 7,
          "xmult_mod": 1.5
        }
      },
      "vars": [
        7,
        1.5
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "lobster_claw",
      "name": "Lobster Claw",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 9,
        "y": 1
      },
      "raw": "key = 'lobster_claw',\n    loc_txt = {\n        name = 'Lobster Claw',\n        text = {\n            \"Jokers give {C:mult}Mult{} equal to\",\n            \"the rank of a random\",\n            \"scoring card\",\n        }\n    },\n    rarity = 3,\n    atlas = 'gb_Jokers',\n    pos = { x = 9, y = 1 },\n    cost = 7,\n    blueprint_compat = true,\n    calculate = function(self, card, context)\n        if context.other_joker then\n            valid_cards = {}\n            for _, playing_card in ipairs(context.scoring_hand) do\n                if not SMODS.has_no_rank(playing_card) then\n                    table.insert(valid_cards, playing_card)\n                end\n            end\n            local random_card = pseudorandom_element(context.scoring_hand, pseudoseed('gb_lobster_claw'))\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    random_card:juice_up()\n                    return true\n                end\n            }))\n            return {\n                mult = random_card.base.nominal or 0,\n                message_card = context.other_joker\n            }\n        end\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "mystery_man",
      "name": "Mystery Man",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 5,
        "y": 3
      },
      "raw": "key = 'mystery_man',\n\tloc_txt = {\n\t\tname = 'Mystery Man',\n\t\ttext = {\n\t\t\t\"If played hand contains {C:attention}#1#{} {C:attention}6{}s,\",\n            \"{C:attention}6{}s gain {C:mult}+#2#{} Mult when scored and\",\n            \"all cards held in hand\",\n            \"are {C:attention}destroyed{} after scoring\"\n            \n\t\t}\n\t},\n    config = { extra = { threshold = 3, mult = 6, active = false } },\n    rarity = 3,\n\tatlas = 'gb_Jokers',\n\tpos = { x = 5, y = 3 },\n\tcost = 6,\n\tblueprint_compat = true,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.threshold, card.ability.extra.mult } }\n    end,\n    calculate = function(self, card, context)\n        if context.before and context.main_eval then\n            local sixes = 0\n            for _, playing_card in ipairs(context.scoring_hand) do\n                if playing_card:get_id() == 6 then\n                    sixes = sixes + 1\n                end\n            end\n            card.ability.extra.active = ((sixes >= card.ability.extra.threshold) and true or false)\n\n        end\n        if context.individual\n        and context.cardarea == G.play\n        and card.ability.extra.active == true\n        and context.other_card:get_id() == 6 then\n            context.other_card.ability.perma_mult = (context.other_card.ability.perma_mult or 0) + card.ability.extra.mult\n            return {\n                message = localize('k_upgrade_ex'),\n                message_card = context.other_card,\n                colour = G.C.MULT\n            }\n        end\n        if context.destroy_card\n        and context.cardarea == G.hand\n        and card.ability.extra.active == true\n        and not context.blueprint then\n            return {\n                remove = true\n            }\n        end\n    end",
      "config": {
        "extra": {
          "threshold": 3,
          "mult": 6,
          "active": false
        }
      },
      "ability": {
        "extra": {
          "threshold": 3,
          "mult": 6,
          "active": false
        }
      },
      "vars": [
        3,
        6
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "pentagram",
      "name": "Pentagram",
      "atlas": "Jokers",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = 'pentagram',\n\tloc_txt = {\n\t\tname = 'Pentagram',\n\t\ttext = {\n            \"This Joker gains {X:mult,C:white}X#1#{} Mult\",\n            \"for every {C:attention}consecutive{} hand with\",\n            \"{C:attention}five scoring cards{}\",\n            \"{C:inactive}(Currently {X:mult,C:white}X#2#{C:inactive} Mult)\",\n\t\t}\n\t},\n\tconfig = { extra = { xmult = 1, xmult_mod = 0.25 } },\n\trarity = 3,\n\tatlas = 'Jokers',\n\tpos = { x = 3, y = 0 },\n\tcost = 8,\n\tblueprint_compat = true,\n    perishable_compat = false,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.xmult_mod, card.ability.extra.xmult } }\n\tend,\n    calculate = function(self, card, context)\n        if context.before and context.main_eval and not context.blueprint then\n            local reset = true\n            if #context.scoring_hand >= 5 then\n                reset = false\n            end\n            if reset then\n                if card.ability.extra.xmult > 1 then\n                    card.ability.extra.xmult = 1\n                    return {\n                        message = localize('k_reset')\n                    }\n                end\n            else\n                SMODS.scale_card(card, {\n                    ref_table = card.ability.extra,\n                    ref_value = \"xmult\",\n                    scalar_value = \"xmult_mod\",\n                    message_colour = G.C.MULT\n                })\n            end\n        end\n        if context.joker_main then\n            return {\n                xmult = card.ability.extra.xmult\n            }\n        end\n    end",
      "config": {
        "extra": {
          "xmult": 1,
          "xmult_mod": 0.25
        }
      },
      "ability": {
        "extra": {
          "xmult": 1,
          "xmult_mod": 0.25
        }
      },
      "vars": [
        0.25,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "the_moons_oceans",
      "name": "The Moon's Oceans",
      "atlas": "gb_Jokers",
      "pos": {
        "x": 9,
        "y": 2
      },
      "raw": "key = 'the_moons_oceans',\n    loc_txt = {\n        name = 'The Moon\\'s Oceans',\n        text = {\n            \"Scored {C:attention}Aces{} retrigger once\",\n            \"and give {X:mult,C:white}X#1#{} Mult\",\n        }\n    },\n    config = { extra = { xmult = 1.5, retriggers = 1} },\n    rarity = 3,\n    atlas = 'gb_Jokers',\n    pos = { x = 9, y = 2 },\n    cost = 9,\n    blueprint_compat = true,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.xmult } }\n    end,\n    calculate = function(self, card, context)\n        if context.repetition and context.cardarea == G.play then\n            if context.other_card:get_id() == 14 then\n                return {\n                    repetitions = card.ability.extra.retriggers,\n                }\n            end\n            \n        end\n        if context.individual and context.cardarea == G.play and\n            context.other_card:get_id() == 14 then\n            return {\n                xmult = card.ability.extra.xmult,\n            }\n        end\n        \n    end",
      "config": {
        "extra": {
          "xmult": 1.5,
          "retriggers": 1
        }
      },
      "ability": {
        "extra": {
          "xmult": 1.5,
          "retriggers": 1
        }
      },
      "vars": [
        1.5
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "arm",
      "name": "The Arm",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 7,
        "y": 1
      },
      "raw": "key = \"arm\",\n    loc_txt = {\n\t\tname = 'The Arm',\n\t\ttext = {\n\t\t\t\"Played poker hands either\",\n            \"lose {C:attention}#1#{} level or gain {C:attention}#2#{} levels\"\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 7, y = 1 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { level_loss = 1, level_gain = 2 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { \n            card.ability.extra.level_loss,\n            card.ability.extra.level_gain\n        } }\n    end,\n\n    calculate = function(self, card, context)\n        if context.before\n        and context.main_eval then\n            local level_choice = pseudorandom_element( { -card.ability.extra.level_loss, card.ability.extra.level_gain }, pseudoseed(\"gb_arm\") )\n            if not (G.GAME.hands[context.scoring_name].level <= 1 and level_choice < 0) then\n                return {\n                    level_up = level_choice\n                }\n            end\n        end  \n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_arm\")\n    end",
      "config": {
        "extra": {
          "level_loss": 1,
          "level_gain": 2
        }
      },
      "ability": {
        "extra": {
          "level_loss": 1,
          "level_gain": 2
        }
      },
      "vars": [
        1,
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "club",
      "name": "The Club",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"club\",\n    loc_txt = {\n\t\tname = 'The Club',\n\t\ttext = {\n            \"{C:clubs}Club{} cards give\",\n            \"{C:money}$#1#{} when scored\",\n            \"{V:1}#2#{} cards are {C:attention}debuffed\",\n            \"{C:inactive}(Changes at end of round)\",\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 2, y = 1 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { dollars = 2, debuffed_suit = \"Hearts\" } },\n    loc_vars = function(self, info_queue, card)\n        local suit = (G.GAME.current_round.gb_club_card or {}).suit or 'Spades'\n        return { vars = { \n            card.ability.extra.dollars,\n            localize(suit, 'suits_singular'),\n            colours = { G.C.SUITS[suit] }\n        } }\n    end,\n    calculate = function(self, card, context)\n        if context.ending_shop then\n            card.ability.extra.debuffed_suit = G.GAME.current_round.gb_club_card.suit\n        end\n        if context.individual\n        and context.other_card:is_suit(\"Clubs\")\n        and context.cardarea == G.play then\n            return {\n                dollars = card.ability.extra.dollars,\n                message_card = context.other_card\n            }\n        end\n        if context.debuff_card\n        and context.debuff_card.area ~= G.jokers\n        and context.debuff_card:is_suit(card.ability.extra.debuffed_suit) then\n            return {\n                debuff = true\n            }\n        end\n    end,\n\n    add_to_deck = function(self, card, from_debuff)\n        card.ability.extra.debuffed_suit = G.GAME.current_round.gb_club_card.suit\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_club\")\n    end",
      "config": {
        "extra": {
          "dollars": 2,
          "debuffed_suit": "Hearts"
        }
      },
      "ability": {
        "extra": {
          "dollars": 2,
          "debuffed_suit": "Hearts"
        }
      },
      "vars": [
        2,
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "eye",
      "name": "The Eye",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"eye\",\n    loc_txt = {\n\t\tname = 'The Eye',\n\t\ttext = {\n\t\t\t\"This Joker gains {X:mult,C:white}X#1#{} Mult for\",\n            \"every {C:attention}consecutive poker hand{}\",\n            \"that has not already been\",\n            \"played this round\",\n            \"{C:inactive}(Currently {X:mult,C:white}X#2#{C:inactive} Mult)\",\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 3, y = 0 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { xmult = 1, xmult_mod = 0.25 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.xmult_mod, card.ability.extra.xmult } }\n    end,\n    calculate = function(self, card, context)\n        if context.before\n        and context.main_eval\n        and not context.blueprint\n        and G.GAME.hands[context.scoring_name] and G.GAME.hands[context.scoring_name].played_this_round > 1 then\n            card.ability.extra.xmult = 1\n            return {\n                message = localize(\"k_reset\"),\n                colour = G.C.FILTER\n            }\n        end\n\n        if context.joker_main and context.main_eval and not G.GAME.hands[context.scoring_name].played_this_round > 1 then\n            SMODS.scale_card(card, {\n                ref_table = card.ability.extra,\n                ref_value = \"xmult\",\n                scalar_value = \"xmult_mod\",\n                message_colour = G.C.MULT\n            })\n        end\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_eye\")\n    end",
      "config": {
        "extra": {
          "xmult": 1,
          "xmult_mod": 0.25
        }
      },
      "ability": {
        "extra": {
          "xmult": 1,
          "xmult_mod": 0.25
        }
      },
      "vars": [
        0.25,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "fish",
      "name": "The Fish",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 8,
        "y": 1
      },
      "raw": "key = \"fish\",\n    loc_txt = {\n\t\tname = 'The Fish',\n\t\ttext = {\n\t\t\t\"Cards drawn after\",\n            \"a hand is played\",\n            \"{C:attention}permanently{} gain {C:chips}+#1#{} Chips\",\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 8, y = 1 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { chips = 10, prepped = nil, upgraded = nil } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { \n            card.ability.extra.chips\n        } }\n    end,\n\n    calculate = function(self, card, context)\n        if context.press_play then\n            card.ability.extra.prepped = true\n        end\n        if context.stay_flipped and context.to_area == G.hand and card.ability.extra.prepped then\n            context.other_card.ability.perma_bonus = (context.other_card.ability.perma_bonus or 0) + card.ability.extra.chips\n            card.ability.extra.upgraded = true\n        end\n        if context.setting_blind or context.hand_drawn then\n            card.ability.extra.prepped = nil\n            if card.ability.extra.upgraded then\n                card.ability.extra.upgraded = nil\n                return {\n                    message = localize(\"k_upgrade_ex\"),\n                    colour = G.C.CHIPS,\n                }\n            end\n        end\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_fish\")\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "flint",
      "name": "The Flint",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "key = \"flint\",\n    loc_txt = {\n\t\tname = 'The Flint',\n\t\ttext = {\n\t\t\t\"Doubles {C:blue}Chips{} and {C:red}Mult{}\",\n            \"before scoring\",\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 4, y = 0 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    calculate = function(self, card, context)\n        if context.modify_hand then\n            mult = mult * 2\n            hand_chips = hand_chips * 2\n            update_hand_text({ sound = 'chips2', modded = true }, { chips = hand_chips, mult = mult })\n        end\n    end,\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_flint\")\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "goad",
      "name": "The Goad",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"goad\",\n    loc_txt = {\n\t\tname = 'The Goad',\n\t\ttext = {\n            \"{C:spades}Spade{} cards give\",\n            \"{C:mult}+#1#{} Mult when scored\",\n            \"{V:1}#2#{} cards are {C:attention}debuffed\",\n            \"{C:inactive}(Changes at end of round)\",\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 0, y = 1 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { mult = 8, debuffed_suit = \"Hearts\" } },\n    loc_vars = function(self, info_queue, card)\n        local suit = (G.GAME.current_round.gb_goad_card or {}).suit or 'Hearts'\n        return { vars = { \n            card.ability.extra.mult,\n            localize(suit, 'suits_singular'),\n            colours = { G.C.SUITS[suit] }\n        } }\n    end,\n    calculate = function(self, card, context)\n        if context.ending_shop then\n            card.ability.extra.debuffed_suit = G.GAME.current_round.gb_goad_card.suit\n        end\n        if context.individual\n        and context.other_card:is_suit(\"Spades\")\n        and context.cardarea == G.play then\n            return {\n                mult = card.ability.extra.mult\n            }\n        end\n        if context.debuff_card\n        and context.debuff_card.area ~= G.jokers\n        and context.debuff_card:is_suit(card.ability.extra.debuffed_suit) then\n            return {\n                debuff = true\n            }\n        end\n    end,\n\n    add_to_deck = function(self, card, from_debuff)\n        card.ability.extra.debuffed_suit = G.GAME.current_round.gb_goad_card.suit\n    end,\n\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_goad\")\n    end",
      "config": {
        "extra": {
          "mult": 8,
          "debuffed_suit": "Hearts"
        }
      },
      "ability": {
        "extra": {
          "mult": 8,
          "debuffed_suit": "Hearts"
        }
      },
      "vars": [
        8,
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "head",
      "name": "The Head",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"head\",\n    loc_txt = {\n\t\tname = 'The Head',\n\t\ttext = {\n            \"{C:hearts}Heart{} cards {C:attention}permanently\",\n            \"gain {C:chips}+#1#{} Chips when scored\",\n            \"{V:1}#2#{} cards are {C:attention}debuffed\",\n            \"{C:inactive}(Changes at end of round)\",\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 1, y = 1 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { chips = 20, debuffed_suit = \"Spades\" } },\n    loc_vars = function(self, info_queue, card)\n        local suit = (G.GAME.current_round.gb_head_card or {}).suit or 'Spades'\n        return { vars = { \n            card.ability.extra.chips,\n            localize(suit, 'suits_singular'),\n            colours = { G.C.SUITS[suit] }\n        } }\n    end,\n    calculate = function(self, card, context)\n        if context.ending_shop then\n            card.ability.extra.debuffed_suit = G.GAME.current_round.gb_head_card.suit\n        end\n        if context.individual\n        and context.other_card:is_suit(\"Hearts\") \n        and context.cardarea == G.play then\n            context.other_card.ability.perma_bonus = (context.other_card.ability.perma_bonus or 0) + card.ability.extra.chips\n            return {\n                message = localize('k_upgrade_ex'),\n                message_card = context.other_card,\n                colour = G.C.CHIPS\n            }\n        end\n        if context.debuff_card\n        and context.debuff_card.area ~= G.jokers\n        and context.debuff_card:is_suit(card.ability.extra.debuffed_suit) then\n            return {\n                debuff = true\n            }\n        end\n    end,\n\n    add_to_deck = function(self, card, from_debuff)\n        card.ability.extra.debuffed_suit = G.GAME.current_round.gb_head_card.suit\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_head\")\n    end",
      "config": {
        "extra": {
          "chips": 20,
          "debuffed_suit": "Spades"
        }
      },
      "ability": {
        "extra": {
          "chips": 20,
          "debuffed_suit": "Spades"
        }
      },
      "vars": [
        20,
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "hook",
      "name": "The Hook",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 4,
        "y": 1
      },
      "raw": "key = \"hook\",\n    loc_txt = {\n\t\tname = 'The Hook',\n\t\ttext = {\n\t\t\t\"When a {C:blue}Hand{} is played,\",\n\t\t\t\"{C:attention}#1#{} random card {C:attention}permanently\",\n            \"gains {C:mult}+#2#{} Mult and is {C:attention}discarded\",\n\t\t}\n\t},\n    blueprint_compat = false,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 4, y = 1 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { mult = 10, cards_discarded = 1 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.cards_discarded, card.ability.extra.mult } }\n    end,\n\n    calculate = function(self, card, context)\n        if context.press_play and #G.hand.cards - #G.hand.highlighted > 0 then\n            local selected_card = nil\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    selected_card = pseudorandom_element(G.hand.cards, pseudoseed('gb_hook'))\n                    G.hand:add_to_highlighted(selected_card, true)\n                    play_sound('card1', 1)\n                    selected_card.ability.perma_mult = (selected_card.ability.perma_mult or 0) + card.ability.extra.mult\n                    SMODS.calculate_effect( {\n                        message = localize('k_upgrade_ex'),\n                        message_card = selected_card,\n                        colour = G.C.MULT\n                    }, card)\n                    G.FUNCS.discard_cards_from_highlighted(nil, true)\n                    return true\n                end\n            }))\n        end\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_hook\")\n    end",
      "config": {
        "extra": {
          "mult": 10,
          "cards_discarded": 1
        }
      },
      "ability": {
        "extra": {
          "mult": 10,
          "cards_discarded": 1
        }
      },
      "vars": [
        1,
        10
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "house",
      "name": "The House",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 5,
        "y": 1
      },
      "raw": "key = \"house\",\n    loc_txt = {\n\t\tname = 'The House',\n\t\ttext = {\n\t\t\t\"Cards in first hand\",\n            \"are drawn {C:attention}face-down{} and\",\n            \"{C:attention}permanently{} gain {C:mult}+#1#{} Mult\",\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 5, y = 1 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { mult = 5 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.mult } }\n    end,\n\n    calculate = function(self, card, context)\n        if context.stay_flipped \n        and context.to_area == G.hand \n        and G.GAME.current_round.hands_played == 0 \n        and G.GAME.current_round.discards_used == 0 then\n            context.other_card.ability.perma_mult = (context.other_card.ability.perma_mult or 0) + card.ability.extra.mult\n            return {\n                stay_flipped = true\n            }\n        end\n        if context.first_hand_drawn then\n            return {\n                message = localize(\"k_upgrade_ex\"),\n                colour = G.C.MULT\n            }\n        end\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_house\")\n    end",
      "config": {
        "extra": {
          "mult": 5
        }
      },
      "ability": {
        "extra": {
          "mult": 5
        }
      },
      "vars": [
        5
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "mark",
      "name": "The Mark",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "key = \"mark\",\n    loc_txt = {\n\t\tname = 'The Mark',\n\t\ttext = {\n\t\t\t\"All {C:attention}face{} cards are\",\n            \"drawn {C:attention}face-down{}\",\n            \"and give {X:mult,C:white}X#1#{} Mult when scored\"\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 2, y = 2 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { xmult = 1.5 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = {\n            card.ability.extra.xmult\n        } }\n    end,\n\n    calculate = function(self, card, context)\n        if context.stay_flipped and context.other_card:is_face() and context.to_area == G.hand then\n            return {\n                stay_flipped = true\n            }\n        end\n        if context.individual and context.other_card:is_face() and context.cardarea == G.play then\n            return {\n                xmult = card.ability.extra.xmult\n            }\n        end\n    end,\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_mark\")\n    end",
      "config": {
        "extra": {
          "xmult": 1.5
        }
      },
      "ability": {
        "extra": {
          "xmult": 1.5
        }
      },
      "vars": [
        1.5
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "mouth",
      "name": "The Mouth",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 9,
        "y": 0
      },
      "raw": "key = \"mouth\",\n    loc_txt = {\n\t\tname = 'The Mouth',\n\t\ttext = {\n            \"{C:attention}Retrigger{} all scoring cards\",\n            \"Must play {C:attention}most played poker hand\",\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 9, y = 0 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    calculate = function(self, card, context)\n        if context.repetition and context.cardarea == G.play then\n            return {\n                repetitions = 1\n            }\n        end\n        if context.debuff_hand then \n            local lower = false\n            local play_more_than = (G.GAME.hands[context.scoring_name].played or 0)\n            for k, v in pairs(G.GAME.hands) do\n                if k ~= context.scoring_name and v.played >= play_more_than and v.visible then\n                    lower = true\n                    break\n                end\n            end\n            if lower then\n                return {\n                    debuff = true,\n                    debuff_text = \"Must play most played poker hand\"\n                }\n            end\n        end\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_mouth\")\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "needle",
      "name": "The Needle",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"needle\",\n    loc_txt = {\n\t\tname = 'The Needle',\n\t\ttext = {\n\t\t\t\"{X:mult,C:white}X#1#{} Mult on first hand of round\",\n\t\t\t\"{C:blue}#2#{} hand per round\",\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 0, y = 0 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { xmult = 3, hands = -1 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.xmult, card.ability.extra.hands } }\n    end,\n\n    calculate = function(self, card, context)\n        if context.setting_blind and not context.blueprint then\n           ease_hands_played(card.ability.extra.hands)\n        end\n        if context.joker_main and G.GAME.current_round.hands_played == 0 then\n            return {\n                xmult = card.ability.extra.xmult\n            }\n        end\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_needle\")\n    end",
      "config": {
        "extra": {
          "xmult": 3,
          "hands": -1
        }
      },
      "ability": {
        "extra": {
          "xmult": 3,
          "hands": -1
        }
      },
      "vars": [
        3,
        -1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "ox",
      "name": "The Ox",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"ox\",\n    loc_txt = {\n\t\tname = 'The Ox',\n\t\ttext = {\n\t\t\t\"Earn {C:money}$#1#{} at end of round\",\n\t\t\t\"{C:red}Lose $#2#{} if played hand is\",\n            \"your {C:attention}most played poker hand{}\",\n\t\t}\n\t},\n    blueprint_compat = false,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 1, y = 0 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { money = 10, dollars_loss = 5 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.money, card.ability.extra.dollars_loss } }\n    end,\n\n    calc_dollar_bonus = function(self, card)\n        return card.ability.extra.money\n    end,\n\n    calculate = function(self, card, context)\n        if context.before and context.main_eval and not context.blueprint then\n            local lower = false\n            local play_more_than = (G.GAME.hands[context.scoring_name].played or 0)\n            for k, v in pairs(G.GAME.hands) do\n                if k ~= context.scoring_name and v.played >= play_more_than and v.visible then\n                    lower = true\n                    break\n                end\n            end\n            if not lower then\n                return {\n                    dollars = -dollars_loss\n                }\n            end\n        end\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_ox\")\n    end",
      "config": {
        "extra": {
          "money": 10,
          "dollars_loss": 5
        }
      },
      "ability": {
        "extra": {
          "money": 10,
          "dollars_loss": 5
        }
      },
      "vars": [
        10,
        5
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "pillar",
      "name": "The Pillar",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 6,
        "y": 0
      },
      "raw": "key = \"pillar\",\n    loc_txt = {\n\t\tname = 'The Pillar',\n\t\ttext = {\n            \"Played cards previously\",\n            \"played this {C:attention}Ante permanently{}\",\n            \"gain {C:chips}+#1#{} Chips when scored\"\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 6, y = 0 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { chips = 20 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.chips } }\n    end,\n    calculate = function(self, card, context)\n        if context.individual\n        and context.main_eval\n        and context.cardarea == G.play\n        and context.other_card.played_this_ante == true then\n            context.other_card.ability.perma_bonus = (context.other_card.ability.perma_bonus or 0) + card.ability.extra.chips\n            return {\n                message = localize('k_upgrade_ex'),\n                message_card = context.other_card,\n                colour = G.C.CHIPS\n            }\n        end\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_pillar\")\n    end",
      "config": {
        "extra": {
          "chips": 20
        }
      },
      "ability": {
        "extra": {
          "chips": 20
        }
      },
      "vars": [
        20
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "plant",
      "name": "The Plant",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 9,
        "y": 1
      },
      "raw": "key = \"plant\",\n    loc_txt = {\n\t\tname = 'The Plant',\n\t\ttext = {\n\t\t\t\"All {C:attention}face{} cards are {C:attention}debuffed\",\n            \"{X:mult,C:white}X#2#{} Mult for every\",\n            \"{C:attention}face{} card in {C:attention}full deck\",\n            \"{C:inactive}(Currently {X:mult,C:white}X#1#{C:inactive} Mult)\"\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 9, y = 1 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { xmult_mod = 0.25 } },\n    loc_vars = function(self, info_queue, card)\n        local face_tally = 0\n        for _, playing_card in pairs(G.playing_cards or {}) do\n            if playing_card:is_face(true) then\n                face_tally = face_tally + 1\n            end\n        end\n        return { vars = { \n            1 + card.ability.extra.xmult_mod * face_tally,\n            card.ability.extra.xmult_mod\n        } }\n    end,\n\n    calculate = function(self, card, context)\n        if context.debuff_card and context.debuff_card:is_face() then\n            return {\n                debuff_card = true\n            }\n        end\n        if context.joker_main then\n            local face_tally = 0\n            for _, playing_card in pairs(G.playing_cards or {}) do\n                if playing_card:is_face(true) then\n                    face_tally = face_tally + 1\n                end\n            end\n            return {\n                xmult = 1 + card.ability.extra.xmult_mod * face_tally\n            }\n        end\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_plant\")\n    end",
      "config": {
        "extra": {
          "xmult_mod": 0.25
        }
      },
      "ability": {
        "extra": {
          "xmult_mod": 0.25
        }
      },
      "vars": [
        null,
        0.25
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "psychic",
      "name": "The Psychic",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = \"psychic\",\n    loc_txt = {\n\t\tname = 'The Psychic',\n\t\ttext = {\n\t\t\t\"The {C:attention}fifth{} scoring card has a\",\n            \"{C:green}#1# in #2# chance{} to convert into\",\n            \"the {C:attention}first{} scoring card\"\n\t\t}\n\t},\n    blueprint_compat = false,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 0, y = 2 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { odds = 2 } },\n    loc_vars = function(self, info_queue, card)\n        local new_numerator, new_denominator = SMODS.get_probability_vars(card, 1, card.ability.extra.odds)\n        return { vars = { new_numerator, new_denominator } }\n    end,\n\n    calculate = function(self, card, context)\n        if context.before\n        and context.scoring_hand[5]\n        and not context.blueprint\n        and SMODS.pseudorandom_probability(card, 'gb_psychic', 1, card.ability.extra.odds) then\n            copy_card(context.scoring_hand[1], context.scoring_hand[5])\n            context.scoring_hand[5]:juice_up()\n            return {\n                message = \"Converted!\",\n                colour = G.C.FILTER\n            }\n        end\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_psychic\")\n    end",
      "config": {
        "extra": {
          "odds": 2
        }
      },
      "ability": {
        "extra": {
          "odds": 2
        }
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "serpent",
      "name": "The Serpent",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 5,
        "y": 0
      },
      "raw": "key = \"serpent\",\n    loc_txt = {\n\t\tname = 'The Serpent',\n\t\ttext = {\n            \"{C:attention}+#1#{} hand size\",\n            \"Always draw {C:attention}#2#{} cards\",\n            \"after {C:blue}Play{} or {C:red}Discard{}\"\n\t\t}\n\t},\n    blueprint_compat = false,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 5, y = 0 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { hand_size = 2, cards_to_draw = 3 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.hand_size, card.ability.extra.cards_to_draw } }\n    end,\n    calculate = function(self, card, context)\n        if context.drawing_cards \n        and (G.GAME.current_round.hands_played ~= 0\n        or G.GAME.current_round.discards_used ~= 0)\n        and not context.blueprint then\n            return {\n                cards_to_draw = card.ability.extra.cards_to_draw\n            }\n        end\n    end,\n\n    add_to_deck = function(self, card, from_debuff)\n        G.hand:change_size(card.ability.extra.hand_size)\n    end,\n\n    remove_from_deck = function(self, card, from_debuff)\n        G.hand:change_size(-card.ability.extra.hand_size)\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_serpent\")\n    end",
      "config": {
        "extra": {
          "hand_size": 2,
          "cards_to_draw": 3
        }
      },
      "ability": {
        "extra": {
          "hand_size": 2,
          "cards_to_draw": 3
        }
      },
      "vars": [
        2,
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "tooth",
      "name": "The Tooth",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "key = \"tooth\",\n    loc_txt = {\n\t\tname = 'The Tooth',\n\t\ttext = {\n\t\t\t\"Earn {C:money}$#1#{} for every card played\",\n            \"Lose {C:red}$#2#{} at end of round\"\n\t\t}\n\t},\n    blueprint_compat = false,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 1, y = 2 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { money = 6, dollars = 1 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = {\n            card.ability.extra.dollars,\n            card.ability.extra.money\n        } }\n    end,\n\n    calc_dollar_bonus = function(self, card)\n        return -card.ability.extra.money\n    end,\n\n    calculate = function(self, card, context)\n        if context.press_play and not context.blueprint then\n            G.E_MANAGER:add_event(Event({\n                trigger = 'after',\n                delay = 0.2,\n                func = function()\n                    for i = 1, #G.play.cards do\n                        G.E_MANAGER:add_event(Event({\n                            func = function()\n                                G.play.cards[i]:juice_up()\n                                return true\n                            end,\n                        }))\n                        ease_dollars(card.ability.extra.dollars)\n                        delay(0.23)\n                    end\n                    return true\n                end\n            }))\n            delay(0.4)\n        end\n    end,\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_tooth\")\n    end",
      "config": {
        "extra": {
          "money": 6,
          "dollars": 1
        }
      },
      "ability": {
        "extra": {
          "money": 6,
          "dollars": 1
        }
      },
      "vars": [
        1,
        6
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "wall",
      "name": "The Wall",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"wall\",\n    loc_txt = {\n\t\tname = 'The Wall',\n\t\ttext = {\n\t\t\t\"{C:red}X#1#{C:attention} Boss Blind{} size\",\n            \"{C:attention}+#2#{} hand size\",\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 2, y = 0 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { boss_blind_size = 2, hand_size = 2 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.boss_blind_size, card.ability.extra.hand_size } }\n    end,\n\n    calculate = function(self, card, context)\n        if context.setting_blind and G.GAME.blind.boss then\n            G.GAME.blind.chips = G.GAME.blind.chips * card.ability.extra.boss_blind_size\n            G.GAME.blind.chip_text = number_format(G.GAME.blind.chips)\n            play_sound(\"cancel\")\n            card:juice_up()\n        end\n    end,\n\n    add_to_deck = function(self, card, from_debuff)\n        G.hand:change_size(card.ability.extra.hand_size)\n    end,\n\n    remove_from_deck = function(self, card, from_debuff)\n        G.hand:change_size(-card.ability.extra.hand_size)\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_wall\")\n    end",
      "config": {
        "extra": {
          "boss_blind_size": 2,
          "hand_size": 2
        }
      },
      "ability": {
        "extra": {
          "boss_blind_size": 2,
          "hand_size": 2
        }
      },
      "vars": [
        2,
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "water",
      "name": "The Water",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 8,
        "y": 0
      },
      "raw": "key = \"water\",\n    loc_txt = {\n\t\tname = 'The Water',\n\t\ttext = {\n            \"When {C:attention}Blind{} is selected,\",\n            \"lose all {C:red}discards{}\",\n            \"{C:attention}+#1#{} hand size for\",\n            \"every {C:attention}#4# {C:red}discards{} lost\",\n            \"{C:inactive}(Currently {C:attention}+#3#{C:inactive} hand size)\",\n            \"{C:inactive}({C:attention}#2#{C:inactive}/#4#)\"\n\t\t}\n\t},\n    blueprint_compat = false,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 8, y = 0 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { hand_size_mod = 1, hand_size_tally = 0, discard_tally = 0, discards = 7 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = {\n            card.ability.extra.hand_size_mod,\n            card.ability.extra.discard_tally,\n            card.ability.extra.hand_size_tally,\n            card.ability.extra.discards\n        } }\n    end,\n    calculate = function(self, card, context)\n        if context.setting_blind and not context.blueprint then\n            card.ability.extra.discard_tally = card.ability.extra.discard_tally + G.GAME.current_round.discards_left\n            ease_discard(-G.GAME.current_round.discards_left, nil, true)\n            if card.ability.extra.discard_tally >= card.ability.extra.discards then\n                card.ability.extra.discard_tally = card.ability.extra.discard_tally - card.ability.extra.discards\n                G.hand:change_size(card.ability.extra.hand_size_mod)\n                card.ability.extra.hand_size_tally = card.ability.extra.hand_size_tally + card.ability.extra.hand_size_mod\n                return {\n                    message = \"+\" .. card.ability.extra.hand_size_mod,\n                    colour = G.C.FILTER\n                }\n            else\n                return {\n                    message = card.ability.extra.discard_tally .. \"/\" .. card.ability.extra.discards,\n                    colour = G.C.FILTER\n                }\n            end\n        end\n    end,\n\n    remove_from_deck = function(self, card, from_debuff)\n        G.hand:change_size(-card.ability.extra.hand_size_tally)\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_water\")\n    end",
      "config": {
        "extra": {
          "hand_size_mod": 1,
          "hand_size_tally": 0,
          "discard_tally": 0,
          "discards": 7
        }
      },
      "ability": {
        "extra": {
          "hand_size_mod": 1,
          "hand_size_tally": 0,
          "discard_tally": 0,
          "discards": 7
        }
      },
      "vars": [
        1,
        0,
        0,
        7
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "wheel",
      "name": "The Wheel",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 6,
        "y": 1
      },
      "raw": "key = \"wheel\",\n    loc_txt = {\n\t\tname = 'The Wheel',\n\t\ttext = {\n\t\t\t\"{C:green}#3# in #4# chance{} to\",\n            \"draw a card {C:attention}face-down{} and\",\n            \"give this Joker {X:mult,C:white}X#2#{} Mult\",\n            \"{C:inactive}(Currently {X:mult,C:white}X#1#{C:inactive} Mult)\",\n\n\t\t}\n\t},\n    blueprint_compat = false,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 6, y = 1 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { odds = 7, xmult = 1, xmult_mod = 0.1, flipped_cards = false } },\n    loc_vars = function(self, info_queue, card)\n        local new_numerator, new_denominator = SMODS.get_probability_vars(card, 1, card.ability.extra.odds)\n        return { vars = { \n            card.ability.extra.xmult,\n            card.ability.extra.xmult_mod,\n            new_numerator,\n            new_denominator\n        } }\n    end,\n\n    calculate = function(self, card, context)\n        if context.stay_flipped \n        and context.to_area == G.hand \n        and not context.blueprint\n        and SMODS.pseudorandom_probability(card, 'gb_wheel', 1, card.ability.extra.odds) then\n            card.ability.extra.xmult = card.ability.extra.xmult + card.ability.extra.xmult_mod\n            card.ability.extra.flipped_cards = true\n            return {\n                stay_flipped = true\n            }\n        end\n        if context.hand_drawn and card.ability.extra.flipped_cards == true then\n            card.ability.extra.flipped_cards = false\n            return {\n                message = localize(\"k_upgrade_ex\"),\n                colour = G.C.MULT\n            }\n        end\n        if context.joker_main then\n            return {\n                xmult = card.ability.extra.xmult\n            }\n        end\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_wheel\")\n    end",
      "config": {
        "extra": {
          "odds": 7,
          "xmult": 1,
          "xmult_mod": 0.1,
          "flipped_cards": false
        }
      },
      "ability": {
        "extra": {
          "odds": 7,
          "xmult": 1,
          "xmult_mod": 0.1,
          "flipped_cards": false
        }
      },
      "vars": [
        1,
        0.1,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "window",
      "name": "The Window",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"window\",\n    loc_txt = {\n\t\tname = 'The Window',\n\t\ttext = {\n            \"{C:diamonds}Diamond{} cards retrigger {C:attention}#1#{} time\",\n            \"{V:1}#2#{} cards are {C:attention}debuffed\",\n            \"{C:inactive}(Changes at end of round)\",\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 3, y = 1 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { retriggers = 1, debuffed_suit = \"Hearts\" } },\n    loc_vars = function(self, info_queue, card)\n        local suit = (G.GAME.current_round.gb_window_card or {}).suit or 'Spades'\n        return { vars = { \n            card.ability.extra.retriggers,\n            localize(suit, 'suits_singular'),\n            colours = { G.C.SUITS[suit] }\n        } }\n    end,\n    calculate = function(self, card, context)\n        if context.ending_shop then\n            card.ability.extra.debuffed_suit = G.GAME.current_round.gb_window_card.suit\n        end\n        if context.repetition\n        and context.other_card:is_suit(\"Diamonds\")\n        and context.cardarea == G.play then\n            return {\n                repetitions = card.ability.extra.retriggers,\n            }\n        end\n        if context.debuff_card\n        and context.debuff_card.area ~= G.jokers\n        and context.debuff_card:is_suit(card.ability.extra.debuffed_suit) then\n            return {\n                debuff = true\n            }\n        end\n    end,\n\n    add_to_deck = function(self, card, from_debuff)\n        card.ability.extra.debuffed_suit = G.GAME.current_round.gb_window_card.suit\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_window\")\n    end",
      "config": {
        "extra": {
          "retriggers": 1,
          "debuffed_suit": "Hearts"
        }
      },
      "ability": {
        "extra": {
          "retriggers": 1,
          "debuffed_suit": "Hearts"
        }
      },
      "vars": [
        1,
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "body",
      "name": "The Body",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 8,
        "y": 2
      },
      "raw": "key = \"body\",\n    loc_txt = {\n\t\tname = 'The Body',\n\t\ttext = {\n\t\t\t\"{X:mult,C:white}X#1#{} Mult for every {C:attention}Enhanced{} card\",\n            \"in full deck below {C:attention}#3#{}\",\n            \"{C:inactive}(Currently {X:mult,C:white}X#2#{C:inactive} Mult)\",\n\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 8, y = 2 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { xmult_mod = 0.5, threshold = 12 } },\n    loc_vars = function(self, info_queue, card)\n        local enhanced_tally = 0\n        if G.playing_cards then\n            for _, playing_card in pairs(G.playing_cards or {}) do\n                if next(SMODS.get_enhancements(playing_card)) then\n                    enhanced_tally = enhanced_tally + 1\n                end\n            end\n        end\n\t\treturn { vars = { \n            card.ability.extra.xmult_mod,\n            1 + (math.max(0, card.ability.extra.threshold - enhanced_tally) * card.ability.extra.xmult_mod),\n            card.ability.extra.threshold\n        } }\n\tend,\n    calculate = function(self, card, context)\n        if context.joker_main then\n            local enhanced_tally = 0\n            for _, playing_card in pairs(G.playing_cards or {}) do\n                if next(SMODS.get_enhancements(playing_card)) then\n                    enhanced_tally = enhanced_tally + 1\n                end\n            end\n            if enhanced_tally < card.ability.extra.threshold then\n                return {\n                    xmult = 1 + (math.max(0, card.ability.extra.threshold - enhanced_tally) * card.ability.extra.xmult_mod)\n                }\n            end    \n        end\n    end,\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_gb_body\")\n    end",
      "config": {
        "extra": {
          "xmult_mod": 0.5,
          "threshold": 12
        }
      },
      "ability": {
        "extra": {
          "xmult_mod": 0.5,
          "threshold": 12
        }
      },
      "vars": [
        0.5,
        null,
        null,
        12
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "cross",
      "name": "The Cross",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 2,
        "y": 3
      },
      "raw": "key = \"cross\",\n    loc_txt = {\n\t\tname = 'The Cross',\n\t\ttext = {\n            \"Sets all {C:green}listed probabilities{} to {C:attention}0{}\",\n            \"Jokers with {C:green}listed probabilities{}\",\n            \"give {X:mult,C:white}X#1#{} Mult when scored\",\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 2, y = 3 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { xmult = 1.75 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = {\n            card.ability.extra.xmult\n        } }\n    end,\n    calculate = function(self, card, context)\n        if context.other_joker then\n            if context.other_joker.ability.extra and type(context.other_joker.ability.extra) == \"table\" then\n                if context.other_joker.ability.extra.odds then\n                    return {\n                        xmult = card.ability.extra.xmult,\n                        message_card = context.other_joker\n                    }\n                end\n            elseif type(context.other_joker.ability.extra) == \"number\" then\n                return {\n                    xmult = card.ability.extra.xmult,\n                    message_card = context.other_joker\n                }\n            end\n        end\n        if context.fix_probability then\n            return {\n                numerator = 0\n            }\n        end\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_gb_cross\")\n    end",
      "config": {
        "extra": {
          "xmult": 1.75
        }
      },
      "ability": {
        "extra": {
          "xmult": 1.75
        }
      },
      "vars": [
        1.75
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "dread",
      "name": "The Dread",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 5,
        "y": 3
      },
      "raw": "key = \"dread\",\n    loc_txt = {\n\t\tname = 'The Dread',\n\t\ttext = {\n            \"{X:mult,C:white}X#1#{} Mult if scoring hand\",\n            \"contains {C:attention}exactly #2#{} suits\",\n\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 5, y = 3 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.xmult, card.ability.extra.suits } }\n    end,\n    config = { extra = { xmult = 3, suits = 2 } },\n\n    calculate = function(self, card, context)\n        if context.joker_main and gb_count_suits(context.scoring_hand or {}) == card.ability.extra.suits then\n            return {\n                xmult = card.ability.extra.xmult\n            }\n        end\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_gb_dread\")\n    end",
      "config": {
        "extra": {
          "xmult": 3,
          "suits": 2
        }
      },
      "ability": {
        "extra": {
          "xmult": 3,
          "suits": 2
        }
      },
      "vars": [
        3,
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "flag",
      "name": "The Flag",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 0,
        "y": 3
      },
      "raw": "key = \"flag\",\n    loc_txt = {\n\t\tname = 'The Flag',\n\t\ttext = {\n            \"Cards held in hand at end of round\",\n            \"{C:attention}permanently{} gain {X:mult,C:white}X#1#{} Mult\"\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 0, y = 3 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { xmult = 0.25 } },\n    loc_vars = function(self, info_queue, card)\n\t\treturn { vars = { \n            card.ability.extra.xmult\n        } }\n\tend,\n    calculate = function(self, card, context)\n        if context.end_of_round and context.main_eval then\n            for _, playing_card in pairs(G.hand.cards) do\n                if not playing_card.debuff then\n                    playing_card.ability.perma_x_mult = (playing_card.ability.perma_x_mult or 0) + card.ability.extra.xmult\n                    SMODS.calculate_effect( {\n                        message = localize('k_upgrade_ex'),\n                        message_card = playing_card,\n                        colour = G.C.MULT\n                    }, card)\n                end\n            end\n        end\n    end,\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_gb_flag\")\n    end",
      "config": {
        "extra": {
          "xmult": 0.25
        }
      },
      "ability": {
        "extra": {
          "xmult": 0.25
        }
      },
      "vars": [
        0.25
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "hand",
      "name": "The Hand",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 7,
        "y": 2
      },
      "raw": "key = \"hand\",\n    loc_txt = {\n\t\tname = 'The Hand',\n\t\ttext = {\n\t\t\t\"{C:attention}Debuffs leftmost{} card\",\n            \"in scoring hand, {C:attention}rightmost{} card\",\n            \"gives {X:mult,C:white}X#1#{} Mult when scored\"\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 7, y = 2 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { xmult = 2.5 } },\n    loc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.xmult } }\n\tend,\n    calculate = function(self, card, context)\n        if context.before and context.scoring_hand[1] and not context.blueprint then\n            SMODS.debuff_card(context.scoring_hand[1], true, \"gb_final_pentacle\")\n        end\n        local index = nil\n        if context.individual and context.cardarea == G.play then\n            for k, search_card in ipairs(context.scoring_hand) do\n                if context.other_card == search_card then\n                    index = k\n                    break\n                end\n            end\n            if index and index == #context.scoring_hand then\n                return {\n                    xmult = card.ability.extra.xmult\n                }\n            end\n        end\n    end,\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_gb_hand\")\n    end",
      "config": {
        "extra": {
          "xmult": 2.5
        }
      },
      "ability": {
        "extra": {
          "xmult": 2.5
        }
      },
      "vars": [
        2.5
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "lance",
      "name": "The Lance",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 7,
        "y": 3
      },
      "raw": "key = \"lance\",\n    loc_txt = {\n\t\tname = 'The Lance',\n\t\ttext = {\n            \"Cards discarded this {C:attention}Ante{}\",\n            \"are drawn {C:attention}face-down{} and\",\n            \"give {X:mult,C:white}X#1#{} Mult when scored\"\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 7, y = 3 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.xmult } }\n    end,\n    config = { extra = { xmult = 1.75 } },\n\n    calculate = function(self, card, context)\n        if context.stay_flipped and context.to_area == G.hand and\n            context.other_card.ability.discarded_this_ante then\n            return {\n                stay_flipped = true\n            }\n        end\n        if context.individual\n        and context.cardarea == G.play\n        and context.other_card.ability.discarded_this_ante then \n            return {\n                xmult = card.ability.extra.xmult\n            }\n        end\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_gb_lance\")\n    end",
      "config": {
        "extra": {
          "xmult": 1.75
        }
      },
      "ability": {
        "extra": {
          "xmult": 1.75
        }
      },
      "vars": [
        1.75
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "matchstick",
      "name": "The Matchstick",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 6,
        "y": 3
      },
      "raw": "key = \"matchstick\",\n    loc_txt = {\n\t\tname = 'The Matchstick',\n\t\ttext = {\n            \"When a {C:attention}Blind{} is selected,\",\n            \"{C:attention}double{} either {C:blue}Hands{} or {C:red}Discards\",\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 6, y = 3 },\n    rarity = \"gb_boss\",\n    cost = 6,\n\n    calculate = function(self, card, context)\n        if context.setting_blind then\n            if pseudorandom(\"gb_matchstick\") > 0.5 then\n                ease_hands_played(G.GAME.current_round.hands_left)\n            else\n                ease_discard(G.GAME.current_round.discards_left)\n            end\n        end\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_gb_matchstick\")\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "mind",
      "name": "The Mind",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 4,
        "y": 2
      },
      "raw": "key = \"mind\",\n    loc_txt = {\n\t\tname = 'The Mind',\n\t\ttext = {\n\t\t\t\"When hand is played, {C:attention}flips{} all {C:attention}face-up{}\",\n            \"{C:hearts}Hearts{} and {C:diamonds}Diamonds{} held in hand\",\n            \"Cards flipped by this Joker\",\n            \"{C:attention}permanently{} gain {C:mult}+#1#{} Mult\",\n\t\t}\n\t},\n    blueprint_compat = false,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 4, y = 2 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { mult = 6 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.mult } }\n    end,\n\n    calculate = function(self, card, context)\n        if context.before then\n            for _, playing_card in ipairs(G.hand.cards) do\n                if (playing_card:is_suit(\"Hearts\")\n                or playing_card:is_suit(\"Diamonds\"))\n                and not context.blueprint\n                and playing_card.facing == \"front\" then\n                    playing_card.ability.perma_mult = (playing_card.ability.perma_mult or 0) + card.ability.extra.mult\n                    playing_card:flip()\n                    SMODS.calculate_effect( {\n                        message = localize('k_upgrade_ex'),\n                        message_card = playing_card,\n                        colour = G.C.MULT\n                    }, card)\n                end\n            end\n        end\n    end,\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_gb_mind\")\n    end",
      "config": {
        "extra": {
          "mult": 6
        }
      },
      "ability": {
        "extra": {
          "mult": 6
        }
      },
      "vars": [
        6
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "mystic",
      "name": "The Mystic",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 9,
        "y": 2
      },
      "raw": "key = \"mystic\",\n    loc_txt = {\n\t\tname = 'The Mystic',\n\t\ttext = {\n            \"This Joker gains {X:mult,C:white}X#1#{} Mult\",\n            \"for every {C:attention}consecutive{} hand\",\n            \"with a scoring {C:attention}face{} card\",\n            \"{C:inactive}(Currently {X:mult,C:white}X#2#{C:inactive} Mult)\",\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 9, y = 2 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { xmult_mod = 0.2, xmult = 1 } },\n    loc_vars = function(self, info_queue, card)\n\t\treturn { vars = { \n            card.ability.extra.xmult_mod,\n            card.ability.extra.xmult,\n        } }\n\tend,\n    calculate = function(self, card, context)\n        if context.before and context.main_eval and not context.blueprint then\n            local has_face = false\n            for _, playing_card in pairs(context.scoring_hand) do\n                if playing_card:is_face() then\n                    has_face = true\n                    break\n                end\n            end\n            if has_face == true then\n                SMODS.scale_card(card, {\n                    ref_table = card.ability.extra,\n                    ref_value = \"xmult\",\n                    scalar_value = \"xmult_mod\",\n                    message_colour = G.C.MULT\n                })\n            else\n                card.ability.extra.xmult = 1\n                return {\n                    message = localize(\"k_reset\"),\n                    colour = G.C.RED\n                }\n            end\n        end\n        if context.joker_main then\n            return {\n                xmult = card.ability.extra.xmult\n            }\n        end\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_gb_mystic\")\n    end",
      "config": {
        "extra": {
          "xmult_mod": 0.2,
          "xmult": 1
        }
      },
      "ability": {
        "extra": {
          "xmult_mod": 0.2,
          "xmult": 1
        }
      },
      "vars": [
        0.2,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "piper",
      "name": "The Piper",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 5,
        "y": 2
      },
      "raw": "key = \"piper\",\n    loc_txt = {\n\t\tname = 'The Piper',\n\t\ttext = {\n\t\t\t\"After hand scores, {C:green}#1# in #2# chance{} to\",\n            \"{C:attention}destroy{} the {C:attention}leftmost{} card and\",\n            \"give a {C:attention}third{} of its base {C:chips}Chips{} as {C:money}Money{}\"\n\t\t}\n\t},\n    blueprint_compat = false,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 5, y = 2 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { odds = 2 } },\n    loc_vars = function(self, info_queue, card)\n\t\tlocal new_numerator, new_denominator = SMODS.get_probability_vars(card, 1, card.ability.extra.odds)\n        return { vars = { new_numerator, new_denominator } }\n\tend,\n    calculate = function(self, card, context)\n        if context.before\n        and context.scoring_hand[1]\n        and not context.blueprint\n        and SMODS.pseudorandom_probability(card, 'gb_piper', 1, card.ability.extra.odds) then\n            context.scoring_hand[1].ability.piper_destroy = true\n        end\n        if context.destroy_card and \n        context.destroy_card.ability.piper_destroy == true \n        and not context.blueprint then\n            if not SMODS.has_no_rank(context.destroy_card)\n            and context.destroy_card.base.nominal\n            and context.destroy_card.base.nominal > 0 then\n                context.destroy_card.getting_sliced = true\n                return {\n                    remove = true,\n                    dollars = math.floor(context.destroy_card.base.nominal / 3)\n                }\n            end\n            return {\n                remove = true\n            }\n        end\n    end,\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_gb_piper\")\n    end",
      "config": {
        "extra": {
          "odds": 2
        }
      },
      "ability": {
        "extra": {
          "odds": 2
        }
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "shame",
      "name": "The Shame",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 1,
        "y": 3
      },
      "raw": "key = \"shame\",\n    loc_txt = {\n\t\tname = 'The Shame',\n\t\ttext = {\n            \"{C:green}#3# in #2# chance{} for {C:attention}-1 Ante{}\",\n            \"upon defeating {C:attention}Boss Blind{}\",\n            \"{C:green}Probability{} increases by {C:green}#1#{} for\",\n            \"every {C:attention}Blind{} skipped this {C:attention}Ante\",\n            \"{C:inactive,s:0.85}(Only works once per {C:attention,s:0.85}Ante{C:inactive,s:0.85})\"\n\t\t}\n\t},\n    blueprint_compat = false,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 1, y = 3 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        local new_numerator, new_denominator = SMODS.get_probability_vars(card, 1, self.config.extra.odds)\n        return { vars = { new_numerator, new_denominator, (G.GAME.GB_BLINDS_SKIPPED_THIS_ANTE or 0) * new_numerator } }\n    end,\n    config = { extra = { antes_rewinded = {}, odds = 3 } },\n\n    calculate = function(self, card, context)\n        if context.end_of_round\n        and context.main_eval\n        and G.GAME.GB_BLINDS_SKIPPED_THIS_ANTE\n        and context.beat_boss\n        and not context.blueprint\n        and context.game_over == false\n        and not card.ability.extra.antes_rewinded[G.GAME.round_resets.ante] then\n            if SMODS.pseudorandom_probability(card, 'gb_shame', G.GAME.GB_BLINDS_SKIPPED_THIS_ANTE, card.ability.extra.odds) then\n                card.ability.extra.antes_rewinded[G.GAME.round_resets.ante] = true\n                ease_ante(-1)\n                G.GAME.round_resets.blind_ante = G.GAME.round_resets.blind_ante or G.GAME.round_resets.ante\n                G.GAME.round_resets.blind_ante = G.GAME.round_resets.blind_ante - 1\n            end\n        end\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_gb_shame\")\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "spirit",
      "name": "The Spirit",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 3,
        "y": 2
      },
      "raw": "key = \"spirit\",\n    loc_txt = {\n\t\tname = 'The Spirit',\n\t\ttext = {\n\t\t\t\"When hand is played, {C:attention}flips{} all {C:attention}face-up{}\",\n            \"{C:spades}Spades{} and {C:clubs}Clubs{} held in hand\",\n            \"Cards flipped by this Joker\",\n            \"{C:attention}permanently{} gain {C:chips}+#1#{} Chips\",\n\t\t}\n\t},\n    blueprint_compat = false,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 3, y = 2 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { chips = 20 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.chips } }\n    end,\n\n    calculate = function(self, card, context)\n        if context.before then\n            for _, playing_card in ipairs(G.hand.cards) do\n                if (playing_card:is_suit(\"Spades\")\n                or playing_card:is_suit(\"Clubs\"))\n                and not context.blueprint\n                and playing_card.facing == \"front\" then\n                    playing_card.ability.perma_bonus = (playing_card.ability.perma_bonus or 0) + card.ability.extra.chips\n                    playing_card:flip()\n                    SMODS.calculate_effect( {\n                        message = localize('k_upgrade_ex'),\n                        message_card = playing_card,\n                        colour = G.C.CHIPS\n                    }, card)\n                end\n            end\n        end\n    end,\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_gb_spirit\")\n    end",
      "config": {
        "extra": {
          "chips": 20
        }
      },
      "ability": {
        "extra": {
          "chips": 20
        }
      },
      "vars": [
        20
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "storm",
      "name": "The Storm",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 4,
        "y": 3
      },
      "raw": "key = \"storm\",\n    loc_txt = {\n\t\tname = 'The Storm',\n\t\ttext = {\n            \"{C:attention}-1 Ante{} for every {C:attention}#2#{} blinds\",\n            \"beaten with {C:attention}no hands remaining{}\",\n            \"{C:inactive}({C:attention}#1#{C:inactive}/#2#)\"\n\n\t\t}\n\t},\n    blueprint_compat = false,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 4, y = 3 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.blind_tally, card.ability.extra.blinds } }\n    end,\n    config = { extra = { blind_tally = 0, blinds = 4 } },\n\n    calculate = function(self, card, context)\n        if context.end_of_round\n        and context.main_eval\n        and G.GAME.current_round.hands_left == 0\n        and not context.blueprint\n        and context.game_over == false then\n            card.ability.extra.blind_tally = card.ability.extra.blind_tally + 1\n            if card.ability.extra.blind_tally >= card.ability.extra.blinds then\n                card.ability.extra.blind_tally = card.ability.extra.blind_tally - card.ability.extra.blinds\n                ease_ante(-1)\n                G.GAME.round_resets.blind_ante = G.GAME.round_resets.blind_ante or G.GAME.round_resets.ante\n                G.GAME.round_resets.blind_ante = G.GAME.round_resets.blind_ante - 1\n            else\n                return {\n                    message = card.ability.extra.blind_tally .. \"/\" .. card.ability.extra.blinds,\n                    colour = G.C.FILTER\n                }\n            end\n        end\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_gb_storm\")\n    end",
      "config": {
        "extra": {
          "blind_tally": 0,
          "blinds": 4
        }
      },
      "ability": {
        "extra": {
          "blind_tally": 0,
          "blinds": 4
        }
      },
      "vars": [
        0,
        4
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "trident",
      "name": "The Trident",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 3,
        "y": 3
      },
      "raw": "key = \"trident\",\n    loc_txt = {\n\t\tname = 'The Trident',\n\t\ttext = {\n            \"If all played cards score,\",\n            \"this Joker gains {C:mult}+#1#{} Mult\",\n            \"for every card played\",\n            \"{C:inactive}(Currently {C:mult}+#2#{C:inactive} Mult)\"\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 3, y = 3 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { mult = 0, mult_mod = 1 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = {\n            card.ability.extra.mult_mod,\n            card.ability.extra.mult\n        } }\n    end,\n    calculate = function(self, card, context)\n        if context.before\n        and context.main_eval\n        and #context.scoring_hand == #context.full_hand\n        and not context.blueprint then\n            card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.mult_mod * #context.scoring_hand\n            return {\n                message = localize(\"k_upgrade_ex\"),\n                colour = G.C.MULT\n            }\n        end\n        if context.joker_main then\n            return {\n                mult = card.ability.extra.mult\n            }\n        end\n    end,\n\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_gb_trident\")\n    end",
      "config": {
        "extra": {
          "mult": 0,
          "mult_mod": 1
        }
      },
      "ability": {
        "extra": {
          "mult": 0,
          "mult_mod": 1
        }
      },
      "vars": [
        1,
        0
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "weave",
      "name": "The Weave",
      "atlas": "gb_BossJokers",
      "pos": {
        "x": 6,
        "y": 2
      },
      "raw": "key = \"weave\",\n    loc_txt = {\n\t\tname = 'The Weave',\n\t\ttext = {\n\t\t\t\"Cards give {C:money}$#1#{} when scored\",\n            \"if played hand contains\",\n            \"{C:attention}#2# or fewer{} cards\",\n\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_BossJokers',\n\tpos = { x = 6, y = 2 },\n    rarity = \"gb_boss\",\n    cost = 6,\n    config = { extra = { dollars = 2, cards_played = 3 } },\n    loc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.dollars, card.ability.extra.cards_played } }\n\tend,\n    calculate = function(self, card, context)\n        if context.individual\n        and #context.full_hand <= card.ability.extra.cards_played\n        and context.cardarea == G.play then\n            return {\n                dollars = card.ability.extra.dollars\n            }\n        end\n    end,\n    in_pool = function(self, args)\n        return gb_is_blind_defeated(\"bl_gb_weave\")\n    end",
      "config": {
        "extra": {
          "dollars": 2,
          "cards_played": 3
        }
      },
      "ability": {
        "extra": {
          "dollars": 2,
          "cards_played": 3
        }
      },
      "vars": [
        2,
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "the_clever",
      "name": "The Clever",
      "atlas": "gb_ShatteredJokers",
      "pos": {
        "x": 4,
        "y": 3
      },
      "raw": "key = 'the_clever',\n\tloc_txt = {\n\t\tname = 'The Clever',\n\t\ttext = {\n\t\t\t\"If played hand contains a {C:attention}#1#{},\",\n            \"{C:attention}1{} random scoring card\",\n            \"{C:attention}permanently{} gains {C:chips}+#2#{} Chips\",\n\t\t}\n\t},\n\tconfig = { extra = { hand_type = \"Two Pair\", chips = 80, chosen_index = -1 } },\n\tblueprint_compat = true,\n\tatlas = 'gb_ShatteredJokers',\n\tpos = { x = 4, y = 3 },\n    soul_pos = { x = 7, y = 3 },\n    rarity = \"gb_shattered\",\n    cost = 10,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.hand_type, card.ability.extra.chips } }\n\tend,\n    calculate = function(self, card, context)\n        if context.hand_drawn then\n            card.ability.extra.chosen_index = -1\n        end\n        if context.before then\n            if next(context.poker_hands[card.ability.extra.hand_type]) then\n                card.ability.extra.chosen_index = pseudorandom('gb_the_clever', 1, #context.scoring_hand)\n            end\n        end\n        if context.individual and context.cardarea == G.play then\n            local current_index = 0\n            for k, playing_card in ipairs(context.scoring_hand) do\n                if playing_card == context.other_card then\n                    current_index = k\n                    break\n                end\n            end\n            if current_index == card.ability.extra.chosen_index then\n                context.other_card.ability.perma_bonus = (context.other_card.ability.perma_bonus or 0) + card.ability.extra.chips\n                return {\n                    message = localize(\"k_upgrade_ex\"),\n                    colour = G.C.CHIPS,\n                    message_card = context.other_card\n                }\n            end\n        end\n    end",
      "config": {
        "extra": {
          "hand_type": "Two Pair",
          "chips": 80,
          "chosen_index": -1
        }
      },
      "ability": {
        "extra": {
          "hand_type": "Two Pair",
          "chips": 80,
          "chosen_index": -1
        }
      },
      "vars": [
        "Two Pair",
        80
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "the_crafty",
      "name": "The Crafty",
      "atlas": "gb_ShatteredJokers",
      "pos": {
        "x": 5,
        "y": 3
      },
      "raw": "key = 'the_crafty',\n\tloc_txt = {\n\t\tname = 'The Crafty',\n\t\ttext = {\n\t\t\t\"If played hand contains a {C:attention}#1#{},\",\n            \"{C:attention}1{} random scoring card\",\n            \"{C:attention}permanently{} gains {C:chips}+#2#{} Chips\",\n\t\t}\n\t},\n\tconfig = { extra = { hand_type = \"Flush\", chips = 80, chosen_index = -1 } },\n\tblueprint_compat = true,\n\tatlas = 'gb_ShatteredJokers',\n\tpos = { x = 5, y = 3 },\n    soul_pos = { x = 7, y = 3 },\n    rarity = \"gb_shattered\",\n    cost = 10,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.hand_type, card.ability.extra.chips } }\n\tend,\n    calculate = function(self, card, context)\n        if context.hand_drawn then\n            card.ability.extra.chosen_index = -1\n        end\n        if context.before then\n            if next(context.poker_hands[card.ability.extra.hand_type]) then\n                card.ability.extra.chosen_index = pseudorandom('gb_the_crafty', 1, #context.scoring_hand)\n            end\n        end\n        if context.individual and context.cardarea == G.play then\n            local current_index = 0\n            for k, playing_card in ipairs(context.scoring_hand) do\n                if playing_card == context.other_card then\n                    current_index = k\n                    break\n                end\n            end\n            if current_index == card.ability.extra.chosen_index then\n                context.other_card.ability.perma_bonus = (context.other_card.ability.perma_bonus or 0) + card.ability.extra.chips\n                return {\n                    message = localize(\"k_upgrade_ex\"),\n                    colour = G.C.CHIPS,\n                    message_card = context.other_card\n                }\n            end\n        end\n    end",
      "config": {
        "extra": {
          "hand_type": "Flush",
          "chips": 80,
          "chosen_index": -1
        }
      },
      "ability": {
        "extra": {
          "hand_type": "Flush",
          "chips": 80,
          "chosen_index": -1
        }
      },
      "vars": [
        "Flush",
        80
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "the_devious",
      "name": "The Devious",
      "atlas": "gb_ShatteredJokers",
      "pos": {
        "x": 6,
        "y": 3
      },
      "raw": "key = 'the_devious',\n\tloc_txt = {\n\t\tname = 'The Devious',\n\t\ttext = {\n\t\t\t\"If played hand contains a {C:attention}#1#{},\",\n            \"{C:attention}1{} random scoring card\",\n            \"{C:attention}permanently{} gains {C:chips}+#2#{} Chips\",\n\t\t}\n\t},\n\tconfig = { extra = { hand_type = \"Straight\", chips = 100, chosen_index = -1 } },\n\tblueprint_compat = true,\n\tatlas = 'gb_ShatteredJokers',\n\tpos = { x = 6, y = 3 },\n    soul_pos = { x = 7, y = 3 },\n    rarity = \"gb_shattered\",\n    cost = 10,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.hand_type, card.ability.extra.chips } }\n\tend,\n    calculate = function(self, card, context)\n        if context.hand_drawn then\n            card.ability.extra.chosen_index = -1\n        end\n        if context.before then\n            if next(context.poker_hands[card.ability.extra.hand_type]) then\n                card.ability.extra.chosen_index = pseudorandom('gb_the_devious', 1, #context.scoring_hand)\n            end\n        end\n        if context.individual and context.cardarea == G.play then\n            local current_index = 0\n            for k, playing_card in ipairs(context.scoring_hand) do\n                if playing_card == context.other_card then\n                    current_index = k\n                    break\n                end\n            end\n            if current_index == card.ability.extra.chosen_index then\n                context.other_card.ability.perma_bonus = (context.other_card.ability.perma_bonus or 0) + card.ability.extra.chips\n                return {\n                    message = localize(\"k_upgrade_ex\"),\n                    colour = G.C.CHIPS,\n                    message_card = context.other_card\n                }\n            end\n        end\n    end",
      "config": {
        "extra": {
          "hand_type": "Straight",
          "chips": 100,
          "chosen_index": -1
        }
      },
      "ability": {
        "extra": {
          "hand_type": "Straight",
          "chips": 100,
          "chosen_index": -1
        }
      },
      "vars": [
        "Straight",
        100
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "the_sly",
      "name": "The Sly",
      "atlas": "gb_ShatteredJokers",
      "pos": {
        "x": 2,
        "y": 3
      },
      "raw": "key = 'the_sly',\n\tloc_txt = {\n\t\tname = 'The Sly',\n\t\ttext = {\n\t\t\t\"If played hand contains a {C:attention}#1#{},\",\n            \"{C:attention}1{} random scoring card\",\n            \"{C:attention}permanently{} gains {C:chips}+#2#{} Chips\",\n\t\t}\n\t},\n\tconfig = { extra = { hand_type = \"Pair\", chips = 50, chosen_index = -1 } },\n\tblueprint_compat = true,\n\tatlas = 'gb_ShatteredJokers',\n\tpos = { x = 2, y = 3 },\n    soul_pos = { x = 7, y = 3 },\n    rarity = \"gb_shattered\",\n    cost = 10,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.hand_type, card.ability.extra.chips } }\n\tend,\n    calculate = function(self, card, context)\n        if context.hand_drawn then\n            card.ability.extra.chosen_index = -1\n        end\n        if context.before then\n            if next(context.poker_hands[card.ability.extra.hand_type]) then\n                card.ability.extra.chosen_index = pseudorandom('gb_the_sly', 1, #context.scoring_hand)\n            end\n        end\n        if context.individual and context.cardarea == G.play then\n            local current_index = 0\n            for k, playing_card in ipairs(context.scoring_hand) do\n                if playing_card == context.other_card then\n                    current_index = k\n                    break\n                end\n            end\n            if current_index == card.ability.extra.chosen_index then\n                context.other_card.ability.perma_bonus = (context.other_card.ability.perma_bonus or 0) + card.ability.extra.chips\n                return {\n                    message = localize(\"k_upgrade_ex\"),\n                    colour = G.C.CHIPS,\n                    message_card = context.other_card\n                }\n            end\n        end\n    end",
      "config": {
        "extra": {
          "hand_type": "Pair",
          "chips": 50,
          "chosen_index": -1
        }
      },
      "ability": {
        "extra": {
          "hand_type": "Pair",
          "chips": 50,
          "chosen_index": -1
        }
      },
      "vars": [
        "Pair",
        50
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "the_wily",
      "name": "The Wily",
      "atlas": "gb_ShatteredJokers",
      "pos": {
        "x": 3,
        "y": 3
      },
      "raw": "key = 'the_wily',\n\tloc_txt = {\n\t\tname = 'The Wily',\n\t\ttext = {\n\t\t\t\"If played hand contains a {C:attention}#1#{},\",\n            \"{C:attention}1{} random scoring card\",\n            \"{C:attention}permanently{} gains {C:chips}+#2#{} Chips\",\n\t\t}\n\t},\n\tconfig = { extra = { hand_type = \"Three of a Kind\", chips = 100, chosen_index = -1 } },\n\tblueprint_compat = true,\n\tatlas = 'gb_ShatteredJokers',\n\tpos = { x = 3, y = 3 },\n    soul_pos = { x = 7, y = 3 },\n    rarity = \"gb_shattered\",\n    cost = 10,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.hand_type, card.ability.extra.chips } }\n\tend,\n    calculate = function(self, card, context)\n        if context.hand_drawn then\n            card.ability.extra.chosen_index = -1\n        end\n        if context.before then\n            if next(context.poker_hands[card.ability.extra.hand_type]) then\n                card.ability.extra.chosen_index = pseudorandom('gb_the_wily', 1, #context.scoring_hand)\n            end\n        end\n        if context.individual and context.cardarea == G.play then\n            local current_index = 0\n            for k, playing_card in ipairs(context.scoring_hand) do\n                if playing_card == context.other_card then\n                    current_index = k\n                    break\n                end\n            end\n            if current_index == card.ability.extra.chosen_index then\n                context.other_card.ability.perma_bonus = (context.other_card.ability.perma_bonus or 0) + card.ability.extra.chips\n                return {\n                    message = localize(\"k_upgrade_ex\"),\n                    colour = G.C.CHIPS,\n                    message_card = context.other_card\n                }\n            end\n        end\n    end",
      "config": {
        "extra": {
          "hand_type": "Three of a Kind",
          "chips": 100,
          "chosen_index": -1
        }
      },
      "ability": {
        "extra": {
          "hand_type": "Three of a Kind",
          "chips": 100,
          "chosen_index": -1
        }
      },
      "vars": [
        "Three of a Kind",
        100
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "the_crazy",
      "name": "The Crazy",
      "atlas": "gb_ShatteredJokers",
      "pos": {
        "x": 4,
        "y": 3
      },
      "raw": "key = 'the_crazy',\n\tloc_txt = {\n\t\tname = 'The Crazy',\n\t\ttext = {\n\t\t\t\"If played hand contains a {C:attention}#1#{},\",\n            \"{C:attention}1{} random scoring card\",\n            \"{C:attention}permanently{} gains {C:mult}+#2#{} Mult\",\n\t\t}\n\t},\n\tconfig = { extra = { hand_type = \"Straight\", mult = 12, chosen_index = -1 } },\n\tblueprint_compat = true,\n\tatlas = 'gb_ShatteredJokers',\n\tpos = { x = 4, y = 3 },\n    soul_pos = { x = 7, y = 2 },\n    rarity = \"gb_shattered\",\n    cost = 10,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.hand_type, card.ability.extra.mult } }\n\tend,\n    calculate = function(self, card, context)\n        if context.hand_drawn then\n            card.ability.extra.chosen_index = -1\n        end\n        if context.before then\n            if next(context.poker_hands[card.ability.extra.hand_type]) then\n                card.ability.extra.chosen_index = pseudorandom('gb_the_crazy', 1, #context.scoring_hand)\n            end\n        end\n        if context.individual and context.cardarea == G.play then\n            local current_index = 0\n            for k, playing_card in ipairs(context.scoring_hand) do\n                if playing_card == context.other_card then\n                    current_index = k\n                    break\n                end\n            end\n            if current_index == card.ability.extra.chosen_index then\n                context.other_card.ability.perma_mult = (context.other_card.ability.perma_mult or 0) + card.ability.extra.mult\n                return {\n                    message = localize(\"k_upgrade_ex\"),\n                    colour = G.C.MULT,\n                    message_card = context.other_card\n                }\n            end\n        end\n    end",
      "config": {
        "extra": {
          "hand_type": "Straight",
          "mult": 12,
          "chosen_index": -1
        }
      },
      "ability": {
        "extra": {
          "hand_type": "Straight",
          "mult": 12,
          "chosen_index": -1
        }
      },
      "vars": [
        "Straight",
        12
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "the_droll",
      "name": "The Droll",
      "atlas": "gb_ShatteredJokers",
      "pos": {
        "x": 5,
        "y": 3
      },
      "raw": "key = 'the_droll',\n\tloc_txt = {\n\t\tname = 'The Droll',\n\t\ttext = {\n\t\t\t\"If played hand contains a {C:attention}#1#{},\",\n            \"{C:attention}1{} random scoring card\",\n            \"{C:attention}permanently{} gains {C:mult}+#2#{} Mult\",\n\t\t}\n\t},\n\tconfig = { extra = { hand_type = \"Flush\", mult = 10, chosen_index = -1 } },\n\tblueprint_compat = true,\n\tatlas = 'gb_ShatteredJokers',\n\tpos = { x = 5, y = 3 },\n    soul_pos = { x = 7, y = 2 },\n    rarity = \"gb_shattered\",\n    cost = 10,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.hand_type, card.ability.extra.mult } }\n\tend,\n    calculate = function(self, card, context)\n        if context.hand_drawn then\n            card.ability.extra.chosen_index = -1\n        end\n        if context.before then\n            if next(context.poker_hands[card.ability.extra.hand_type]) then\n                card.ability.extra.chosen_index = pseudorandom('gb_the_droll', 1, #context.scoring_hand)\n            end\n        end\n        if context.individual and context.cardarea == G.play then\n            local current_index = 0\n            for k, playing_card in ipairs(context.scoring_hand) do\n                if playing_card == context.other_card then\n                    current_index = k\n                    break\n                end\n            end\n            if current_index == card.ability.extra.chosen_index then\n                context.other_card.ability.perma_mult = (context.other_card.ability.perma_mult or 0) + card.ability.extra.mult\n                return {\n                    message = localize(\"k_upgrade_ex\"),\n                    colour = G.C.MULT,\n                    message_card = context.other_card\n                }\n            end\n        end\n    end",
      "config": {
        "extra": {
          "hand_type": "Flush",
          "mult": 10,
          "chosen_index": -1
        }
      },
      "ability": {
        "extra": {
          "hand_type": "Flush",
          "mult": 10,
          "chosen_index": -1
        }
      },
      "vars": [
        "Flush",
        10
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "the_jolly",
      "name": "The Jolly",
      "atlas": "gb_ShatteredJokers",
      "pos": {
        "x": 2,
        "y": 3
      },
      "raw": "key = 'the_jolly',\n\tloc_txt = {\n\t\tname = 'The Jolly',\n\t\ttext = {\n\t\t\t\"If played hand contains a {C:attention}#1#{},\",\n            \"{C:attention}1{} random scoring card\",\n            \"{C:attention}permanently{} gains {C:mult}+#2#{} Mult\",\n\t\t}\n\t},\n\tconfig = { extra = { hand_type = \"Pair\", mult = 8, chosen_index = -1 } },\n\tblueprint_compat = true,\n\tatlas = 'gb_ShatteredJokers',\n\tpos = { x = 2, y = 3 },\n    soul_pos = { x = 7, y = 2 },\n    rarity = \"gb_shattered\",\n    cost = 10,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.hand_type, card.ability.extra.mult } }\n\tend,\n    calculate = function(self, card, context)\n        if context.hand_drawn then\n            card.ability.extra.chosen_index = -1\n        end\n        if context.before then\n            if next(context.poker_hands[card.ability.extra.hand_type]) then\n                card.ability.extra.chosen_index = pseudorandom('gb_the_jolly', 1, #context.scoring_hand)\n            end\n        end\n        if context.individual and context.cardarea == G.play then\n            local current_index = 0\n            for k, playing_card in ipairs(context.scoring_hand) do\n                if playing_card == context.other_card then\n                    current_index = k\n                    break\n                end\n            end\n            if current_index == card.ability.extra.chosen_index then\n                context.other_card.ability.perma_mult = (context.other_card.ability.perma_mult or 0) + card.ability.extra.mult\n                return {\n                    message = localize(\"k_upgrade_ex\"),\n                    colour = G.C.MULT,\n                    message_card = context.other_card\n                }\n            end\n        end\n    end",
      "config": {
        "extra": {
          "hand_type": "Pair",
          "mult": 8,
          "chosen_index": -1
        }
      },
      "ability": {
        "extra": {
          "hand_type": "Pair",
          "mult": 8,
          "chosen_index": -1
        }
      },
      "vars": [
        "Pair",
        8
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "the_mad",
      "name": "The Mad",
      "atlas": "gb_ShatteredJokers",
      "pos": {
        "x": 4,
        "y": 3
      },
      "raw": "key = 'the_mad',\n\tloc_txt = {\n\t\tname = 'The Mad',\n\t\ttext = {\n\t\t\t\"If played hand contains a {C:attention}#1#{},\",\n            \"{C:attention}1{} random scoring card\",\n            \"{C:attention}permanently{} gains {C:mult}+#2#{} Mult\",\n\t\t}\n\t},\n\tconfig = { extra = { hand_type = \"Two Pair\", mult = 10, chosen_index = -1 } },\n\tblueprint_compat = true,\n\tatlas = 'gb_ShatteredJokers',\n\tpos = { x = 4, y = 3 },\n    soul_pos = { x = 7, y = 2 },\n    rarity = \"gb_shattered\",\n    cost = 10,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.hand_type, card.ability.extra.mult } }\n\tend,\n    calculate = function(self, card, context)\n        if context.hand_drawn then\n            card.ability.extra.chosen_index = -1\n        end\n        if context.before then\n            if next(context.poker_hands[card.ability.extra.hand_type]) then\n                card.ability.extra.chosen_index = pseudorandom('gb_the_mad', 1, #context.scoring_hand)\n            end\n        end\n        if context.individual and context.cardarea == G.play then\n            local current_index = 0\n            for k, playing_card in ipairs(context.scoring_hand) do\n                if playing_card == context.other_card then\n                    current_index = k\n                    break\n                end\n            end\n            if current_index == card.ability.extra.chosen_index then\n                context.other_card.ability.perma_mult = (context.other_card.ability.perma_mult or 0) + card.ability.extra.mult\n                return {\n                    message = localize(\"k_upgrade_ex\"),\n                    colour = G.C.MULT,\n                    message_card = context.other_card\n                }\n            end\n        end\n    end",
      "config": {
        "extra": {
          "hand_type": "Two Pair",
          "mult": 10,
          "chosen_index": -1
        }
      },
      "ability": {
        "extra": {
          "hand_type": "Two Pair",
          "mult": 10,
          "chosen_index": -1
        }
      },
      "vars": [
        "Two Pair",
        10
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "the_zany",
      "name": "The Zany",
      "atlas": "gb_ShatteredJokers",
      "pos": {
        "x": 3,
        "y": 3
      },
      "raw": "key = 'the_zany',\n\tloc_txt = {\n\t\tname = 'The Zany',\n\t\ttext = {\n\t\t\t\"If played hand contains a {C:attention}#1#{},\",\n            \"{C:attention}1{} random scoring card\",\n            \"{C:attention}permanently{} gains {C:mult}+#2#{} Mult\",\n\t\t}\n\t},\n\tconfig = { extra = { hand_type = \"Three of a Kind\", mult = 12, chosen_index = -1 } },\n\tblueprint_compat = true,\n\tatlas = 'gb_ShatteredJokers',\n\tpos = { x = 3, y = 3 },\n    soul_pos = { x = 7, y = 2 },\n    rarity = \"gb_shattered\",\n    cost = 10,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.hand_type, card.ability.extra.mult } }\n\tend,\n    calculate = function(self, card, context)\n        if context.hand_drawn then\n            card.ability.extra.chosen_index = -1\n        end\n        if context.before then\n            if next(context.poker_hands[card.ability.extra.hand_type]) then\n                card.ability.extra.chosen_index = pseudorandom('gb_the_zany', 1, #context.scoring_hand)\n            end\n        end\n        if context.individual and context.cardarea == G.play then\n            local current_index = 0\n            for k, playing_card in ipairs(context.scoring_hand) do\n                if playing_card == context.other_card then\n                    current_index = k\n                    break\n                end\n            end\n            if current_index == card.ability.extra.chosen_index then\n                context.other_card.ability.perma_mult = (context.other_card.ability.perma_mult or 0) + card.ability.extra.mult\n                return {\n                    message = localize(\"k_upgrade_ex\"),\n                    colour = G.C.MULT,\n                    message_card = context.other_card\n                }\n            end\n        end\n    end",
      "config": {
        "extra": {
          "hand_type": "Three of a Kind",
          "mult": 12,
          "chosen_index": -1
        }
      },
      "ability": {
        "extra": {
          "hand_type": "Three of a Kind",
          "mult": 12,
          "chosen_index": -1
        }
      },
      "vars": [
        "Three of a Kind",
        12
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "cosmic_diamond",
      "name": "Cosmic Diamond",
      "atlas": "gb_ShatteredJokers",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"cosmic_diamond\",\n    loc_txt = {\n\t\tname = 'Cosmic Diamond',\n\t\ttext = {\n\t\t\t\"Earn {C:money}$#1#{} at end of round\",\n\t\t\t\"Payout increases by {C:money}$#2#{} for every\",\n            \"{C:attention}#4#{} scored {C:diamonds}Diamonds{} {C:inactive}(#3#/#4#)\"\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_ShatteredJokers',\n\tpos = { x = 0, y = 1 },\n    rarity = \"gb_shattered\",\n    cost = 10,\n    config = { extra = { dollars = 1, dollars_mod = 1, diamond_tally = 0, diamonds = 5 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.dollars, card.ability.extra.dollars_mod, card.ability.extra.diamond_tally, card.ability.extra.diamonds } }\n    end,\n    calc_dollar_bonus = function(self, card)\n        return card.ability.extra.dollars\n    end,\n    calculate = function(self, card, context)\n         if context.individual and context.cardarea == G.play and context.other_card:is_suit(\"Diamonds\") and not context.blueprint then\n            card.ability.extra.diamond_tally = card.ability.extra.diamond_tally + 1\n            if card.ability.extra.diamond_tally >= card.ability.extra.diamonds then\n                card.ability.extra.dollars = card.ability.extra.dollars + card.ability.extra.dollars_mod\n                card.ability.extra.diamond_tally = card.ability.extra.diamond_tally - card.ability.extra.diamonds\n                return {\n                    message = localize('k_upgrade_ex'),\n                    colour = G.C.MONEY,\n                    message_card = card\n                }\n            end\n        end\n    end",
      "config": {
        "extra": {
          "dollars": 1,
          "dollars_mod": 1,
          "diamond_tally": 0,
          "diamonds": 5
        }
      },
      "ability": {
        "extra": {
          "dollars": 1,
          "dollars_mod": 1,
          "diamond_tally": 0,
          "diamonds": 5
        }
      },
      "vars": [
        1,
        1,
        0,
        5
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "divination",
      "name": "Divination",
      "atlas": "gb_ShatteredJokers",
      "pos": {
        "x": 5,
        "y": 0
      },
      "raw": "key = 'divination',\n    loc_txt = {\n        name = 'Divination',\n        text = {\n            \"{C:green}#1# in #2#{} chance to create\",\n            \"a random {C:spectral}Spectral{} card when\",\n            \"any {C:attention}Booster Pack{} is skipped\",\n        }\n    },\n    blueprint_compat = true,\n\tatlas = 'gb_ShatteredJokers',\n\tpos = { x = 5, y = 0 },\n    rarity = \"gb_shattered\",\n    cost = 10,\n    config = { extra = { odds = 2 } },\n    loc_vars = function(self, info_queue, card)\n        local new_numerator, new_denominator = SMODS.get_probability_vars(card, 1, card.ability.extra.odds)\n        return { vars = { new_numerator, new_denominator } }\n    end,\n    calculate = function(self, card, context)\n        if context.skipping_booster then\n            if SMODS.pseudorandom_probability(card, 'gb_divination', 1, card.ability.extra.odds) then\n                G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1\n                G.E_MANAGER:add_event(Event({\n                    trigger = 'before',\n                    delay = 0.0,\n                    func = (function()\n                        SMODS.add_card {\n                            set = 'Spectral',\n                            key_append = 'gb_divination'\n                        }\n                        G.GAME.consumeable_buffer = 0\n                        return true\n                    end)\n                }))\n                return {\n                    message = \"+1 Spectral\",\n                    colour = G.C.SECONDARY_SET.Spectral,\n                }\n            end\n        end\n    end",
      "config": {
        "extra": {
          "odds": 2
        }
      },
      "ability": {
        "extra": {
          "odds": 2
        }
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "golden_ratio",
      "name": "Golden Ratio",
      "atlas": "gb_ShatteredJokers",
      "pos": {
        "x": 4,
        "y": 1
      },
      "raw": "key = \"golden_ratio\",\n    loc_txt = {\n\t\tname = 'Golden Ratio',\n\t\ttext = {\n\t\t\t\"Scored {C:attention}Ace{}s, {C:attention}3{}s, {C:attention}6{}s and {C:attention}8{}s\",\n\t\t\t\"are enhanced to {C:attention}Gold Cards{}\",\n            \"and give {X:mult,C:white}X#1#{} Mult\",\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_ShatteredJokers',\n\tpos = { x = 4, y = 1 },\n    rarity = \"gb_shattered\",\n    cost = 10,\n    config = { extra = { xmult = 1.5 } },\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue + 1] = G.P_CENTERS.m_gold\n        return { vars = { card.ability.extra.xmult } }\n    end,\n    calculate = function(self, card, context)\n        if context.before and context.main_eval and not context.blueprint then\n            local cards = 0\n            for _, scored_card in ipairs(context.scoring_hand) do\n                if (\n                scored_card:get_id() == 3\n                or scored_card:get_id() == 6\n                or scored_card:get_id() == 8\n                or scored_card:get_id() == 14\n                ) then\n                    cards = cards + 1\n                    scored_card:set_ability('m_gold', nil, true)\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            scored_card:juice_up()\n                            return true\n                        end\n                    }))\n                end\n            end\n            if cards > 0 then\n                return {\n                    message = localize('k_gold'),\n                    colour = G.C.MONEY\n                }\n            end\n        end\n        if context.individual and context.cardarea == G.play and\n            (\n                context.other_card:get_id() == 3\n                or context.other_card:get_id() == 6\n                or context.other_card:get_id() == 8\n                or context.other_card:get_id() == 14\n            ) then\n            return {\n                xmult = card.ability.extra.xmult\n\t\t\t}\n        end\n    end",
      "config": {
        "extra": {
          "xmult": 1.5
        }
      },
      "ability": {
        "extra": {
          "xmult": 1.5
        }
      },
      "vars": [
        1.5
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "jimbo",
      "name": "Jimbo",
      "atlas": "gb_ShatteredJokers",
      "pos": {
        "x": 7,
        "y": 0
      },
      "raw": "key = 'jimbo',\n\tloc_txt = {\n\t\tname = 'Jimbo',\n\t\ttext = {\n\t\t\t\"{X:mult,C:white}X#1#{} Mult\",\n\t\t}\n\t},\n\tconfig = { extra = { xmult = 4 } },\n\tblueprint_compat = true,\n\tatlas = 'gb_ShatteredJokers',\n\tpos = { x = 7, y = 0 },\n    soul_pos = { x = 7, y = 2 },\n    rarity = \"gb_shattered\",\n    cost = 10,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.xmult } }\n\tend,\n    calculate = function(self, card, context)\n        if context.joker_main then\n            return {\n                xmult = card.ability.extra.xmult\n            }\n        end\n    end",
      "config": {
        "extra": {
          "xmult": 4
        }
      },
      "ability": {
        "extra": {
          "xmult": 4
        }
      },
      "vars": [
        4
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "lighthouse",
      "name": "Lighthouse",
      "atlas": "gb_ShatteredJokers",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = 'lighthouse',\n    loc_txt = {\n        name = 'Lighthouse',\n        text = {\n            \"{X:mult,C:white}X#1#{} Mult for every\",\n            \"{C:attention}Joker{} to the right of this one\",\n            \"{C:inactive}(Currently {X:mult,C:white}X#2#{C:inactive} Mult)\",\n        }\n    },\n    config = { extra = { xmult = 1, xmult_mod = 0.75 } },\n    blueprint_compat = true,\n\tatlas = 'gb_ShatteredJokers',\n\tpos = { x = 2, y = 0 },\n    rarity = \"gb_shattered\",\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        local position = 0\n        if card.area and card.area == G.jokers then\n            for k, joker in ipairs(G.jokers.cards) do\n                if joker == card then\n                    position = #G.jokers.cards - k\n                    break\n                end\n            end\n            return { vars = { card.ability.extra.xmult_mod, 1 + card.ability.extra.xmult_mod * position} }\n        else\n            return { vars = { card.ability.extra.xmult_mod, 1 } }\n        end\n            \n    end,\n    calculate = function(self, card, context)\n        if context.joker_main then\n            local position = 0\n            for k, joker in ipairs(G.jokers.cards) do\n                if joker == card then\n                    position = #G.jokers.cards - k\n                    break\n                end\n            end\n            card.ability.extra.xmult = 1 + card.ability.extra.xmult_mod * position\n            return { \n                xmult = card.ability.extra.xmult\n            }\n        end\n    end,",
      "config": {
        "extra": {
          "xmult": 1,
          "xmult_mod": 0.75
        }
      },
      "ability": {
        "extra": {
          "xmult": 1,
          "xmult_mod": 0.75
        }
      },
      "vars": [
        0.75,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "lovecraftian_horror",
      "name": "Lovecraftian Horror",
      "atlas": "gb_ShatteredJokers",
      "pos": {
        "x": 5,
        "y": 2
      },
      "raw": "key = 'lovecraftian_horror',\n    loc_txt = {\n        name = 'Lovecraftian Horror',\n        text = {\n            \"When a card is discarded, {C:green}#3# in #4#{} chance\",\n            \"for this Joker to gain {X:mult,C:white}X#2#{} Mult\",\n            \"and {C:attention}destroy{} the discarded card\",\n            \"{C:inactive}(Currently {X:mult,C:white}X#1#{C:inactive} Mult)\",\n        }\n    },\n    config = { extra = { xmult = 1, xmult_mod = 0.25, odds = 6 } },\n    blueprint_compat = true,\n\tatlas = 'gb_ShatteredJokers',\n\tpos = { x = 5, y = 2 },\n    soul_pos = { x = 6, y = 2 },\n    rarity = \"gb_shattered\",\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        local new_numerator, new_denominator = SMODS.get_probability_vars(card, 1, card.ability.extra.odds)\n        return { vars = {\n            card.ability.extra.xmult,\n            card.ability.extra.xmult_mod,\n            new_numerator, \n            new_denominator\n        } }\n    end,\n    calculate = function(self, card, context)\n        if context.discard then\n            if SMODS.pseudorandom_probability(card, 'gb_lovecraftian_horror', 1, card.ability.extra.odds) then\n                SMODS.scale_card(card, {\n                    ref_table = card.ability.extra,\n                    ref_value = \"xmult\",\n                    scalar_value = \"xmult_mod\",\n                    message_colour = G.C.MULT\n                })\n                return {\n                    remove = true\n                }\n            end\n        end\n        if context.joker_main then\n            return {\n                xmult = card.ability.extra.xmult\n            }\n        end\n    end",
      "config": {
        "extra": {
          "xmult": 1,
          "xmult_mod": 0.25,
          "odds": 6
        }
      },
      "ability": {
        "extra": {
          "xmult": 1,
          "xmult_mod": 0.25,
          "odds": 6
        }
      },
      "vars": [
        1,
        0.25,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "lure",
      "name": "Lure",
      "atlas": "gb_ShatteredJokers",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = 'lure',\n    loc_txt = {\n        name = 'Lure',\n        text = {\n            \"{X:mult,C:white}X#1#{} Mult\",\n            \"{C:green}#2# in #3#{} chance at\",\n            \"end of round to\",\n            \"{C:attention}reel something in{}\",\n        }\n    },\n    config = { extra = { xmult = 1.5, odds = 6 } },\n    blueprint_compat = true,\n\tatlas = 'gb_ShatteredJokers',\n\tpos = { x = 0, y = 2 },\n    rarity = \"gb_shattered\",\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        local new_numerator, new_denominator = SMODS.get_probability_vars(card, 1, card.ability.extra.odds)\n        return { vars = { card.ability.extra.xmult, new_numerator, new_denominator } }\n    end,\n    calculate = function(self, card, context)\n        if context.joker_main then\n            return {\n                xmult = card.ability.extra.xmult\n            }\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval and not context.blueprint then\n            if SMODS.pseudorandom_probability(card, 'gb_lure', 1, card.ability.extra.odds) then\n                SMODS.add_card{\n                    set = 'Joker',\n                    key = \"j_gb_lovecraftian_horror\",\n                    edition = (card.edition and card.edition.key) or nil\n                }\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        play_sound('tarot1')\n                        card.T.r = -0.2\n                        card:juice_up(0.3, 0.4)\n                        card.states.drag.is = true\n                        card.children.center.pinch.x = true\n                        G.E_MANAGER:add_event(Event({\n                            trigger = 'after',\n                            delay = 0.3,\n                            blockable = false,\n                            func = function()\n                                card:remove()\n                                return true\n                            end\n                        }))\n                        return true\n                    end\n                }))            \n                return {\n                    message = 'Caught!',\n                    colour = G.C.FILTER\n                }\n            end\n        end\n    end,",
      "config": {
        "extra": {
          "xmult": 1.5,
          "odds": 6
        }
      },
      "ability": {
        "extra": {
          "xmult": 1.5,
          "odds": 6
        }
      },
      "vars": [
        1.5,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "melting_face",
      "name": "Melting Face",
      "atlas": "gb_ShatteredJokers",
      "pos": {
        "x": 6,
        "y": 0
      },
      "raw": "key = 'melting_face',\n\tloc_txt = {\n\t\tname = 'Melting Face',\n\t\ttext = {\n\t\t\t\"{C:attention}Face{} cards give\",\n            \"{C:chips}+#1#{} Chips and {C:mult}+#2#{} Mult\",\n            \"for every scoring {C:attention}face{} card\",\n\t\t}\n\t},\n\tconfig = { extra = { mult = 2, chips = 15, faces = 0 } },\n\tblueprint_compat = true,\n\tatlas = 'gb_ShatteredJokers',\n\tpos = { x = 6, y = 0 },\n    rarity = \"gb_shattered\",\n    cost = 10,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.chips, card.ability.extra.mult } }\n\tend,\n    calculate = function(self, card, context)\n        if context.before and context.main_eval then\n            card.ability.extra.faces = 0\n            for _, playing_card in ipairs(context.scoring_hand) do\n                if playing_card:is_face() then\n                    card.ability.extra.faces = card.ability.extra.faces + 1\n                end\n            end\n        end\n        if context.individual and context.cardarea == G.play and context.other_card:is_face() then\n            return {\n                chips = card.ability.extra.chips * card.ability.extra.faces,\n                mult = card.ability.extra.mult * card.ability.extra.faces\n            }\n        end\n    end",
      "config": {
        "extra": {
          "mult": 2,
          "chips": 15,
          "faces": 0
        }
      },
      "ability": {
        "extra": {
          "mult": 2,
          "chips": 15,
          "faces": 0
        }
      },
      "vars": [
        15,
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "memory_leak",
      "name": "Memory Leak",
      "atlas": "gb_ShatteredJokers",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "key = 'memory_leak',\n    loc_txt = {\n        name = 'Memory Leak',\n        text = {\n            \"Gives between {X:mult,C:white}X#1#{} and {X:mult,C:white}X#2#{} Mult\",\n            \"{C:attention}Maximum{} value {C:attention}increases{} by {X:mult,C:white}X#3#{}\",\n            \"before hand scored\"\n        }\n    },\n    config = { extra = { xmult_min = 1, xmult_max = 1, xmult_mod = 0.2 } },\n    blueprint_compat = true,\n\tatlas = 'gb_ShatteredJokers',\n\tpos = { x = 1, y = 2 },\n    rarity = \"gb_shattered\",\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.xmult_min, card.ability.extra.xmult_max, card.ability.extra.xmult_mod } }\n    end,\n    calculate = function(self, card, context)\n        if context.joker_main then\n            card.ability.extra.xmult_max = card.ability.extra.xmult_max + card.ability.extra.xmult_mod\n            local random_mult = pseudorandom('gb_memory_leak', card.ability.extra.xmult_min * 10, card.ability.extra.xmult_max * 10) * 0.1\n            return {\n                xmult = random_mult\n            }\n        end\n    end",
      "config": {
        "extra": {
          "xmult_min": 1,
          "xmult_max": 1,
          "xmult_mod": 0.2
        }
      },
      "ability": {
        "extra": {
          "xmult_min": 1,
          "xmult_max": 1,
          "xmult_mod": 0.2
        }
      },
      "vars": [
        1,
        1,
        0.2
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "monolith",
      "name": "Monolith",
      "atlas": "gb_ShatteredJokers",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"monolith\",\n    loc_txt = {\n\t\tname = 'Monolith',\n\t\ttext = {\n\t\t\t\"{X:mult,C:white}X#2#{} Mult, loses {X:mult,C:white}X#1#{} Mult\",\n\t\t\t\"if played hand is not \",\n            \"{C:attention}most played poker hand{}\",\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_ShatteredJokers',\n\tpos = { x = 0, y = 0 },\n    rarity = \"gb_shattered\",\n    cost = 10,\n    config = { extra = { xmult_loss = 0.25, xmult = 4 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.xmult_loss, card.ability.extra.xmult } }\n    end,\n    calculate = function(self, card, context)\n        if context.before and context.main_eval and not context.blueprint then\n            local lower = false\n            local play_more_than = (G.GAME.hands[context.scoring_name].played or 0)\n            for k, v in pairs(G.GAME.hands) do\n                if k ~= context.scoring_name and v.played >= play_more_than and v.visible then\n                    lower = true\n                    break\n                end\n            end\n            if lower then\n                card.ability.extra.xmult = card.ability.extra.xmult - card.ability.extra.xmult_loss\n                if card.ability.extra.xmult <= 1 then\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            play_sound('tarot1')\n                            card.T.r = -0.2\n                            card:juice_up(0.3, 0.4)\n                            card.states.drag.is = true\n                            card.children.center.pinch.x = true\n                            G.E_MANAGER:add_event(Event({\n                                trigger = 'after',\n                                delay = 0.3,\n                                blockable = false,\n                                func = function()\n                                    card:remove()\n                                    return true\n                                end\n                            }))\n                            return true\n                        end\n                    }))\n                    return {\n                    message = \"Shattered!\",\n                    colour = G.C.RED\n                    }\n                else\n                    return {\n                        message = \"Downgraded!\",\n                        colour = G.C.MULT\n                    }\n                end\n            end\n        end\n        if context.joker_main then\n            return {\n                xmult = card.ability.extra.xmult\n            }\n        end\n    end",
      "config": {
        "extra": {
          "xmult_loss": 0.25,
          "xmult": 4
        }
      },
      "ability": {
        "extra": {
          "xmult_loss": 0.25,
          "xmult": 4
        }
      },
      "vars": [
        0.25,
        4
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "ornate_vase",
      "name": "Ornate Vase",
      "atlas": "gb_ShatteredJokers",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"ornate_vase\",\n    loc_txt = {\n\t\tname = 'Ornate Vase',\n\t\ttext = {\n\t\t\t\"This Joker gains {X:mult,C:white}X#1#{} Mult if\",\n\t\t\t\"played hand contains scoring cards\",\n            \"of {C:attention}3 or more{} different suits\",\n            \"{C:inactive}(Currently {X:mult,C:white}X#2#{C:inactive} Mult)\"\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_ShatteredJokers',\n\tpos = { x = 1, y = 0 },\n    rarity = \"gb_shattered\",\n    cost = 10,\n    config = { extra = { xmult_mod = 0.25, xmult = 1 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.xmult_mod, card.ability.extra.xmult } }\n    end,\n    calculate = function(self, card, context)\n        if context.before and context.main_eval and not context.blueprint then\n            local scored_suits = {}\n            for _, c in ipairs(context.scoring_hand) do\n                if c.base.suit and not scored_suits[c.base.suit] then scored_suits[c.base.suit] = true end\n            end\n\n            local suitamt = 0\n            for _, _ in pairs(scored_suits) do\n                suitamt = suitamt + 1\n            end\n\n            if suitamt >= 3 then\n                SMODS.scale_card(card, {\n                    ref_table = card.ability.extra,\n                    ref_value = \"xmult\",\n                    scalar_value = \"xmult_mod\",\n                    message_colour = G.C.MULT\n                })\n            end\n        end\n        if context.joker_main then\n            return {\n                xmult = card.ability.extra.xmult\n            }\n        end\n    end",
      "config": {
        "extra": {
          "xmult_mod": 0.25,
          "xmult": 1
        }
      },
      "ability": {
        "extra": {
          "xmult_mod": 0.25,
          "xmult": 1
        }
      },
      "vars": [
        0.25,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "phase_charts",
      "name": "Phase Charts",
      "atlas": "gb_ShatteredJokers",
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "key = 'phase_charts',\n\tloc_txt = {\n\t\tname = 'Phase Charts',\n\t\ttext = {\n\t\t\t\"This Joker gains {X:mult,C:white}X#1#{} Mult\",\n            \"at end of round, {C:attention}resets{} at {X:mult,C:white}X#3#{}\",\n            \"{C:inactive}(Currently {X:mult,C:white}X#2#{C:inactive} Mult)\"\n\t\t}\n\t},\n\tconfig = { extra = { xmult = 1, xmult_mod = 1, xmult_limit = 5 } },\n\tblueprint_compat = true,\n\tatlas = 'gb_ShatteredJokers',\n\tpos = { x = 4, y = 0 },\n    rarity = \"gb_shattered\",\n    cost = 10,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.xmult_mod, card.ability.extra.xmult, card.ability.extra.xmult_limit } }\n\tend,\n    calculate = function(self, card, context)\n        if context.joker_main then\n            return {\n                xmult = card.ability.extra.xmult\n            }\n        end\n        if context.end_of_round and not context.blueprint then\n            SMODS.scale_card(card, {\n                    ref_table = card.ability.extra,\n                    ref_value = \"xmult\",\n                    scalar_value = \"xmult_mod\",\n                    no_message = true\n                })\n            if card.ability.extra.xmult > card.ability.extra.xmult_limit then\n                card.ability.extra.xmult = 1\n                return {\n                    message = localize('k_reset'),\n                    colour = G.C.MULT\n                }\n            else\n                return {\n                    message = localize('k_upgrade_ex'),\n                    colour = G.C.MULT\n                }\n            end\n        end\n    end",
      "config": {
        "extra": {
          "xmult": 1,
          "xmult_mod": 1,
          "xmult_limit": 5
        }
      },
      "ability": {
        "extra": {
          "xmult": 1,
          "xmult_mod": 1,
          "xmult_limit": 5
        }
      },
      "vars": [
        1,
        1,
        5
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "pure_essence",
      "name": "Pure Essence",
      "atlas": "gb_ShatteredJokers",
      "pos": {
        "x": 7,
        "y": 0
      },
      "raw": "key = 'pure_essence',\n\tloc_txt = {\n\t\tname = 'Pure Essence',\n\t\ttext = {\n\t\t\t\"Sell this Joker to create\",\n            \"a random {C:legendary,E:1}Legendary{} Joker\",\n\t\t}\n\t},\n\tblueprint_compat = false,\n\tatlas = 'gb_ShatteredJokers',\n\tpos = { x = 7, y = 0 },\n    soul_pos = { x = 7, y = 1 },\n    rarity = \"gb_shattered\",\n    cost = 10,\n    calculate = function(self, card, context)\n        if context.selling_self and not context.blueprint then\n            G.E_MANAGER:add_event(Event({\n                trigger = 'after',\n                delay = 0.4,\n                func = function()\n                    play_sound('timpani')\n                    SMODS.add_card({ set = 'Joker', legendary = true })\n                    check_for_unlock { type = 'spawn_legendary' }\n                    card:juice_up(0.3, 0.5)\n                    return true\n                end\n            }))\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "purple_rain",
      "name": "Purple Rain",
      "atlas": "gb_ShatteredJokers",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"purple_rain\",\n    loc_txt = {\n\t\tname = 'Purple Rain',\n\t\ttext = {\n\t\t\t\"Retriggers every {C:attention}scoring card{} once\",\n            \"for every {C:attention}non-scoring card{}\",\n\t\t}\n\t},\n    blueprint_compat = true,\n\tatlas = 'gb_ShatteredJokers',\n\tpos = { x = 3, y = 0 },\n    rarity = \"gb_shattered\",\n    cost = 10,\n    config = { extra = { repetitions = 0 } },\n    calculate = function(self, card, context)\n        if context.before and context.main_eval then\n            card.ability.extra.repetitions = 0\n            for _, _ in ipairs(context.full_hand) do\n                card.ability.extra.repetitions = card.ability.extra.repetitions + 1\n            end\n            for _, _ in ipairs(context.scoring_hand) do\n                card.ability.extra.repetitions = card.ability.extra.repetitions - 1\n            end\n        end\n        if context.repetition and context.cardarea == G.play then\t\n            return {\n                repetitions = card.ability.extra.repetitions\n            }\n        end\n    end",
      "config": {
        "extra": {
          "repetitions": 0
        }
      },
      "ability": {
        "extra": {
          "repetitions": 0
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "supercharger",
      "name": "Supercharger",
      "atlas": "gb_ShatteredJokers",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = 'supercharger',\n\tloc_txt = {\n\t\tname = 'Supercharger',\n\t\ttext = {\n\t\t\t\"{C:attention}Bonus Cards{} and {C:attention}Mult Cards{}\",\n\t\t\t\"give {X:mult,C:white}X#1#{} Mult when scored\",\n\t\t}\n\t},\n\tconfig = { extra = { xmult = 1.5 } },\n\tblueprint_compat = true,\n\tatlas = 'gb_ShatteredJokers',\n\tpos = { x = 3, y = 1 },\n    rarity = \"gb_shattered\",\n    cost = 10,\n\tloc_vars = function(self, info_queue, card)\n\t\tinfo_queue[#info_queue + 1] = G.P_CENTERS.m_bonus\n\t\tinfo_queue[#info_queue + 1] = G.P_CENTERS.m_mult\n\t\treturn { vars = { card.ability.extra.xmult } }\n\tend,\n    calculate = function(self, card, context)\n        if context.individual and context.cardarea == G.play and\n            SMODS.has_enhancement(context.other_card, 'm_bonus') then\n            return {\n                xmult = card.ability.extra.xmult\n\t\t\t}\n        end\n        if context.individual and context.cardarea == G.play and\n            SMODS.has_enhancement(context.other_card, 'm_mult') then\n            return {\n                chips = card.ability.extra.chips\n\t\t\t}\n        end\n    end",
      "config": {
        "extra": {
          "xmult": 1.5
        }
      },
      "ability": {
        "extra": {
          "xmult": 1.5
        }
      },
      "vars": [
        1.5
      ],
      "infoQueue": []
    },
    {
      "type": "Seal",
      "key": "dual",
      "name": "Dual Seal",
      "atlas": "gb_Seals",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = 'dual',\n    loc_txt = {\n        name = \"Dual Seal\",\n        label = \"Dual Seal\",\n        text = {\n            \"If scoring, {C:attention}duplicate{}\",\n            \"this card to hand\",\n            \"without the {C:attention}Seal\",\n        }\n    },\n    atlas = \"gb_Seals\",\n    pos = { x = 0, y = 0 },\n    badge_colour = HEX('6E89C2'),\n    calculate = function(self, card, context)\n        if context.before \n        and context.cardarea == G.play then\n            G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n            local copy_card = copy_card(card, nil, nil, G.playing_card)\n            copy_card:set_seal(nil, nil, true)\n            copy_card:add_to_deck()\n            G.deck.config.card_limit = G.deck.config.card_limit + 1\n            table.insert(G.playing_cards, copy_card)\n            G.hand:emplace(copy_card)\n            copy_card.states.visible = nil\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    copy_card:start_materialize()\n                    return true\n                end\n            }))\n            return {\n                message = localize('k_copied_ex'),\n                colour = HEX(\"6E89C2\"),\n                func = function()\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            SMODS.calculate_context({ playing_card_added = true, cards = { copy_card } })\n                            return true\n                        end\n                    }))\n                end\n            }\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Seal",
      "key": "fortune",
      "name": "Fortune Seal",
      "atlas": "gb_Seals",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = 'fortune',\n    loc_txt = {\n        name = \"Fortune Seal\",\n        label = \"Fortune Seal\",\n        text = {\n            \"{C:green}#1# in #2#{} chance to\",\n            \"give an {C:dark_edition}Edition{} to\",\n            \"a random played card\",\n            \"if scoring\",\n        }\n    },\n    atlas = \"gb_Seals\",\n    pos = { x = 1, y = 0 },\n    config = { extra = { odds = 4 } },\n    badge_colour = HEX('CAB785'),\n    loc_vars = function(self, info_queue, card)\n        local new_numerator, new_denominator = SMODS.get_probability_vars(card, 1, self.config.extra.odds)\n        return { vars = { new_numerator, new_denominator } }\n    end,\n    calculate = function(self, card, context)\n        if context.before \n        and context.cardarea == G.play then    \n            if SMODS.pseudorandom_probability(card, 'gb_fortune', 1, self.config.extra.odds) then\n                local eligible_card = pseudorandom_element(context.scoring_hand, pseudoseed('gb_fortune'))\n                local edition = poll_edition('gb_fortune', nil, true, true)\n                if eligible_card and not eligible_card.edition then\n                    eligible_card:set_edition(edition, true)\n                end\n            else\n                return {\n                    message = localize(\"k_nope_ex\"),\n                    colour = G.C.SECONDARY_SET.Tarot,\n\t\t\t\t\tsound = 'cancel'\n                }\n            end\n        end\n    end",
      "config": {
        "extra": {
          "odds": 4
        }
      },
      "ability": {
        "extra": {
          "odds": 4
        }
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Seal",
      "key": "infinite",
      "name": "Infinite Seal",
      "atlas": "gb_Seals",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = 'infinite',\n    loc_txt = {\n        name = \"Infinite Seal\",\n        label = \"Infinite Seal\",\n        text = {\n            \"If this card is {C:attention}destroyed{},\",\n            \"{C:attention}duplicate{} it and earn {C:money}$#1#{}\",\n        }\n    },\n    atlas = \"gb_Seals\",\n    pos = { x = 2, y = 0 },\n    config = { extra = { odds = 4, dollars = 5 } },\n    badge_colour = HEX('A1A5A6'),\n    loc_vars = function(self, info_queue, card)\n        return { vars = { self.config.extra.dollars } }\n    end,\n    calculate = function(self, card, context)\n        if context.remove_playing_cards then\n            local being_removed = false\n            for _, playing_card in ipairs(context.removed) do\n                if playing_card == card and not (card.edition and card.edition.key ~= \"e_gb_temporary\") then\n                    being_removed = true\n                end\n            end\n            if being_removed then\n                G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                local copy_card = copy_card(card, nil, nil, G.playing_card)\n                copy_card:add_to_deck()\n                G.deck.config.card_limit = G.deck.config.card_limit + 1\n                table.insert(G.playing_cards, copy_card)\n                if G.hand then\n                    G.hand:emplace(copy_card)\n                else\n                    G.deck:emplace(copy_card)\n                end\n                copy_card.states.visible = nil\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        copy_card:start_materialize()\n                        return true\n                    end\n                }))\n                ease_dollars(self.config.extra.dollars)\n                return {\n                    func = function()\n                        G.E_MANAGER:add_event(Event({\n                            func = function()\n                                SMODS.calculate_context({ playing_card_added = true, cards = { copy_card } })\n                                return true\n                            end\n                        }))\n                    end\n                }\n            end\n        end\n    end",
      "config": {
        "extra": {
          "odds": 4,
          "dollars": 5
        }
      },
      "ability": {
        "extra": {
          "odds": 4,
          "dollars": 5
        }
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Rarity",
      "key": "shattered",
      "name": "Shattered",
      "atlas": null,
      "pos": null,
      "raw": "key = \"shattered\",\n    loc_txt = {name = \"Shattered\"},\n    badge_colour = HEX(\"834896\")",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Rarity",
      "key": "boss",
      "name": "Boss",
      "atlas": null,
      "pos": null,
      "raw": "key = \"boss\",\n    loc_txt = {name = \"Boss\"},\n    badge_colour = HEX(\"EFC03C\"),\n\tpools = { [\"Joker\"] = { rate = 0.02 } },\n    default_weight = 0.02,\n\tget_weight = function(self, weight, object_type)\n\t\tif G.GAME.GB_DEFEATED_BLINDS and G.GAME.GB_DEFEATED_BLIND_COUNT >= 1 then\n\t\t\treturn 0.02\n\t\telse\n\t\t\treturn 0\n\t\tend\n\tend",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "ConsumableType",
      "key": "Ephemeral",
      "name": "Ephemeral",
      "atlas": null,
      "pos": null,
      "raw": "key = 'Ephemeral',\n    shader = 'spectral',\n    primary_colour = HEX('59778c'),\n    secondary_colour = HEX('8ea4b3'),\n    collection_rows = { 5, 5 },\n    default = 'c_gb_sculpture',\n    shop_rate = 1,\n    cards = {\n        ['c_gb_chain'] = true,\n\t\t['c_gb_collapse'] = true,\n\t\t['c_gb_comet'] = true,\n\t\t['c_gb_diffusion'] = true,\n\t\t['c_gb_gold_dust'] = true,\n\t\t['c_gb_group'] = true,\n\t\t['c_gb_harlequin'] = true,\n\t\t['c_gb_hourglass'] = true,\n\t\t['c_gb_incense'] = true,\n\t\t['c_gb_magic'] = true,\n\t\t['c_gb_mirage'] = true,\n\t\t['c_gb_motley'] = true,\n\t\t['c_gb_plasma'] = true,\n\t\t['c_gb_portal'] = true,\n\t\t['c_gb_rust'] = true,\n\t\t['c_gb_sculpture'] = true,\n\t\t['c_gb_spark'] = true,\n\t\t['c_gb_spirit'] = true,\n\t\t['c_gb_vanish'] = true,\n\t\t['c_gb_wish'] = true,\n        },\n    loc_txt = {\n        name = \"Ephemeral\",\n        collection = \"Ephemeral Cards\",\n        undiscovered = {\n            name = \"Not Discovered\",\n            text = {\n                \"Purchase or use\",\n                \"this card in an\",\n                \"unseeded run to\",\n                \"learn what it does\"\n            }\n        }\n    }",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "ConsumableType",
      "key": "Hex",
      "name": "Hex",
      "atlas": null,
      "pos": null,
      "raw": "key = 'Hex',\n    shader = 'spectral',\n    primary_colour = HEX('4f5767'),\n    secondary_colour = HEX('807ead'),\n    collection_rows = { 7, 6 },\n    default = 'c_gb_nihilism',\n\tshop_rate = 0.5,\n    cards = {\n        ['c_gb_apparition'] = true,\n\t\t['c_gb_conceit'] = true,\n\t\t['c_gb_nihilism'] = true,\n\t\t['c_gb_pestilence'] = true,\n\t\t['c_gb_tyranny'] = true,\n\t\t['c_gb_war'] = true,\n        },\n    loc_txt = {\n        name = \"Hex\",\n        collection = \"Hex Cards\",\n        undiscovered = {\n            name = \"Not Discovered\",\n            text = {\n                \"Purchase or use\",\n                \"this card in an\",\n                \"unseeded run to\",\n                \"learn what it does\"\n            }\n        }\n    }",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Suit",
      "key": "Eyes",
      "name": null,
      "atlas": "gb_Suits",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = 'Eyes',\n\tcard_key = 'EYES',\n\n\tlc_atlas = 'gb_Suits',\n\tlc_ui_atlas = 'gb_SuitUI',\n\tlc_colour = HEX(\"673E79\"),\n\n\thc_atlas = 'gb_Suits_HC',\n\thc_ui_atlas = 'gb_SuitUI_HC',\n\thc_colour = HEX(\"9448A4\"),\n\n\tpos = { y = 0 },\n\tui_pos = { x = 0, y = 0 },\n\n\tin_pool = function(self, args)\n\t\treturn gb_is_suit_in_deck(\"gb_Eyes\")\n\tend",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "UndiscoveredSprite",
      "key": "Ephemeral",
      "name": null,
      "atlas": "Consumables",
      "pos": {
        "x": 3,
        "y": 2
      },
      "raw": "key = 'Ephemeral',\n    atlas = 'Consumables',\n    pos = { x = 3, y = 2 },",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "DrawStep",
      "key": "Ephemeral",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"Ephemeral\",\n    order = 0,\n    func = function(card, layer)\n        if card.ability.set == 'Ephemeral'\n        and (layer == 'card' or layer == 'both')\n        and card.sprite_facing == 'front'\n        and (card.config.center.discovered or card.bypass_discovery_center) then\n            card.children.center:draw_shader('voucher', nil, card.ARGS.send_to_shader)\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "gb_Blinds",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'gb_Blinds',\n    path = 'Blinds.png',\n    atlas_table = 'ANIMATION_ATLAS',\n    frames = 21,\n    px = 34,\n    py = 34",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "gb_Boosters",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"gb_Boosters\",\n\tpath = \"Boosters.png\",\n\tpx = 71,\n\tpy = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "gb_Consumables",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"gb_Consumables\",\n\tpath = \"Consumables.png\",\n\tpx = 71,\n\tpy = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "gb_Decks",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"gb_Decks\",\n\tpath = \"Decks.png\",\n\tpx = 71,\n\tpy = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "gb_Ephemerals",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"gb_Ephemerals\",\n\tpath = \"Ephemerals.png\",\n\tpx = 71,\n\tpy = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "gb_Enhancements",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"gb_Enhancements\",\n\tpath = \"Enhancements.png\",\n\tpx = 71,\n\tpy = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "gb_Jokers",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"gb_Jokers\",\n\tpath = \"Jokers.png\",\n\tpx = 71,\n\tpy = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "gb_Seals",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"gb_Seals\",\n\tpath = \"Seals.png\",\n\tpx = 71,\n\tpy = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "gb_ShatteredJokers",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"gb_ShatteredJokers\",\n\tpath = \"ShatteredJokers.png\",\n\tpx = 71,\n\tpy = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "gb_BossJokers",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"gb_BossJokers\",\n\tpath = \"BossJokers.png\",\n\tpx = 71,\n\tpy = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "gb_modicon",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"gb_modicon\",\n\tpath = \"icon.png\",\n\tpx = 34,\n\tpy = 34,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "gb_SuitUI",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"gb_SuitUI\",\n\tpath = \"Suit_UI.png\",\n\tpx = 18,\n\tpy = 18,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "gb_SuitUI_HC",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"gb_SuitUI_HC\",\n\tpath = \"Suit_UI_HC.png\",\n\tpx = 18,\n\tpy = 18,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "gb_Suits",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"gb_Suits\",\n\tpath = \"Suits.png\",\n\tpx = 71,\n\tpy = 95,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "gb_Suits_HC",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"gb_Suits_HC\",\n\tpath = \"Suits_HC.png\",\n\tpx = 71,\n\tpy = 95,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "gb_HexCards",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"gb_HexCards\",\n\tpath = \"HexCards.png\",\n\tpx = 71,\n\tpy = 95,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "gb_Hexes",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"gb_Hexes\",\n\tpath = \"Hexes.png\",\n\tpx = 71,\n\tpy = 95,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "gb_music1",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "vol = music_volume,\n    pitch = music_pitch,\n    key = \"gb_music1\",\n    path = \"gb_music1.ogg\",\n    select_music_track = function()\n        return (gb_config.custom_music == true and 10 ) or false\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "gb_music2",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "vol = music_volume,\n    pitch = music_pitch,\n    key = \"gb_music2\",\n    path = \"gb_music2.ogg\",\n    select_music_track = function()\n        return (gb_config.custom_music == true and G.booster_pack_sparkles and not G.booster_pack_sparkles.REMOVED and 11) or false\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "gb_music3",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "vol = music_volume,\n    pitch = music_pitch,\n    key = \"gb_music3\",\n    path = \"gb_music3.ogg\",\n    select_music_track = function()\n        return (gb_config.custom_music == true and G.booster_pack_meteors and not G.booster_pack_meteors.REMOVED and 11) or false\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "gb_music4",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "vol = music_volume,\n    pitch = music_pitch,\n    key = \"gb_music4\",\n    path = \"gb_music4.ogg\",\n    select_music_track = function()\n        return (gb_config.custom_music == true and G.shop and not G.shop.REMOVED and 11) or false\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "gb_music5",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "vol = music_volume,\n    pitch = music_pitch,\n    key = \"gb_music5\",\n    path = \"gb_music5.ogg\",\n    select_music_track = function()\n        return (gb_config.custom_music == true and G.GAME.blind and G.GAME.blind.boss and 11) or false\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    }
  ],
  "version": "v0.8p1"
}