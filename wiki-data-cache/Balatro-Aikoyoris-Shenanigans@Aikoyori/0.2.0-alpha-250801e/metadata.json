{
  "locMap": {
    "b_akyrs_letter_deck": {
      "name": "Letter Deck",
      "text": [
        "Letters-Only Deck",
        "with Scrabble Distribution",
        "and its {C:mult}Mult{} Enabled",
        "Play {C:akyrs_playable}as many{} cards",
        "as you want per hand",
        "{C:red}X#1#{} base Blind Size",
        "{C:red}+#2#{} Discards",
        "{C:attention}+#3#{} Hand Size"
      ],
      "type": "Back"
    },
    "b_akyrs_math_deck": {
      "name": "Math Deck",
      "text": [
        "Make Maths Expressions",
        "Get within {C:red,f:6}Â±{C:red}#1#%{}",
        "of the Blind Requirements",
        "Gain {C:akyrs_playable}+#3#{} selection per Ante"
      ],
      "type": "Back"
    },
    "b_akyrs_hardcore_challenges": {
      "name": "Hardcore Challenge Deck",
      "text": [
        ""
      ],
      "type": "Back"
    },
    "b_akyrs_scuffed_misprint": {
      "name": "Scuffed Misprint Deck",
      "text": [
        "Values of most cards",
        "are {C:attention}randomized{}",
        "{C:inactive}(From X#1# to X#2#)",
        "me vs the guy she tells you not to worry about"
      ],
      "type": "Back"
    },
    "b_akyrs_freedom": {
      "name": "Freedom Deck",
      "text": [
        "You can drag cards",
        "to place them anywhere."
      ],
      "type": "Back"
    },
    "b_akyrs_cry_misprint_ultima": {
      "name": "Ultima Misprint Deck",
      "text": [
        "Values of cards",
        "and poker hands",
        "are {C:attention}randomized{}",
        "{C:inactive}(From X#1# to X#2#)",
        "The challenge is to not crash the game."
      ],
      "type": "Back"
    },
    "bl_akyrs_the_thought": {
      "name": "The Thought",
      "text": [
        "Solve 5-letter puzzle to win!"
      ],
      "type": "Blind"
    },
    "bl_akyrs_the_libre": {
      "name": "The Libre",
      "text": [
        "Disabling this boss",
        "Sets Blind Req. to #1#"
      ],
      "type": "Blind"
    },
    "bl_akyrs_the_picker": {
      "name": "The Picker",
      "text": [
        "X#2# Score Requirement when you",
        "change the given card selection"
      ],
      "type": "Blind"
    },
    "bl_akyrs_the_height": {
      "name": "The Height",
      "text": [
        "Score Requirement becomes X#1#",
        "your round score on non-final hands"
      ],
      "type": "Blind"
    },
    "bl_akyrs_the_expiry": {
      "name": "The Expiry",
      "text": [
        "All consumables are",
        "permanently debuffed"
      ],
      "type": "Blind"
    },
    "bl_akyrs_the_nature": {
      "name": "The Nature",
      "text": [
        "Face cards (both held and played)",
        "give X#1# Mult each"
      ],
      "type": "Blind"
    },
    "bl_akyrs_the_key": {
      "name": "The Key",
      "text": [
        "Played cards have a #1# in #2#",
        "chance to be forever selected"
      ],
      "type": "Blind"
    },
    "bl_akyrs_final_periwinkle_pinecone": {
      "name": "Periwinkle Pinecone",
      "text": [
        "Sealed cards",
        "are debuffed"
      ],
      "type": "Blind"
    },
    "bl_akyrs_final_razzle_raindrop": {
      "name": "Razzle Raindrop",
      "text": [
        "Suits already played",
        "this round are debuffed"
      ],
      "type": "Blind"
    },
    "bl_akyrs_final_velvet_vapour": {
      "name": "Velvet Vapour",
      "text": [
        "Ranks already played",
        "this round are debuffed"
      ],
      "type": "Blind"
    },
    "bl_akyrs_final_chamomile_cloud": {
      "name": "Chamomile Cloud",
      "text": [
        "Cards with enhancements already played",
        "this round are debuffed"
      ],
      "type": "Blind"
    },
    "bl_akyrs_final_salient_stream": {
      "name": "Salient Stream",
      "text": [
        "Must alternate between",
        "Play and Discard"
      ],
      "type": "Blind"
    },
    "bl_akyrs_final_luminous_lemonade": {
      "name": "Luminous Lemonade",
      "text": [
        "-#1# Discards per hand played",
        "-#1# Hands per discards"
      ],
      "type": "Blind"
    },
    "bl_akyrs_final_glorious_glaive": {
      "name": "Glorious Glaive",
      "text": [
        "X#1# Mult per card played"
      ],
      "type": "Blind"
    },
    "bl_akyrs_final_lilac_lasso": {
      "name": "Lilac Lasso",
      "text": [
        "All but #1# Jokers randomly",
        "debuffed every hand"
      ],
      "type": "Blind"
    },
    "bl_akyrs_forgotten_weights_of_the_past": {
      "name": "Weights of the Past",
      "text": [
        "X#1# Ante per Card scored"
      ],
      "type": "Blind"
    },
    "bl_akyrs_forgotten_prospects_of_the_future": {
      "name": "Prospects of the Future",
      "text": [
        "+#1# Ante per Card held in hand"
      ],
      "type": "Blind"
    },
    "bl_akyrs_forgotten_uncertainties_of_life": {
      "name": "Uncertainties of Life",
      "text": [
        "-#1# hand size permanently after hand played"
      ],
      "type": "Blind"
    },
    "bl_akyrs_forgotten_inevitability_of_death": {
      "name": "Inevitability of Death",
      "text": [
        "Lose money at the end of the round",
        "By Final Score divided by Blind Requirement"
      ],
      "type": "Blind"
    },
    "bl_akyrs_expert_confrontation": {
      "name": "Confrontation",
      "text": [
        "Face cards must not be held in hand"
      ],
      "type": "Blind"
    },
    "bl_akyrs_expert_fluctuation": {
      "name": "Fluctuation",
      "text": [
        "Randomly multiply score by",
        "between #1# and #2# before hand played"
      ],
      "type": "Blind"
    },
    "bl_akyrs_expert_straightforwardness": {
      "name": "Straightforwardness",
      "text": [
        "All Hands starts with",
        "base #1# Chip and #2# Mult"
      ],
      "type": "Blind"
    },
    "bl_akyrs_expert_entanglement": {
      "name": "Entanglement",
      "text": [
        "All but one cards from each suit",
        "are drawn face down"
      ],
      "type": "Blind"
    },
    "bl_akyrs_expert_manuscript": {
      "name": "Manuscript",
      "text": [
        "Lose money per hand equal to",
        "played Poker Hand's Base Mult"
      ],
      "type": "Blind"
    },
    "bl_akyrs_expert_inflation": {
      "name": "Inflation",
      "text": [
        "Absurdly large blind"
      ],
      "type": "Blind"
    },
    "bl_akyrs_the_choice": {
      "name": "The Choice",
      "text": [
        "Played words must contain '#1#'"
      ],
      "type": "Blind"
    },
    "bl_akyrs_the_reject": {
      "name": "The Reject",
      "text": [
        "Played words must not contain '#1#'"
      ],
      "type": "Blind"
    },
    "bl_akyrs_the_redo": {
      "name": "The Redo",
      "text": [
        "Played words must not contain letter",
        "from last played words this Blind"
      ],
      "type": "Blind"
    },
    "bl_akyrs_the_reverse": {
      "name": "The Reverse",
      "text": [
        "Words must be played in reverse"
      ],
      "type": "Blind"
    },
    "bl_akyrs_master_faraway_island": {
      "name": "Faraway Island",
      "text": [
        "Hand must contain at least",
        "one card with no suit or rank",
        "(For example, Stone cards)"
      ],
      "type": "Blind"
    },
    "bl_akyrs_master_plywood_forest": {
      "name": "Plywood Forest",
      "text": [
        "All unplayed cards are destroyed",
        "at the end of the round"
      ],
      "type": "Blind"
    },
    "bl_akyrs_master_golden_jade": {
      "name": "Golden Jade",
      "text": [
        "X#1# your money per card scored"
      ],
      "type": "Blind"
    },
    "bl_akyrs_master_milk_crown_on_sonnetica": {
      "name": "Milk Crown on Sonnetica",
      "text": [
        "Set Mult to 0 if a King is scored"
      ],
      "type": "Blind"
    },
    "bl_akyrs_master_bug": {
      "name": "BUG",
      "text": [
        "One Random Joker destroyed",
        "per card played"
      ],
      "type": "Blind"
    },
    "dd_akyrs_maxwell_example": {
      "name": "Example",
      "text": [
        "{C:inactive,s:0.8}For example, Spelling {C:spectral,s:0.8}'Spectral'",
        "{C:inactive,s:0.8}gives you a {C:spectral,s:0.8}Spectral{C:inactive,s:0.8} Card"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_yona_yona_ex": {
      "name": "Visual Example",
      "text": [],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_2fa_example": {
      "name": "Example Hand",
      "text": [],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_credit_larantula": {
      "name": "Art Credit",
      "text": [
        "{X:dark_edition,C:white}@larantula_l{}"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_hibana_conditions": {
      "name": "Cycle Option",
      "text": [
        "{X:dark_edition,C:white}1{} - Aces",
        "{X:dark_edition,C:white}2{} - Face Cards",
        "{X:dark_edition,C:white}3{} - Hearts",
        "{X:dark_edition,C:white}4{} - 5"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_tldr_tldr": {
      "name": "Too Long; Ain't reading allat",
      "text": [
        "{C:mult}+#1#{} Mult per card",
        "played and in hand"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_tldr_tldr_absurd": {
      "name": "Too Long; Ain't reading allat",
      "text": [
        "{C:white,X:mult} X#1# {} Mult"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_aikoyori_base_ability": {
      "name": "Base Ability",
      "text": [
        "{X:mult,C:white} X#1# {} Mult per",
        "{C;attention}non-face{} cards scored"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_aikoyori_base_ability_absurd": {
      "name": "Base Ability",
      "text": [
        "{X:dark_edition,C:white} ^#1# {} Mult per",
        "{C;attention}non-face{} cards scored"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_aikoyori_cryptid_ability": {
      "name": "Cryptid Ability",
      "text": [
        "If hand only contains {C:attention}a single Ace{}",
        "Create a {C:dark_edition}Negative{} {C:green}Code{} card"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_aikoyori_more_fluff_ability": {
      "name": "More Fluff Ability",
      "text": [
        "Add {C:attention}1{} round to {C:colourcard}Colour Cards{}",
        "when they gain a round"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_aikoyori_entropy_ability": {
      "name": "Entropy Ability",
      "text": [
        "If {C:attention}full hand{} contains at least",
        "{C:attention}4{} cards of different rank and suit,",
        "create a {C:dark_edition}Negative{} {C:spectral}Flipside{}"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_aikoyori_sdmstuff_ability": {
      "name": "SDM_0's Stuff Ability",
      "text": [
        "If {C:attention}played hand{} contains",
        "a {C:attention}Full House{}, create a",
        "{C:dark_edition}Negative{} {C:attention}Bakery{} card"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_aikoyori_togasstuff_ability": {
      "name": "TOGA's Stuff Ability",
      "text": [
        "If you gain less than {C:money}$10{}",
        "at the end of the round,",
        "create a random Booster tag",
        "from {C:attention}TOGA's Stuff{}"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_cryptposting_ability": {
      "name": "Cryptposting Ability",
      "text": [
        "Create a {X:attention,E:1}Joker{} when",
        "Blind is skipped",
        "{C:inactive}(No room needed)"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_aikoyori_pta_ability": {
      "name": "Paya's Terrible Additions Ability",
      "text": [
        "Earn extra {C:blue}Pyroxenes{}",
        "equal to {C:money}money{} earned this round"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_placeholder_art": {
      "name": "Placeholder Art",
      "text": [
        "This card is using a",
        "{C:attention}Placeholder art.",
        "It will be changed later"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_prism_ability": {
      "name": "Prism Ability",
      "text": [
        "Create a Negative {C:attention}Myth Card{}",
        "if Hand doesn't contain a {C:attention}Flush"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_garbshit_ability": {
      "name": "GARBSHIT Ability",
      "text": [
        "Create a {C:dark_edition}Negative {C:attention}Stamp Card{}",
        "When a {C:attention}Joker{} is sold"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_finity_ability": {
      "name": "Finity Ability",
      "text": [
        "Create a {C:dark_edition}Negative {C:spectral}Finity{}",
        "When a {C:attention}Showdown{} Blind is defeated"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_bakery_ability": {
      "name": "Bakery Ability",
      "text": [
        "{C:dark_edition} +1 {}{C:attention} Charm{} available in shop{}"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_astronomica_ability": {
      "name": "Astronomica Ability",
      "text": [
        "{C:purple}Multiply score{} by",
        "number of cards played",
        "below hand size"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_mukuroju_en": {
      "name": "Mukuroju no Hakamori",
      "text": [
        "This Joker gains {X:mult,C:white} X#1# {} Mult",
        "per {C:tarot}The Star{} used",
        "{C:inactive}(Currently {X:mult,C:white} X#2# {C:inactive} Mult)"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_mukuroju_en_absurd": {
      "name": "Mukuroju no Hakamori",
      "text": [
        "This Joker {C:attention}octuples{} ({X:mult,C:white} X8 {})",
        "its {X:mult,C:white} XMult {} every time {C:tarot}The Star{} is used",
        "{C:inactive}(Currently {X:mult,C:white} X#1# {C:inactive} Mult)"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_nhh_cryptid": {
      "name": "If Cryptid is installed...",
      "text": [
        "Gives {X:dark_edition,C:white} ^#1# {} Mult instead"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_expert_blind": {
      "name": "Expert Blind",
      "text": [
        "Blind with higher",
        "difficulty than usual"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_master_blind": {
      "name": "Master Blind",
      "text": [
        "Blind with even higher",
        "difficulty level"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_ultima_blind": {
      "name": "Ultima Blind",
      "text": [
        "Extremely difficult blind",
        "{scale:0.7,C:inactive}(I feel like I've seen this somewhere)"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_remaster_blind": {
      "name": "Re:Master Blind",
      "text": [
        "Buffed version of existing blinds",
        "{scale:0.7,C:inactive}(I feel like I've seen this somewhere too)"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_lunatic_blind": {
      "name": "Lunatic Blind",
      "text": [
        "Even more difficult than Ultima Blinds",
        "{scale:0.7,C:inactive}(I feel like I've seen this somewhere as well)"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_dx_blind": {
      "name": "DX Blind",
      "text": [
        "Upgraded Ante 8 Blinds",
        "from More Fluff"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_no_reroll": {
      "name": "No Rerolling",
      "text": [
        "This blind cannot be rerolled"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_no_disabling": {
      "name": "No Disabling",
      "text": [
        "This blind cannot be disabled"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_no_overriding": {
      "name": "No Overriding",
      "text": [
        "This blind cannot be overridden",
        "until it's defeated"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_no_skipping": {
      "name": "No Skipping",
      "text": [
        "This blind cannot be skipped"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_forgotten_blind": {
      "name": "Forgotten Blind",
      "text": [
        "This blind can only appear",
        "in Negative Antes"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_word_blind": {
      "name": "Word Blind",
      "text": [
        "This blind can only appear",
        "when it is possible to",
        "play words"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_puzzle_blind": {
      "name": "Puzzle Blind",
      "text": [
        "This blind can only be defeated",
        "by completing certain criteria"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_postwin_blind": {
      "name": "Post Win Blind",
      "text": [
        "This blind appears on Antes",
        "above winning Ante"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_endless_blind": {
      "name": "Endless Blind",
      "text": [
        "This blind only appears",
        "in Endless Mode"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_kessoku_band": {
      "name": "{f:5}çµæãã³ã {}(Kessoku Band)",
      "text": [
        "This Joker looks like it",
        "wants to {C:akyrs_bocchi}R{C:akyrs_kita}o{C:akyrs_nijika}c{C:akyrs_ryou}k{}!"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_copper_scrape_tip": {
      "name": "Scraping",
      "text": [
        "Fixed {C:green}25% chance{} to {C:attention}scrape{} off",
        "{C:attention}a layer{} of oxidation when a consumable is {C:attention}used{}"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_break_up_tip": {
      "name": "Pure Cards",
      "text": [
        "{C:attention}Pure Cards{} can form {C:attention}Pure Hands",
        "{C:attention}Pure Hands{} give more",
        "base {C:chips}Chips{} and {C:mult}Mult",
        "but can only be played if played hand",
        "only has {C:attention}Pure Cards{}",
        "For example, this is a {C:attention}Pure Flush{}"
      ],
      "type": "DescriptionDummy"
    },
    "e_akyrs_texelated": {
      "name": "Texelated",
      "text": [
        "{C:white,X:chips}X#1#{} Chips",
        "{C:white,X:mult}X#2#{} Mult"
      ],
      "type": "Edition"
    },
    "e_akyrs_noire": {
      "name": "Noire",
      "text": [
        "{C:dark_edition}+#1#{} Card Limit",
        "{C:white,X:mult}X#2#{} Mult"
      ],
      "type": "Edition"
    },
    "e_akyrs_sliced": {
      "name": "Sliced",
      "text": [
        "{C:attention}Halves{} all values",
        "Triggers {C:attention}twice"
      ],
      "type": "Edition"
    },
    "e_akyrs_burnt": {
      "name": "Burnt",
      "text": [
        "{C:green}#1# in #2#{} chance",
        "of disintegrating into Ash",
        "at the end of the round"
      ],
      "type": "Edition"
    },
    "e_akyrs_enchanted": {
      "name": "Enchanted",
      "text": [
        "[WIP]"
      ],
      "type": "Edition"
    },
    "ench_akyrs_unbreaking": {
      "name": "Unbreaking",
      "text": [
        "When this card gets {C:attention}destroyed{}",
        "{C:attention}Fixed {C:green}#1#%{} chance to",
        "duplicate this card"
      ],
      "type": "Enchantment"
    },
    "ench_akyrs_effeciency": {
      "name": "Efficiency",
      "text": [
        "When this card gets {C:attention}destroyed{}",
        "{C:attention}Fixed {C:green}#1#%{} chance to",
        "duplicate this card"
      ],
      "type": "Enchantment"
    },
    "m_akyrs_brick_card": {
      "name": "Brick Card",
      "text": [
        "{C:mult}+#1#{} Mult",
        "No Rank or Suit"
      ],
      "type": "Enhanced"
    },
    "m_akyrs_scoreless": {
      "name": "Scoreless",
      "text": [
        "Does not score"
      ],
      "type": "Enhanced"
    },
    "m_akyrs_ash_card": {
      "name": "Ash Card",
      "text": [
        "{C:blue}+#1#{} Chips",
        "{C:green}#2# in #3#{} chance",
        "of disintegrating into nothing",
        "at the end of the round"
      ],
      "type": "Enhanced"
    },
    "m_akyrs_ash_card_absurd": {
      "name": "Ash Card",
      "text": [
        "{C:purple,X:edition} ^#1# {} Chips",
        "{C:attention}Always{} disintegrating into nothing",
        "at the end of the round"
      ],
      "type": "Enhanced"
    },
    "m_akyrs_hatena": {
      "name": "? Card",
      "text": [
        "{C:green}#1# in #2#{} chance to gain {C:money}$#3#",
        "{C:green}#4# in #5#{} chance to gain {C:money}$#6#",
        "{C:green}#7# in #8#{} chance to give {C:mult}+#9#{} Mult",
        "on initial scoring and {X:mult,C:white} X#10# {} on retriggers",
        "No rank, no suit, always scores"
      ],
      "type": "Enhanced"
    },
    "m_akyrs_item_box": {
      "name": "Item Box Card",
      "text": [
        "Create a {C:attention}random{}",
        "{C:tarot}consumable{} card when {C:attention}scored",
        "{C:inactive}(Must have room)",
        "{C:red,E:1}Self-destructs{} and the end of the round",
        "if successfully triggered",
        "No rank, no suit, always scores"
      ],
      "type": "Enhanced"
    },
    "m_akyrs_insolate_card": {
      "name": "Insolate Card",
      "text": [
        "This card gains {C:white,X:mult} X#1# {} Mult when scored",
        "if played hand {C:attention}does not contain{} a suit more than {C:attention}once",
        "{C:inactive}(Currently {C:white,X:mult} X#2# {} {C:mult}Mult{}{C:inactive}){}"
      ],
      "type": "Enhanced"
    },
    "m_akyrs_canopy_card": {
      "name": "Canopy Card",
      "text": [
        "Reduce the rank of this card by {C:attention}1{}",
        "if {C:attention}held in hand{} after scoring"
      ],
      "type": "Enhanced"
    },
    "m_akyrs_thai_tea_card": {
      "name": "Thai Tea Card",
      "text": [
        "{X:mult,C:white} X#1# {} Mult",
        "{C:inactive,s:0.8}The {s:0.8}absurd{C:inactive,s:0.8}ly good smell of it {s:0.8}alone",
        "{C:inactive,s:0.8}is sure to make any {s:0.8}Mouth{s:0.8} water{C:inactive,s:0.8}s"
      ],
      "type": "Enhanced"
    },
    "m_akyrs_matcha_card": {
      "name": "Matcha Card",
      "text": [
        "{X:chips,C:white} X#1# {} Chips"
      ],
      "type": "Enhanced"
    },
    "m_akyrs_earl_grey_tea_card": {
      "name": "Earl Grey Tea Card",
      "text": [
        "{C:money} +$#1#{} if this card is played",
        "but not scored"
      ],
      "type": "Enhanced"
    },
    "m_akyrs_zap_card": {
      "name": "Zap Card",
      "text": [
        "{C:attention}Duplicates{} itself",
        "without the enhancement",
        "every {C:attention}#1#{} {C:inactive}(#2#){} times",
        "this card scores"
      ],
      "type": "Enhanced"
    },
    "j_akyrs_redstone_repeater": {
      "name": "Redstone Repeater",
      "text": [
        "Swaps the current {C:white,X:mult} Mult {}",
        "with the stored {C:mult}Mult",
        "then {C:white,X:mult} X#2# {} Mult",
        "Start with X {C:white,X:mult}   #3#   {} {C:mult}Mult{}",
        "{C:inactive}(Currently X {C:white,X:mult}   #1#   {} {C:mult}Mult{}{C:inactive}){}"
      ],
      "type": "Joker"
    },
    "j_akyrs_redstone_repeater_absurd": {
      "name": "Redstone Repeater",
      "text": [
        "Swaps the current {C:white,X:mult} Mult {}",
        "with the stored {C:mult}Mult",
        "then {C:white,X:dark_edition} ^#2# {} Mult",
        "Start with X {C:white,X:mult}   #3#   {} {C:mult}Mult{}",
        "{C:inactive}(Currently X {C:white,X:mult}   #1#   {} {C:mult}Mult{}{C:inactive}){}"
      ],
      "type": "Joker"
    },
    "j_akyrs_observer": {
      "name": "Observer",
      "text": [
        "This Joker gains {C:mult}#1#{} Mult",
        "for every{C:attention} #4# {}times {C:inactive}(#3#)",
        "a card gets triggered.",
        "{s:0.8}Times needed increases by {C:attention}#5#{}",
        "{s:0.8}every time this Joker gains {C:mult}Mult{}",
        "{C:inactive}(Currently {C:mult}+#2#{C:inactive} Mult){}"
      ],
      "type": "Joker"
    },
    "j_akyrs_observer_absurd": {
      "name": "Observer",
      "text": [
        "This Joker gains {X:mult,C:white} X#1# {} Mult",
        "for every{C:attention} #4# {}times {C:inactive}(#3#)",
        "{C:chips}Chips{} or {C:mult}Mult{} value changes",
        "{s:0.8}Times needed increases by {C:attention}#5#{}",
        "{s:0.8}every time this Joker gains {X:mult,C:white}XMult{}",
        "{C:inactive}(Currently {X:mult,C:white} X#2# {C:inactive} Mult){}"
      ],
      "type": "Joker"
    },
    "j_akyrs_quasi_connectivity": {
      "name": "Quasi Connectivity",
      "text": [
        "{C:white,X:mult} X#1# {} Mult",
        "Disables one {C:attention}random Joker{}",
        "after a hand is played",
        "{s:0.8}Debuffs itself if it's",
        "{s:0.8}the sole card"
      ],
      "type": "Joker"
    },
    "j_akyrs_quasi_connectivity_absurd": {
      "name": "Quasi Connectivity",
      "text": [
        "{C:white,X:dark_edition} ^#1# {} Mult",
        "Disables two {C:attention}random Jokers{}",
        "after a hand is played",
        "{s:0.8}Debuffs itself if you have",
        "{s:0.8}2 Jokers or less"
      ],
      "type": "Joker"
    },
    "j_akyrs_diamond_pickaxe": {
      "name": "Diamond Pickaxe",
      "text": [
        "Gives {C:attention}#2#{} stacks of {C:chips}+#1#{} Chips",
        "for every {C:attention}Stone{} Card scored",
        "and change every scored {C:attention}Stone{} card",
        "to a random {C:attention}non-Stone Upgrades{}"
      ],
      "type": "Joker"
    },
    "j_akyrs_diamond_pickaxe_absurd": {
      "name": "Diamond Pickaxe",
      "text": [
        "After a hand is played, turn {C:attention}all{} cards",
        "you held into {C:attention}Stone Card{}",
        "Gives {C:attention}#2#{} stacks of {C:chips}+#1#{} Chips",
        "for every {C:attention}Stone{} Card scored",
        "and change every scored {C:attention}Stone{} card",
        "to a random {C:attention}non-Stone Upgrades{}"
      ],
      "type": "Joker"
    },
    "j_akyrs_netherite_pickaxe": {
      "name": "Netherite Pickaxe",
      "text": [
        "Gives {C:attention}#2#{} stacks of {C:chips}+#1#{} Chips",
        "for every {C:attention}Stone{} Card scored",
        "{C:red,E:1}Destroy all scored",
        "{C:attention,E:1}Stone{C:red,E:1} cards afterwards"
      ],
      "type": "Joker"
    },
    "j_akyrs_netherite_pickaxe_absurd": {
      "name": "Netherite Pickaxe",
      "text": [
        "Turn {C:attention}all Discarded{} cards",
        "into {C:attention}Stone Cards{}",
        "Gains {C:attention}#2#{} stacks of {X:chips,C:white} X#1# {} Chips",
        "for every {C:attention}Stone{} Card scored",
        "{C:red,E:1}Destroy all scored",
        "{C:attention,E:1}Stone{C:red,E:1} cards afterwards",
        "{C:inactive}(Currently {X:chips,C:white} X#3# {C:inactive} Chips){}"
      ],
      "type": "Joker"
    },
    "j_akyrs_utage_charts": {
      "name": "Utage Charts",
      "text": [
        "{C:akyrs_playable}+#1#{} Hand Selection"
      ],
      "type": "Joker"
    },
    "j_akyrs_maxwells_notebook": {
      "name": "Maxwell's Notebook",
      "text": [
        "Spelling the type of a card",
        "gives you {C:attention}one{} of that card",
        "Spelling enhancements enhance",
        "the {C:attention}scored card{} to the one you spelled",
        "{C:inactive}(Must have room)"
      ],
      "type": "Joker"
    },
    "j_akyrs_it_is_forbidden_to_dog": {
      "name": "It is forbidden to dog",
      "text": [
        "Debuffed Cards held in hand or played",
        "give {X:mult,C:white} X#1#{} Mult each",
        "{C:inactive,s:0.8}Now works properly on macOS :D!"
      ],
      "type": "Joker"
    },
    "j_akyrs_it_is_forbidden_to_dog_absurd": {
      "name": "It is forbidden to dog",
      "text": [
        "{C:attention}Unscored{} played cards",
        "give {X:dark_edition,C:white} ^#1#{} Mult each",
        "{C:attention}All{} unscored cards becomes {C:attention}Scoreless{}"
      ],
      "type": "Joker"
    },
    "j_akyrs_eat_pant": {
      "name": "eat pant",
      "text": [
        "If played hand contains exactly {C:attention}#1#{} cards",
        "This joker loses {X:mult,C:white} 1/#2# {} of its current Mult.",
        "for every played card and {C:red}destroys all scored cards{}",
        "{C:inactive}(Currently {X:mult,C:white} X#3# {C:inactive} Mult)",
        "{C:inactive}(Can underflow below {X:mult,C:white} X1 {C:inactive})"
      ],
      "type": "Joker"
    },
    "j_akyrs_eat_pant_absurd": {
      "name": "eat pant",
      "text": [
        "If played hand contains a {C:attention}Two Pair{}",
        "This joker gains {X:mult,C:white} X#2# {} Mult for every scored card",
        "{C:red}Destroys all played cards{}",
        "{C:inactive}(Currently {X:mult,C:white} X#3# {C:inactive} Mult)"
      ],
      "type": "Joker"
    },
    "j_akyrs_tsunagite": {
      "name": "{f:5,C:akyrs_luminous}ç³»ãã¦",
      "text": [
        "Played cards permanently gain {X:mult,C:white} X#2#{} Mult",
        "if played cards' {C:chips}chips{} is divisible by {C:attention}#1#"
      ],
      "type": "Joker"
    },
    "j_akyrs_tsunagite_absurd": {
      "name": "{f:5,C:akyrs_luminous}ç³»ãã¦{}",
      "text": [
        "Gives value listed",
        "Joker gain the value listed",
        "When a {C:tarot,T:c_wheel_of_fortune}Wheel of Fortune{} is used",
        "{C:tarot,T:c_wheel_of_fortune}Wheel of Fortune{} always fails"
      ],
      "type": "Joker"
    },
    "j_akyrs_yona_yona_dance": {
      "name": "Yona Yona Dance",
      "text": [
        "Retrigger each played {C:attention}4{} and {C:attention}7{}",
        "{C:attention}#1#{} additional times",
        "{C:inactive,s:0.9,f:akyrs_MochiyPopOne}ãªãã°è¸ãã«ãæãè¸ãã«ãæã§ã!{}"
      ],
      "type": "Joker"
    },
    "j_akyrs_tldr_joker": {
      "name": "TL;DR Joker",
      "text": [
        "In the immersive and strategic world of {C:attention,E:1,s:1.5}Balatro{}, a distinctive role is played by this special joker card,",
        "equipped with a potent ability known as the '{C:mult}+#1#{} Mult.' This ability dramatically enhances a player's score",
        "under specific conditions, primarily centered around the presence of any {C:attention}High Card{} in the hand, which includes",
        "but is not limited to traditional {C:attention}high-ranking cards{} like {C:attention}Aces, Kings, Queens, and Jacks.{}",
        "Even then, the ability of this card goes further. But let's not get ahead of ourselves by going through with it before learning that",
        "{C:attention,E:1,s:1.5}Balatro{} expands the definition of scoring to include key strategic cards that heighten gameplay impact.",
        "This transformative {C:mult}multiplier{} is not just an advantage but a central aspect of strategic planning in {C:attention,E:1,s:1.5}Balatro{}.",
        "It compels players to consider their hand composition carefully, aiming to incorporate {C:attention}High Cards{} and maximize benefits.",
        "Delving into the history of gambling, card games have been a corner{C:tarot}stone{} of gaming culture for centuries.",
        "by {C:attention}activating for every card in hand and at play{}, this ability ensures you will gain a high score by merely playing a {C:attention}High Card{}.",
        "From the ancient {C:white,X:red,f:4}ä¸­å½äºº{} who are credited with inventing playing cards in the {C:attention}9th century{} to the spread of card",
        "games across Europe during the {C:chips}Middle Ages{}, gambling has evolved into a sophisticated form of entertainment and strategy.",
        "The concept of {C:mult}multipliers{}, like the '{C:mult}+#1#{} Mult' in {C:attention,E:1,s:1.5}Balatro{}, echoes innovations in probability and risk-taking found",
        "throughout gambling history, where players sharpened their skills to navigate the {C:green}uncertainties of chance.{}",
        "These elements of chance and strategy create a rich tapestry of gameplay where players harness both their intuition and",
        "analytical abilities. The presence of the '{C:mult}+#1#{} Mult' deepens {C:attention,E:1,s:1.5}Balatro{}'s complexity, fostering a richly engaging",
        "environment where tactical decision-making is crucial. Players dynamically shift the game balance by leveraging the {C:mult}multiplier{},",
        "turning potential {C:chips}deficits{} into {C:dark_edition,E:1}commanding leads{}. Thus, the '{C:mult}+#1#{} Mult' feature isn't merely a rule but a critical",
        "strategic tool and an exhilarating element."
      ],
      "type": "Joker"
    },
    "j_akyrs_tldr_joker_absurd": {
      "name": "TL;DR Joker",
      "text": [
        "In the beginning, there was {C:attention,E:1,s:1.1}Balatro{} - not a deity, but something more complex - an ever-shuffling embodiment of {C:akyrs_playable}chaos{} wrapped in crisp, digital playing cards. The game exists",
        "in a liminal space between logic and {C:tarot}lunacy{}, math and mirage, where {C:green}probability{} becomes pliable and poker mutates into myth with each {C:blue}hand{}. In {C:attention,E:1,s:1.1}Balatro{}, one doesnât merely {E:2,C:attention}play{}",
        "poker. One communes with the improbable. Here, {C:attention}straights{} stretch into the surreal, and {C:attention}flushes whisper forbidden geometry. {C:akyrs_playable}The{} deck is alive, vibrating with potential energy",
        "and pixelated menace, as every draw feels like yanking {C:attention}Ceremonial Dagger{} from a haunted {C:attention}Mega Buffoon Pack{}. And looming large above the fray is the pantheon of the unholy: the",
        "Jokers. They are not jesters; they are gods. Mathematical spirits dressed as {C:akyrs_playable}clown{}s. Each Joker bends the rules, breaks them, and sometimes eats them whole, fueling strategies",
        "built on hubris, spreadsheets, and primal instinct alike. Enter the {C:attention}TL;DR Joker{}, a Joker whispered of in halls of madness and theory: a rectangular rune inscribed with a",
        "singular prophecy: â{C:white,X:mult} X#1# {} Mult if hand contains a high cardâ It is simple. It is divine. It is arbitrarily brilliant. Why {C:white,X:mult} X#1# {}? Why not {C:white,X:mult} X1.19542 {} Mult? Or {C:white,X:mult} X638.95 {}? Or {C:white,X:mult,f:6} XÏ {}",
        "Mult? Because {C:white,X:mult} X#1# {} is the sacred number of drama. Because three is the number of the holy sprit,  {C:attention}face cards{}, triangles in triforce, wheels on tricycles. Because to look upon a",
        "hand and see a {C:attention}King{}, and be told, {C:attention,E:1}âYou may multiply,â{} is to witness design at the intersection of {C:akyrs_playable}chaos{} theory and stylish arrogance. The {C:attention}TL;DR Joker{} does not beg for synergy.",
        "It {C:attention}demands{} reverence and vigilance. It turns high cards into sacred relics, their mere presence {C:spectral}summoning{} power. No longer are {C:attention}Jacks{} just teenage nobility in a velvet blazer of",
        "mid-value. Now they are conduits of cosmic {C:white,X:mult} XMult {}, bridges to {C:dark_edition}exponentia{}l escalation. And let us speak plainly of {C:attention}âhigh cardsâ{} - those royal specters of cardboard rank. The",
        "{C:attention}Jack{}, swaggering in adolescent cunning. The {C:attention}Queen{}, dangerous and divine. The {C:attention}King{}, a heavy-headed monarch wielding {C:attention}tax{} burdens and {C:white,X:mult} XMult {}ipliers alike. And the {C:attention}Ace{} -",
        "ambiguous, adaptable, alpha and omega, god-tier wildness incarnate. To draw one is {C:tarot}lucky{}. To play one is strategy. To combine one with {C:attention}TL;DR Joker{} is to summon an equation so",
        "violent, it punches through the spreadsheet matrix. Itâs not just a combo. Itâs a lifestyle. A statement. A mathematical swagger. Decks warp around it. You start seeking",
        "{C:attention}royalty{} not out of vanity, but devotion. The {C:hearts}hearts{} beat faster. The {C:spades}spades{} dig deeper. The {C:diamonds}diamonds{} glint with purpose. Even the {C:clubs}clubs{}, usually so brutish, now {C:attention}shimmer{} with",
        "refined potential. Every draw becomes a prayer: please, let it be a {C:attention}Queen{}. Or a {C:attention}King{}. Or her {C:attention}Jack{}. Because even if the poker hand is garbage, a single face card sanctifies it.",
        "{C:attention,E:1,s:1.1}Balatro{} becomes not a game of best hands, but of best {C:attention}conditions{} for value. A trash hand with a King is not trash - itâs a {C:white,X:mult} X#1# {}-fueled engine of consequence. Let us now wander",
        "backward in time - centuries before Jokers, before {C:attention,E:1,s:1.1}Balatro{}, before silicon and CPUs - back to 9th century {C:white,X:red,f:4}ä¸­å½{}, where {C:attention}playing cards{} began. There, amid scrolls and shadow puppets,",
        "the corner{C:tarot}stone{} of gaming was born. The uncertainty of paper, the dance of fate inked in {C:attention}characters{} and calligraphy. In that world, {C:green}luck{} was not an {C:attention}adversary{} - it was an",
        "{C:attention}elemental truth{}. {C:green}Dice{} were cast not for control, but for communion with the unknown. Chance was worshipped as a muse, not solved as a math problem. And so too, in {C:attention,E:1,s:1.1}Balatro{}, do",
        "we feel this ancient reverence for uncertainty. The {C:attention}TL;DR Joker{}, in its modern mask, is ancestor to those ancient principles. It is the phoenix feather embedded in a digital",
        "deck, the whisper of dynasties. It reminds us that no matter how far we've come - from silk cards to OLED screens - we are still haunted and humbled by the {C:green}uncertainties of",
        "chance{}. So when we draw a {C:attention}high card{}, and {C:attention}TL;DR Joker{} flickers into being, we do not merely multiply - we {C:attention}invoke{} the ancient. The timeless. The chaotic. We become both",
        "strategist and supplicant, mathematician and {C:red}myst{}ic. The run ends. The screen fades. The Joker remains. {C:attention}TL;DR Joker{}. {C:attention}High cards{}. High stakes. High living. It is not just a",
        "mechanic. It is a metaphor. {C:attention,E:1,s:1.1}Balatro{} teaches that success is built not only on full hands, but on full {C:hearts}hearts{}. Sometimes, all it takes is a King - and a Joker who notices"
      ],
      "type": "Joker"
    },
    "j_akyrs_reciprocal_joker": {
      "name": "Reciprocal Joker",
      "text": [
        "Set {X:mult,C:white}Mult{} to",
        "{X:chips,C:white}Chips{} divided by {X:mult,C:white}Mult{}"
      ],
      "type": "Joker"
    },
    "j_akyrs_reciprocal_joker_absurd": {
      "name": "Reciprocal Joker",
      "text": [
        "Set {X:chips,C:white}Chips{} to",
        "{X:mult,C:white}Mult{} divided by {X:chips,C:white}Chips{}"
      ],
      "type": "Joker"
    },
    "j_akyrs_kyoufuu_all_back": {
      "name": "Kyoufuu All Back",
      "text": [
        "Return previously {C:attention}played and discarded",
        "{C:attention and played{} cards back to deck"
      ],
      "type": "Joker"
    },
    "Partner": {
      "name": "smol Aiko",
      "text": [
        "Retrigger {C:attention}every{} card {C:attention}#1#{} times"
      ],
      "type": "Joker"
    },
    "Akyrs_Dialog": {
      "name": "",
      "text": [
        "Hello! Thank you and Welcome to {C:edition}Aikoyori's Shenanigans{}",
        "I am {E:2,C:dark_edition}Aikoyori{} and I will guide you through",
        "some necessary settings. Let's get started!"
      ],
      "type": "Joker"
    },
    "Other": {
      "name": "Self-Destructive",
      "text": [
        "{C:red}Self-Destructs{} at ",
        "the end of the round"
      ],
      "type": "Joker"
    },
    "Planet": {
      "name": "Ara",
      "text": [
        "{S:0.8}({S:0.8,V:1}lvl.#1#{S:0.8}){} Level up",
        "{C:attention}#2#",
        "{C:mult}+#3#{} Mult and",
        "{C:chips}+#4#{} chips"
      ],
      "type": "Joker"
    },
    "Spectral": {
      "name": "",
      "text": [],
      "type": "Joker"
    },
    "Stake": {
      "name": "Oxidising Stake",
      "text": [
        "Cards can have {C:attention}Oxidising{} Sticker",
        "{s:0.8}Applies White Stake"
      ],
      "type": "Joker"
    },
    "Tag": {
      "name": "Tag that spells Tag",
      "text": [
        "Gives a free",
        "{C:blue}Mega Alphabet Pack"
      ],
      "type": "Joker"
    },
    "Tarot": {
      "name": "The Wheel of Fortune (Modified)",
      "text": [
        "Does not do anything."
      ],
      "type": "Joker"
    },
    "Voucher": {
      "name": "Alphabet Soup",
      "text": [
        "{C:attention}Letters{} appear on playing cards",
        "Words can be made with playing cards"
      ],
      "type": "Joker"
    },
    "AikoyoriExtraBases": {
      "name": "Null",
      "text": [
        "No rank or suit"
      ],
      "type": "Joker"
    },
    "Sleeve": {
      "name": "Letter Sleeve",
      "text": [
        "Start with {C:red}Letters{} Enabled"
      ],
      "type": "Joker"
    },
    "Umbral": {
      "name": "Graduate",
      "text": [
        "Creates the last",
        "{C:akyrs_umbral_p,X:akyrs_umbral_y} Umbral {} card",
        "used during this run",
        "{s:0.8,C:akyrs_umbral_p,X:akyrs_umbral_y} Graduate {s:0.8} excluded"
      ],
      "type": "Joker"
    },
    "achievement_descriptions": {
      "name": "",
      "text": [],
      "type": "misc"
    },
    "achievement_names": {
      "name": "",
      "text": [],
      "type": "misc"
    },
    "blind_states": {
      "name": "",
      "text": [],
      "type": "misc"
    },
    "akyrs_balancing_wizard": {
      "name": "",
      "text": [],
      "type": "misc"
    },
    "challenge_names": {
      "name": "",
      "text": [],
      "type": "misc"
    },
    "hardcore_challenge_names": {
      "name": "",
      "text": [],
      "type": "misc"
    },
    "collabs": {
      "name": "",
      "text": [],
      "type": "misc"
    },
    "dictionary": {
      "name": "",
      "text": [],
      "type": "misc"
    },
    "high_scores": {
      "name": "",
      "text": [],
      "type": "misc"
    },
    "labels": {
      "name": "",
      "text": [],
      "type": "misc"
    },
    "poker_hand_descriptions": {
      "name": "",
      "text": [],
      "type": "misc"
    },
    "poker_hands": {
      "name": "",
      "text": [],
      "type": "misc"
    },
    "quips": {
      "name": "",
      "text": [],
      "type": "misc"
    },
    "ranks": {
      "name": "",
      "text": [],
      "type": "misc"
    },
    "suits_plural": {
      "name": "",
      "text": [],
      "type": "misc"
    },
    "suits_singular": {
      "name": "",
      "text": [],
      "type": "misc"
    },
    "tutorial": {
      "name": "",
      "text": [],
      "type": "misc"
    },
    "v_dictionary": {
      "name": "",
      "text": [],
      "type": "misc"
    },
    "v_text": {
      "name": "",
      "text": [],
      "type": "misc"
    }
  },
  "atlases": {
    "AikoyoriJokers": {
      "path": "AikoyoriJokers.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-250801e/AikoyoriJokers.png",
      "resolvedGitHubPath": "assets/1x/AikoyoriJokers.png"
    },
    "guestJokerArts": {
      "path": "guestJokerArts.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-250801e/guestJokerArts.png",
      "resolvedGitHubPath": "assets/1x/guestJokerArts.png"
    },
    "lettersStickers": {
      "path": "lettersStickers.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-250801e/lettersStickers.png",
      "resolvedGitHubPath": "assets/1x/lettersStickers.png"
    },
    "aikoyoriStickers": {
      "path": "aikoyoriStickersAndSeals.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-250801e/aikoyoriStickersAndSeals.png",
      "resolvedGitHubPath": "assets/1x/aikoyoriStickersAndSeals.png"
    },
    "cardUpgrades": {
      "path": "cardUpgrades.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-250801e/cardUpgrades.png",
      "resolvedGitHubPath": "assets/1x/cardUpgrades.png"
    },
    "deckBacks": {
      "path": "deckBacks.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-250801e/deckBacks.png",
      "resolvedGitHubPath": "assets/1x/deckBacks.png"
    },
    "consumablesAlphabetPacks": {
      "path": "consumablesAlphabetPacks.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-250801e/consumablesAlphabetPacks.png",
      "resolvedGitHubPath": "assets/1x/consumablesAlphabetPacks.png"
    },
    "aikoConstellationCards": {
      "path": "aikoConstellationCards.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-250801e/aikoConstellationCards.png",
      "resolvedGitHubPath": "assets/1x/aikoConstellationCards.png"
    },
    "aikoyoriBoosterPack": {
      "path": "aikoyoriBoosterPack.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-250801e/aikoyoriBoosterPack.png",
      "resolvedGitHubPath": "assets/1x/aikoyoriBoosterPack.png"
    },
    "aikoyoriBlindsChips": {
      "path": "aikoyoriBlindsChips.png",
      "px": 34,
      "py": 34,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-250801e/aikoyoriBlindsChips.png",
      "resolvedGitHubPath": "assets/1x/aikoyoriBlindsChips.png"
    },
    "aikoyoriBlindsChips2": {
      "path": "aikoyoriBlindsChips2.png",
      "px": 34,
      "py": 34,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-250801e/aikoyoriBlindsChips2.png",
      "resolvedGitHubPath": "assets/1x/aikoyoriBlindsChips2.png"
    },
    "aikoyoriVouchers": {
      "path": "aikoyoriVouchers.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-250801e/aikoyoriVouchers.png",
      "resolvedGitHubPath": "assets/1x/aikoyoriVouchers.png"
    },
    "aikoyoriSleeves": {
      "path": "aikoSleeves.png",
      "px": 73,
      "py": 95,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-250801e/aikoSleeves.png",
      "resolvedGitHubPath": "assets/1x/aikoSleeves.png"
    },
    "aikoyoriMiscIcons": {
      "path": "aikoyoriMiscIcons.png",
      "px": 34,
      "py": 34,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-250801e/aikoyoriMiscIcons.png",
      "resolvedGitHubPath": "assets/1x/aikoyoriMiscIcons.png"
    },
    "larantula_l_credits": {
      "path": "credits/larantula_l.png",
      "px": 400,
      "py": 400,
      "resolvedGitHubPath": "assets/1x/credits/larantula_l.png"
    },
    "aikoyori_credits": {
      "path": "aikoyoriP.png",
      "px": 320,
      "py": 320,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-250801e/aikoyoriP.png",
      "resolvedGitHubPath": "assets/1x/aikoyoriP.png"
    },
    "aikoyoriTags": {
      "path": "aikoyoriTags.png",
      "px": 34,
      "py": 34,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-250801e/aikoyoriTags.png",
      "resolvedGitHubPath": "assets/1x/aikoyoriTags.png"
    },
    "togasstuff_crossmod": {
      "path": "crossmod/togasstuff.png",
      "px": 72,
      "py": 95,
      "resolvedGitHubPath": "assets/1x/crossmod/togasstuff.png"
    },
    "blank": {
      "path": "blank.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-250801e/blank.png",
      "resolvedGitHubPath": "assets/1x/blank.png"
    },
    "18blank": {
      "path": "blank.png",
      "px": 18,
      "py": 18,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-250801e/blank.png",
      "resolvedGitHubPath": "assets/1x/blank.png"
    },
    "special_suit_icon": {
      "path": "specialsuiticons.png",
      "px": 18,
      "py": 18,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-250801e/specialsuiticons.png",
      "resolvedGitHubPath": "assets/1x/specialsuiticons.png"
    },
    "villager": {
      "path": "villager.png",
      "px": 111,
      "py": 161,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-250801e/villager.png",
      "resolvedGitHubPath": "assets/1x/villager.png"
    },
    "aikoyori_intro": {
      "path": "aikoyoriintro.png",
      "px": 114,
      "py": 174,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-250801e/aikoyoriintro.png",
      "resolvedGitHubPath": "assets/1x/aikoyoriintro.png"
    },
    "umbra": {
      "path": "aikoUmbraTarot.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-250801e/aikoUmbraTarot.png",
      "resolvedGitHubPath": "assets/1x/aikoUmbraTarot.png"
    },
    "umbra_undisc": {
      "path": "undiscoveredUmbra.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-250801e/undiscoveredUmbra.png",
      "resolvedGitHubPath": "assets/1x/undiscoveredUmbra.png"
    },
    "rank_suit_cards": {
      "path": "ranksuitCards.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-250801e/ranksuitCards.png",
      "resolvedGitHubPath": "assets/1x/ranksuitCards.png"
    },
    "aikoPlanets": {
      "path": "aikoPlanetCards.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-250801e/aikoPlanetCards.png",
      "resolvedGitHubPath": "assets/1x/aikoPlanetCards.png"
    },
    "aikoStakes": {
      "path": "aikoyoriStakes.png",
      "px": 29,
      "py": 29,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-250801e/aikoyoriStakes.png",
      "resolvedGitHubPath": "assets/1x/aikoyoriStakes.png"
    },
    "aikoStakeStickers": {
      "path": "aikoyoriStakeStickers.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-250801e/aikoyoriStakeStickers.png",
      "resolvedGitHubPath": "assets/1x/aikoyoriStakeStickers.png"
    },
    "aikoPartners": {
      "path": "aikoPartners.png",
      "px": 46,
      "py": 58,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-250801e/aikoPartners.png",
      "resolvedGitHubPath": "assets/1x/aikoPartners.png"
    }
  },
  "cards": [
    {
      "type": "Atlas",
      "key": "AikoyoriJokers",
      "atlas": null,
      "pos": null,
      "raw": "key = \"AikoyoriJokers\",\r\n    path = \"AikoyoriJokers.png\",\r\n    px = 71,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "guestJokerArts",
      "atlas": null,
      "pos": null,
      "raw": "key = \"guestJokerArts\",\r\n    path = \"guestJokerArts.png\",\r\n    px = 71,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "lettersStickers",
      "atlas": null,
      "pos": null,
      "raw": "key = \"lettersStickers\",\r\n    path = \"lettersStickers.png\",\r\n    px = 71,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "aikoyoriStickers",
      "atlas": null,
      "pos": null,
      "raw": "key = \"aikoyoriStickers\",\r\n    path = \"aikoyoriStickersAndSeals.png\",\r\n    px = 71,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "cardUpgrades",
      "atlas": null,
      "pos": null,
      "raw": "key = \"cardUpgrades\",\r\n    path = \"cardUpgrades.png\",\r\n    px = 71,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "deckBacks",
      "atlas": null,
      "pos": null,
      "raw": "key = \"deckBacks\",\r\n    path = \"deckBacks.png\",\r\n    px = 71,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "consumablesAlphabetPacks",
      "atlas": null,
      "pos": null,
      "raw": "key = \"consumablesAlphabetPacks\",\r\n    path = \"consumablesAlphabetPacks.png\",\r\n    px = 71,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "aikoConstellationCards",
      "atlas": null,
      "pos": null,
      "raw": "key = \"aikoConstellationCards\",\r\n    path = \"aikoConstellationCards.png\",\r\n    px = 71,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "aikoyoriBoosterPack",
      "atlas": null,
      "pos": null,
      "raw": "key = \"aikoyoriBoosterPack\",\r\n    path = \"aikoyoriBoosterPack.png\",\r\n    px = 71,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "aikoyoriBlindsChips",
      "atlas": null,
      "pos": null,
      "raw": "key = \"aikoyoriBlindsChips\",\r\n    path = \"aikoyoriBlindsChips.png\",\r\n    px = 34,\r\n    py = 34,\r\n    atlas_table = 'ANIMATION_ATLAS',\r\n    frames = 21,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "aikoyoriBlindsChips2",
      "atlas": null,
      "pos": null,
      "raw": "key = \"aikoyoriBlindsChips2\",\r\n    path = \"aikoyoriBlindsChips2.png\",\r\n    px = 34,\r\n    py = 34,\r\n    atlas_table = 'ANIMATION_ATLAS',\r\n    frames = 21,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "aikoyoriVouchers",
      "atlas": null,
      "pos": null,
      "raw": "key = \"aikoyoriVouchers\",\r\n    path = \"aikoyoriVouchers.png\",\r\n    px = 71,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "aikoyoriSleeves",
      "atlas": null,
      "pos": null,
      "raw": "key = \"aikoyoriSleeves\",\r\n    path = \"aikoSleeves.png\",\r\n    px = 73,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "aikoyoriMiscIcons",
      "atlas": null,
      "pos": null,
      "raw": "key = \"aikoyoriMiscIcons\",\r\n    path = \"aikoyoriMiscIcons.png\",\r\n    px = 34,\r\n    py = 34",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "larantula_l_credits",
      "atlas": null,
      "pos": null,
      "raw": "key = \"larantula_l_credits\",\r\n    path = \"credits/larantula_l.png\",\r\n    px = 400,\r\n    py = 400",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "aikoyori_credits",
      "atlas": null,
      "pos": null,
      "raw": "key = \"aikoyori_credits\",\r\n    path = \"aikoyoriP.png\",\r\n    px = 320,\r\n    py = 320",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "aikoyoriTags",
      "atlas": null,
      "pos": null,
      "raw": "key = \"aikoyoriTags\",\r\n    path = \"aikoyoriTags.png\",\r\n    px = 34,\r\n    py = 34",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "modicon",
      "atlas": null,
      "pos": null,
      "raw": "key = \"modicon\",\r\n    path = \"aikoyoriModIcon.png\",\r\n    px = 32,\r\n    py = 32",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "togasstuff_crossmod",
      "atlas": null,
      "pos": null,
      "raw": "key = \"togasstuff_crossmod\",\r\n    path = \"crossmod/togasstuff.png\",\r\n    px = 72,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "blank",
      "atlas": null,
      "pos": null,
      "raw": "key = \"blank\",\r\n    path = \"blank.png\",\r\n    px = 71,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "18blank",
      "atlas": null,
      "pos": null,
      "raw": "key = \"18blank\",\r\n    path = \"blank.png\",\r\n    px = 18,\r\n    py = 18",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "special_suit_icon",
      "atlas": null,
      "pos": null,
      "raw": "key = \"special_suit_icon\",\r\n    path = \"specialsuiticons.png\",\r\n    px = 18,\r\n    py = 18",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "villager",
      "atlas": null,
      "pos": null,
      "raw": "key = 'villager',\r\n    path = 'villager.png',\r\n    px = 111,\r\n    py = 161",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "aikoyori_intro",
      "atlas": null,
      "pos": null,
      "raw": "key = 'aikoyori_intro',\r\n    path = 'aikoyoriintro.png',\r\n    px = 114,\r\n    py = 174",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "umbra",
      "atlas": null,
      "pos": null,
      "raw": "key = \"umbra\",\r\n    path = \"aikoUmbraTarot.png\",\r\n    px = 71,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "umbra_undisc",
      "atlas": null,
      "pos": null,
      "raw": "key = \"umbra_undisc\",\r\n    path = \"undiscoveredUmbra.png\",\r\n    px = 71,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "rank_suit_cards",
      "atlas": null,
      "pos": null,
      "raw": "key = \"rank_suit_cards\",\r\n    path = \"ranksuitCards.png\",\r\n    px = 71,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "aikoPlanets",
      "atlas": null,
      "pos": null,
      "raw": "key = \"aikoPlanets\",\r\n    path = \"aikoPlanetCards.png\",\r\n    px = 71,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "aikoStakes",
      "atlas": null,
      "pos": null,
      "raw": "key = \"aikoStakes\",\r\n    path = \"aikoyoriStakes.png\",\r\n    px = 29,\r\n    py = 29",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "aikoStakeStickers",
      "atlas": null,
      "pos": null,
      "raw": "key = \"aikoStakeStickers\",\r\n    path = \"aikoyoriStakeStickers.png\",\r\n    px = 71,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Shader",
      "key": "texelated",
      "atlas": null,
      "pos": null,
      "raw": "key = \"texelated\",\r\n    path = \"texelated.fs\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Shader",
      "key": "noire",
      "atlas": null,
      "pos": null,
      "raw": "key = \"noire\",\r\n    path = \"noire.fs\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Shader",
      "key": "sliced",
      "atlas": null,
      "pos": null,
      "raw": "key = \"sliced\",\r\n    path = \"sliced.fs\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Shader",
      "key": "trimmed_flame",
      "atlas": null,
      "pos": null,
      "raw": "key = \"trimmed_flame\",\r\n    path = \"trimmed_flame.fs\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Shader",
      "key": "magenta_tint",
      "atlas": null,
      "pos": null,
      "raw": "key = \"magenta_tint\",\r\n    path = \"magenta_letter_tint.fs\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Shader",
      "key": "burnt",
      "atlas": null,
      "pos": null,
      "raw": "key = \"burnt\",\r\n    path = \"burnt.fs\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Shader",
      "key": "enchanted",
      "atlas": null,
      "pos": null,
      "raw": "key = \"enchanted\",\r\n    path = \"enchanted.fs\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Shader",
      "key": "color_shift",
      "atlas": null,
      "pos": null,
      "raw": "key = \"color_shift\",\r\n    path = \"color_shift.fs\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Rank",
      "key": "non_playing",
      "atlas": "blank",
      "pos": null,
      "raw": "key = \"non_playing\",\r\n    card_key = \"SP\",\r\n    pos = { x = 0 },\r\n    lc_atlas = 'blank',\r\n    hc_atlas = 'blank',\r\n    nominal = 0,\r\n    suit_map = {\r\n        akyrs_joker = 0\r\n    },\r\n    shorthand = \"-\",\r\n    strength_effect = {\r\n        ignore = true\r\n    },\r\n    in_pool = function (self, args)\r\n        return false\r\n    end,\r\n    inject = function(self)\r\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Suit",
      "key": "joker",
      "atlas": "blank",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"joker\",\r\n    card_key = \"j\",\r\n    pos = { y = 0 },\r\n    ui_pos = { x = 0, y = 0 },\r\n    akyrs_hidden = true,\r\n    lc_atlas = 'blank',\r\n    hc_atlas = 'blank',\r\n    lc_ui_atlas  = 'special_suit_icon',\r\n    hc_ui_atlas  = 'special_suit_icon',\r\n    \r\n    inject = function(self)\r\n        --SMODS.inject_p_card(self, SMODS.Ranks[l.key])\r\n    end,\r\n    lc_colour = AKYRS.C.JOKER_LC,\r\n    hc_colour = AKYRS.C.JOKER_HC,\r\n    in_pool = function (self, args)\r\n        return false\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Suit",
      "key": "consumable",
      "atlas": "blank",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"consumable\",\r\n    card_key = \"c\",\r\n    pos = { y = 0 },\r\n    ui_pos = { x = 1, y = 0 },\r\n    akyrs_hidden = true,\r\n    lc_atlas = 'blank',\r\n    hc_atlas = 'blank',\r\n    lc_ui_atlas  = 'special_suit_icon',\r\n    hc_ui_atlas  = 'special_suit_icon',\r\n    \r\n    inject = function(self)\r\n        --SMODS.inject_p_card(self, SMODS.Ranks[l.key])\r\n    end,\r\n    lc_colour = AKYRS.C.CONSU_LC,\r\n    hc_colour = AKYRS.C.CONSU_HC,\r\n    in_pool = function (self, args)\r\n        return false\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Suit",
      "key": "booster",
      "atlas": "blank",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"booster\",\r\n    card_key = \"b\",\r\n    pos = { y = 0 },\r\n    ui_pos = { x = 2, y = 0 },\r\n    akyrs_hidden = true,\r\n    lc_atlas = 'blank',\r\n    hc_atlas = 'blank',\r\n    lc_ui_atlas  = 'special_suit_icon',\r\n    hc_ui_atlas  = 'special_suit_icon',\r\n    \r\n    inject = function(self)\r\n        --SMODS.inject_p_card(self, SMODS.Ranks[l.key])\r\n    end,\r\n    lc_colour = AKYRS.C.BOOST_LC,\r\n    hc_colour = AKYRS.C.BOOST_HC,\r\n    in_pool = function (self, args)\r\n        return false\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Suit",
      "key": "voucher",
      "atlas": "blank",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"voucher\",\r\n    card_key = \"v\",\r\n    pos = { y = 0 },\r\n    ui_pos = { x = 3, y = 0 },\r\n    akyrs_hidden = true,\r\n    lc_atlas = 'blank',\r\n    hc_atlas = 'blank',\r\n    lc_ui_atlas  = 'special_suit_icon',\r\n    hc_ui_atlas  = 'special_suit_icon',\r\n    \r\n    inject = function(self)\r\n        --SMODS.inject_p_card(self, SMODS.Ranks[l.key])\r\n    end,\r\n    lc_colour = AKYRS.C.VOUCH_LC,\r\n    hc_colour = AKYRS.C.VOUCH_HC,\r\n    in_pool = function (self, args)\r\n        return false\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Suit",
      "key": "thing",
      "atlas": "blank",
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "key = \"thing\",\r\n    card_key = \"th\",\r\n    pos = { y = 0 },\r\n    ui_pos = { x = 4, y = 0 },\r\n    akyrs_hidden = true,\r\n    lc_atlas = 'blank',\r\n    hc_atlas = 'blank',\r\n    lc_ui_atlas  = 'special_suit_icon',\r\n    hc_ui_atlas  = 'special_suit_icon',\r\n    \r\n    inject = function(self)\r\n        --SMODS.inject_p_card(self, SMODS.Ranks[l.key])\r\n    end,\r\n    lc_colour = AKYRS.C.THING_LC,\r\n    hc_colour = AKYRS.C.THING_HC,\r\n    in_pool = function (self, args)\r\n        return false\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Gradient",
      "key": "akyrs_mod_title",
      "atlas": null,
      "pos": null,
      "raw": "key = \"akyrs_mod_title\",\r\n    colours = {\r\n        HEX(\"ef4444\"),\r\n        HEX(\"eab308\"),\r\n        HEX(\"2dd4bf\"),\r\n    },\r\n    cycle = 5",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Gradient",
      "key": "akyrs_unset_letter",
      "atlas": null,
      "pos": null,
      "raw": "key = \"akyrs_unset_letter\",\r\n    colours = {\r\n        G.C.GREEN,\r\n        G.C.BLUE,\r\n        G.C.RED,\r\n    },\r\n    cycle = 1",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Gradient",
      "key": "akyrs_luminous",
      "atlas": null,
      "pos": null,
      "raw": "key = \"akyrs_luminous\",\r\n    colours = {\r\n        HEX(\"ff71b1\"),\r\n        HEX(\"48a2ff\"),\r\n        HEX(\"f29d2e\"),\r\n    },\r\n    cycle = 10",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Gradient",
      "key": "akyrs_glorious",
      "atlas": null,
      "pos": null,
      "raw": "key = \"akyrs_glorious\",\r\n    colours = {\r\n        HEX(\"47cbff\"),\r\n        HEX(\"a98dda\"),\r\n        HEX(\"ff58bb\"),\r\n    },\r\n    cycle = 10",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Gradient",
      "key": "akyrs_money_x",
      "atlas": null,
      "pos": null,
      "raw": "key = \"akyrs_money_x\",\r\n    colours = {\r\n        HEX(\"ffea29\"),\r\n        HEX(\"6e914a\"),\r\n        HEX(\"319137\"),\r\n    },\r\n    cycle = 10",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Gradient",
      "key": "akyrs_money_c",
      "atlas": null,
      "pos": null,
      "raw": "key = \"akyrs_money_c\",\r\n    colours = {\r\n        HEX(\"319137\"),\r\n        HEX(\"ffea29\"),\r\n        HEX(\"bfe34b\"),\r\n    },\r\n    cycle = 10",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Gradient",
      "key": "akyrs_money_c",
      "atlas": null,
      "pos": null,
      "raw": "key = \"akyrs_money_c\",\r\n    colours = {\r\n        HEX(\"319137\"),\r\n        HEX(\"ffea29\"),\r\n    },\r\n    cycle = 10",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "cry_misprint_ultima",
      "atlas": "deckBacks",
      "pos": {
        "x": 6,
        "y": 0
      },
      "raw": "key = \"cry_misprint_ultima\",\r\n        atlas = \"deckBacks\",\r\n        pos = { x = 6, y = 0},\r\n        config = { cry_misprint_min = 1e-4, cry_misprint_max = 1e4 },\r\n        set_badges = function (self, card, badges)\r\n            SMODS.create_mod_badges({ mod = Cryptid }, badges)\r\n        end,\r\n        loc_vars = function (self, info_queue, card)\r\n            return {\r\n                vars = {\r\n                    self.config.cry_misprint_min,\r\n                    self.config.cry_misprint_max\r\n                }\r\n            }\r\n        end,\r\n        apply = function(self)\r\n            G.GAME.modifiers.cry_misprint_min = (G.GAME.modifiers.cry_misprint_min or to_big(1)) * self.config.cry_misprint_min\r\n            G.GAME.modifiers.cry_misprint_max = (G.GAME.modifiers.cry_misprint_max or to_big(1)) * self.config.cry_misprint_max\r\n        end,",
      "config": {
        "cry_misprint_min": 0.0001,
        "cry_misprint_max": 10000
      },
      "ability": {
        "cry_misprint_min": 0.0001,
        "cry_misprint_max": 10000
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "aikoPartners",
      "atlas": null,
      "pos": null,
      "raw": "key = \"aikoPartners\",\r\n        path = \"aikoPartners.png\",\r\n        px = 46,\r\n        py = 58",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "toga_charmap",
      "atlas": "togasstuff_crossmod",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"toga_charmap\",\r\n        atlas = \"togasstuff_crossmod\",\r\n        rarity = 1,\r\n        cost = 3,\r\n        pos = { x = 0, y = 0},\r\n        in_pool = function (self, args)\r\n            return G.GAME.akyrs_character_stickers_enabled\r\n        end,\r\n        set_badges = function (self, card, badges)\r\n            SMODS.create_mod_badges({ mod = togabalatro },badges)\r\n        end,\r\n        config = {\r\n            extras = { money = 1 }\r\n        },\r\n        blueprint_compat = true,\r\n        calculate = function (self, card, context)\r\n            if context.joker_main and G.GAME.akyrs_character_stickers_enabled then\r\n                local w = AKYRS.get_letter_freq_from_cards(G.play.cards)\r\n                local max_freq = 0\r\n                local most_common_letter = nil\r\n                for letter, freq in pairs(w) do\r\n                    if freq > max_freq then\r\n                        max_freq = freq\r\n                        most_common_letter = letter\r\n                    elseif freq == max_freq then\r\n                        most_common_letter = nil -- Tie, no single most common letter\r\n                    end\r\n                end\r\n                if most_common_letter then\r\n                    return {\r\n                        func = function ()\r\n                            if AKYRS.has_room(G.consumeables) then\r\n                                SMODS.add_card({area = G.consumeables, set = 'Alphabet', key = 'c_akyrs_'..most_common_letter})\r\n                            end\r\n                        end\r\n                    }\r\n                end\r\n            end\r\n        end",
      "config": {
        "extras": {
          "money": 1
        }
      },
      "ability": {
        "extras": {
          "money": 1
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "toga_winword",
      "atlas": "togasstuff_crossmod",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"toga_winword\",\r\n        atlas = \"togasstuff_crossmod\",\r\n        pos = { x = 1, y = 0},\r\n        in_pool = function (self, args)\r\n            return G.GAME.akyrs_character_stickers_enabled\r\n        end,\r\n        set_badges = function (self, card, badges)\r\n            SMODS.create_mod_badges({ mod = togabalatro },badges)\r\n        end,\r\n        loc_vars = function (self, info_queue, card)\r\n            return {\r\n                vars = {\r\n                    card.ability.extras.xmult_gain,\r\n                    card.ability.extras.xmult\r\n                }\r\n            }\r\n        end,\r\n        rarity = 3,\r\n        cost = 8,\r\n        config = {\r\n            extras = { xmult_gain = 0.1992, xmult = 1 }\r\n        },\r\n        calculate = function (self, card, context)\r\n            if context.individual and context.cardarea == G.play then\r\n                if G.GAME.aiko_current_word and not context.blueprint then\r\n                    return {\r\n                        message = localize(\"k_upgrade_ex\"),\r\n                        func = function ()\r\n                            card.ability.extras.xmult = card.ability.extras.xmult + card.ability.extras.xmult_gain\r\n                        end\r\n                    }\r\n                end\r\n            end\r\n            if context.joker_main then\r\n                return {\r\n                    xmult = card.ability.extras.xmult\r\n                }\r\n            end\r\n        end,\r\n        blueprint_compat = true",
      "config": {
        "extras": {
          "xmult_gain": 0.1992,
          "xmult": 1
        }
      },
      "ability": {
        "extras": {
          "xmult_gain": 0.1992,
          "xmult": 1
        }
      },
      "vars": [
        0.1992,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Achievement",
      "key": "spell_aikoyori",
      "atlas": "icons",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"spell_aikoyori\",\n    atlas = \"icons\",\n    pos = {x = 3, y = 0},\n    hidden_pos = {x = 0, y = 1},\n    prefix_config = {\n        atlas = false\n    },\n    hidden_name = false,\n    hidden_text = true,\n    bypass_all_unlocked = true,\n    unlock_condition = function (self, args)\n        if args and (args.type == \"akyrs_spell_word\" and args.lowercase_word == \"aikoyori\") then\n            return true\n        end\n    end",
      "config": {
        "atlas": false
      },
      "ability": {
        "atlas": false
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Achievement",
      "key": "happy_ghast_grown",
      "atlas": "icons",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"happy_ghast_grown\",\n    atlas = \"icons\",\n    pos = {x = 3, y = 0},\n    hidden_pos = {x = 0, y = 1},\n    prefix_config = {\n        atlas = false\n    },\n    bypass_all_unlocked = true,\n    unlock_condition = function (self, args)\n        if args and (args.type == \"akyrs_happy_ghast_grown_from_dried\") then\n            return true\n        end\n    end",
      "config": {
        "atlas": false
      },
      "ability": {
        "atlas": false
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Achievement",
      "key": "repeater_into_another_one",
      "atlas": "icons",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"repeater_into_another_one\",\n    atlas = \"icons\",\n    pos = {x = 3, y = 0},\n    hidden_pos = {x = 0, y = 1},\n    prefix_config = {\n        atlas = false\n    },\n    bypass_all_unlocked = true,\n    unlock_condition = function (self, args)\n        if args and (args.type == \"akyrs_repeater_into_another_one\") then\n            return true\n        end\n    end",
      "config": {
        "atlas": false
      },
      "ability": {
        "atlas": false
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Achievement",
      "key": "repeater_into_another_one",
      "atlas": "icons",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"repeater_into_another_one\",\n    atlas = \"icons\",\n    pos = {x = 3, y = 0},\n    hidden_pos = {x = 0, y = 1},\n    prefix_config = {\n        atlas = false\n    },\n    bypass_all_unlocked = true,\n    unlock_condition = function (self, args)\n        if args and (args.type == \"akyrs_repeater_into_another_one\") then\n            return true\n        end\n    end",
      "config": {
        "atlas": false
      },
      "ability": {
        "atlas": false
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Achievement",
      "key": "both_pickaxe",
      "atlas": "icons",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"both_pickaxe\",\n    atlas = \"icons\",\n    pos = {x = 3, y = 0},\n    hidden_pos = {x = 0, y = 1},\n    prefix_config = {\n        atlas = false\n    },\n    bypass_all_unlocked = true,\n    unlock_condition = function (self, args)\n        if args and (args.type == \"akyrs_both_pickaxe\") then\n            return true\n        end\n    end",
      "config": {
        "atlas": false
      },
      "ability": {
        "atlas": false
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Achievement",
      "key": "win_klondike",
      "atlas": "icons",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"win_klondike\",\n    atlas = \"icons\",\n    pos = {x = 3, y = 0},\n    hidden_pos = {x = 0, y = 1},\n    prefix_config = {\n        atlas = false\n    },\n    bypass_all_unlocked = true,\n    unlock_condition = function (self, args)\n        if args and (args.type == \"akyrs_win_solitaire\") then\n            return true\n        end\n    end",
      "config": {
        "atlas": false
      },
      "ability": {
        "atlas": false
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "UndiscoveredSprite",
      "key": "Alphabet",
      "atlas": "consumablesAlphabetPacks",
      "pos": {
        "x": 6,
        "y": 2
      },
      "raw": "atlas = \"consumablesAlphabetPacks\",\r\n    key = \"Alphabet\",\r\n    pos = {x = 6, y = 2}",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "ConsumableType",
      "key": "Alphabet",
      "atlas": "consumablesAlphabetPacks",
      "pos": null,
      "raw": "atlas = \"consumablesAlphabetPacks\",\r\n    key = \"Alphabet\",\r\n    primary_colour = HEX(\"747482\"),\r\n    secondary_colour = HEX(\"3e63c2\"),\r\n    collection_rows = {6,6,6},\r\n    shop_rate = 0,\r\n    default = \"c_akyrs_a\",\r\n    loc_txt = {\r\n        collection = \"Alphabet Cards\",\r\n        name = \"Alphabet\",\r\n\r\n        undiscovered = { -- description for undiscovered cards in the collection\r\n            name = 'Unknown Alphabet',\r\n            text = { 'Find this card when', 'letters are enabled' },\r\n        },\r\n    },",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "letters",
      "atlas": "consumablesAlphabetPacks",
      "pos": null,
      "raw": "key = v,\r\n        set = \"Alphabet\",\r\n        atlas = 'consumablesAlphabetPacks',\r\n        pos = { x = math.fmod(k-1,20), y = math.floor((k-1)/20) } ,\r\n        loc_txt = {\r\n            name = upper..\" for \"..word_letter[k],\r\n            text = { \"Convert all selected cards'\",\"letter to {C:red}#1#{}\",\"{C:inactive,s:0.75}(up to #2# cards){}\" },\r\n        },\r\n        loc_vars = function(self, info_queue, card)\r\n            info_queue[#info_queue+1] = {key = 'letters'..string.upper(card.ability.extra.letter), set = 'AikoyoriExtraBases' ,vars = {\r\n      \r\n                (AKYRS.get_scrabble_score(card.ability.extra.letter)),\r\n                1 + (AKYRS.get_scrabble_score(card.ability.extra.letter)/10),\r\n            }}\r\n            return {\r\n                vars = {\r\n                    string.upper(card.ability.extra.letter),\r\n                    card.ability.extra.max_selected,\r\n                },\r\n            }\r\n        end,\r\n        \r\n        config = {extra = {letter = v, max_selected = 999999}},\r\n        \r\n        can_use = function(self, card)\r\n            return #G.hand.highlighted <= card.ability.extra.max_selected and #G.hand.highlighted > 0\r\n        end,\r\n        use = function(self, card, area, copier)\r\n            for i=1, #G.hand.highlighted do\r\n                local percent = math.abs(1.15 - (i-0.999)/(#G.hand.highlighted-0.998)*0.3)\r\n                G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.15,func = function() G.hand.highlighted[i]:flip();play_sound('card1', percent);G.hand.highlighted[i]:juice_up(0.3, 0.3);return true end }))\r\n            end\r\n            \r\n            delay(0.5)\r\n            \r\n            for i=1, #G.hand.highlighted do\r\n                local percent = math.abs(0.85 + (i-0.999)/(#G.hand.highlighted-0.998)*0.3)\r\n                G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.15,func = function()\r\n                    G.hand.highlighted[i]:set_letters(card.ability.extra.letter)\r\n                    G.hand.highlighted[i]:flip();play_sound('tarot2', percent, 0.6);G.hand.highlighted[i]:juice_up(0.3, 0.3);return true end }))\r\n            end\r\n        end,\r\n        in_pool = function(self, args)\r\n            return G.GAME.akyrs_character_stickers_enabled\r\n        end,",
      "config": {},
      "ability": {},
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "Wild",
      "atlas": "consumablesAlphabetPacks",
      "pos": {
        "x": 6,
        "y": 1
      },
      "raw": "key = \"Wild\",\r\n    set = \"Alphabet\",\r\n    atlas = 'consumablesAlphabetPacks',\r\n    pos = { x = 6, y = 1 } ,\r\n    cost = 6,\r\n    loc_txt = {\r\n        name = \"? for ????\",\r\n        text = { \"Convert up to #2# selected card's\",\"letter to {C:red}Wild (#1#){}\" },\r\n    },\r\n    loc_vars = function(self, info_queue, card)\r\n        info_queue[#info_queue+1] = {key = 'lettersWild', set = 'AikoyoriExtraBases'}\r\n        return {\r\n            vars = {\r\n                string.upper(card.ability.extra.letter),\r\n                card.ability.extra.max_selected,\r\n            },\r\n        }\r\n    end,\r\n    config = {extra = {letter = \"#\", max_selected = 1}},\r\n    \r\n    can_use = function(self, card)\r\n        return #G.hand.highlighted <= card.ability.extra.max_selected and #G.hand.highlighted > 0\r\n    end,\r\n    use = function(self, card, area, copier)\r\n        for i=1, #G.hand.highlighted do\r\n            local percent = math.abs(1.15 - (i-0.999)/(#G.hand.highlighted-0.998)*0.3)\r\n            G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.15,func = function() G.hand.highlighted[i]:flip();play_sound('card1', percent);G.hand.highlighted[i]:juice_up(0.3, 0.3);return true end }))\r\n        end\r\n        \r\n        delay(0.5)\r\n        \r\n        for i=1, #G.hand.highlighted do\r\n            local percent = math.abs(0.85 + (i-0.999)/(#G.hand.highlighted-0.998)*0.3)\r\n            G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.15,func = function()\r\n                G.hand.highlighted[i]:set_letters(card.ability.extra.letter)\r\n                G.hand.highlighted[i]:flip();play_sound('tarot2', percent, 0.6);G.hand.highlighted[i]:juice_up(0.3, 0.3);return true end }))\r\n        end\r\n    end,\r\n    in_pool = function(self, args)\r\n        return G.GAME.akyrs_character_stickers_enabled\r\n    end,",
      "config": {
        "extra": {
          "letter": "#",
          "max_selected": 1
        }
      },
      "ability": {
        "extra": {
          "letter": "#",
          "max_selected": 1
        }
      },
      "vars": [
        null,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "the_thought",
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"the_thought\",\r\n    dollars = 5,\r\n    mult = 2,\r\n    boss_colour =HEX('95df3e'),\r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = 1, max = 10},\r\n    pos = { x = 0, y = 0 },\r\n    debuff = {\r\n        special_blind = true,\r\n        infinite_discards = true,\r\n        akyrs_is_word_blind = true,\r\n        akyrs_is_puzzle_blind = true,\r\n    },\r\n    vars = {},\r\n    set_blind = function(self)\r\n        G.GAME.aiko_puzzle_win = false\r\n        G.GAME.current_round.advanced_blind = true\r\n        G.GAME.word_todo = AKYRS.aiko_pickRandomInTable(AKYRS.puzzle_words)\r\n        \r\n        \r\n        for _,c in ipairs(G.playing_cards) do\r\n            c:set_sprites(c.config.center,c.config.card)\r\n        end\r\n        \r\n        --print (\"Word is \"..G.GAME.word_todo)\r\n        G.E_MANAGER:add_event(\r\n            Event({\r\n                delay = 10,\r\n                func = function()\r\n                    G.hand:change_size(3)\r\n                    G.FUNCS.draw_from_deck_to_hand()\r\n                    \r\n                    G.GAME.current_round.discards_sub = G.GAME.current_round.discards_left + 1\r\n                    self.discards_sub = G.GAME.current_round.discards_left + 1 -- math.max(G.GAME.current_round.discards_left, 0)\r\n                    ease_discard(-self.discards_sub)\r\n                    \r\n                    G.GAME.current_round.hand_sub = G.GAME.round_resets.hands-math.max(G.GAME.round_resets.hands,6)\r\n                    self.hands_sub = G.GAME.round_resets.hands-math.max(G.GAME.round_resets.hands,6)\r\n                    ease_hands_played(-self.hands_sub)\r\n                    ease_background_colour{new_colour = HEX('95df3e'), special_colour = HEX('ffd856'), tertiary_colour = G.C.BLACK, contrast = 3}\r\n                    \r\n                    return true\r\n                end\r\n            })\r\n        )\r\n        G.E_MANAGER:add_event(\r\n            Event({\r\n                delay = 10,\r\n                func = function()\r\n                    recalculateHUDUI()\r\n                    recalculateBlindUI()\r\n                    return true\r\n                end\r\n            })\r\n        )\r\n        -- add 5 temp wilds to hand so players don't get fucked royally\r\n        AKYRS.simple_event_add(\r\n            function ()\r\n                for i = 1, 5 do\r\n                    AKYRS.simple_event_add(\r\n                        function ()\r\n                            local wldcrd = Card(11.5,15,G.CARD_W,G.CARD_H,pseudorandom_element(G.P_CARDS,pseudoseed(\"thethoughtblind\")),G.P_CENTERS['c_base'],{playing_card = G.playing_card})\r\n                            wldcrd.is_null = true\r\n                            wldcrd.ability.akyrs_self_destructs = true\r\n                            AKYRS.change_letter_to(wldcrd,\"#\")\r\n                            G.hand:emplace(wldcrd)\r\n                            return true\r\n                        end, 0.1\r\n                    )\r\n                end\r\n                return true\r\n            end, 0\r\n        )\r\n    end,\r\n    drawn_to_hand = function(self)\r\n        AKYRS.simple_event_add(\r\n            function()\r\n                G.FUNCS.draw_from_discard_to_deck()\r\n                G.deck:shuffle('akyrthought')\r\n                return true\r\n            end,0.2\r\n        )\r\n    end,\r\n    in_pool = function(self)\r\n        return (G.GAME.akyrs_character_stickers_enabled and G.GAME.akyrs_wording_enabled)\r\n    end,\r\n    disable = function(self)\r\n        G.GAME.current_round.advanced_blind = false\r\n        G.hand:change_size(-3)\r\n        \r\n        ease_hands_played(self.hands_sub or G.GAME.current_round.hand_sub)\r\n        ease_discard(self.discards_sub or G.GAME.current_round.discards_sub)\r\n        \r\n        recalculateHUDUI()\r\n        recalculateBlindUI()\r\n        \r\n    end,\r\n    defeat = function(self)\r\n        G.GAME.current_round.advanced_blind = false\r\n        G.hand:change_size(-3)\r\n        \r\n        for _,c in ipairs(G.playing_cards) do\r\n            c:set_sprites(c.config.center,c.config.card)\r\n        end\r\n        recalculateHUDUI()\r\n        recalculateBlindUI()\r\n    end,\r\n    press_play = function(self)\r\n        G.STATE_COMPLETE = false\r\n        if not G.GAME.akyrs_win_checked then\r\n            AKYRS.simple_event_add(function()\r\n                AKYRS.simple_event_add(function()\r\n                    if not G.GAME.akyrs_win_checked then\r\n                        AKYRS.force_check_win({force_draw = true, state_to_go = G.STATES.HAND_PLAYED})\r\n                    end\r\n                    return true\r\n                end, 0.1)\r\n                return true\r\n            end, 0)\r\n        end\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "the_choice",
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"the_choice\",\r\n    dollars = 5,\r\n    mult = 2,\r\n    boss_colour = HEX(\"918b8b\"),\r\n    atlas = 'aikoyoriBlindsChips',\r\n    debuff = {\r\n        akyrs_is_word_blind = true,\r\n    },\r\n    boss = {min = 3, max = 10},\r\n    pos = { x = 0, y = 1 },\r\n    in_pool = function(self)\r\n        return (G.GAME.akyrs_character_stickers_enabled and G.GAME.akyrs_wording_enabled)\r\n    end,\r\n    loc_vars = function (self)\r\n        return {\r\n            vars = {\r\n                string.upper(G.GAME.akyrs_letter_target)\r\n            }\r\n        }\r\n    end,\r\n    debuff_hand = function (self, cards, hand, handname, check)\r\n        if not G.GAME.akyrs_character_stickers_enabled or self.disabled then return false end\r\n        for i, v in ipairs(cards) do\r\n            local l = string.upper(v:get_letter_with_pretend())\r\n            if l and l == string.upper(G.GAME.akyrs_letter_target) then\r\n                return false\r\n            end\r\n        end\r\n        return true\r\n    end,\r\n    collection_loc_vars = function (self)\r\n        return {\r\n            vars = {\r\n                localize(\"k_akyrs_random_letter\")\r\n            }\r\n        }\r\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "the_reject",
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = \"the_reject\",\r\n    dollars = 5,\r\n    mult = 2,\r\n    boss_colour = HEX(\"a2a2a2\"),\r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = 1, max = 10},\r\n    pos = { x = 0, y = 2 },\r\n    debuff = {\r\n        akyrs_is_word_blind = true,\r\n    },\r\n    in_pool = function(self)\r\n        return (G.GAME.akyrs_character_stickers_enabled and G.GAME.akyrs_wording_enabled)\r\n    end,\r\n    loc_vars = function (self)\r\n        return {\r\n            vars = {\r\n                string.upper(G.GAME.akyrs_letter_target)\r\n            }\r\n        }\r\n    end,\r\n    debuff_hand = function (self, cards, hand, handname, check)\r\n        if not G.GAME.akyrs_character_stickers_enabled or self.disabled then return false end\r\n        for i, v in ipairs(cards) do\r\n            local l = string.upper(v:get_letter_with_pretend())\r\n            if l and G.GAME.akyrs_last_played_letters[string.upper(G.GAME.akyrs_letter_target)] then\r\n                return true\r\n            end\r\n        end\r\n        return false\r\n    end,\r\n    collection_loc_vars = function (self)\r\n        return {\r\n            vars = {\r\n                localize(\"k_akyrs_random_letter\")\r\n            }\r\n        }\r\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "the_redo",
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 3
      },
      "raw": "key = \"the_redo\",\r\n    dollars = 5,\r\n    mult = 2,\r\n    boss_colour = HEX(\"ffd611\"),\r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = 3, max = 10},\r\n    pos = { x = 0, y = 3 },\r\n    debuff = {\r\n        akyrs_is_word_blind = true,\r\n    },\r\n    in_pool = function(self)\r\n        return (G.GAME.akyrs_character_stickers_enabled and G.GAME.akyrs_wording_enabled)\r\n    end,\r\n    debuff_hand = function (self, cards, hand, handname, check)\r\n        if not G.GAME.akyrs_character_stickers_enabled or self.disabled then return false end\r\n        for i, v in ipairs(cards) do\r\n            local l = string.upper(v:get_letter_with_pretend())\r\n            if l and G.GAME.akyrs_last_played_letters[l] then\r\n                return true\r\n            end\r\n        end\r\n        return false\r\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "the_reverse",
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 4
      },
      "raw": "key = \"the_reverse\",\r\n    dollars = 5,\r\n    mult = 2,\r\n    boss_colour = HEX(\"ff7d49\"),\r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = 1, max = 10},\r\n    pos = { x = 0, y = 4 },\r\n    debuff = {\r\n        akyrs_is_word_blind = true,\r\n    },\r\n    in_pool = function(self)\r\n        return (G.GAME.akyrs_character_stickers_enabled and G.GAME.akyrs_wording_enabled)\r\n    end,\r\n    loc_vars = function (self)\r\n        return {\r\n            vars = {\r\n                string.upper(G.GAME.akyrs_letter_target)\r\n            }\r\n        }\r\n    end,\r\n    set_blind = function (self)\r\n        G.GAME.words_reversed = true\r\n    end,\r\n    disable = function (self)\r\n        G.GAME.words_reversed = nil\r\n    end,\r\n    defeat = function (self)\r\n        G.GAME.words_reversed = nil\r\n    end,",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "the_libre",
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 5
      },
      "raw": "key = \"the_libre\",\r\n    dollars = 5,\r\n    mult = 2,\r\n    boss_colour = HEX('a74ce8'),\r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = 3, max = 10},\r\n    pos = { x = 0, y = 5 },\r\n    debuff = {\r\n        disable_chip_x = 2\r\n    },\r\n    loc_vars = function(self)\r\n        local orig_chips = (Talisman and to_big(SMODS.get_blind_amount(G.GAME.round_resets.ante)*self.mult*G.GAME.starting_params.ante_scaling) or get_blind_amount(G.GAME.round_resets.ante)*self.mult*G.GAME.starting_params.ante_scaling) * G.GAME.round_resets.ante\r\n        return { vars = {orig_chips * self.debuff.disable_chip_x}, key = self.key }\r\n    end,\r\n    collection_loc_vars = function(self)\r\n        return { vars = { \"2X\"..localize(\"k_akyrs_power_ante\")}, key = self.key }\r\n    end,\r\n    set_blind = function(self)\r\n    end,\r\n    drawn_to_hand = function(self)\r\n        \r\n    end,\r\n    in_pool = function(self)\r\n        return true\r\n    end,\r\n    disable = function(self)\r\n        G.GAME.blind.chips = (Talisman and to_big(SMODS.get_blind_amount(G.GAME.round_resets.ante)*self.mult*G.GAME.starting_params.ante_scaling) or get_blind_amount(G.GAME.round_resets.ante)*self.mult*G.GAME.starting_params.ante_scaling ) * G.GAME.round_resets.ante\r\n        G.GAME.blind.chip_text = number_format(G.GAME.blind.chips)\r\n            \r\n    end,\r\n    defeat = function(self)\r\n        \r\n    end,\r\n    press_play = function(self)\r\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "the_picker",
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 6
      },
      "raw": "key = \"the_picker\",\r\n    dollars = 5,\r\n    mult = 1.5,\r\n    boss_colour = HEX('67e38b'),\r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = 2, max = 10},\r\n    pos = { x = 0, y = 6 },\r\n    debuff = {\r\n        primed = false,\r\n        acted = false,\r\n        initial_action_acted = false,\r\n        initial_action_act_set = false,\r\n        hand_per_hand = 3,\r\n        lock = false,\r\n        score_change = 1.25,\r\n        akyrs_pick_cards = true,\r\n    },\r\n    loc_vars = function(self)\r\n        return { vars = {G.hand.config.highlighted_limit, self.debuff.score_change}, key = self.key }\r\n    end,\r\n    collection_loc_vars = function(self)\r\n        return { vars = { localize(\"k_akyrs_up_to_sel\"), 1.2 }, key = self.key }\r\n    end,\r\n    set_blind = function(self)\r\n        G.GAME.blind.debuff.orig_chips = G.GAME.blind.chips\r\n    end,\r\n    drawn_to_hand = function(self)\r\n    end,\r\n    in_pool = function(self)\r\n        return true\r\n    end,\r\n    disable = function(self)\r\n        G.GAME.blind.chips = G.GAME.blind.debuff.orig_chips * 2\r\n    end,\r\n    defeat = function(self)\r\n    end,\r\n    press_play = function(self)\r\n        G.GAME.blind.debuff.primed = false\r\n        G.GAME.blind.debuff.acted = false\r\n        G.E_MANAGER:add_event(Event{\r\n            trigger = \"after\",\r\n            func = function ()\r\n                G.GAME.blind.debuff.initial_action_act_set = false\r\n                return true\r\n            end\r\n        })\r\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "the_height",
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 7
      },
      "raw": "key = \"the_height\",\r\n    dollars = 7,\r\n    mult = 0.5,\r\n    boss_colour = HEX('36adff'),\r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = 3, max = 10},\r\n    pos = { x = 0, y = 7 },\r\n    debuff = {\r\n        requirement_scale = 2\r\n    },\r\n    loc_vars = function(self)\r\n        return { vars = {self.debuff.requirement_scale}, key = self.key }\r\n    end,\r\n    collection_loc_vars = function(self)\r\n        return { vars = { \"2\"}, key = self.key }\r\n    end,",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "the_expiry",
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 8
      },
      "raw": "key = \"the_expiry\",\r\n    dollars = 5,\r\n    mult = 2,\r\n    boss_colour = HEX('ca60ff'),\r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = 2, max = 10},\r\n    pos = { x = 0, y = 8 },\r\n    set_blind = function (self)\r\n        for i,k in ipairs(G.consumeables.cards) do\r\n            k.ability.akyrs_perma_debuff = true\r\n        end\r\n    end,\r\n    \r\n    disable = function (self)\r\n        for i,k in ipairs(G.consumeables.cards) do\r\n            k.ability.akyrs_perma_debuff = false\r\n            k.debuff = false\r\n        end\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "the_nature",
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 9
      },
      "raw": "key = \"the_nature\",\r\n    dollars = 5,\r\n    mult = 2,\r\n    boss_colour = HEX('3d8a55'),\r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = 4, max = 10},\r\n    debuff = {\r\n        dec_mult = 0.75,\r\n    },\r\n    \r\n    loc_vars = function (self)\r\n        return {\r\n            vars = { self.debuff.dec_mult }\r\n        }\r\n    end,\r\n    collection_loc_vars = function (self)\r\n        return {\r\n            vars = { 0.75 }\r\n        }\r\n    end,\r\n    calculate = function (self, blind, context)\r\n        if context.individual and (context.cardarea == G.hand or context.cardarea == G.play or context.cardarea == \"unscored\") then\r\n            if context.other_card:is_face(true) then\r\n                return { Xmult = blind.debuff.dec_mult }\r\n            end\r\n        end\r\n    end,\r\n    pos = { x = 0, y = 9 },",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "the_key",
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 12
      },
      "raw": "key = \"the_key\",\r\n    dollars = 5,\r\n    mult = 2,\r\n    boss_colour = HEX('8c7d36'),\r\n    debuff = {\r\n        akyrs_perma_selection = { num = 1, denum = 4, seed = \"akyrs_boss_the_key\" }\r\n    },\r\n    loc_vars = function(self)\r\n        local n, d = SMODS.get_probability_vars(self, self.debuff.akyrs_perma_selection.num,self.debuff.akyrs_perma_selection.denum,self.debuff.akyrs_perma_selection.seed )\r\n        return {\r\n            vars = {\r\n                n, d\r\n            }\r\n        }\r\n    end,\r\n    collection_loc_vars = function (self)\r\n        return {\r\n            vars = {\r\n                1, 4\r\n            }\r\n        }\r\n    end,\r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = 3, max = 10},\r\n    pos = { x = 0, y = 12 },\r\n    calculate = function (self, card, context)\r\n        \r\n    end,\r\n    press_play = function (self)\r\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "final_periwinkle_pinecone",
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 10
      },
      "raw": "key = \"final_periwinkle_pinecone\",\r\n    dollars = 8,\r\n    mult = 2,\r\n    boss_colour = HEX('7da8f0'),\r\n    atlas = 'aikoyoriBlindsChips', \r\n    debuff = {\r\n        --akyrs_all_seals_perma_debuff = true\r\n    },\r\n    boss = {min = 1, max = 10, showdown = true},\r\n    pos = { x = 0, y = 10 },\r\n    recalc_debuff = function (self, card, from_blind)\r\n        if card.seal then \r\n            return true\r\n        end\r\n        return false\r\n    end\r\n    --[[\r\n    disable = function (self)\r\n        if G.I.CARDAREA then \r\n            for _,area in ipairs(G.I.CARDAREA) do\r\n                if (area and area.cards) then\r\n                    for j,c in ipairs(area.cards) do\r\n                        if c.seal then\r\n                            c.ability.akyrs_perma_debuff = false\r\n                        end\r\n                    end\r\n                end\r\n    \r\n            end\r\n                \r\n        end\r\n    end\r\n    ]]",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "final_razzle_raindrop",
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 11
      },
      "raw": "key = \"final_razzle_raindrop\",\r\n    dollars = 8,\r\n    mult = 2,\r\n    boss_colour = HEX('ff40ac'),\r\n    debuff = {\r\n        akyrs_suit_debuff_hand = true\r\n    },\r\n    \r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = 1, max = 10, showdown = true},\r\n    pos = { x = 0, y = 11 },",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "final_velvet_vapour",
      "atlas": "aikoyoriBlindsChips2",
      "pos": {
        "x": 0,
        "y": 10
      },
      "raw": "key = \"final_velvet_vapour\",\r\n    dollars = 8,\r\n    mult = 2,\r\n    boss_colour = HEX('911468'),    \r\n    atlas = 'aikoyoriBlindsChips2', \r\n    boss = {min = 1, max = 10, showdown = true},\r\n    pos = { x = 0, y = 10 },\r\n    debuff = {\r\n        akyrs_rank_debuff_hand = true\r\n    },",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "final_chamomile_cloud",
      "atlas": "aikoyoriBlindsChips2",
      "pos": {
        "x": 0,
        "y": 9
      },
      "raw": "key = \"final_chamomile_cloud\",\r\n    dollars = 8,\r\n    mult = 2,\r\n    boss_colour = HEX('f0ae22'),    \r\n    atlas = 'aikoyoriBlindsChips2', \r\n    boss = {min = 1, max = 10, showdown = true},\r\n    pos = { x = 0, y = 9 },\r\n    debuff = {\r\n        akyrs_enhancement_debuff_hand = true\r\n    },",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "final_lilac_lasso",
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 13
      },
      "raw": "key = \"final_lilac_lasso\",\r\n    dollars = 8,\r\n    mult = 2,\r\n    boss_colour = HEX('973fd5'),\r\n    debuff = {\r\n        jokers_not_debuffed = 4,\r\n    },\r\n    \r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = 1, max = 10, showdown = true},\r\n    pos = { x = 0, y = 13 },\r\n    \r\n    loc_vars = function (self)\r\n        return {\r\n            vars = { self.debuff.jokers_not_debuffed }\r\n        }\r\n    end,\r\n    collection_loc_vars = function (self)\r\n        return {\r\n            vars = { 4 }\r\n        }\r\n    end,\r\n    set_blind =function (self)\r\n        self.prepped = true\r\n    end,\r\n    drawn_to_hand = function (self)\r\n        if self.prepped and G.jokers.cards[1] then\r\n            local jokers = {}\r\n            local undebuffed = {}\r\n            for i = 1, #G.jokers.cards do\r\n                G.jokers.cards[i]:set_debuff(false)\r\n                jokers[#jokers+1] = G.jokers.cards[i] \r\n            end \r\n            for i = 1, (self.debuff.jokers_not_debuffed or 4) do\r\n                if #jokers == 0 then break end\r\n                local _card = pseudorandom_element(jokers, pseudoseed('lilac_lasso'))\r\n                for l,j in ipairs(jokers) do\r\n                    if j == _card then\r\n                        table.insert(undebuffed, j)\r\n                        table.remove(jokers, l)\r\n                        break\r\n                    end\r\n                end\r\n            end \r\n            \r\n            for i, jkr in ipairs(jokers) do\r\n                jkr:set_debuff(true)\r\n            end\r\n            local r_und = {}\r\n            for i = #undebuffed, 1, -1 do\r\n                table.insert(r_und, undebuffed[i])\r\n            end\r\n            for i, carder in ipairs(r_und) do\r\n                G.E_MANAGER:add_event(\r\n                    Event{\r\n                        trigger = \"after\",\r\n                        delay = AKYRS.get_speed_mult(carder)*0.05,\r\n                        func = function ()\r\n                            carder:juice_up(0.5,1)\r\n                            return true\r\n                        end\r\n                    }\r\n                )\r\n            end\r\n        end\r\n        self.prepped = nil\r\n        \r\n    end,\r\n    press_play =function (self)\r\n        if G.jokers.cards[1] then\r\n            self.triggered = true\r\n            self.prepped = true\r\n        end\r\n    end,\r\n    disable = function (self)\r\n        \r\n        for i = 1, #G.jokers.cards do\r\n            G.jokers.cards[i]:set_debuff(false)\r\n        end \r\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "final_salient_stream",
      "atlas": "aikoyoriBlindsChips2",
      "pos": {
        "x": 0,
        "y": 11
      },
      "raw": "key = \"final_salient_stream\",\r\n    dollars = 8,\r\n    mult = 2,\r\n    boss_colour = HEX('358dff'),    \r\n    atlas = 'aikoyoriBlindsChips2', \r\n    boss = {min = 1, max = 10, showdown = true},\r\n    pos = { x = 0, y = 11 },\r\n    debuff = {\r\n        akyrs_alternate_action = true\r\n    },\r\n    debuff_hand = function (self, cards, hand, handname, check)\r\n        if G.GAME.current_round.akyrs_last_action and G.GAME.current_round.akyrs_last_action == \"play\" and not G.GAME.blind.disabled  then\r\n            return true\r\n        end\r\n        return false\r\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "final_luminous_lemonade",
      "atlas": "aikoyoriBlindsChips2",
      "pos": {
        "x": 0,
        "y": 12
      },
      "raw": "key = \"final_luminous_lemonade\",\r\n    dollars = 8,\r\n    mult = 3.5,\r\n    boss_colour = SMODS.Gradients['akyrs_luminous'],    \r\n    atlas = 'aikoyoriBlindsChips2', \r\n    boss = {min = 1, max = 10, showdown = true},\r\n    pos = { x = 0, y = 12 },\r\n    debuff = {\r\n        akyrs_reduce_other = 2\r\n    },\r\n    loc_vars = function (self)\r\n        return {\r\n            vars = {\r\n                self.debuff.akyrs_reduce_other\r\n            }\r\n        }\r\n    end,\r\n    collection_loc_vars = function (self)\r\n        return {\r\n            vars = {\r\n                2\r\n            }\r\n        }\r\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "final_glorious_glaive",
      "atlas": "aikoyoriBlindsChips2",
      "pos": {
        "x": 0,
        "y": 13
      },
      "raw": "key = \"final_glorious_glaive\",\r\n    dollars = 8,\r\n    mult = 2,\r\n    boss_colour = SMODS.Gradients['akyrs_glorious'],    \r\n    atlas = 'aikoyoriBlindsChips2', \r\n    boss = {min = 1, max = 10, showdown = true},\r\n    pos = { x = 0, y = 13 },\r\n    debuff = {\r\n        akyrs_mult_per_played = 0.8\r\n    },\r\n    loc_vars = function (self)\r\n        return {\r\n            vars = {\r\n                self.debuff.akyrs_mult_per_played\r\n            }\r\n        }\r\n    end,\r\n    collection_loc_vars = function (self)\r\n        return {\r\n            vars = {\r\n                0.8\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, blind, context)\r\n        if context.individual and not context.repetition and context.cardarea == G.play and not G.GAME.blind.disabled then\r\n            return {\r\n                xmult = blind.debuff.akyrs_mult_per_played,\r\n            }\r\n        end\r\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "forgotten_weights_of_the_past",
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 14
      },
      "raw": "key = \"forgotten_weights_of_the_past\",\r\n    dollars = 8,\r\n    mult = 2,\r\n    boss_colour = HEX('60203f'),\r\n    debuff = {\r\n        ante_scaler = 2,\r\n        current_ante = nil,\r\n        akyrs_is_forgotten_blind = true,\r\n        akyrs_cannot_be_overridden = true,\r\n    },\r\n    \r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = -999999999999, max = 10},\r\n    pos = { x = 0, y = 14 },\r\n    \r\n    loc_vars = function (self)\r\n        return {\r\n            vars = { self.debuff.ante_scaler }\r\n        }\r\n    end,\r\n    collection_loc_vars = function (self)\r\n        return {\r\n            vars = { 2 }\r\n        }\r\n    end,\r\n    in_pool = function (self)\r\n        return G.GAME.round_resets.ante < 0  -- :3\r\n    end,\r\n    set_blind = function (self)\r\n        G.GAME.blind.debuff.current_ante = G.GAME.round_resets.ante\r\n    end,\r\n    calculate = function (self, blind, context)\r\n        if context.individual and context.cardarea == G.play and not context.repetition and not blind.disabled then\r\n            local old_ante = blind.debuff.current_ante\r\n            blind.debuff.current_ante = blind.debuff.current_ante*blind.debuff.ante_scaler\r\n            ease_ante(-old_ante + blind.debuff.current_ante)\r\n        end\r\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "forgotten_prospects_of_the_future",
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 15
      },
      "raw": "key = \"forgotten_prospects_of_the_future\",\r\n    dollars = 8,\r\n    mult = 2,\r\n    boss_colour = HEX('2b664f'),\r\n    debuff = {\r\n        ante_scaler = 1,\r\n        akyrs_is_forgotten_blind = true,\r\n        akyrs_cannot_be_overridden = true,\r\n    },\r\n    \r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = -999999999999, max = 10},\r\n    pos = { x = 0, y = 15 },\r\n    \r\n    loc_vars = function (self)\r\n        return {\r\n            vars = { self.debuff.ante_scaler }\r\n        }\r\n    end,\r\n    collection_loc_vars = function (self)\r\n        return {\r\n            vars = { 1 }\r\n        }\r\n    end,\r\n    in_pool = function (self)\r\n        return G.GAME.round_resets.ante < 1  -- :3\r\n    end,\r\n    set_blind = function (self)\r\n        G.GAME.blind.debuff.current_ante = G.GAME.round_resets.ante\r\n    end,\r\n    calculate = function (self, blind, context)\r\n        if context.after and not blind.disabled then\r\n            ease_ante(blind.debuff.ante_scaler * #G.hand.cards)\r\n        end\r\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "forgotten_uncertainties_of_life",
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 16
      },
      "raw": "key = \"forgotten_uncertainties_of_life\",\r\n    dollars = 8,\r\n    mult = 2,\r\n    boss_colour = HEX('2c5c6c'),\r\n    debuff = {\r\n        hand_shrinker = 1,\r\n        akyrs_is_forgotten_blind = true,\r\n        akyrs_cannot_be_overridden = true,\r\n    },\r\n    \r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = -999999999999, max = 10},\r\n    pos = { x = 0, y = 16 },\r\n    \r\n    loc_vars = function (self)\r\n        return {\r\n            vars = { self.debuff.hand_shrinker }\r\n        }\r\n    end,\r\n    collection_loc_vars = function (self)\r\n        return {\r\n            vars = { 1 }\r\n        }\r\n    end,\r\n    in_pool = function (self)\r\n        return G.GAME.round_resets.ante < 1  -- :3\r\n    end,\r\n    calculate = function (self, blind, context)\r\n        if context.after and not context.end_of_round and not blind.disabled then\r\n            G.hand:change_size(-blind.debuff.hand_shrinker)\r\n        end\r\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "forgotten_inevitability_of_death",
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 17
      },
      "raw": "key = \"forgotten_inevitability_of_death\",\r\n    dollars = 8,\r\n    mult = 2,\r\n    boss_colour = HEX('4d494b'),\r\n    debuff = {\r\n        discard_dealer = 1,\r\n        akyrs_is_forgotten_blind = true,\r\n        akyrs_cannot_be_overridden = true,\r\n    },\r\n    \r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = -999999999999, max = 10},\r\n    pos = { x = 0, y = 17 },\r\n    \r\n    loc_vars = function (self)\r\n        return {\r\n            vars = { self.debuff.discard_dealer }\r\n        }\r\n    end,\r\n    collection_loc_vars = function (self)\r\n        return {\r\n            vars = { 1 }\r\n        }\r\n    end,\r\n    in_pool = function (self)\r\n        return G.GAME.round_resets.ante < 1  -- :3\r\n    end,\r\n    calculate = function (self, blind, context)\r\n        if context.blind_defeated and not blind.disabled then\r\n            return{\r\n                func = function ()\r\n                    ease_dollars(-G.GAME.chips / G.GAME.blind.chips)\r\n                end\r\n            }\r\n        end\r\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "expert_confrontation",
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 18
      },
      "raw": "key = \"expert_confrontation\",\r\n    dollars = 10,\r\n    mult = 3,\r\n    boss_colour = HEX('ce36ff'),\r\n    debuff = {\r\n        akyrs_cannot_be_disabled = true,\r\n        akyrs_blind_difficulty = \"expert\",\r\n        akyrs_is_postwin_blind = true,\r\n        akyrs_cannot_be_overridden = true,\r\n    },\r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = 9, max = 10},\r\n    pos = { x = 0, y = 18 },\r\n    debuff_hand = function (self, cards, hand, handname, check)\r\n        local has_face = false\r\n        for i,j in ipairs(G.hand.cards) do\r\n            if j:is_face() and not j.highlighted then\r\n                has_face = true\r\n                break\r\n            end\r\n        end\r\n        return has_face\r\n    end,\r\n    loc_vars = function (self)\r\n        return {\r\n        }\r\n    end,\r\n    collection_loc_vars = function (self)\r\n        return {\r\n        }\r\n    end,\r\n    in_pool = function (self)\r\n        return G.GAME.round_resets.ante > G.GAME.win_ante\r\n    end,\r\n    get_loc_debuff_text = function (self)\r\n        return localize(\"k_akyrs_confrontation_has_face_in_hand_warning\")\r\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "expert_fluctuation",
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 19
      },
      "raw": "key = \"expert_fluctuation\",\r\n    dollars = 10,\r\n    mult = 3,\r\n    boss_colour = HEX('ff6c9a'),\r\n    debuff = {\r\n        mult_min = 0.01,\r\n        mult_max = 1.1,\r\n        akyrs_cannot_be_disabled = true,\r\n        akyrs_blind_difficulty = \"expert\",\r\n        akyrs_is_postwin_blind = true,\r\n        akyrs_cannot_be_overridden = true,\r\n    },\r\n    \r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = 9, max = 10},\r\n    pos = { x = 0, y = 19 },\r\n    \r\n    loc_vars = function (self)\r\n        return {\r\n            vars = { self.debuff.mult_min, self.debuff.mult_max }\r\n        }\r\n    end,\r\n    collection_loc_vars = function (self)\r\n        return {\r\n            vars = { 0.01, 1.1 }\r\n        }\r\n    end,\r\n    in_pool = function (self)\r\n        return G.GAME.round_resets.ante > G.GAME.win_ante\r\n    end,\r\n    calculate = function (self, blind, context)\r\n        if context.before then\r\n            local xm = pseudorandom(pseudoseed(\"akyrs_fluctuation\"))*(blind.debuff.mult_max - blind.debuff.mult_min) + blind.debuff.mult_min\r\n            G.GAME.chips = G.GAME.chips * xm\r\n            G.GAME.chips_text = number_format(G.GAME.chips)\r\n            G.HUD:get_UIE_by_ID(\"chip_UI_count\"):juice_up()\r\n            play_sound('timpani')\r\n        end\r\n    end,",
      "config": {},
      "ability": {},
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "expert_straightforwardness",
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 20
      },
      "raw": "key = \"expert_straightforwardness\",\r\n    dollars = 10,\r\n    mult = 3,\r\n    boss_colour = HEX('4d77ff'),\r\n    debuff = {\r\n        akyrs_cannot_be_disabled = true,\r\n        akyrs_blind_difficulty = \"expert\",\r\n        akyrs_is_postwin_blind = true,\r\n        akyrs_cannot_be_overridden = true,\r\n        ch = 1,\r\n        mul = 1\r\n    },\r\n    \r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = 9, max = 10},\r\n    pos = { x = 0, y = 20 },\r\n    \r\n    loc_vars = function (self)\r\n        return {\r\n            vars = {\r\n                self.debuff.ch,\r\n                self.debuff.mul,\r\n            }\r\n        }\r\n    end,\r\n    collection_loc_vars = function (self)\r\n        return {\r\n            vars = {\r\n                1, 1\r\n            }\r\n        }\r\n    end,\r\n    in_pool = function (self)\r\n        return G.GAME.round_resets.ante > G.GAME.win_ante\r\n    end,\r\n    modify_hand = function (self, cards, poker_hands, text, mult, hand_chips)\r\n        if Talisman then\r\n            return to_big(self.debuff.mul), to_big(self.debuff.ch), true\r\n        end\r\n        return self.debuff.mul, self.debuff.ch, true\r\n        -- return mult, hand_chips, false\r\n    end,",
      "config": {},
      "ability": {},
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "expert_entanglement",
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 21
      },
      "raw": "key = \"expert_entanglement\",\r\n    dollars = 10,\r\n    mult = 3,\r\n    boss_colour = HEX('1fb643'),\r\n    debuff = {\r\n        akyrs_cannot_be_disabled = true,\r\n        akyrs_blind_difficulty = \"expert\",\r\n        akyrs_is_postwin_blind = true,\r\n        akyrs_cannot_be_overridden = true,\r\n    },\r\n    stay_flipped = function (self, area, card)\r\n        if area == G.hand and G.hand.cards then\r\n            local ranks = {}\r\n            for i, v in ipairs(G.hand.cards) do\r\n                if v.base and v.base.suit and not SMODS.has_no_suit(v) and v.facing == 'front' then\r\n                    ranks[v.base.suit] = true\r\n                end\r\n            end\r\n            if card.base and card.base.suit and ranks[card.base.suit] and not SMODS.has_no_suit(card) then\r\n                return true\r\n            end\r\n        end\r\n        return false\r\n    end,\r\n    \r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = 9, max = 10},\r\n    pos = { x = 0, y = 21 },\r\n    \r\n    loc_vars = function (self)\r\n        return {\r\n        }\r\n    end,\r\n    collection_loc_vars = function (self)\r\n        return {\r\n        }\r\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "expert_manuscript",
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 22
      },
      "raw": "key = \"expert_manuscript\",\r\n    dollars = 10,\r\n    mult = 3,\r\n    boss_colour = HEX('ffa530'),\r\n    debuff = {\r\n        akyrs_cannot_be_disabled = true,\r\n        akyrs_blind_difficulty = \"expert\",\r\n        akyrs_is_postwin_blind = true,\r\n        akyrs_cannot_be_overridden = true,\r\n    },\r\n    \r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = 9, max = 10},\r\n    pos = { x = 0, y = 22 },\r\n    \r\n    in_pool = function (self)\r\n        return G.GAME.round_resets.ante > G.GAME.win_ante\r\n    end,\r\n    modify_hand = function (self, cards, poker_hands, text, mult, hand_chips)\r\n        AKYRS.simple_event_add(\r\n            function ()\r\n                ease_dollars(-mult)\r\n                return true\r\n            end, 0\r\n        )\r\n        return mult, hand_chips, true\r\n    end,\r\n    --[[\r\n    calculate = function (self, blind, context)\r\n        if context.individual and context.area == G.play and not context.repetition then\r\n            local x = localize(context.scoring_name,\"poker_hands\")\r\n            local y = G.GAME.hands[scoring_hand]\r\n            return {\r\n                dollars = -y.mult\r\n            }\r\n                \r\n        end\r\n    end]]",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "expert_inflation",
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 23
      },
      "raw": "key = \"expert_inflation\",\r\n    dollars = 10,\r\n    mult = 1,\r\n    boss_colour = HEX('7371ff'),\r\n    debuff = {\r\n        akyrs_cannot_be_disabled = true,\r\n        akyrs_blind_difficulty = \"expert\",\r\n        akyrs_is_postwin_blind = true,\r\n        akyrs_cannot_be_overridden = true,\r\n        akyrs_anteth_power_of_x_blind_req = 2,\r\n        akyrs_anteth_power_of_x_blind_req_multiplier = 2,\r\n        akyrs_anteth_power_of_x_blind_req_power = 1.2,\r\n    },\r\n    \r\n    in_pool = function (self)\r\n        return G.GAME.round_resets.ante > G.GAME.win_ante\r\n    end,\r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = 10, max = 10},\r\n    pos = { x = 0, y = 23 },",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "master_faraway_island",
      "atlas": "aikoyoriBlindsChips2",
      "pos": {
        "x": 0,
        "y": 3
      },
      "raw": "key = \"master_faraway_island\",\r\n    dollars = 14,\r\n    mult = 8,\r\n    boss_colour = HEX('4bbdff'),\r\n    debuff = {\r\n        akyrs_cannot_be_disabled = true,\r\n        akyrs_cannot_be_rerolled = true,\r\n        akyrs_blind_difficulty = \"master\",\r\n        akyrs_is_endless_blind = true,\r\n        akyrs_cannot_be_overridden = true,\r\n        akyrs_cannot_be_skipped = true,\r\n    },\r\n    \r\n    in_pool = function (self)\r\n        return G.GAME.round_resets.ante >= self.boss.min and G.GAME.won\r\n    end,\r\n    atlas = 'aikoyoriBlindsChips2', \r\n    boss = {min = 12, max = 10},\r\n    pos = { x = 0, y = 3 },\r\n    debuff_hand = function (self, cards, hand, handname, check)\r\n        for i, c in ipairs(cards) do\r\n            if SMODS.has_no_rank(c) or SMODS.has_no_suit(c) then\r\n                return false\r\n            end\r\n        end\r\n        return true\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "master_plywood_forest",
      "atlas": "aikoyoriBlindsChips2",
      "pos": {
        "x": 0,
        "y": 4
      },
      "raw": "key = \"master_plywood_forest\",\r\n    dollars = 14,\r\n    mult = 8,\r\n    boss_colour = HEX('f74d4d'),\r\n    debuff = {\r\n        akyrs_cannot_be_disabled = true,\r\n        akyrs_cannot_be_rerolled = true,\r\n        akyrs_blind_difficulty = \"master\",\r\n        akyrs_is_endless_blind = true,\r\n        akyrs_destroy_unplayed = true,\r\n        akyrs_cannot_be_overridden = true,\r\n        akyrs_cannot_be_skipped = true,\r\n    },\r\n    \r\n    in_pool = function (self)\r\n        return G.GAME.round_resets.ante >= self.boss.min and G.GAME.won\r\n    end,\r\n    atlas = 'aikoyoriBlindsChips2', \r\n    boss = {min = 12, max = 10},\r\n    pos = { x = 0, y = 4 },",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "master_golden_jade",
      "atlas": "aikoyoriBlindsChips2",
      "pos": {
        "x": 0,
        "y": 5
      },
      "raw": "key = \"master_golden_jade\",\r\n    dollars = 14,\r\n    mult = 8,\r\n    boss_colour = HEX('d0521a'),\r\n    debuff = {\r\n        akyrs_cannot_be_disabled = true,\r\n        akyrs_cannot_be_rerolled = true,\r\n        akyrs_blind_difficulty = \"master\",\r\n        akyrs_is_endless_blind = true,\r\n        akyrs_cannot_be_overridden = true,\r\n        akyrs_deduct_mult = 0.1,\r\n        akyrs_cannot_be_skipped = true,\r\n    },\r\n    loc_vars = function (self)\r\n        return {\r\n            vars = {self.debuff.akyrs_deduct_mult}\r\n        }\r\n    end,\r\n\r\n    collection_loc_vars = function (self)\r\n        return {\r\n            vars = { 0.1 }\r\n        }\r\n    end,    \r\n    in_pool = function (self)\r\n        return G.GAME.round_resets.ante >= self.boss.min and G.GAME.won\r\n    end,\r\n    atlas = 'aikoyoriBlindsChips2', \r\n    boss = {min = 12, max = 10},\r\n    pos = { x = 0, y = 5 },\r\n    calculate = function (self, blind, context)\r\n        if context.individual and context.cardarea == G.play then\r\n            \r\n            blind.debuff.current_money = blind.debuff.current_money or G.GAME.dollars\r\n            local old_money = blind.debuff.current_money or G.GAME.dollars\r\n            blind.debuff.current_money = blind.debuff.current_money * blind.debuff.akyrs_deduct_mult\r\n            return {\r\n                func = function ()\r\n                    ease_dollars(-old_money + blind.debuff.current_money)\r\n                end\r\n            }\r\n        end\r\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "master_milk_crown_on_sonnetica",
      "atlas": "aikoyoriBlindsChips2",
      "pos": {
        "x": 0,
        "y": 6
      },
      "raw": "key = \"master_milk_crown_on_sonnetica\",\r\n    dollars = 14,\r\n    mult = 8,\r\n    boss_colour = HEX('5f848c'),\r\n    debuff = {\r\n        akyrs_cannot_be_disabled = true,\r\n        akyrs_cannot_be_rerolled = true,\r\n        akyrs_blind_difficulty = \"master\",\r\n        akyrs_is_endless_blind = true,\r\n        akyrs_cannot_be_overridden = true,\r\n        akyrs_cannot_be_skipped = true,\r\n    },\r\n    \r\n    in_pool = function (self)\r\n        return G.GAME.round_resets.ante >= self.boss.min and G.GAME.won\r\n    end,\r\n    atlas = 'aikoyoriBlindsChips2', \r\n    boss = {min = 12, max = 10},\r\n    pos = { x = 0, y = 6 },\r\n    calculate = function (self, blind, context)\r\n        if context.individual and context.cardarea == G.play then\r\n            if context.other_card:get_id() == 13 then\r\n                return {\r\n                    xmult = 0\r\n                }\r\n            end\r\n        end\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "master_bug",
      "atlas": "aikoyoriBlindsChips2",
      "pos": {
        "x": 0,
        "y": 7
      },
      "raw": "key = \"master_bug\",\r\n    dollars = 14,\r\n    mult = 8,\r\n    boss_colour = HEX('4de740'),\r\n    debuff = {\r\n        akyrs_cannot_be_disabled = true,\r\n        akyrs_cannot_be_rerolled = true,\r\n        akyrs_blind_difficulty = \"master\",\r\n        akyrs_is_endless_blind = true,\r\n        akyrs_cannot_be_overridden = true,\r\n        akyrs_cannot_be_skipped = true,\r\n    },\r\n    \r\n    in_pool = function (self)\r\n        return G.GAME.round_resets.ante >= self.boss.min and G.GAME.won\r\n    end,\r\n    atlas = 'aikoyoriBlindsChips2', \r\n    boss = {min = 12, max = 10},\r\n    pos = { x = 0, y = 7 },\r\n    calculate = function (self, blind, context)\r\n        if context.after and not context.repetition then\r\n            return {\r\n                func = function ()\r\n                    local jkrs = AKYRS.get_non_eternals(G.jokers, blind)\r\n                    if #jkrs > 0 then\r\n                        for i = 1, #G.play.cards do\r\n                            local attempts = 0\r\n                            local card_to_destroy\r\n                            repeat\r\n                                card_to_destroy = pseudorandom_element(jkrs, pseudoseed(\"bl_bug_akyrs\"))\r\n                                attempts = attempts + 1\r\n                                --print(\"atttempt \"..attempts..\" \"..card_to_destroy.config.center_key)\r\n                            until (card_to_destroy and (not card_to_destroy.akyrs_removed and not card_to_destroy.ability.eternal and card_to_destroy.ability.cry_absolute)) or attempts >= #G.jokers.cards\r\n                            if card_to_destroy then\r\n                                card_to_destroy.akyrs_removed = true\r\n                                AKYRS.simple_event_add(\r\n                                    function ()\r\n                                        card_to_destroy:start_dissolve({ G.C.RED }, nil, 1.6)\r\n                                        return true\r\n                                    end, 0\r\n                                )\r\n                            end\r\n                        end\r\n                    end\r\n                end\r\n            }\r\n\r\n        end\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "letter_pack_1",
      "atlas": "aikoyoriBoosterPack",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"letter_pack_1\",\r\n    set = \"Booster\",\r\n    config = { extra = 3, choose = 1 },\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.choose,\r\n                card.ability.extra,\r\n            },\r\n            key = \"p_akyrs_letter_pack_normal\"\r\n        }\r\n    end,\r\n    atlas = 'aikoyoriBoosterPack', pos = { x = 0, y = 0 },\r\n    group_key = \"k_akyrs_alphabet_pack\",\r\n    cost = 4,\r\n    select_card = 'consumeables',\r\n    weight = 1,\r\n    kind = \"letter_pack\",\r\n    create_card = function (self, card, i) \r\n        return create_card(\"Alphabet\", G.pack_cards, nil, nil, true, true, nil, \"_letter\")\r\n    end,\r\n    in_pool = function(self, args)\r\n        return G.GAME.akyrs_character_stickers_enabled and G.GAME.akyrs_wording_enabled\r\n    end,\r\n    cry_digital_hallucinations = alphabet_digital_hallucinations_compat,",
      "config": {
        "extra": 3,
        "choose": 1
      },
      "ability": {
        "extra": 3,
        "choose": 1
      },
      "vars": [
        1,
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "letter_pack_2",
      "atlas": "aikoyoriBoosterPack",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"letter_pack_2\",\r\n    set = \"Booster\",\r\n    config = { extra = 3, choose = 1 },\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.choose,\r\n                card.ability.extra,\r\n            },\r\n            key = \"p_akyrs_letter_pack_normal\"\r\n        }\r\n    end,\r\n    atlas = 'aikoyoriBoosterPack', pos = { x = 1, y = 0 },\r\n    group_key = \"k_akyrs_alphabet_pack\",\r\n    cost = 4,\r\n    select_card = 'consumeables',\r\n    weight = 1,\r\n    kind = \"letter_pack\",\r\n    create_card = function (self, card, i) \r\n        return create_card(\"Alphabet\", G.pack_cards, nil, nil, true, true, nil, \"_letter\")\r\n    end,\r\n    in_pool = function(self, args)\r\n        return G.GAME.akyrs_character_stickers_enabled and G.GAME.akyrs_wording_enabled\r\n    end,\r\n    cry_digital_hallucinations = alphabet_digital_hallucinations_compat,",
      "config": {
        "extra": 3,
        "choose": 1
      },
      "ability": {
        "extra": 3,
        "choose": 1
      },
      "vars": [
        1,
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "letter_pack_3",
      "atlas": "aikoyoriBoosterPack",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"letter_pack_3\",\r\n    set = \"Booster\",\r\n    config = { extra = 3, choose = 1 },\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.choose,\r\n                card.ability.extra,\r\n            },\r\n            key = \"p_akyrs_letter_pack_normal\"\r\n        }\r\n    end,\r\n    atlas = 'aikoyoriBoosterPack', pos = { x = 2, y = 0 },\r\n    group_key = \"k_akyrs_alphabet_pack\",\r\n    cost = 4,\r\n    select_card = 'consumeables',\r\n    weight = 1,\r\n    kind = \"letter_pack\",\r\n    create_card = function (self, card, i) \r\n        return create_card(\"Alphabet\", G.pack_cards, nil, nil, true, true, nil, \"_letter\")\r\n    end,\r\n    in_pool = function(self, args)\r\n        return G.GAME.akyrs_character_stickers_enabled and G.GAME.akyrs_wording_enabled\r\n    end,\r\n    cry_digital_hallucinations = alphabet_digital_hallucinations_compat,",
      "config": {
        "extra": 3,
        "choose": 1
      },
      "ability": {
        "extra": 3,
        "choose": 1
      },
      "vars": [
        1,
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "letter_pack_4",
      "atlas": "aikoyoriBoosterPack",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"letter_pack_4\",\r\n    set = \"Booster\",\r\n    config = { extra = 3, choose = 1 },\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.choose,\r\n                card.ability.extra,\r\n            },\r\n            key = \"p_akyrs_letter_pack_normal\"\r\n        }\r\n    end,\r\n    atlas = 'aikoyoriBoosterPack', pos = { x = 3, y = 0 },\r\n    group_key = \"k_akyrs_alphabet_pack\",\r\n    cost = 4,\r\n    select_card = 'consumeables',\r\n    weight = 1,\r\n    kind = \"letter_pack\",\r\n    create_card = function (self, card, i) \r\n        return create_card(\"Alphabet\", G.pack_cards, nil, nil, true, true, nil, \"_letter\")\r\n    end,\r\n    in_pool = function(self, args)\r\n        return G.GAME.akyrs_character_stickers_enabled and G.GAME.akyrs_wording_enabled\r\n    end,\r\n    cry_digital_hallucinations = alphabet_digital_hallucinations_compat,",
      "config": {
        "extra": 3,
        "choose": 1
      },
      "ability": {
        "extra": 3,
        "choose": 1
      },
      "vars": [
        1,
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "jumbo_letter_pack_1",
      "atlas": "aikoyoriBoosterPack",
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "key = \"jumbo_letter_pack_1\",\r\n    set = \"Booster\",\r\n    config = { extra = 5, choose = 1 },\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.choose,\r\n                card.ability.extra,\r\n            },\r\n            key = \"p_akyrs_letter_pack_jumbo\"\r\n        }\r\n    end,\r\n    atlas = 'aikoyoriBoosterPack', pos = { x = 4, y = 0 },\r\n    group_key = \"k_akyrs_alphabet_pack\",\r\n    cost = 6,\r\n    select_card = 'consumeables',\r\n    weight = 1,\r\n    kind = \"letter_pack\",\r\n    create_card = function (self, card, i) \r\n        return create_card(\"Alphabet\", G.pack_cards, nil, nil, true, true, nil, \"_letter\")\r\n    end,\r\n    in_pool = function(self, args)\r\n        return G.GAME.akyrs_character_stickers_enabled and G.GAME.akyrs_wording_enabled\r\n    end,\r\n    cry_digital_hallucinations = alphabet_digital_hallucinations_compat,",
      "config": {
        "extra": 5,
        "choose": 1
      },
      "ability": {
        "extra": 5,
        "choose": 1
      },
      "vars": [
        1,
        5
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "jumbo_letter_pack_2",
      "atlas": "aikoyoriBoosterPack",
      "pos": {
        "x": 5,
        "y": 0
      },
      "raw": "key = \"jumbo_letter_pack_2\",\r\n    set = \"Booster\",\r\n    config = { extra = 5, choose = 1 },\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.choose,\r\n                card.ability.extra,\r\n            },\r\n            key = \"p_akyrs_letter_pack_jumbo\"\r\n        }\r\n    end,\r\n    atlas = 'aikoyoriBoosterPack', pos = { x = 5, y = 0 },\r\n    group_key = \"k_akyrs_alphabet_pack\",\r\n    cost = 6,\r\n    select_card = 'consumeables',\r\n    weight = 1,\r\n    kind = \"letter_pack\",\r\n    create_card = function (self, card, i) \r\n        return create_card(\"Alphabet\", G.pack_cards, nil, nil, true, true, nil, \"_letter\")\r\n    end,\r\n    in_pool = function(self, args)\r\n        return G.GAME.akyrs_character_stickers_enabled and G.GAME.akyrs_wording_enabled\r\n    end,\r\n    cry_digital_hallucinations = alphabet_digital_hallucinations_compat,",
      "config": {
        "extra": 5,
        "choose": 1
      },
      "ability": {
        "extra": 5,
        "choose": 1
      },
      "vars": [
        1,
        5
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "mega_letter_pack_1",
      "atlas": "aikoyoriBoosterPack",
      "pos": {
        "x": 6,
        "y": 0
      },
      "raw": "key = \"mega_letter_pack_1\",\r\n    set = \"Booster\",\r\n    config = { extra = 5, choose = 2 },\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.choose,\r\n                card.ability.extra,\r\n            },\r\n            key = \"p_akyrs_letter_pack_mega\"\r\n        }\r\n    end,\r\n    atlas = 'aikoyoriBoosterPack', pos = { x = 6, y = 0 },\r\n    group_key = \"k_akyrs_alphabet_pack\",\r\n    cost = 8,\r\n    select_card = 'consumeables',\r\n    weight = 0.25,\r\n    kind = \"letter_pack\",\r\n    create_card = function (self, card, i) \r\n        return create_card(\"Alphabet\", G.pack_cards, nil, nil, true, true, nil, \"_letter\")\r\n    end,\r\n    in_pool = function(self, args)\r\n        return G.GAME.akyrs_character_stickers_enabled and G.GAME.akyrs_wording_enabled\r\n    end,\r\n    cry_digital_hallucinations = alphabet_digital_hallucinations_compat,",
      "config": {
        "extra": 5,
        "choose": 2
      },
      "ability": {
        "extra": 5,
        "choose": 2
      },
      "vars": [
        2,
        5
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "mega_letter_pack_2",
      "atlas": "aikoyoriBoosterPack",
      "pos": {
        "x": 7,
        "y": 0
      },
      "raw": "key = \"mega_letter_pack_2\",\r\n    set = \"Booster\",\r\n    config = { extra = 5, choose = 2 },\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.choose,\r\n                card.ability.extra,\r\n            },\r\n            key = \"p_akyrs_letter_pack_mega\"\r\n        }\r\n    end,\r\n    atlas = 'aikoyoriBoosterPack', pos = { x = 7, y = 0 },\r\n    group_key = \"k_akyrs_alphabet_pack\",\r\n    cost = 8,\r\n    select_card = 'consumeables',\r\n    weight = 0.25,\r\n    kind = \"letter_pack\",\r\n    create_card = function (self, card, i) \r\n        return create_card(\"Alphabet\", G.pack_cards, nil, nil, true, true, nil, \"_letter\")\r\n    end,\r\n    in_pool = function(self, args)\r\n        return G.GAME.akyrs_character_stickers_enabled and G.GAME.akyrs_wording_enabled\r\n    end,\r\n    cry_digital_hallucinations = alphabet_digital_hallucinations_compat,",
      "config": {
        "extra": 5,
        "choose": 2
      },
      "ability": {
        "extra": 5,
        "choose": 2
      },
      "vars": [
        2,
        5
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "umbral_pack_1",
      "atlas": "aikoyoriBoosterPack",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"umbral_pack_1\",\r\n    set = \"Booster\",\r\n    config = { extra = 3, choose = 1 },\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.choose,\r\n                card.ability.extra,\r\n            },\r\n            key = \"p_akyrs_umbral_pack_normal\"\r\n        }\r\n    end,\r\n    atlas = 'aikoyoriBoosterPack', pos = { x = 0, y = 1 },\r\n    group_key = \"k_akyrs_umbral_pack\",\r\n    cost = 4,\r\n    weight = 0.5,\r\n    draw_hand = true,\r\n    kind = \"umbral_pack\",\r\n    create_card = function (self, card, i) \r\n        return SMODS.create_card{ set = \"Umbral\", area = G.pack_cards, skip_materialize = true }\r\n    end,\r\n    ease_background_colour = ease_bg_umbral,\r\n    cry_digital_hallucinations = umbral_digital_hallucinations_compat,",
      "config": {
        "extra": 3,
        "choose": 1
      },
      "ability": {
        "extra": 3,
        "choose": 1
      },
      "vars": [
        1,
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "umbral_pack_2",
      "atlas": "aikoyoriBoosterPack",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"umbral_pack_2\",\r\n    set = \"Booster\",\r\n    config = { extra = 3, choose = 1 },\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.choose,\r\n                card.ability.extra,\r\n            },\r\n            key = \"p_akyrs_umbral_pack_normal\"\r\n        }\r\n    end,\r\n    atlas = 'aikoyoriBoosterPack', pos = { x = 1, y = 1 },\r\n    group_key = \"k_akyrs_umbral_pack\",\r\n    cost = 4,\r\n    weight = 0.5,\r\n    draw_hand = true,\r\n    kind = \"umbral_pack\",\r\n    create_card = function (self, card, i) \r\n        return SMODS.create_card{ set = \"Umbral\", area = G.pack_cards, skip_materialize = true }\r\n    end,\r\n    ease_background_colour = ease_bg_umbral,\r\n    cry_digital_hallucinations = umbral_digital_hallucinations_compat,",
      "config": {
        "extra": 3,
        "choose": 1
      },
      "ability": {
        "extra": 3,
        "choose": 1
      },
      "vars": [
        1,
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "umbral_pack_3",
      "atlas": "aikoyoriBoosterPack",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"umbral_pack_3\",\r\n    set = \"Booster\",\r\n    config = { extra = 3, choose = 1 },\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.choose,\r\n                card.ability.extra,\r\n            },\r\n            key = \"p_akyrs_umbral_pack_normal\"\r\n        }\r\n    end,\r\n    atlas = 'aikoyoriBoosterPack', pos = { x = 2, y = 1 },\r\n    group_key = \"k_akyrs_umbral_pack\",\r\n    cost = 4,\r\n    weight = 0.5,\r\n    draw_hand = true,\r\n    kind = \"umbral_pack\",\r\n    create_card = function (self, card, i) \r\n        return SMODS.create_card{ set = \"Umbral\", area = G.pack_cards, skip_materialize = true }\r\n    end,\r\n    ease_background_colour = ease_bg_umbral,\r\n    cry_digital_hallucinations = umbral_digital_hallucinations_compat,",
      "config": {
        "extra": 3,
        "choose": 1
      },
      "ability": {
        "extra": 3,
        "choose": 1
      },
      "vars": [
        1,
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "umbral_pack_4",
      "atlas": "aikoyoriBoosterPack",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"umbral_pack_4\",\r\n    set = \"Booster\",\r\n    config = { extra = 3, choose = 1 },\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.choose,\r\n                card.ability.extra,\r\n            },\r\n            key = \"p_akyrs_umbral_pack_normal\"\r\n        }\r\n    end,\r\n    atlas = 'aikoyoriBoosterPack', pos = { x = 3, y = 1 },\r\n    group_key = \"k_akyrs_umbral_pack\",\r\n    cost = 4,\r\n    weight = 0.5,\r\n    create_card = function (self, card, i) \r\n        return SMODS.create_card{ set = \"Umbral\", area = G.pack_cards, skip_materialize = true }\r\n    end,\r\n    draw_hand = true,\r\n    kind = \"umbral_pack\",\r\n    ease_background_colour = ease_bg_umbral,\r\n    cry_digital_hallucinations = umbral_digital_hallucinations_compat,",
      "config": {
        "extra": 3,
        "choose": 1
      },
      "ability": {
        "extra": 3,
        "choose": 1
      },
      "vars": [
        1,
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "jumbo_umbral_pack_1",
      "atlas": "aikoyoriBoosterPack",
      "pos": {
        "x": 4,
        "y": 1
      },
      "raw": "key = \"jumbo_umbral_pack_1\",\r\n    set = \"Booster\",\r\n    config = { extra = 5, choose = 1 },\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.choose,\r\n                card.ability.extra,\r\n            },\r\n            key = \"p_akyrs_umbral_pack_jumbo\"\r\n        }\r\n    end,\r\n    atlas = 'aikoyoriBoosterPack', pos = { x = 4, y = 1 },\r\n    group_key = \"k_akyrs_umbral_pack\",\r\n    cost = 6,\r\n    weight = 0.5,\r\n    draw_hand = true,\r\n    kind = \"umbral_pack\",\r\n    create_card = function (self, card, i) \r\n        return SMODS.create_card{ set = \"Umbral\", area = G.pack_cards, skip_materialize = true }\r\n    end,\r\n    ease_background_colour = ease_bg_umbral,\r\n    cry_digital_hallucinations = umbral_digital_hallucinations_compat,",
      "config": {
        "extra": 5,
        "choose": 1
      },
      "ability": {
        "extra": 5,
        "choose": 1
      },
      "vars": [
        1,
        5
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "jumbo_umbral_pack_2",
      "atlas": "aikoyoriBoosterPack",
      "pos": {
        "x": 5,
        "y": 1
      },
      "raw": "key = \"jumbo_umbral_pack_2\",\r\n    set = \"Booster\",\r\n    config = { extra = 5, choose = 1 },\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.choose,\r\n                card.ability.extra,\r\n            },\r\n            key = \"p_akyrs_umbral_pack_jumbo\"\r\n        }\r\n    end,\r\n    atlas = 'aikoyoriBoosterPack', pos = { x = 5, y = 1 },\r\n    group_key = \"k_akyrs_umbral_pack\",\r\n    cost = 6,\r\n    weight = 0.5,\r\n    draw_hand = true,\r\n    kind = \"umbral_pack\",\r\n    create_card = function (self, card, i) \r\n        return SMODS.create_card{ set = \"Umbral\", area = G.pack_cards, skip_materialize = true }\r\n    end,\r\n    ease_background_colour = ease_bg_umbral,\r\n    cry_digital_hallucinations = umbral_digital_hallucinations_compat,",
      "config": {
        "extra": 5,
        "choose": 1
      },
      "ability": {
        "extra": 5,
        "choose": 1
      },
      "vars": [
        1,
        5
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "mega_umbral_pack_1",
      "atlas": "aikoyoriBoosterPack",
      "pos": {
        "x": 6,
        "y": 1
      },
      "raw": "key = \"mega_umbral_pack_1\",\r\n    set = \"Booster\",\r\n    config = { extra = 5, choose = 2 },\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.choose,\r\n                card.ability.extra,\r\n            },\r\n            key = \"p_akyrs_umbral_pack_mega\"\r\n        }\r\n    end,\r\n    atlas = 'aikoyoriBoosterPack', pos = { x = 6, y = 1 },\r\n    group_key = \"k_akyrs_umbral_pack\",\r\n    cost = 8,\r\n    weight = 0.5,\r\n    draw_hand = true,\r\n    kind = \"umbral_pack\",\r\n    create_card = function (self, card, i) \r\n        return SMODS.create_card{ set = \"Umbral\", area = G.pack_cards, skip_materialize = true }\r\n    end,\r\n    ease_background_colour = ease_bg_umbral,\r\n    cry_digital_hallucinations = umbral_digital_hallucinations_compat,",
      "config": {
        "extra": 5,
        "choose": 2
      },
      "ability": {
        "extra": 5,
        "choose": 2
      },
      "vars": [
        2,
        5
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "mega_umbral_pack_2",
      "atlas": "aikoyoriBoosterPack",
      "pos": {
        "x": 7,
        "y": 1
      },
      "raw": "key = \"mega_umbral_pack_2\",\r\n    set = \"Booster\",\r\n    config = { extra = 5, choose = 2 },\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.choose,\r\n                card.ability.extra,\r\n            },\r\n            key = \"p_akyrs_umbral_pack_mega\"\r\n        }\r\n    end,\r\n    atlas = 'aikoyoriBoosterPack', pos = { x = 7, y = 1 },\r\n    group_key = \"k_akyrs_umbral_pack\",\r\n    draw_hand = true,\r\n    cost = 8,\r\n    weight = 0.5,\r\n    kind = \"umbral_pack\",\r\n    create_card = function (self, card, i) \r\n        return SMODS.create_card{ set = \"Umbral\", area = G.pack_cards, skip_materialize = true }\r\n    end,\r\n    ease_background_colour = ease_bg_umbral,\r\n    cry_digital_hallucinations = umbral_digital_hallucinations_compat,",
      "config": {
        "extra": 5,
        "choose": 2
      },
      "ability": {
        "extra": 5,
        "choose": 2
      },
      "vars": [
        2,
        5
      ],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "null",
      "atlas": "cardUpgrades",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "--    key = \"null\",\r\n--    atlas = 'cardUpgrades',\r\n--    pos = {x = 0, y = 0},\r\n--    loc_txt =  \t{\r\n--        name = 'Null',\r\n--        text = { 'No Base Chips' },\r\n--    },\r\n--    replace_base_card = true,\r\n--    no_rank = true,\r\n--    no_suit = true,\r\n--    always_scores = true,\r\n--    weight = 0,\r\n--    config = {\r\n--        bonus = 0,\r\n--        bonus_chips = 0,\r\n--        mult = 0,\r\n--    }\r\n--",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "letter_deck",
      "atlas": "deckBacks",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"letter_deck\",\r\n    atlas = 'deckBacks',\r\n    pos = {x = 0, y = 0},\r\n    loc_vars = function (self, info_queue, card)\r\n        return { vars = {\r\n            self.config.ante_scaling,\r\n            self.config.discards,\r\n            self.config.hand_size\r\n        } }\r\n    end,\r\n    config = {\r\n        akyrs_starting_letters = AKYRS.scrabble_letters,\r\n        starting_deck_size = 100,\r\n        akyrs_selection = 1e100,\r\n        discards = 2,\r\n        akyrs_start_with_no_cards = true,\r\n        akyrs_letters_mult_enabled = true,\r\n        akyrs_hide_normal_hands = true,\r\n        ante_scaling = 2,\r\n        hand_size = 2,\r\n        vouchers = {'v_akyrs_alphabet_soup','v_akyrs_crossing_field'}\r\n    },",
      "config": {},
      "ability": {},
      "vars": [
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "math_deck",
      "atlas": "deckBacks",
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "key = \"math_deck\",\r\n    atlas = 'deckBacks',\r\n    pos = {x = 4, y = 0},\r\n    loc_vars = function (self, info_queue, card)\r\n        return { vars = {\r\n            self.config.akyrs_math_threshold,\r\n            5 + self.config.akyrs_selection,\r\n            self.config.akyrs_gain_selection_per_ante\r\n        } }\r\n    end,\r\n    config = {\r\n        akyrs_starting_letters = AKYRS.math_deck_characters,\r\n        akyrs_start_with_no_cards = true,\r\n        akyrs_mathematics_enabled = true,\r\n        akyrs_character_stickers_enabled = true,\r\n        akyrs_no_skips = true,\r\n        akyrs_selection = 0,\r\n        akyrs_gain_selection_per_ante = 1,\r\n        discards = 1,\r\n        --akyrs_always_skip_shops = true,\r\n        akyrs_math_threshold = 1,\r\n        hand_size = 6,\r\n        akyrs_power_of_x_scaling = 13.69,\r\n        akyrs_hide_normal_hands = true,\r\n        akyrs_hide_high_card = true,\r\n        akyrs_hand_to_not_hide = {[\"akyrs_expression\"] = true,[\"akyrs_modification\"] = true },\r\n        akyrs_random_scale = {min = 0.5, max = 9.5},\r\n    },",
      "config": {},
      "ability": {},
      "vars": [
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "hardcore_challenges",
      "atlas": "deckBacks",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"hardcore_challenges\",\r\n    name = \"Hardcore Challenge Deck\",\r\n    atlas = 'deckBacks',\r\n    pos = {x = 1, y = 0},\r\n    omit = true,\r\n    config = {\r\n    },",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "scuffed_misprint",
      "atlas": "deckBacks",
      "pos": {
        "x": 7,
        "y": 0
      },
      "raw": "key = \"scuffed_misprint\",\r\n    atlas = \"deckBacks\",\r\n    pos = { x = 7, y = 0},\r\n    config = { akyrs_misprint_min = 1e-4, akyrs_misprint_max = 1e4 },\r\n    set_badges = function (self, card, badges)\r\n    end,\r\n    loc_vars = function (self, info_queue, card)\r\n        --info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_placeholder_art\"}\r\n        return {\r\n            vars = {\r\n                self.config.akyrs_misprint_min,\r\n                self.config.akyrs_misprint_max\r\n            }\r\n        }\r\n    end,\r\n    apply = function(self)\r\n        G.GAME.modifiers.akyrs_misprint = true\r\n    end,",
      "config": {
        "akyrs_misprint_min": 0.0001,
        "akyrs_misprint_max": 10000
      },
      "ability": {
        "akyrs_misprint_min": 0.0001,
        "akyrs_misprint_max": 10000
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "freedom",
      "atlas": "deckBacks",
      "pos": {
        "x": 8,
        "y": 0
      },
      "raw": "key = \"freedom\",\r\n    atlas = \"deckBacks\",\r\n    pos = { x = 8, y = 0},\r\n    config = { akyrs_any_drag = true },\r\n    set_badges = function (self, card, badges)\r\n    end,\r\n    loc_vars = function (self, info_queue, card)\r\n    end,",
      "config": {
        "akyrs_any_drag": true
      },
      "ability": {
        "akyrs_any_drag": true
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "brick_card",
      "atlas": "cardUpgrades",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"brick_card\",\r\n    atlas = 'cardUpgrades',\r\n    pos = {x = 1, y = 0},\r\n    loc_vars = function (self, info_queue, card)\r\n        return { vars = {\r\n            card.ability.extra.mult\r\n        } }\r\n    end,\r\n    config = {\r\n        extra = {\r\n            mult = 10\r\n        }\r\n    },\r\n    calculate = function (self, card, context)\r\n        if context.main_scoring and context.cardarea == G.play then\r\n            return {\r\n                mult = card.ability.extra.mult\r\n            }\r\n        end\r\n    end,\r\n    no_rank = true,\r\n    no_suit = true,\r\n    always_scores = true,\r\n    replace_base_card = true,",
      "config": {
        "extra": {
          "mult": 10
        }
      },
      "ability": {
        "extra": {
          "mult": 10
        }
      },
      "vars": [
        10
      ],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "scoreless",
      "atlas": "cardUpgrades",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"scoreless\",\r\n    atlas = 'cardUpgrades',\r\n    pos = {x = 0, y = 0},\r\n    loc_vars = function (self, info_queue, card)\r\n        return { vars = {\r\n        } }\r\n    end,\r\n    in_pool = function (self, args)\r\n        return false\r\n    end,\r\n    never_scores = true,\r\n    replace_base_card = false,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "ash_card",
      "atlas": "cardUpgrades",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"ash_card\",\r\n    atlas = 'cardUpgrades',\r\n    pos = {x = 2, y = 0},\r\n    loc_vars = function (self, info_queue, card)\r\n        \r\n        if AKYRS.bal(\"absurd\") then\r\n            return {\r\n                key = self.key .. \"_absurd\",\r\n                vars = {\r\n                    card.ability.extras.echips,\r\n                }\r\n            }\r\n        end\r\n        local n,d = SMODS.get_probability_vars(card,1,card.ability.extras.odds,\"akyrs_ash_card\")\r\n        return { vars = {\r\n            card.ability.extras.chips,\r\n            n,d\r\n        } }\r\n    end,\r\n    config = {\r\n        extras = {\r\n            chips = 35,\r\n            echips = 2,\r\n            odds = 4\r\n        }\r\n    },\r\n    in_pool = function (self, args)\r\n        return false\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.main_scoring and context.cardarea == G.play then\r\n            return AKYRS.bal_val({\r\n                chips = card.ability.extras.chips\r\n            }, {\r\n                echips = card.ability.extras.echips\r\n            })\r\n        end\r\n    end,\r\n    no_rank = true,\r\n    no_suit = true,\r\n    always_scores = true,\r\n    replace_base_card = true,",
      "config": {
        "extras": {
          "chips": 35,
          "echips": 2,
          "odds": 4
        }
      },
      "ability": {
        "extras": {
          "chips": 35,
          "echips": 2,
          "odds": 4
        }
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "hatena",
      "atlas": "cardUpgrades",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"hatena\",\r\n    atlas = 'cardUpgrades',\r\n    pos = {x = 3, y = 0},\r\n    no_rank = true,\r\n    no_suit = true,\r\n    always_scores = true,\r\n    replace_base_card = true,\r\n    config = {\r\n        extras = {\r\n            odds_d = 2,\r\n            d = 1, \r\n            odds_d10 = 10,\r\n            d10 = 10,\r\n            nom_mults = 4,\r\n            denom_mults = 5,\r\n            mult_init = 6,\r\n            xmult_retrig = 1.3\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        local n_dollar_1, d_dollar_1 = SMODS.get_probability_vars(card,1,card.ability.extras.odds_d,\"akyrs_hatena_d1\") -- odds of getting 1 money\r\n        local n_dollar_10, d_dollar_10 = SMODS.get_probability_vars(card,1,card.ability.extras.odds_d10,\"akyrs_hatena_d10\") -- odds of getting 10 money\r\n        local n_dollar_mult, d_dollar_mult = SMODS.get_probability_vars(card,card.ability.extras.nom_mults,card.ability.extras.denom_mults,\"akyrs_hatena_mults\") -- odds of getting mults\r\n        return {\r\n            vars = {\r\n                n_dollar_1, d_dollar_1,card.ability.extras.d,\r\n                n_dollar_10, d_dollar_10,card.ability.extras.d10,\r\n                n_dollar_mult, d_dollar_mult,card.ability.extras.mult_init,card.ability.extras.xmult_retrig,\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.main_scoring and context.cardarea == G.play then\r\n            if SMODS.pseudorandom_probability(card,\"akyrs_hatena_d1\",1,card.ability.extras.odds_d) then\r\n                return {\r\n                    dollars = card.ability.extras.d\r\n                }\r\n            end\r\n            if SMODS.pseudorandom_probability(card,\"akyrs_hatena_d10\",1,card.ability.extras.odds_d10) then\r\n                return {\r\n                    dollars = card.ability.extras.d10\r\n                }\r\n            end\r\n            if SMODS.pseudorandom_probability(card,\"akyrs_hatena_mults\",card.ability.extras.nom_mults,card.ability.extras.denom_mults) then\r\n                if card.akyrs_triggered then\r\n                    return {\r\n                        xmult = card.ability.extras.xmult_retrig\r\n                    }\r\n                else\r\n                    return {\r\n                        mult = card.ability.extras.mult_init,\r\n                        func = function()\r\n                            card.akyrs_triggered = true\r\n                        end\r\n                    }\r\n                end\r\n            end\r\n            if context.final_scoring_step then\r\n                return {\r\n                    func = function()\r\n                        card.akyrs_triggered = nil\r\n                    end\r\n                }\r\n            end\r\n        end\r\n    end",
      "config": {
        "extras": {
          "odds_d": 2,
          "d": 1,
          "odds_d10": 10,
          "d10": 10,
          "nom_mults": 4,
          "denom_mults": 5,
          "mult_init": 6,
          "xmult_retrig": 1.3
        }
      },
      "ability": {
        "extras": {
          "odds_d": 2,
          "d": 1,
          "odds_d10": 10,
          "d10": 10,
          "nom_mults": 4,
          "denom_mults": 5,
          "mult_init": 6,
          "xmult_retrig": 1.3
        }
      },
      "vars": [
        null,
        null,
        1,
        null,
        null,
        10,
        null,
        null,
        6,
        1.3
      ],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "item_box",
      "atlas": "cardUpgrades",
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "key = \"item_box\",\r\n    atlas = 'cardUpgrades',\r\n    pos = {x = 4, y = 0},\r\n    no_rank = true,\r\n    no_suit = true,\r\n    always_scores = true,\r\n    replace_base_card = true,\r\n    config = {\r\n        extras = {\r\n        }\r\n    },\r\n    calculate = function (self, card, context)\r\n        if context.main_scoring and context.cardarea == G.play then\r\n            return {\r\n                message = localize(\"k_akyrs_item_box_trigger\"),\r\n                func = function ()\r\n                    AKYRS.simple_event_add(\r\n                        function ()\r\n                            --[[\r\n                            -- this is just me being stupid\r\n                            if AKYRS.has_room(G.consumeables) then\r\n                                card.ability.akyrs_triggered = true\r\n                                local k, lim = nil, 0\r\n                                repeat\r\n                                    lim = lim + 1\r\n                                    k = pseudorandom_element(G.P_CENTER_POOLS.Consumeables,pseudoseed(\"akyrs_item_box_consumable_pick\"))\r\n                                until (not k.hidden and (not k.in_pool or k:in_pool({})) and not G.GAME.banned_keys[k.key]) or lim >= #G.P_CENTER_POOLS.Consumeables\r\n                                if not lim >= #G.P_CENTER_POOLS.Consumeables then\r\n                                    SMODS.add_card{key = k.key}\r\n                                end\r\n                            end\r\n                            ]]\r\n                            if AKYRS.has_room(G.consumeables) then\r\n                                SMODS.add_card{set = \"Consumeables\", area = G.consumeables}\r\n                            end\r\n                            return true\r\n                        end, 0\r\n                    )\r\n                end\r\n            }\r\n        end\r\n    end",
      "config": {
        "extras": {}
      },
      "ability": {
        "extras": {}
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "insolate_card",
      "atlas": "cardUpgrades",
      "pos": {
        "x": 5,
        "y": 0
      },
      "raw": "key = \"insolate_card\",\r\n    atlas = 'cardUpgrades',\r\n    pos = {x = 5, y = 0},\r\n    config = {\r\n        extras = {\r\n            xmult = 1,\r\n            xmult_add = 0.2,\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras.xmult_add,\r\n                card.ability.extras.xmult,\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.before then\r\n        end\r\n        if context.main_scoring and context.cardarea == G.play then\r\n            local r = AKYRS.get_suit_freq_from_cards(G.play.cards,true)\r\n            local s = true\r\n            for k,v in pairs(r) do\r\n                if v > 1 then\r\n                    s = false\r\n                    break\r\n                end\r\n            end\r\n            if s then\r\n                SMODS.calculate_effect({\r\n                    message = localize(\"k_upgrade_ex\"),\r\n                    func = function ()\r\n                        card.ability.extras.xmult = card.ability.extras.xmult + card.ability.extras.xmult_add\r\n                    end\r\n                }, card)\r\n            end\r\n            return {\r\n                xmult = card.ability.extras.xmult\r\n            }\r\n        end\r\n    end",
      "config": {
        "extras": {
          "xmult": 1,
          "xmult_add": 0.2
        }
      },
      "ability": {
        "extras": {
          "xmult": 1,
          "xmult_add": 0.2
        }
      },
      "vars": [
        0.2,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "canopy_card",
      "atlas": "cardUpgrades",
      "pos": {
        "x": 6,
        "y": 0
      },
      "raw": "key = \"canopy_card\",\r\n    atlas = 'cardUpgrades',\r\n    pos = {x = 6, y = 0},\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.after and context.cardarea == G.hand then\r\n            return {\r\n                func = function ()\r\n                    AKYRS.simple_event_add(\r\n                        function ()\r\n                            card:akyrs_flip_y()\r\n                            AKYRS.simple_event_add(\r\n                                function ()\r\n                                    card:akyrs_flip_y()\r\n                                    card = SMODS.modify_rank(card, -1)\r\n                                    return true\r\n                                end\r\n                            )\r\n                            return true\r\n                        end\r\n                    )\r\n                end\r\n            }\r\n        end\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "thai_tea_card",
      "atlas": "cardUpgrades",
      "pos": {
        "x": 7,
        "y": 0
      },
      "raw": "key = \"thai_tea_card\",\r\n    atlas = 'cardUpgrades',\r\n    pos = {x = 7, y = 0},\r\n    config = {\r\n        extras = {\r\n            xmult = 1.6,\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras.xmult\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.main_scoring and context.cardarea == G.play then\r\n            if AKYRS.bal(\"absurd\") and AKYRS.checkBlindKey(\"bl_mouth\") and #G.play.cards == 1 then\r\n                SMODS.calculate_effect(\r\n                    {\r\n                        func = function ()\r\n                            G.GAME.blind:set_blind(G.P_BLINDS['bl_water'])\r\n                        end\r\n                    },card\r\n                )\r\n            end\r\n            return {\r\n                xmult = card.ability.extras.xmult\r\n            }\r\n        end\r\n    end",
      "config": {
        "extras": {
          "xmult": 1.6
        }
      },
      "ability": {
        "extras": {
          "xmult": 1.6
        }
      },
      "vars": [
        1.6
      ],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "matcha_card",
      "atlas": "cardUpgrades",
      "pos": {
        "x": 8,
        "y": 0
      },
      "raw": "key = \"matcha_card\",\r\n    atlas = 'cardUpgrades',\r\n    pos = {x = 8, y = 0},\r\n    config = {\r\n        extras = {\r\n            xchips = 1.4,\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras.xchips\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.main_scoring and context.cardarea == G.play then\r\n            return {\r\n                xchips = card.ability.extras.xchips\r\n            }\r\n        end\r\n    end",
      "config": {
        "extras": {
          "xchips": 1.4
        }
      },
      "ability": {
        "extras": {
          "xchips": 1.4
        }
      },
      "vars": [
        1.4
      ],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "earl_grey_tea_card",
      "atlas": "cardUpgrades",
      "pos": {
        "x": 9,
        "y": 0
      },
      "raw": "key = \"earl_grey_tea_card\",\r\n    atlas = 'cardUpgrades',\r\n    pos = {x = 9, y = 0},\r\n    config = {\r\n        extras = {\r\n            dollars = 3,\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras.dollars\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.main_scoring and context.cardarea == 'unscored' then\r\n            return {\r\n                dollars = card.ability.extras.dollars\r\n            }\r\n        end\r\n    end",
      "config": {
        "extras": {
          "dollars": 3
        }
      },
      "ability": {
        "extras": {
          "dollars": 3
        }
      },
      "vars": [
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "zap_card",
      "atlas": "cardUpgrades",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"zap_card\",\r\n    atlas = 'cardUpgrades',\r\n    pos = {x = 0, y = 1},\r\n    config = {\r\n        extras = {\r\n            trigger_triggered = 0,\r\n            trigger_needed = 3,\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras.trigger_needed,\r\n                card.ability.extras.trigger_triggered\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.main_scoring and context.cardarea == G.play then\r\n            return {\r\n                func = function ()\r\n                    card.ability.extras.trigger_triggered = card.ability.extras.trigger_triggered + 1\r\n                    if card.ability.extras.trigger_triggered >= card.ability.extras.trigger_needed then\r\n                        SMODS.calculate_effect({\r\n                            message = localize(\"k_duplicated_ex\"),\r\n                            func = function ()\r\n                                card.ability.extras.trigger_triggered = 0\r\n                                local c2 = AKYRS.copy_p_card(card,nil,nil,nil,nil,G.hand)\r\n                                c2:set_ability(G.P_CENTERS.c_base)\r\n                            end\r\n                        }, card)\r\n                    end\r\n                end,\r\n                message = localize(\"k_upgrade_ex\")\r\n            }\r\n        end\r\n    end",
      "config": {
        "extras": {
          "trigger_triggered": 0,
          "trigger_needed": 3
        }
      },
      "ability": {
        "extras": {
          "trigger_triggered": 0,
          "trigger_needed": 3
        }
      },
      "vars": [
        3,
        0
      ],
      "infoQueue": []
    },
    {
      "type": "Challenge",
      "key": "space_oddity",
      "atlas": null,
      "pos": null,
      "raw": "key = \"space_oddity\",\n    jokers = {\n        AKYRS.crypternity{\n            id = \"j_space\",\n            edition = \"akyrs_sliced\",\n            akyrs_sell_cost = 0,\n        },\n        AKYRS.crypternity{\n            id = \"j_oops\",\n            edition = \"akyrs_noire\",\n            akyrs_sell_cost = 0,\n        },\n    }",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Challenge",
      "key": "4_hibanas",
      "atlas": null,
      "pos": null,
      "raw": "key = \"4_hibanas\",\n    jokers = {\n        AKYRS.crypternity{\n            id = \"j_akyrs_hibana\",\n            edition = \"negative\",\n            pinned = true,\n            eternal = true,\n            akyrs_sell_cost = 0,\n            akyrs_card_ability = {\n                immutable = {\n                    akyrs_cycler = 4,\n                    akyrs_priority_draw_rank = \"5\"\n                }\n\n            }\n        },\n        AKYRS.crypternity{\n            id = \"j_akyrs_hibana\",\n            edition = \"negative\",\n            pinned = true,\n            eternal = true,\n            akyrs_sell_cost = 0,\n            akyrs_card_ability = {\n                immutable = {\n                    akyrs_cycler = 3,\n                    akyrs_priority_draw_suit = \"Hearts\"\n                }\n            }\n        },\n        AKYRS.crypternity{\n            id = \"j_akyrs_hibana\",\n            edition = \"negative\",\n            pinned = true,\n            eternal = true,\n            akyrs_sell_cost = 0,\n            akyrs_card_ability = {\n                immutable = {\n                    akyrs_cycler = 2,\n                    akyrs_priority_draw_conditions = \"Face Cards\"\n                }\n            }\n        },\n        AKYRS.crypternity{\n            id = \"j_akyrs_hibana\",\n            edition = \"negative\",\n            eternal = true,\n            pinned = true,\n            akyrs_sell_cost = 0,\n            akyrs_card_ability = {\n                immutable = {\n                    akyrs_cycler = 1,\n                    akyrs_priority_draw_rank = \"Ace\"\n                }\n            }\n        },\n    },\n    rules = {\n        modifiers = {\n            { id = \"discards\", value = 1 },\n            { id = \"dollars\", value = 10 },\n        }\n    }",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Planet",
      "key": "p_",
      "atlas": "aikoConstellationCards",
      "pos": null,
      "raw": "atlas = \"aikoConstellationCards\",\r\n        pos = { x = i-1 , y=0},\r\n        key = \"p_\"..k,\r\n        config = {\r\n            hand_type = hand,\r\n            softlock = true\r\n        },\r\n        set_card_type_badge = function(self, card, badges)\r\n            badges[1] = create_badge(localize('k_akyrs_constellation'), get_type_colour(self or card.config, card), nil, 1.2)\r\n        end,\r\n        loc_vars = function (self,iq,_c)\r\n            local level = AKYRS.get_hand_in_game(_c) and AKYRS.get_hand_in_game(_c).level or 1\r\n            local handlevelcol = G.C.HAND_LEVELS[math.min(7, level)]\r\n            if Talisman then\r\n                handlevelcol = G.C.HAND_LEVELS[math.min(7, to_number(level))]\r\n            end\r\n            return {\r\n                vars = {\r\n                    level,\r\n                    localize(hand, 'poker_hands') or \"???\", \r\n                    SMODS.PokerHands[hand].l_mult or 1, \r\n                    SMODS.PokerHands[hand].l_chips or 1,\r\n                    colours = {\r\n                        (to_number(level) == 1 and \r\n                        G.C.UI.TEXT_DARK or \r\n                        handlevelcol)\r\n                    }\r\n                },\r\n            }\r\n        end,\r\n        \r\n        calculate = function(self, card, context)\r\n            if G.GAME.used_vouchers.v_observatory\r\n                and context.joker_main\r\n                and (\r\n                    context.scoring_name == hand\r\n                )\r\n            then\r\n                local value = G.P_CENTERS.v_observatory.config.extra\r\n                return {\r\n                    Xmult = value,\r\n                }\r\n            end\r\n        end,\r\n        in_pool = function(self, args)\r\n            return (G.GAME.akyrs_character_stickers_enabled and G.GAME.akyrs_wording_enabled) and true or false\r\n        end,",
      "config": {},
      "ability": {},
      "vars": [
        null,
        null,
        null,
        1,
        1,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Planet",
      "key": "p_microscopium",
      "atlas": "aikoConstellationCards",
      "pos": {
        "x": 9,
        "y": 0
      },
      "raw": "atlas = \"aikoConstellationCards\",\r\n    pos = { x = 9 , y=0},\r\n    key = \"p_microscopium\",\r\n    config = {\r\n        akyrs_hand_types = hands_multi,\r\n        softlock = true\r\n    },\r\n    set_card_type_badge = function(self, card, badges)\r\n        badges[1] = create_badge(localize('k_akyrs_constellation'), get_type_colour(self or card.config, card), nil, 1.2)\r\n    end,\r\n    loc_vars = function (self,iq,_c)\r\n        local level = AKYRS.get_hand_in_game(_c) and AKYRS.get_hand_in_game(_c).level or 1\r\n        return {\r\n            vars = {\r\n                localize(hands_multi[1], 'poker_hands') or \"???\", \r\n            },\r\n        }\r\n    end,\r\n    use = function (self,card,area,copier)\r\n        AKYRS.silent_bulk_level_up(self, card, area, copier, 1)\r\n    end,\r\n\r\n    can_use = function(self, card) return true end,\r\n    calculate = function(self, card, context)\r\n        if G.GAME.used_vouchers.v_observatory\r\n            and context.joker_main\r\n            and (\r\n                hands_multi_rev[context.scoring_name]\r\n            )\r\n        then\r\n            local value = G.P_CENTERS.v_observatory.config.extra\r\n            return {\r\n                Xmult = value,\r\n            }\r\n        end\r\n    end,\r\n    in_pool = function(self, args)\r\n        return (G.GAME.akyrs_character_stickers_enabled and G.GAME.akyrs_wording_enabled) and true or false\r\n    end,",
      "config": {},
      "ability": {},
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Edition",
      "key": "texelated",
      "atlas": null,
      "pos": null,
      "raw": "key = \"texelated\",\r\n    shader = \"akyrs_texelated\",\r\n    config = {\r\n        extra = {\r\n            x_chip = 0.8,\r\n            x_mult = 2;\r\n        }\r\n    },\r\n    \r\n    calculate =  function (self, card, context)\r\n        if context.main_scoring and context.cardarea == G.play then\r\n            return {\r\n                mult = card.edition.extra.x_chip,\r\n                Xmult = card.edition.extra.x_mult\r\n            }\r\n        end\r\n        if context.pre_joker and (context.cardarea == G.jokers)  then\r\n            return {\r\n                mult = card.edition.extra.x_chip,\r\n                Xmult = card.edition.extra.x_mult\r\n            }\r\n        end\r\n    end,\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                self.config.extra.x_chip,\r\n                self.config.extra.x_mult,\r\n            }\r\n        }\r\n    end,\r\n    sound = { sound = \"akyrs_texelated_sfx\", per = 1.2, vol = 0.4 },\r\n    in_shop = true,\r\n    weight = 7,",
      "config": {},
      "ability": {},
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Edition",
      "key": "noire",
      "atlas": null,
      "pos": null,
      "raw": "key = \"noire\",\r\n    shader = \"akyrs_noire\",\r\n    config = {\r\n        extra ={\r\n            x_mult = 0.75,\r\n        },\r\n        card_limit = 2\r\n    },\r\n    calculate =  function (self, card, context)\r\n        if context.main_scoring and (context.cardarea == G.hand or context.cardarea == G.play)  then\r\n            return {\r\n                Xmult = card.edition.extra.x_mult\r\n            }\r\n        end\r\n        if context.pre_joker and (context.cardarea == G.jokers)  then\r\n            return {\r\n                Xmult = card.edition.extra.x_mult\r\n            }\r\n        end\r\n    end,\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                self.config.card_limit,\r\n                self.config.extra.x_mult,\r\n            }\r\n        }\r\n    end,\r\n    sound = { sound = \"akyrs_noire_sfx\", per = 0.8, vol = 0.3 },\r\n    in_shop = true,\r\n    weight = 3,",
      "config": {
        "extra": {
          "x_mult": 0.75
        },
        "card_limit": 2
      },
      "ability": {
        "extra": {
          "x_mult": 0.75
        },
        "card_limit": 2
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Edition",
      "key": "sliced",
      "atlas": null,
      "pos": null,
      "raw": "key = \"sliced\",\r\n    shader = \"akyrs_sliced\",\r\n    config = {\r\n        extra = {\r\n            mod_mult = 0.5,\r\n        },\r\n        akyrs_card_extra_triggers = 1\r\n    },\r\n    disable_base_shader = true,\r\n    sound = { sound = \"akyrs_sliced_sfx\", per = 0.8, vol = 0.3 },\r\n    in_shop = true,\r\n    on_apply = function (card)\r\n        if not card.akyrs_upgrade_sliced then\r\n            AKYRS.mod_card_values(card.ability,{multiply = 0.5, reference = card.akyrs_old_ability, unkeywords = AKYRS.blacklist_mod})\r\n            card.akyrs_upgrade_sliced = true\r\n        end\r\n    end,\r\n    on_remove = function (card)\r\n        card:set_ability(card.config.center)\r\n        card.akyrs_upgrade_sliced = false\r\n    end,\r\n    weight = 5,",
      "config": {
        "extra": {
          "mod_mult": 0.5
        },
        "akyrs_card_extra_triggers": 1
      },
      "ability": {
        "extra": {
          "mod_mult": 0.5
        },
        "akyrs_card_extra_triggers": 1
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Edition",
      "key": "burnt",
      "atlas": null,
      "pos": null,
      "raw": "key = \"burnt\",\r\n    shader = \"akyrs_burnt\",\r\n    config = {\r\n        extras = {\r\n            odds = 7,\r\n        },\r\n        name = \"akyrs_burnt\"\r\n    },\r\n    disable_base_shader = true,\r\n    sound = { sound = \"akyrs_burnt_sfx\", per = 1.2, vol = 0.3 },\r\n    in_shop = false,\r\n    loc_vars = function (self, info_queue, card)\r\n        info_queue[#info_queue+1] = G.P_CENTERS[\"m_akyrs_ash_card\"]\r\n        info_queue[#info_queue+1] = G.P_CENTERS[\"j_akyrs_ash_joker\"]\r\n        local n,d = SMODS.get_probability_vars(card,1,self.config.extras.odds,\"akyrs_burnt_edition\")\r\n        return {\r\n            vars = {\r\n                n,d\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        \r\n    end,\r\n    weight = 0,",
      "config": {
        "extras": {
          "odds": 7
        },
        "name": "akyrs_burnt"
      },
      "ability": {
        "extras": {
          "odds": 7
        },
        "name": "akyrs_burnt"
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Edition",
      "key": "enchanted",
      "atlas": null,
      "pos": null,
      "raw": "key = \"enchanted\",\r\n    shader = \"akyrs_enchanted\",\r\n    config = {\r\n        name = \"akyrs_enchanted\"\r\n    },\r\n    sound = { sound = \"akyrs_enchanted\", per = 1, vol = 0.7 },\r\n    in_shop = false,\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n    end,\r\n    weight = 0,",
      "config": {
        "name": "akyrs_enchanted"
      },
      "ability": {
        "name": "akyrs_enchanted"
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "redstone_repeater",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    pos = {\r\n        x = 0,\r\n        y = 0\r\n    },\r\n    pools = { [\"Minecraft\"] = true, [\"Redstone\"] = true },\r\n    key = \"redstone_repeater\",\r\n    rarity = 2,\r\n    cost = 5,\r\n    config = {\r\n        extra = {\r\n            mult_stored = 1,\r\n            mult = 2.25,\r\n            starting_mult = 1,\r\n            exp = 1.5\r\n        }\r\n    },\r\n\r\n    loc_vars = function(self, info_queue, card)\r\n        if AKYRS.bal(\"absurd\") then\r\n            return {\r\n                key = self.key..'_absurd',\r\n                vars = { card.ability.extra.mult_stored, card.ability.extra.exp, card.ability.extra.starting_mult }\r\n            }\r\n        end\r\n        return {\r\n            vars = { card.ability.extra.mult_stored, card.ability.extra.mult, card.ability.extra.starting_mult }\r\n        }\r\n    end,\r\n    calculate = function(self, card, context)\r\n        if context.joker_main and card or context.forcetrigger then\r\n            stored = mult\r\n            mult = mod_mult(card.ability.extra.mult_stored)\r\n            card.ability.extra.mult_stored = stored\r\n            update_hand_text({ immediate = true, nopulse = true, delay = 0 }, { mult_stored = stored })\r\n            \r\n            local ind = AKYRS.find_index(card.area.cards, card)\r\n            if ind and ind > 1 and card.area.cards[ind - 1].config.center_key == card.config.center_key then\r\n                check_for_unlock({type = \"akyrs_repeater_into_another_one\"})\r\n            end\r\n            if AKYRS.bal(\"absurd\") then\r\n                return {\r\n                    message = \"Swapped!\",\r\n                    emult = card.ability.extra.exp,\r\n                }\r\n            end\r\n            return {\r\n                message = \"Swapped!\",\r\n                xmult = card.ability.extra.mult,\r\n            }\r\n        end\r\n    end,\r\n    blueprint_compat = true,\r\n\tdemicoloncompat = true,",
      "config": {
        "extra": {
          "mult_stored": 1,
          "mult": 2.25,
          "starting_mult": 1,
          "exp": 1.5
        }
      },
      "ability": {
        "extra": {
          "mult_stored": 1,
          "mult": 2.25,
          "starting_mult": 1,
          "exp": 1.5
        }
      },
      "vars": [
        1,
        1.5,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "observer",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    pos = {\r\n        x = 1,\r\n        y = 0\r\n    },\r\n    key = \"observer\",\r\n    rarity = 2,\r\n    cost = 5,\r\n    config = {\r\n        extra = {\r\n            mult_stored = 0,\r\n            xmult_stored = 1,\r\n            mult = 4,\r\n            xmult = 1,\r\n            times = 2,\r\n            total_times = 2,\r\n            times_increment = 1,\r\n            mult_change = 0,\r\n            chip_change = 0\r\n        },\r\n        name = \"Observer\"\r\n    },\r\n\r\n    loc_vars = function(self, info_queue, card)\r\n        if AKYRS.bal(\"absurd\") then\r\n            return {\r\n                key = self.key..'_absurd',\r\n                vars = { card.ability.extra.xmult, card.ability.extra.xmult_stored, card.ability.extra.times,\r\n                    card.ability.extra.total_times, card.ability.extra.times_increment }\r\n            }\r\n        end\r\n        return {\r\n            vars = { card.ability.extra.mult, card.ability.extra.mult_stored, card.ability.extra.times,\r\n                card.ability.extra.total_times, card.ability.extra.times_increment }\r\n        }\r\n    end,\r\n    calculate = function(self, card, context)\r\n        if context.akyrs_score_change then\r\n            card.ability.extra.times = card.ability.extra.times - 1\r\n            return {\r\n                func = function()\r\n                    card_eval_status_text(card, 'jokers', nil, 0.5, nil, {\r\n                        instant = true,\r\n                        card_align = \"m\",\r\n                        message = localize {\r\n                            type = 'variable',\r\n                            key = 'a_remaining',\r\n                            vars = { card.ability.extra.times }\r\n                        },\r\n                    })\r\n                    --update_hand_text({ immediate = true, nopulse = true, delay = 0 }, { mult_stored = stored })\r\n\r\n                    if card.ability.extra.times <= 0 then\r\n                        card_eval_status_text(card, 'jokers', nil, 0.5, nil, {\r\n                            instant = true,\r\n                            card_align = \"m\",\r\n                            message = localize {\r\n                                type = 'variable',\r\n                                key = 'a_remaining',\r\n                                vars = { card.ability.extra.times }\r\n                            },\r\n                        })\r\n                        card.ability.extra.total_times = card.ability.extra.total_times + card.ability.extra.times_increment\r\n                        card.ability.extra.times = card.ability.extra.total_times\r\n                        card.ability.extra.xmult_stored = card.ability.extra.xmult_stored + card.ability.extra.xmult\r\n                    end\r\n                    card.ability.extra.mult_change = mult\r\n                    card.ability.extra.chip_change = chips\r\n                end\r\n            }\r\n        end\r\n        if context.individual and AKYRS.bal(\"adequate\") then\r\n            SMODS.calculate_effect({\r\n                message = localize { type = 'variable', key = 'a_remaining', vars = { card.ability.extra.times }},\r\n                card = card,\r\n                func = function ()\r\n                    card.ability.extra.times = card.ability.extra.times - 1\r\n                    if card.ability.extra.times <= 0 then\r\n                        SMODS.calculate_effect({\r\n                            message = localize(\"k_upgrade_ex\"),\r\n                            func = function ()\r\n                                card.ability.extra.mult_stored = card.ability.extra.mult_stored + card.ability.extra.mult\r\n                                card.ability.extra.total_times = card.ability.extra.total_times + card.ability.extra.times_increment\r\n                                card.ability.extra.times = card.ability.extra.total_times\r\n                            end,\r\n                            card = card\r\n                        })\r\n                    end\r\n                end\r\n            })\r\n        end\r\n        if context.joker_main or context.forcetrigger then\r\n            return AKYRS.bal_val(\r\n                {\r\n                    mult = card.ability.extra.mult_stored,\r\n                },\r\n                {\r\n                    xmult = card.ability.extra.xmult_stored,\r\n                }\r\n            )\r\n        end\r\n    end,\r\n\tdemicoloncompat = true,\r\n    blueprint_compat = true",
      "config": {
        "extra": {
          "mult_stored": 0,
          "xmult_stored": 1,
          "mult": 4,
          "xmult": 1,
          "times": 2,
          "total_times": 2,
          "times_increment": 1,
          "mult_change": 0,
          "chip_change": 0
        },
        "name": "Observer"
      },
      "ability": {
        "extra": {
          "mult_stored": 0,
          "xmult_stored": 1,
          "mult": 4,
          "xmult": 1,
          "times": 2,
          "total_times": 2,
          "times_increment": 1,
          "mult_change": 0,
          "chip_change": 0
        },
        "name": "Observer"
      },
      "vars": [
        1,
        1,
        2,
        2,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "quasi_connectivity",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "pools = { [\"Minecraft\"] = true, [\"Redstone\"] = true },\r\n    atlas = 'AikoyoriJokers',\r\n    pos = {\r\n        x = 2,\r\n        y = 0\r\n    },\r\n    key = \"quasi_connectivity\",\r\n    rarity = 3,\r\n    cost = 6,\r\n    loc_vars = function(self, info_queue, card)\r\n        if AKYRS.bal(\"absurd\") then\r\n            return {\r\n                key = self.key..'_absurd',\r\n            vars = { card.ability.extra.emult }\r\n            }\r\n        end\r\n        return {\r\n            vars = { card.ability.extra.mult }\r\n        }\r\n    end,\r\n    config = {\r\n        name = \"Quasi Connectivity\",\r\n        extra = {\r\n            mult = 6,\r\n            emult = 4,\r\n            first_hand = true\r\n        }\r\n    },\r\n    calculate = function(self, card, context)\r\n        if context.before and not context.blueprint then\r\n            return {\r\n                func = function()\r\n                local quasiCount = 0\r\n                local jokers = {}\r\n                for i = 1, #G.jokers.cards do\r\n                    if G.jokers.cards[i].ability.name == \"Quasi Connectivity\" then\r\n                        quasiCount = quasiCount + 1\r\n                    end\r\n                    if (G.jokers.cards[i] ~= card or #G.jokers.cards < 2) then\r\n                        jokers[#jokers + 1] = G.jokers.cards[i]\r\n                    end\r\n\r\n                    G.jokers.cards[i]:set_debuff(false)\r\n                end\r\n                -- remove the current card from the list\r\n                if not G.GAME.aiko_has_quasi then\r\n                    jokers[card] = nil\r\n                    G.GAME.aiko_has_quasi = true\r\n                end\r\n                for i = 1, quasiCount do\r\n                    if (#jokers > 0) then\r\n                        local re = AKYRS.bal(\"absurd\") and 2 or 1\r\n                        for i = 1, re do\r\n                            local _card = pseudorandom_element(jokers, pseudoseed('akyrs:quasi_connectivity'))\r\n                            local iter = 1\r\n                            while _card and _card.debuff and iter < #jokers do\r\n                                local _card = pseudorandom_element(jokers, pseudoseed('akyrs:quasi_connectivity'))\r\n                                iter = iter + 1\r\n                            end\r\n                            if _card then\r\n                                _card:set_debuff(true)\r\n                                _card:juice_up(1, 1)\r\n                            end\r\n                            jokers[_card] = nil\r\n                        end\r\n                    end\r\n                end\r\n                G.GAME.aiko_has_quasi = false\r\n                card.ability.extra.first_hand = false\r\n            end\r\n            }\r\n        end\r\n        if context.joker_main or context.forcetrigger then\r\n            return AKYRS.bal_val(\r\n                {\r\n                    xmult = card.ability.extra.mult,\r\n                },\r\n                {\r\n                    emult = card.ability.extra.emult,\r\n                }\r\n            )\r\n        end\r\n        if context.selling_card then\r\n            for i = 1, #G.jokers.cards do\r\n                if G.jokers.cards[i].debuff then\r\n                    G.jokers.cards[i]:set_debuff(false)\r\n                end\r\n            end\r\n        end\r\n    end,\r\n\tdemicoloncompat = true,\r\n    blueprint_compat = true",
      "config": {
        "name": "Quasi Connectivity",
        "extra": {
          "mult": 6,
          "emult": 4,
          "first_hand": true
        }
      },
      "ability": {
        "name": "Quasi Connectivity",
        "extra": {
          "mult": 6,
          "emult": 4,
          "first_hand": true
        }
      },
      "vars": [
        4
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "diamond_pickaxe",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    enhancement_gate = \"m_stone\",\r\n    pools = { [\"Minecraft\"] = true },\r\n    pos = {\r\n        x = 3,\r\n        y = 0\r\n    },\r\n    key = \"diamond_pickaxe\",\r\n    rarity = 2,\r\n    cost = 3,\r\n    loc_vars = function(self, info_queue, card)\r\n        info_queue[#info_queue+1] = G.P_CENTERS[\"m_stone\"]\r\n        if AKYRS.bal(\"absurd\") then\r\n            return {\r\n                key = self.key..'_absurd',\r\n                vars = { card.ability.extra.chip_add, card.ability.extra.chip_add_stack_absurd }\r\n            }\r\n        end\r\n        return {\r\n            vars = { card.ability.extra.chip_add, card.ability.extra.chip_add_stack }\r\n        }\r\n    end,\r\n    config = {\r\n        name = \"Diamond Pickaxe\",\r\n        extra = {\r\n            chip_add = 64,\r\n            chip_add_stack = 2,\r\n            chip_add_stack_absurd = 12,\r\n        }\r\n    },\r\n    add_to_deck = function (self, card, from_debuff)\r\n        if #SMODS.find_card(\"j_akyrs_netherite_pickaxe\") > 0 then\r\n            check_for_unlock({ type = \"akyrs_both_pickaxe\" })\r\n        end\r\n    end,\r\n    calculate = function(self, card, context)\r\n        if context.before and AKYRS.bal(\"absurd\") and not context.blueprint or context.forcetrigger then\r\n            AKYRS.simple_event_add(\r\n                function()\r\n                    for _,cardhand in ipairs(G.hand.cards) do\r\n                        cardhand:set_ability(G.P_CENTERS[\"m_stone\"])\r\n                        cardhand:juice_up(0.5, 2)\r\n                    end\r\n                    return true\r\n                end\r\n            )\r\n        end\r\n        if context.individual and context.cardarea == G.play then\r\n            if context.other_card.config.center_key == \"m_stone\" then\r\n                for i = 1, to_number(AKYRS.bal_val(card.ability.extra.chip_add_stack,card.ability.extra.chip_add_stack_absurd)) do\r\n                    context.other_card:juice_up(0.5, 2)\r\n                    SMODS.calculate_effect({\r\n                        chips = card.ability.extra.chip_add,\r\n                        juice_card = context.other_card,\r\n                    },card)\r\n                end\r\n                return {\r\n                    juice_card = context.other_card,\r\n                    func = function ()\r\n                        if  not context.blueprint then\r\n                        context.other_card:set_ability(\r\n                            pseudorandom_element(NON_STONE_UPGRADES, pseudoseed('akyrj:pickaxe')), nil, true)\r\n                        end\r\n                    end\r\n                }\r\n            end\r\n        end\r\n    end,\r\n\tdemicoloncompat = true,\r\n    blueprint_compat = true",
      "config": {
        "name": "Diamond Pickaxe",
        "extra": {
          "chip_add": 64,
          "chip_add_stack": 2,
          "chip_add_stack_absurd": 12
        }
      },
      "ability": {
        "name": "Diamond Pickaxe",
        "extra": {
          "chip_add": 64,
          "chip_add_stack": 2,
          "chip_add_stack_absurd": 12
        }
      },
      "vars": [
        64,
        12
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "netherite_pickaxe",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    enhancement_gate = \"m_stone\",\r\n    pools = { [\"Minecraft\"] = true },\r\n    pos = {\r\n        x = 4,\r\n        y = 0\r\n    },\r\n    key = \"netherite_pickaxe\",\r\n    rarity = 2,\r\n    cost = 4,\r\n    loc_vars = function(self, info_queue, card)\r\n        info_queue[#info_queue+1] = G.P_CENTERS[\"m_stone\"]\r\n        if AKYRS.bal(\"absurd\") then\r\n            return {\r\n                key = self.key..'_absurd',\r\n                vars = { card.ability.extra.xchip_add, card.ability.extra.chip_add_stack_absurd, card.ability.extra.xchip_storage  }\r\n            }\r\n        end\r\n        return {\r\n            vars = { card.ability.extra.chip_add, card.ability.extra.chip_add_stack }\r\n        }\r\n    end,\r\n    add_to_deck = function (self, card, from_debuff)\r\n        if #SMODS.find_card(\"j_akyrs_diamond_pickaxe\") > 0 then\r\n            check_for_unlock({ type = \"akyrs_both_pickaxe\" })\r\n        end\r\n    end,\r\n    config = {\r\n        name = \"Netherite Pickaxe\",\r\n        extra = {\r\n            xchip_add = 0.64,\r\n            xchip_storage = 1,\r\n\r\n            chip_add = 64,\r\n            chip_add_stack = 5,\r\n            chip_add_stack_absurd = 18,\r\n        }\r\n    },\r\n    generate_ui = function(self, info_queue, card, desc_nodes, specific_vars, full_UI_table)\r\n        SMODS.Center.generate_ui(self, info_queue, card, desc_nodes, specific_vars, full_UI_table)\r\n        \r\n        if AKYRS.config.show_joker_preview then\r\n            local cards = {}\r\n            for i = 1,5 do\r\n                local carder = AKYRS.create_random_card(\"netheritepick\")\r\n                carder:set_ability(G.P_CENTERS[\"m_stone\"], true)\r\n                table.insert(cards, carder)\r\n            end\r\n            AKYRS.card_area_preview(G.akyrsCardsPrev, desc_nodes, {\r\n                cards = cards,\r\n                override = true,\r\n                w = 2.2,\r\n                h = 0.6,\r\n                ml = 0,\r\n                scale = 0.5,\r\n                func_delay = 1.0,\r\n                func_after = function(ca) \r\n                    if ca and ca.cards then\r\n                        for i,k in ipairs(ca.cards) do\r\n                            if not k.removed then\r\n                                k:start_dissolve({G.C.CHIPS}, true)\r\n                            end\r\n                        end\r\n                    end\r\n                end,\r\n            })\r\n        end\r\n    end,\r\n    calculate = function(self, card, context)\r\n        if context.individual and context.cardarea == G.play and not context.blueprint then\r\n            if context.other_card.config.center_key == \"m_stone\" then\r\n                context.other_card.ability.aiko_about_to_be_destroyed = true\r\n                if AKYRS.bal(\"absurd\") then\r\n                    SMODS.calculate_effect({\r\n                        message = localize(\"k_upgrade_ex\"),\r\n                        func = function ()\r\n                            card.ability.extra.xchip_storage = card.ability.extra.xchip_storage + card.ability.extra.xchip_add * card.ability.extra.chip_add_stack_absurd\r\n                        end\r\n                    },card)\r\n                else\r\n                    for i = 1, to_number(AKYRS.bal_val(card.ability.extra.chip_add_stack,card.ability.extra.chip_add_stack_absurd)) do\r\n                        SMODS.calculate_effect({\r\n                            chips = card.ability.extra.chip_add,\r\n                            juice_card = context.other_card,\r\n                        },card)\r\n                    end\r\n                end\r\n                \r\n            end\r\n        end\r\n\r\n        if (context.joker_main or context.forcetrigger) and AKYRS.bal(\"absurd\")  then\r\n            return {\r\n                xchips = card.ability.extra.xchip_storage\r\n            }\r\n        end\r\n\r\n        if context.pre_discard and AKYRS.bal(\"absurd\") and not context.forcetrigger then\r\n            return {\r\n                func = function ()\r\n                    AKYRS.simple_event_add(\r\n                        function()\r\n                            for _,cardhand in ipairs(context.full_hand) do\r\n                                cardhand:set_ability(G.P_CENTERS[\"m_stone\"])\r\n                                cardhand:juice_up(0.5, 2)\r\n                            end\r\n                            return true\r\n                        end\r\n                    )\r\n                end\r\n            }\r\n        end\r\n\r\n        if context.destroy_card and context.cardarea == G.play and not context.blueprint and not context.destroy_card.ability.eternal then\r\n            \r\n            if context.destroy_card.ability.aiko_about_to_be_destroyed then\r\n                return { remove = true }\r\n            end\r\n        end\r\n    end,\r\n\tdemicoloncompat = true,\r\n    blueprint_compat = true",
      "config": {
        "name": "Netherite Pickaxe",
        "extra": {
          "xchip_add": 0.64,
          "xchip_storage": 1,
          "chip_add": 64,
          "chip_add_stack": 5,
          "chip_add_stack_absurd": 18
        }
      },
      "ability": {
        "name": "Netherite Pickaxe",
        "extra": {
          "xchip_add": 0.64,
          "xchip_storage": 1,
          "chip_add": 64,
          "chip_add_stack": 5,
          "chip_add_stack_absurd": 18
        }
      },
      "vars": [
        0.64,
        18,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "utage_charts",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 5,
        "y": 0
      },
      "raw": "pools = { [\"Rhythm Games\"] = true, [\"Maimai\"] = true },\r\n    atlas = 'AikoyoriJokers',\r\n    pos = {\r\n        x = 5,\r\n        y = 0\r\n    },\r\n    key = \"utage_charts\",\r\n    rarity = 3,\r\n    cost = 4,\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n            vars = { card.ability.play_mod }\r\n        }\r\n    end,\r\n    config = {\r\n        name = \"Playable Cards\",\r\n        play_mod = 3,\r\n    },\r\n    add_to_deck = function(self, card, from_debuff)\r\n        SMODS.change_play_limit(card.ability.play_mod)\r\n        SMODS.change_discard_limit(card.ability.play_mod)\r\n    end,\r\n    remove_from_deck = function(self, card, from_debuff)\r\n        SMODS.change_play_limit(-card.ability.play_mod)\r\n        SMODS.change_discard_limit(-card.ability.play_mod)\r\n    end,\r\n    blueprint_compat = false,",
      "config": {
        "name": "Playable Cards",
        "play_mod": 3
      },
      "ability": {
        "name": "Playable Cards",
        "play_mod": 3
      },
      "vars": [
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "it_is_forbidden_to_dog",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 7,
        "y": 0
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    pos = {\r\n        x = 7,\r\n        y = 0\r\n    },\r\n    key = \"it_is_forbidden_to_dog\",\r\n    rarity = 3,\r\n    cost = 6,\r\n    loc_vars = function(self, info_queue, card)\r\n        if AKYRS.bal(\"absurd\") then\r\n            info_queue[#info_queue+1] = G.P_CENTERS[\"m_akyrs_scoreless\"]\r\n        end\r\n        return {\r\n            key = AKYRS.bal_val(self.key, self.key..\"_absurd\"),\r\n            vars = { \r\n                AKYRS.bal_val(card.ability.extra.mult, card.ability.extra.emult_absurd)\r\n            }\r\n        }\r\n    end,\r\n    config = {\r\n        extra = {\r\n            mult = 1.75,\r\n            emult_absurd = 1.2,\r\n        }\r\n    },\r\n    calculate = function(self, card, context)\r\n        if AKYRS.bal(\"absurd\") then\r\n            if context.individual and context.cardarea == 'unscored' then\r\n                return {\r\n                    emult = card.ability.extra.emult_absurd,\r\n                    func = function ()\r\n                        context.other_card:set_ability(G.P_CENTERS[\"m_akyrs_scoreless\"])\r\n                        context.other_card:juice_up(0.5,1)\r\n                    end\r\n                }\r\n            end\r\n        else\r\n            if context.individual and context.other_card.debuff and not context.end_of_round and \r\n            (   context.cardarea == G.play or \r\n                context.cardarea == G.hand ) then\r\n                return {\r\n                    xmult = card.ability.extra.mult\r\n                }\r\n            end\r\n        end\r\n    end,\r\n\tdemicoloncompat = true,\r\n    blueprint_compat = true,",
      "config": {
        "extra": {
          "mult": 1.75,
          "emult_absurd": 1.2
        }
      },
      "ability": {
        "extra": {
          "mult": 1.75,
          "emult_absurd": 1.2
        }
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "eat_pant",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 8,
        "y": 0
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    pos = {\r\n        x = 8,\r\n        y = 0\r\n    },\r\n    pools = { [\"Meme\"] = true },\r\n    key = \"eat_pant\",\r\n    rarity = 3,\r\n    cost = 6,\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n            key = AKYRS.bal_val(self.key, self.key..\"_absurd\"), \r\n            vars = AKYRS.bal_val({ \r\n                math.floor(card.ability.extra.card_target),\r\n                card.ability.extra.extra,\r\n                card.ability.extra.Xmult,\r\n             }, { \r\n                \"heheheha\",\r\n                card.ability.extra.extra_absurd,\r\n                card.ability.extra.Xmult_absurd,\r\n             })\r\n        }\r\n    end,\r\n    config = {\r\n        extra = {\r\n            extra = 16,\r\n            extra_absurd = 2,\r\n            card_target = 4,\r\n            Xmult = 2,\r\n            Xmult_absurd = 1,\r\n        }\r\n    },\r\n    calculate = function(self, card, context)\r\n        if context.joker_main then\t\r\n            return {\r\n                xmult = AKYRS.bal_val(card.ability.extra.Xmult,card.ability.extra.Xmult_absurd)\r\n            }\r\n        end\r\n        if AKYRS.bal(\"absurd\") then\r\n            if context.individual and context.cardarea == G.play and next(context.poker_hands[\"Two Pair\"]) or context.forcetrigger then\r\n                return {\r\n                    message = localize('k_upgrade_ex'),\r\n                    colour = G.C.MULT,\r\n                    card = card,\r\n                    func = function ()\r\n                        card.ability.extra.Xmult_absurd = card.ability.extra.Xmult_absurd + card.ability.extra.extra_absurd\r\n                    end\r\n                }\r\n            end\r\n            if context.destroy_card and (context.cardarea == G.play or context.cardarea == 'unscored') and not context.blueprint and not context.destroy_card.ability.eternal and not context.forcetrigger then\r\n                if next(context.poker_hands[\"Two Pair\"]) then\r\n                    return { remove = true }\r\n                end\r\n            end\r\n        else\r\n            if context.individual and (context.cardarea == G.play or context.cardarea == 'unscored') and #context.full_hand == math.floor(card.ability.extra.card_target) or context.forcetrigger  then\r\n                card.ability.extra.Xmult = card.ability.extra.Xmult * (1-(1)/card.ability.extra.extra)\r\n                return {\r\n                    message = localize('k_akyrs_downgrade_ex'),\r\n                    colour = G.C.MULT,\r\n                    card = card\r\n                }\r\n            end\r\n            if context.destroy_card and (context.cardarea == G.play) and not context.blueprint and not context.destroy_card.ability.eternal and not context.forcetrigger then\r\n                if #context.full_hand == math.floor(card.ability.extra.card_target) then\r\n                    return { remove = true }\r\n                end\r\n            end\r\n        end\r\n    end,\r\n\tdemicoloncompat = true,\r\n    blueprint_compat = true,",
      "config": {
        "extra": {
          "extra": 16,
          "extra_absurd": 2,
          "card_target": 4,
          "Xmult": 2,
          "Xmult_absurd": 1
        }
      },
      "ability": {
        "extra": {
          "extra": 16,
          "extra_absurd": 2,
          "card_target": 4,
          "Xmult": 2,
          "Xmult_absurd": 1
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "tsunagite",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 9,
        "y": 0
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    pos = {\r\n        x = 9,\r\n        y = 0\r\n    },\r\n    soul_pos = {\r\n        x = 9,\r\n        y = 1\r\n    },\r\n    pools = { [\"Rhythm Games\"] = true, [\"Maimai\"] = true },\r\n    key = \"tsunagite\",\r\n    rarity = 4,\r\n    cost = 50,\r\n    loc_vars = function(self, info_queue, card)\r\n        if AKYRS.bal(\"absurd\") then\r\n            info_queue[#info_queue+1] = {key = \"akyrs_chip_mult_xchip_xmult\", set = 'Other', vars = \r\n                { \r\n                    card.ability.extra.chips_absurd,\r\n                    card.ability.extra.mult_absurd,\r\n                    card.ability.extra.Xchips_absurd,\r\n                    card.ability.extra.Xmult_absurd,\r\n                }\r\n            }\r\n            info_queue[#info_queue+1] = {key = \"akyrs_gain_chip_mult_xchip_xmult\", set = 'Other', vars = \r\n                { \r\n                    card.ability.extra.gain_chips_absurd,\r\n                    card.ability.extra.gain_mult_absurd,\r\n                    card.ability.extra.gain_Xchips_absurd,\r\n                    card.ability.extra.gain_Xmult_absurd,\r\n                }\r\n            }\r\n        end\r\n        if AKYRS.bal(\"adequate\") then\r\n            local total = 0\r\n            if G.hand and G.hand.highlighted then\r\n                for i,k in ipairs(G.hand.highlighted) do\r\n                    total = total + k:get_chip_bonus()\r\n                end\r\n            end\r\n            info_queue[#info_queue+1] = {key = \"akyrs_tsunagite_scores\", set = 'Other', vars = {\r\n                total\r\n            } }\r\n        end\r\n        info_queue[#info_queue+1] = {key = \"akyrs_tsunagite_name\", set = 'Other', }\r\n        return {\r\n            key = AKYRS.bal_val(self.key, self.key..\"_absurd\"), \r\n            vars = { \r\n                15,\r\n                card.ability.extra.gain_Xmult,\r\n            }\r\n        }\r\n    end,\r\n    config = {\r\n        extra = {\r\n            total = 15,\r\n            gain_Xmult = 0.15,\r\n            -- absurd\r\n            chips_absurd = 150,\r\n            Xchips_absurd = 15,\r\n            mult_absurd = 150,\r\n            Xmult_absurd = 15,\r\n            base_chips_absurd = 150,\r\n            base_Xchips_absurd = 1.5,\r\n            base_mult_absurd = 15,\r\n            base_Xmult_absurd = 1.5,\r\n            \r\n            gain_chips_absurd = 150,\r\n            gain_Xchips_absurd = 15,\r\n            gain_mult_absurd = 150,\r\n            gain_Xmult_absurd = 15,\r\n        }\r\n    },\r\n    calculate = function(self, card, context)\r\n        if context.individual and context.cardarea == G.play and AKYRS.bal(\"absurd\") then\r\n            return {\r\n                chips = card.ability.extra.chips_absurd,\r\n                xchips = card.ability.extra.Xchips_absurd,\r\n                mult = card.ability.extra.mult_absurd,\r\n                xmult = card.ability.extra.Xmult_absurd,\r\n            }\r\n        end\t\t\r\n        if context.using_consumeable or context.forcetrigger and AKYRS.bal(\"absurd\") then\r\n            if context.consumeable.config.center_key == 'c_wheel_of_fortune' or context.forcetrigger then\r\n                card.ability.extra.chips = card.ability.extra.chips + card.ability.extra.gain_chips \r\n                card.ability.extra.Xchips = card.ability.extra.Xchips + card.ability.extra.gain_Xchips \r\n                card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.gain_mult \r\n                card.ability.extra.Xmult = card.ability.extra.Xmult + card.ability.extra.gain_Xmult\r\n                card.ability.extra.chips_absurd = card.ability.extra.chips_absurd + card.ability.extra.gain_chips_absurd\r\n                card.ability.extra.Xchips_absurd = card.ability.extra.Xchips_absurd + card.ability.extra.gain_Xchips_absurd\r\n                card.ability.extra.mult_absurd = card.ability.extra.mult_absurd + card.ability.extra.gain_mult_absurd\r\n                card.ability.extra.Xmult_absurd = card.ability.extra.Xmult_absurd + card.ability.extra.gain_Xmult_absurd\r\n                SMODS.calculate_effect({\r\n                    message= localize('k_upgrade_ex')\r\n                }, card)\r\n            end\r\n        end\r\n        if context.akyrs_pre_play and AKYRS.bal(\"adequate\") then\r\n            return {\r\n                func = function ()\r\n                    local total = 0\r\n                    for i,k in ipairs(context.akyrs_pre_play_cards) do\r\n                        total = total + k:get_chip_bonus()\r\n                    end\r\n                    if math.fmod(total,15) == 0 then\r\n                        for i,k in ipairs(context.akyrs_pre_play_cards) do\r\n                            AKYRS.simple_event_add(function()\r\n                                AKYRS.juice_like_tarot(card)\r\n                                k:juice_up(0.3, 0.5)\r\n                                k.ability.perma_x_mult = (k.ability.perma_x_mult or 0) + card.ability.extra.gain_Xmult\r\n                                return true\r\n                            end, 0.5)\r\n                        end\r\n                    end\r\n                end\r\n            }\r\n        end\r\n    end,\r\n    blueprint_compat = true,\r\n\tdemicoloncompat = true,",
      "config": {},
      "ability": {},
      "vars": [
        15,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "yona_yona_dance",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    pos = {\r\n        x = 0,\r\n        y = 1\r\n    },\r\n    pools = { [\"J-POP\"] = true },\r\n    key = \"yona_yona_dance\",\r\n    rarity = 2,\r\n    cost = 6,\r\n    loc_vars = function(self, info_queue, card)\r\n        if AKYRS.config.show_joker_preview then\r\n            info_queue[#info_queue+1] = AKYRS.DescriptionDummies[\"dd_akyrs_yona_yona_ex\"]\r\n        end\r\n        return {\r\n            vars = { \r\n                card.ability.extra.times,\r\n             }\r\n        }\r\n    end,\r\n    config = {\r\n        extra = {\r\n            times = 2\r\n        },\r\n    },\r\n\r\n    calculate = function(self, card, context)\r\n        if context.repetition and (context.other_card:get_id() == 4 or context.other_card:get_id() == 7) then\r\n            return {\r\n                message = localize('k_again_ex'),\r\n                repetitions = card.ability.extra.times,\r\n            }\r\n        end\r\n    end,\r\n    blueprint_compat = true,\r\n\tdemicoloncompat = true,",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "tldr_joker",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 6,
        "y": 1
      },
      "raw": "key = \"tldr_joker\",\r\n    atlas = 'AikoyoriJokers',\r\n\tpools = { [\"Meme\"] = true },\r\n    pos = {\r\n        x = 6,\r\n        y = 1\r\n    },\r\n    soul_pos = {\r\n        x = 7,\r\n        y = 1\r\n    },\r\n    rarity = 1,\r\n    cost = 2,\r\n    loc_vars = function(self, info_queue, card)\r\n        if AKYRS.bal(\"absurd\") then\r\n            info_queue[#info_queue+1] = G.P_CENTERS[\"j_chaos\"]\r\n            info_queue[#info_queue+1] = G.P_CENTERS[\"c_moon\"]\r\n            info_queue[#info_queue+1] = G.P_CENTERS[\"v_grabber\"]\r\n            info_queue[#info_queue+1] = G.P_CENTERS[\"j_ceremonial\"]\r\n            if Cryptid then\r\n                info_queue[#info_queue+1] = G.P_CENTERS[\"c_cry_summoning\"]\r\n                info_queue[#info_queue+1] = G.P_CENTERS[\"j_cry_exponentia\"]\r\n                info_queue[#info_queue+1] = G.P_BLINDS[\"bl_cry_tax\"]\r\n            end\r\n            info_queue[#info_queue+1] = G.P_CENTERS[\"m_lucky\"]\r\n            info_queue[#info_queue+1] = G.P_CENTERS[\"j_akyrs_shimmer_bucket\"]\r\n            info_queue[#info_queue+1] = G.P_CENTERS[\"m_stone\"]\r\n            info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_tldr_tldr_absurd\", vars = {card.ability.extra.xmult}}\r\n            info_queue[#info_queue+1] = G.P_CENTERS[\"v_akyrs_alphabet_soup\"]\r\n            info_queue[#info_queue+1] = G.P_CENTERS[\"j_oops\"]\r\n        else\r\n            info_queue[#info_queue+1] = G.P_CENTERS[\"m_stone\"]\r\n            info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_tldr_tldr\", vars = {card.ability.extra.mult}}\r\n        end\r\n        return {\r\n            key = AKYRS.bal_val(self.key, self.key..\"_absurd\"), \r\n            scale = 0.7,\r\n            vars = { \r\n                AKYRS.bal_val(card.ability.extra.mult,card.ability.extra.xmult)\r\n            }\r\n        }\r\n    end,\r\n    config = {\r\n        extra = {\r\n            mult = 2,\r\n            xmult = 3\r\n        },\r\n    },\r\n    calculate = function(self, card, context)\r\n        if AKYRS.bal(\"absurd\") then\r\n                if context.joker_main or context.forcetrigger then\r\n                return {\r\n                    xmult = card.ability.extra.xmult\r\n                }\r\n            end\r\n        else\r\n            if context.joker_main or context.individual and not context.end_of_round and (context.cardarea == G.hand or context.cardarea == G.play) or context.forcetrigger then\r\n                return AKYRS.bal_val(\r\n                    {\r\n                        mult = card.ability.extra.mult\r\n                    }\r\n                )\r\n            end\r\n        end\r\n    end,\r\n    blueprint_compat = true,\r\n\tdemicoloncompat = true,",
      "config": {
        "extra": {
          "mult": 2,
          "xmult": 3
        }
      },
      "ability": {
        "extra": {
          "mult": 2,
          "xmult": 3
        }
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "reciprocal_joker",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    key = \"reciprocal_joker\",\r\n    pos = {\r\n        x = 1,\r\n        y = 1\r\n    },\r\n    rarity = 1,\r\n    cost = 2,\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n            key = AKYRS.bal_val(self.key, self.key..\"_absurd\"), \r\n            vars = {\r\n            }\r\n        }\r\n    end,\r\n    config = {\r\n        extra = {\r\n        },\r\n    },\r\n    calculate = function(self, card, context)\r\n        if context.joker_main or context.forcetrigger then\r\n            return {\r\n                message = localize('k_akyrs_reciprocaled'),\r\n                func = function()\r\n                    if AKYRS.bal(\"absurd\") then\r\n                        hand_chips = mod_mult(mult / hand_chips)\r\n                    else\r\n                        mult = mod_mult(hand_chips / mult)\r\n                    end\r\n                    update_hand_text({ delay = 0, immediate = false }, { mult = mult, chips = hand_chips })\r\n                end\r\n            }\r\n        end\r\n    end,\r\n\tdemicoloncompat = true,\r\n    blueprint_compat = true,",
      "config": {
        "extra": {}
      },
      "ability": {
        "extra": {}
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "kyoufuu_all_back",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    key = \"kyoufuu_all_back\",\r\n    pools = { [\"Vocaloids\"] = true, [\"J-POP\"] = true },\r\n    pos = {\r\n        x = 2,\r\n        y = 1\r\n    },\r\n    rarity = 1,\r\n    cost = 3,\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n        }\r\n    end,\r\n    config = {\r\n        extra = {\r\n        },\r\n    },\r\n    calculate = function(self, card, context)\r\n        if context.hand_drawn or context.forcetrigger then\r\n            return {\r\n                message = localize('k_akyrs_drawn_discard'),\r\n                func = function()\r\n                    AKYRS.simple_event_add(\r\n                        function ()\r\n                            G.FUNCS.draw_from_discard_to_deck()\r\n\r\n                            AKYRS.simple_event_add(\r\n                                function ()\r\n                                    AKYRS.remove_dupes(G.deck.cards)\r\n                                    return true\r\n                                end, 0\r\n                            )\r\n                            return true\r\n                        end, 0\r\n                    )\r\n                end\r\n            }\r\n        end\r\n    end,\r\n    blueprint_compat = false,",
      "config": {
        "extra": {}
      },
      "ability": {
        "extra": {}
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "2fa",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    pools = { [\"Tech\"] = true, },\r\n    key = \"2fa\",\r\n    pos = {\r\n        x = 3,\r\n        y = 1\r\n    },\r\n    rarity = 1,\r\n    cost = 3,\r\n    loc_vars = function(self, info_queue, card)\r\n        if AKYRS.config.show_joker_preview then\r\n            info_queue[#info_queue + 1] = AKYRS.DescriptionDummies[\"dd_akyrs_2fa_example\"]\r\n        end\r\n        if AKYRS.bal(\"absurd\") then\r\n            return {\r\n                key = self.key .. \"_absurd\",\r\n                vars = {\r\n                    card.ability.extra.xchips_gain,\r\n                    card.ability.extra.xmult_gain,\r\n                    card.ability.extra.xchips,\r\n                    card.ability.extra.xmult,\r\n                }\r\n            }            \r\n        end\r\n        return {\r\n            vars = {\r\n                card.ability.extra.extra,\r\n                card.ability.extra.chips\r\n            }\r\n        }\r\n    end,\r\n    config = {\r\n        extra = {\r\n            chips = 0,\r\n            extra = 8,\r\n\r\n            xmult = 1,\r\n            xchips = 1,\r\n            xmult_gain = .1,\r\n            xchips_gain = 0.3,\r\n        },\r\n    },\r\n    calculate = function(self, card, context)\r\n        if context.before or context.forcetrigger then\r\n            for i, _card in ipairs(G.play.cards) do\r\n                card.ability.extra.chips = card.ability.extra.chips + card.ability.extra.extra\r\n            end\r\n            return {\r\n                message = localize(\"k_akyrs_2fa_generate\")\r\n            }\r\n        end\r\n        if (context.joker_main or context.forcetrigger) and AKYRS.bal(\"adequate\") then\r\n            return {\r\n                chips = card.ability.extra.chips\r\n            }\r\n        end\r\n        if (context.joker_main or context.forcetrigger) and AKYRS.bal(\"absurd\") then\r\n            return {\r\n                xchips = card.ability.extra.xchips,\r\n                xmult = card.ability.extra.xmult\r\n            }\r\n        end\r\n        if context.end_of_round and context.cardarea == G.jokers and AKYRS.bal(\"adequate\") then\r\n            return {\r\n                message = localize(\"k_akyrs_2fa_reset\"),\r\n                func = function()\r\n                    card.ability.extra.chips = card.ability.extra.chips / 2\r\n                end\r\n            }\r\n        end\r\n        if context.after and not context.blueprint then\r\n            return {\r\n                func = function()\r\n                    for i, _card in ipairs(G.play.cards) do\r\n                        local original_rank = _card:get_id()\r\n                        local original_suit = _card.base.suit\r\n                        G.E_MANAGER:add_event(Event {\r\n                            trigger = 'after',\r\n                            blocking = false,\r\n                            delay = 0.2 * AKYRS.get_speed_mult(_card),\r\n                            func = function()\r\n                                if G.play and G.play.cards then\r\n                                    local percent = math.abs(1.15 - (i - 0.999) / (#G.play.cards - 0.998) * 0.3)\r\n                                    if G.play.cards[i] then\r\n                                        G.play.cards[i]:flip()\r\n                                    end\r\n                                    --G.play.cards[i]:a_cool_fucking_spin(1,math.pi * 100)\r\n                                    play_sound('card1', percent);\r\n                                end\r\n                                return true\r\n                            end\r\n                        })\r\n                        G.E_MANAGER:add_event(Event {\r\n                            trigger = 'after',\r\n                            delay = 0.5 * AKYRS.get_speed_mult(card),\r\n                            blocking = false,\r\n                            func = function()\r\n                                if G.play and G.play.cards then\r\n                                    local _rank = nil\r\n                                    local _suit = nil\r\n                                    while _rank == nil or _suit == nil do\r\n                                        _rank = pseudorandom_element(SMODS.Ranks, pseudoseed('akyrs2far'))\r\n                                        _suit = pseudorandom_element(SMODS.Suits, pseudoseed('akyrs2fas'))\r\n                                    end\r\n                                    if G.play.cards[i] then\r\n                                        assert(SMODS.change_base(G.play.cards[i], _suit.key, _rank.key))\r\n                                        G.play.cards[i]:flip()\r\n                                        if G.play.cards[i]:get_id() == original_rank and AKYRS.bal(\"absurd\") then\r\n                                            card.ability.extra.xchips = card.ability.extra.xchips + card.ability.extra.xchips_gain\r\n                                            SMODS.calculate_effect({\r\n                                                message = localize(\"k_upgrade_ex\"),\r\n                                                colour = G.C.CHIPS\r\n                                            }, card)\r\n                                        end\r\n                                        if G.play.cards[i].base.suit == original_suit and AKYRS.bal(\"absurd\") then\r\n                                            card.ability.extra.xmult = card.ability.extra.xmult + card.ability.extra.xmult_gain\r\n                                            SMODS.calculate_effect({\r\n                                                message = localize(\"k_upgrade_ex\"),\r\n                                                colour = G.C.MULT\r\n                                            }, card)\r\n                                        end\r\n                                    end\r\n                                end\r\n\r\n                                return true\r\n                            end\r\n                        })\r\n                    end\r\n                    delay((0.5 * AKYRS.get_speed_mult(card) + 0.2 * #G.play.cards))\r\n                end,\r\n                message = localize(\"k_akyrs_2fa_regen\"),\r\n            }\r\n        end\r\n    end,\r\n    demicoloncompat = true,\r\n    blueprint_compat = false,",
      "config": {},
      "ability": {},
      "vars": [
        null,
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "gaslighting",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 4,
        "y": 1
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    key = \"gaslighting\",\r\n    pos = {\r\n        x = 4,\r\n        y = 1\r\n    },\r\n    rarity = 3,\r\n    cost = 5,\r\n    config = {\r\n        extra = {\r\n            xmult = 1,\r\n            extra = 0.5,\r\n            eemult = 1.21,\r\n            eemult_negative = 0.35,\r\n            chance = 3,\r\n            super_mario = 1,\r\n        },\r\n    },\r\n    loc_vars = function(self, info_queue, card)\r\n        if AKYRS.bal(\"absurd\") then\r\n            local num, denom = SMODS.get_probability_vars(card, 1, card.ability.extra.chance, 'akyrs_gaslighting_absurd')\r\n            return {\r\n                key = self.key .. \"_absurd\",\r\n                vars = {\r\n                    card.ability.extra.eemult,\r\n                    card.ability.extra.eemult_negative,\r\n                    num,\r\n                    denom,\r\n                }\r\n            }\r\n        end\r\n        return {\r\n            vars = {\r\n                card.ability.extra.extra,\r\n                card.ability.extra.xmult,\r\n            }\r\n        }\r\n    end,\r\n    calculate = function(self, card, context)\r\n        if AKYRS.bal(\"absurd\") and (context.joker_main or context.forcetrigger) then\r\n            local odder = SMODS.pseudorandom_probability(card, \"akyrs_gaslighting_absurd\",1, card.ability.extra.chance, 'akyrs_gaslighting_absurd')\r\n            if odder then\r\n                return {\r\n                    eemult = card.ability.extra.eemult\r\n                }\r\n            else\r\n                return {\r\n                    eemult = card.ability.extra.eemult_negative\r\n\r\n                }\r\n            end\r\n        end\r\n        if AKYRS.bal(\"adequate\") then\r\n            if context.joker_main or context.forcetrigger then\r\n                return {\r\n                    xmult = card.ability.extra.xmult\r\n                }\r\n            end\r\n            if context.final_scoring_step and G.GAME.blind then\r\n                \r\n                    local comp = false\r\n                    if Talisman then\r\n                        comp = G.GAME.blind.chips:lt(G.GAME.current_round.current_hand.chips * G.GAME.current_round.current_hand.mult)\r\n                    else\r\n                        \r\n                        comp = G.GAME.current_round.current_hand.chips * G.GAME.current_round.current_hand.mult >= G.GAME.blind.chips\r\n                    end\r\n                    G.E_MANAGER:add_event(\r\n                        Event{\r\n                            func = function ()\r\n                                if AKYRS.score_catches_fire_or_not() then\r\n                                    card.ability.extra.xmult = 1\r\n                                else \r\n                                    card.ability.extra.xmult = card.ability.extra.xmult + card.ability.extra.extra\r\n                                end\r\n                                return true\r\n                            end\r\n                        }\r\n                    )\r\n                    if comp then\r\n                        return {\r\n                            message = localize(\"k_akyrs_extinguish\")\r\n                        }\r\n                    else \r\n                        return {\r\n                            message = localize(\"k_akyrs_burn\"),\r\n                        }\r\n                    end\r\n            end\r\n        end\r\n \r\n    end,\r\n    demicoloncompat = true,\r\n    blueprint_compat = true,",
      "config": {
        "extra": {
          "xmult": 1,
          "extra": 0.5,
          "eemult": 1.21,
          "eemult_negative": 0.35,
          "chance": 3,
          "super_mario": 1
        }
      },
      "ability": {
        "extra": {
          "xmult": 1,
          "extra": 0.5,
          "eemult": 1.21,
          "eemult_negative": 0.35,
          "chance": 3,
          "super_mario": 1
        }
      },
      "vars": [
        1.21,
        0.35,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "hibana",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 5,
        "y": 1
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    key = \"hibana\",\r\n    pools = { [\"Vocaloids\"] = true, [\"J-POP\"] = true },\r\n    pos = {\r\n        x = 5,\r\n        y = 1\r\n    },\r\n    soul_pos = {\r\n        x = 8,\r\n        y = 1\r\n    },\r\n    rarity = 3,\r\n    cost = 7,\r\n    config = {\r\n        possible_table = {\r\n            {\"Ace\", \"Rank\", {\"k_aces\", \"dictionary\"}},\r\n            {\"Face Cards\", \"Condition\", {\"k_face_cards\",\"dictionary\"}},\r\n            {\"Hearts\", \"Suit\", {\"Hearts\", 'suits_plural'}},\r\n            {\"5\", \"Rank\", {\"5\", \"ranks\"}}\r\n        },\r\n        immutable = {\r\n            akyrs_cycler = 1,\r\n            akyrs_priority_draw_rank = \"Ace\",\r\n            akyrs_priority_draw_suit = nil,\r\n            akyrs_priority_draw_conditions = nil,\r\n        },\r\n    },\r\n    set_ability = function (self, card, initial, delay_sprites)\r\n        if card.ability.immutable.akyrs_cycler ~= 1 and card.ability.immutable.akyrs_cycler ~= 2 and card.ability.immutable.akyrs_cycler ~= 3 and card.ability.immutable.akyrs_cycler ~= 4 then\r\n            card.ability.immutable.akyrs_cycler = 1\r\n        end\r\n    end,\r\n    loc_vars = function(self, info_queue, card)\r\n        if card.ability.immutable.akyrs_cycler ~= 1 and card.ability.immutable.akyrs_cycler ~= 2 and card.ability.immutable.akyrs_cycler ~= 3 and card.ability.immutable.akyrs_cycler ~= 4 then\r\n            card.ability.immutable.akyrs_cycler = 1\r\n        end\r\n        local table = card.ability.possible_table[math.floor(card.ability.immutable.akyrs_cycler)]\r\n        info_queue[#info_queue+1] = { key = \"dd_akyrs_hibana_conditions\", set = \"DescriptionDummy\"}\r\n        return {\r\n            vars = {\r\n                localize(table[3][1],table[3][2]),\r\n                card.ability.immutable.akyrs_cycler,\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if (context.end_of_round or context.forcetrigger) and context.cardarea == G.jokers then\r\n            if card.ability.immutable.akyrs_cycler ~= 1 and card.ability.immutable.akyrs_cycler ~= 2 and card.ability.immutable.akyrs_cycler ~= 3 and card.ability.immutable.akyrs_cycler ~= 4 then\r\n                card.ability.immutable.akyrs_cycler = 1\r\n            end\r\n            card.ability.immutable.akyrs_priority_draw_rank = nil\r\n            card.ability.immutable.akyrs_priority_draw_suit = nil\r\n            card.ability.immutable.akyrs_priority_draw_conditions = nil\r\n            card.ability.immutable.akyrs_cycler = math.fmod(card.ability.immutable.akyrs_cycler,#(card.ability.possible_table)) + 1\r\n            local curr = card.ability.possible_table[card.ability.immutable.akyrs_cycler]\r\n            if curr[2] == \"Rank\" then\r\n                card.ability.immutable.akyrs_priority_draw_rank = curr[1]\r\n            end\r\n            if curr[2] == \"Suit\" then\r\n                card.ability.immutable.akyrs_priority_draw_suit = curr[1]\r\n            end\r\n            if curr[2] == \"Condition\" then\r\n                card.ability.immutable.akyrs_priority_draw_conditions = curr[1]\r\n            end\r\n            return {\r\n                message = localize('k_akyrs_hibana_change')\r\n            }\r\n        end\r\n    end,\r\n    add_to_deck = function (self, card, from_debuff)        \r\n        card.ability.immutable.akyrs_cycler = math.floor(card.ability.immutable.akyrs_cycler)\r\n        card.ability.immutable.akyrs_priority_draw_rank = nil\r\n        card.ability.immutable.akyrs_priority_draw_suit = nil\r\n        card.ability.immutable.akyrs_priority_draw_conditions = nil\r\n        local curr = card.ability.possible_table[card.ability.immutable.akyrs_cycler]\r\n        if curr[2] == \"Rank\" then\r\n            card.ability.immutable.akyrs_priority_draw_rank = curr[1]\r\n        end\r\n        if curr[2] == \"Suit\" then\r\n            card.ability.immutable.akyrs_priority_draw_suit = curr[1]\r\n        end\r\n        if curr[2] == \"Condition\" then\r\n            card.ability.immutable.akyrs_priority_draw_conditions = curr[1]\r\n        end\r\n        if G.deck then\r\n            G.deck:shuffle()\r\n        end\r\n    end,\r\n    remove_from_deck = function (self, card, from_debuff)\r\n        if G.deck then\r\n            G.deck:shuffle()\r\n        end\r\n    end,\r\n    demicoloncompat = true,",
      "config": {},
      "ability": {},
      "vars": [
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "centrifuge",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    key = \"centrifuge\",\r\n    pools = { [\"Science\"] = true },\r\n    pos = {\r\n        x = 0, y = 2\r\n    },\r\n    rarity = 2,\r\n    cost = 2,\r\n    config = {\r\n        extra = {\r\n            rank_delta = 1,\r\n            chips = 4,\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        if AKYRS.bal(\"absurd\") then\r\n            info_queue[#info_queue+1] = G.P_CENTERS[\"m_akyrs_scoreless\"]\r\n            return {\r\n                key = self.key .. \"_absurd\",\r\n                vars = {\r\n                    1,\r\n                }\r\n            }\r\n        end\r\n        return {\r\n            vars = {\r\n                1,\r\n                card.ability.extra.chips\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.after and #G.play.cards >= 3 and not context.blueprint then\r\n\r\n            for i, card2 in ipairs(G.play.cards) do\r\n                \r\n                G.E_MANAGER:add_event(Event{\r\n                    trigger = 'after',\r\n                    blocking = false,\r\n                    -- the abs thing is so it does the center to the sides effect\r\n                    -- TODO: Maybe make it flip from center to border like a centrifuge, not priority tho\r\n                    delay = 0.2*AKYRS.get_speed_mult(card),\r\n                    func = function ()\r\n                        if G.play and G.play.cards then\r\n                            local percent = math.abs(1.15 - (i-0.999)/(#G.play.cards-0.998)*0.3)\r\n                            if G.play.cards[i] then\r\n                                G.play.cards[i]:flip()\r\n                            end\r\n                            play_sound('card1', percent);\r\n                        end\r\n                        return true\r\n                    end\r\n                })\r\n                G.E_MANAGER:add_event(\r\n                    Event{\r\n                        trigger = 'after',\r\n                        delay = 0.5*AKYRS.get_speed_mult(card),\r\n                        func = function ()\r\n                            local rankToChangeTo = card2.base.value\r\n                            local ed = poll_edition(\"akyrs_centrifuge_absurd_edition\",1, true, true)\r\n                            local en = SMODS.poll_enhancement({guaranteed = true, key = \"akyrs_centrifuge_absurd\"})\r\n                            if type(en) == \"string\" then en = G.P_CENTERS[en] end\r\n                            local rim = true\r\n                            if i == 1 or i == #G.play.cards then\r\n                                rankToChangeTo = pseudorandom_element(SMODS.Ranks[card2.base.value].next,pseudoseed(\"akyrscentrifuge\"))\r\n                            else\r\n                                en = G.P_CENTERS[\"m_akyrs_scoreless\"]\r\n                                rankToChangeTo = pseudorandom_element(SMODS.Ranks[card2.base.value].prev,pseudoseed(\"akyrscentrifuge\"))\r\n                                rim = false\r\n                            end\r\n                            card2:flip()\r\n                            assert(SMODS.change_base(card2, nil, rankToChangeTo))\r\n                            if AKYRS.bal(\"absurd\") then\r\n                                card2:set_ability(en)\r\n                                if rim then card2:set_edition(ed) end\r\n                                \r\n                            end\r\n                            return true\r\n                        end\r\n                    }\r\n                )\r\n            end\r\n            delay(0.1*AKYRS.get_speed_mult(card)+0.3*#G.play.cards)\r\n        end\r\n        if context.joker_main and AKYRS.bal(\"adequate\") then\r\n            return {\r\n                chips = card.ability.extra.chips * #G.play.cards,\r\n                message = localize(\"k_akyrs_centrifuged\")\r\n            }\r\n        end\r\n    end,\r\n    demicoloncompat = true,",
      "config": {
        "extra": {
          "rank_delta": 1,
          "chips": 4
        }
      },
      "ability": {
        "extra": {
          "rank_delta": 1,
          "chips": 4
        }
      },
      "vars": [
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "neurosama",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    key = \"neurosama\",\r\n    pools = { [\"Vtuber\"] = true, },\r\n    pos = {\r\n        x = 1, y = 2\r\n    },\r\n    rarity = 3,\r\n    cost = 6,\r\n    config = {\r\n        name = \"Neuro Sama\",\r\n        extras = {\r\n            xmult = 1,\r\n            xmult_inc = 0.1,\r\n            xmult_absurd = 1,\r\n            xmult_inc_absurd = 1.2,\r\n        }\r\n    },\r\n    loc_vars = function (self,info_queue, card)\r\n        \r\n        if Talisman then\r\n            card.ability.extras.xmult_absurd = to_big(card.ability.extras.xmult_absurd)\r\n            card.ability.extras.xmult_inc_absurd = to_big(card.ability.extras.xmult_inc_absurd)\r\n        end\r\n        return {\r\n            key = AKYRS.bal_val(self.key, self.key..\"_absurd\"), \r\n            vars = AKYRS.bal_val({\r\n                card.ability.extras.xmult,\r\n                card.ability.extras.xmult_inc\r\n            },\r\n            {\r\n                card.ability.extras.xmult_absurd,\r\n                card.ability.extras.xmult_inc_absurd\r\n            })\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.individual and context.cardarea == G.play and not context.blueprint then\r\n            if context.other_card:is_suit(\"Hearts\") or ((context.other_card:is_suit(\"Spades\") and next(SMODS.find_card(\"j_akyrs_evilneuro\")))) then\r\n                return {\r\n                    message = localize(\"k_upgrade_ex\"),\r\n                    message_card = card,\r\n                    func = function ()\r\n                        if Talisman then\r\n                            card.ability.extras.xmult_absurd = to_big(card.ability.extras.xmult_absurd)\r\n                            card.ability.extras.xmult_inc_absurd = to_big(card.ability.extras.xmult_inc_absurd)\r\n                        end\r\n                        card.ability.extras.xmult = card.ability.extras.xmult + card.ability.extras.xmult_inc\r\n                        card.ability.extras.xmult_absurd = card.ability.extras.xmult_absurd * card.ability.extras.xmult_inc_absurd\r\n                    end\r\n                }\r\n            end\r\n        end\r\n        if context.joker_main or context.forcetrigger then\r\n            return {\r\n                xmult = AKYRS.bal_val(card.ability.extras.xmult,card.ability.extras.xmult_absurd)\r\n            }\r\n        end\r\n    end,\r\n    blueprint_compat = true,\r\n    demicoloncompat = true,",
      "config": {
        "name": "Neuro Sama",
        "extras": {
          "xmult": 1,
          "xmult_inc": 0.1,
          "xmult_absurd": 1,
          "xmult_inc_absurd": 1.2
        }
      },
      "ability": {
        "name": "Neuro Sama",
        "extras": {
          "xmult": 1,
          "xmult_inc": 0.1,
          "xmult_absurd": 1,
          "xmult_inc_absurd": 1.2
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "evilneuro",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    key = \"evilneuro\",\r\n    pools = { [\"Vtuber\"] = true, },\r\n    pos = {\r\n        x = 2, y = 2\r\n    },\r\n    rarity = 3,\r\n    cost = 6,\r\n    config = {\r\n        name = \"Evil Neuro\",\r\n        extras = {\r\n            xchips = 1,\r\n            xchips_inc = 0.1,\r\n            xchips_absurd = 1.1,\r\n            xchips_inc_absurd = 1.1,\r\n        }\r\n    },\r\n    loc_vars = function (self,info_queue, card)\r\n        if Talisman then\r\n            card.ability.extras.xchips_absurd = to_big(card.ability.extras.xchips_absurd)\r\n            card.ability.extras.xchips_inc_absurd = to_big(card.ability.extras.xchips_inc_absurd)\r\n        end\r\n        return {\r\n            key = AKYRS.bal_val(self.key, self.key..\"_absurd\"), \r\n            vars = AKYRS.bal_val({\r\n                card.ability.extras.xchips,\r\n                card.ability.extras.xchips_inc\r\n            },\r\n            {\r\n                card.ability.extras.xchips_absurd,\r\n                card.ability.extras.xchips_inc_absurd\r\n            })\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.individual and context.cardarea == G.play and not context.blueprint then\r\n            if context.other_card:is_suit(\"Clubs\") or ((context.other_card:is_suit(\"Diamonds\") and next(SMODS.find_card(\"j_akyrs_neurosama\")))) then\r\n                return {\r\n                    message = localize(\"k_upgrade_ex\"),\r\n                    message_card = card,\r\n                    func = function ()\r\n                        card.ability.extras.xchips = card.ability.extras.xchips + card.ability.extras.xchips_inc\r\n                        if Talisman then\r\n                            card.ability.extras.xchips_absurd = to_big(card.ability.extras.xchips_absurd)\r\n                            card.ability.extras.xchips_inc_absurd = to_big(card.ability.extras.xchips_inc_absurd)\r\n                        end\r\n                        card.ability.extras.xchips_absurd = card.ability.extras.xchips_absurd ^ card.ability.extras.xchips_inc_absurd\r\n                    end\r\n                }\r\n            end\r\n        end\r\n        if context.joker_main or context.forcetrigger then\r\n            return {\r\n                xchips = AKYRS.bal_val(card.ability.extras.xchips,card.ability.extras.xchips_absurd)\r\n            }\r\n        end\r\n    end,\r\n    blueprint_compat = true,\r\n    demicoloncompat = true,",
      "config": {
        "name": "Evil Neuro",
        "extras": {
          "xchips": 1,
          "xchips_inc": 0.1,
          "xchips_absurd": 1.1,
          "xchips_inc_absurd": 1.1
        }
      },
      "ability": {
        "name": "Evil Neuro",
        "extras": {
          "xchips": 1,
          "xchips_inc": 0.1,
          "xchips_absurd": 1.1,
          "xchips_inc_absurd": 1.1
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "dried_ghast",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 3,
        "y": 2
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    key = \"dried_ghast\",\r\n    pools = { [\"Minecraft\"] = true, },\r\n    pos = {\r\n        x = 3, y = 2\r\n    },\r\n    rarity = 1,\r\n    cost = 3,\r\n    config = {\r\n        name = \"Dried Ghast\",\r\n        extras = {\r\n            rounds_left = 2\r\n        }\r\n    },\r\n    loc_vars = function (self,info_queue, card)\r\n        info_queue[#info_queue+1] = G.P_CENTERS[\"j_akyrs_ghastling\"]\r\n        return {\r\n            vars = {\r\n                card.ability.extras.rounds_left,\r\n                2\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.setting_blind and not context.blueprint then\r\n            return {\r\n                message = localize(\"k_akyrs_dried\"),\r\n                func = function ()\r\n                    card.ability.current_round_discards = G.GAME.round_resets.discards\r\n                    G.GAME.current_round.discards_left = 0\r\n                end\r\n            }\r\n        end\r\n        if context.selling_card and context.card == card and not context.blueprint then\r\n            G.GAME.current_round.discards_left = card.ability.current_round_discards \r\n        end\r\n        if (context.end_of_round and context.cardarea == G.jokers or context.forcetrigger) and not context.blueprint then\r\n            if not card.ability.do_not_decrease then\r\n                return {\r\n                    message = localize(\"k_akyrs_moisture\"),\r\n                    func = function ()\r\n                        card.ability.extras.rounds_left = card.ability.extras.rounds_left - 1\r\n                        if card.ability.extras.rounds_left <= 0 then\r\n                            card:start_dissolve({G.C.BLUE}, nil, 0.5)\r\n                            local c = SMODS.add_card({ key = \"j_akyrs_ghastling\"})\r\n                            c.ability.akyrs_from_dried = true\r\n                        end\r\n                    end\r\n                }\r\n            else\r\n                return {\r\n                    func = function ()\r\n                        card.ability.do_not_decrease = false\r\n                    end\r\n                }\r\n            end\r\n\r\n        end\r\n    end,\r\n    demicoloncompat = true,",
      "config": {
        "name": "Dried Ghast",
        "extras": {
          "rounds_left": 2
        }
      },
      "ability": {
        "name": "Dried Ghast",
        "extras": {
          "rounds_left": 2
        }
      },
      "vars": [
        2,
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "ghastling",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 4,
        "y": 2
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    key = \"ghastling\",\r\n    pools = { [\"Minecraft\"] = true, },\r\n    pos = {\r\n        x = 4, y = 2\r\n    },\r\n    rarity = 2,\r\n    cost = 6,\r\n    config = {\r\n        name = \"Ghastling\",\r\n        extras = {\r\n            rounds_left = 10,\r\n            rounds_left_absurd = 20,\r\n            mult = 21.6\r\n        }\r\n    },\r\n    in_pool = function (self, args)\r\n        return false\r\n    end,\r\n    loc_vars = function (self,info_queue, card)\r\n        info_queue[#info_queue+1] = G.P_CENTERS[\"j_akyrs_happy_ghast\"]\r\n        return {\r\n            vars = {\r\n                AKYRS.bal_val(card.ability.extras.rounds_left,card.ability.extras.rounds_left_absurd),\r\n                card.ability.extras.mult,\r\n                3\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if (context.after and context.cardarea == G.jokers or context.forcetrigger) and not context.blueprint then\r\n            if not card.ability.do_not_decrease then\r\n                return {\r\n                    message = localize(\"k_akyrs_growth\"),\r\n                    func = function ()\r\n                        card.ability.extras.rounds_left = card.ability.extras.rounds_left - (#SMODS.find_card(\"j_ice_cream\") + 1)\r\n                        card.ability.extras.rounds_left_absurd = card.ability.extras.rounds_left_absurd - (#SMODS.find_card(\"j_ice_cream\") + 1)\r\n                        if AKYRS.bal_val(card.ability.extras.rounds_left <= 0,card.ability.extras.rounds_left_absurd <= 0) then\r\n                            card:start_dissolve({G.C.RED}, nil, 0.5)\r\n                            if card.ability.akyrs_from_dried then\r\n                                check_for_unlock({ type = \"akyrs_happy_ghast_grown_from_dried\"})\r\n                            end\r\n                            SMODS.add_card({ key = \"j_akyrs_happy_ghast\"})\r\n                        end\r\n                    end\r\n                }\r\n            else\r\n                return {\r\n                    func = function ()\r\n                        card.ability.do_not_decrease = false\r\n                    end\r\n                }\r\n            end\r\n\r\n        end\r\n        if (context.joker_main or context.forcetrigger) then\r\n            return {\r\n                mult = card.ability.extras.mult\r\n            }\r\n        end\r\n    end,\r\n    demicoloncompat = true,\r\n    blueprint_compat = true",
      "config": {
        "name": "Ghastling",
        "extras": {
          "rounds_left": 10,
          "rounds_left_absurd": 20,
          "mult": 21.6
        }
      },
      "ability": {
        "name": "Ghastling",
        "extras": {
          "rounds_left": 10,
          "rounds_left_absurd": 20,
          "mult": 21.6
        }
      },
      "vars": [
        null,
        null,
        21.6,
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "happy_ghast",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 5,
        "y": 2
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    key = \"happy_ghast\",\r\n    pools = { [\"Minecraft\"] = true, },\r\n    pos = {\r\n        x = 5, y = 2\r\n    },\r\n    rarity = 3,\r\n    cost = 10,\r\n    config = {\r\n        name = \"Happy Ghast\",\r\n        extras = {\r\n            xmult = 4.32,\r\n            eemult_absurd = 2.16\r\n        }\r\n    },\r\n    in_pool = function (self, args)\r\n        return false\r\n    end,\r\n    loc_vars = function (self,info_queue, card)\r\n        return {\r\n            key = AKYRS.bal_val(self.key, self.key..\"_absurd\"),\r\n            vars = {\r\n                AKYRS.bal_val(card.ability.extras.xmult,card.ability.extras.eemult_absurd)\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if AKYRS.bal_val(context.joker_main,context.individual and context.cardarea == G.play) or context.forcetrigger then\r\n            return AKYRS.bal_val({\r\n                xmult = card.ability.extras.xmult\r\n            },{\r\n                emult = card.ability.extras.eemult_absurd\r\n            })\r\n        end\r\n    end,\r\n    demicoloncompat = true,\r\n    blueprint_compat = true",
      "config": {
        "name": "Happy Ghast",
        "extras": {
          "xmult": 4.32,
          "eemult_absurd": 2.16
        }
      },
      "ability": {
        "name": "Happy Ghast",
        "extras": {
          "xmult": 4.32,
          "eemult_absurd": 2.16
        }
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "charred_roach",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 6,
        "y": 2
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    pools = { [\"Meme\"] = true, },\r\n    key = \"charred_roach\",\r\n    pos = {\r\n        x = 6, y = 2\r\n    },\r\n    rarity = 3,\r\n    cost = 12,\r\n    config = {\r\n        name = \"Charred Roach\",\r\n        extras = {\r\n        }\r\n    },\r\n    demicoloncompat = true,\r\n    loc_vars = function (self, info_queue, card)\r\n        info_queue[#info_queue+1] = G.P_CENTERS[\"e_akyrs_burnt\"]\r\n        \r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.akyrs_card_remove and context.card_getting_removed.config.center_key ~= \"j_akyrs_charred_roach\" and not (context.card_getting_removed.edition and context.card_getting_removed.edition.key == \"e_akyrs_burnt\")\r\n        then\r\n            return {\r\n                func = function ()\r\n                    local crm = context.card_getting_removed\r\n                    if crm.ability.set == \"Joker\" and crm.config.center_key ~= \"j_akyrs_ash_joker\" then\r\n                        local copy = copy_card(crm,nil,nil,nil, true)\r\n                        copy:set_edition('e_akyrs_burnt')\r\n                        copy.sell_cost = 0\r\n                        G.jokers:emplace(copy)\r\n                    end\r\n                    if (crm.ability.set == \"Enhanced\" or crm.ability.set == \"Default\") and not (crm.config.center_key == \"m_akyrs_ash_card\") then\r\n                        G.playing_card = (G.playing_card and G.playing_card + 1) or 1\r\n                        local copy = copy_card(crm,nil,nil,G.playing_card, true)\r\n                        G.deck.config.card_limit = G.deck.config.card_limit + 1\r\n                        table.insert(G.playing_cards, copy)\r\n                        copy:set_edition('e_akyrs_burnt')\r\n                        if #G.hand.cards > 0 then\r\n                            G.hand:emplace(copy)\r\n                        else\r\n                            G.deck:emplace(copy)\r\n                        end\r\n                        copy:add_to_deck()\r\n                        copy.sell_cost = 0\r\n                        copy:start_materialize(nil)\r\n                        playing_card_joker_effects({copy})\r\n                    end\r\n                end\r\n            }\r\n        end\r\n    end",
      "config": {
        "name": "Charred Roach",
        "extras": {}
      },
      "ability": {
        "name": "Charred Roach",
        "extras": {}
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "ash_joker",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 7,
        "y": 2
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    key = \"ash_joker\",\r\n    pos = {\r\n        x = 7, y = 2\r\n    },\r\n    rarity = 1,\r\n    cost = 0,\r\n    in_pool = function (self, args)\r\n        return false\r\n    end,\r\n    config = {\r\n        name = \"Ash Joker\",\r\n        extras = {\r\n            chips = 35,\r\n            chips_gain = 15,\r\n            echips = 2,\r\n            odds = 4\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        if AKYRS.bal(\"absurd\") then\r\n            return {\r\n                key = self.key .. \"_absurd\",\r\n                vars = {\r\n                    card.ability.extras.echips,\r\n                }\r\n            }\r\n        end\r\n        local n, d = SMODS.get_probability_vars(card, 1, card.ability.extras.odds, 'akyrs_ash_joker_adequate')\r\n        return {\r\n            vars = {\r\n                card.ability.extras.chips,\r\n                n,\r\n                d,\r\n                card.ability.extras.chips_gain\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.joker_main or context.forcetrigger then\r\n            return AKYRS.bal_val({\r\n                chips = card.ability.extras.chips\r\n            }, {\r\n                echips = card.ability.extras.echips\r\n            })\r\n        end\r\n        if context.end_of_round and context.cardarea == G.jokers then\r\n            local odder = AKYRS.bal(\"absurd\") or \r\n                SMODS.pseudorandom_probability(card,\"akyrs_ash_joker_adequate\", 1, card.ability.extras.odds)\r\n            if odder then\r\n                card.ability.akyrs_ash_disintegrate = odder\r\n            else\r\n                card.ability.extras.chips = card.ability.extras.chips + card.ability.extras.chips_gain\r\n            end\r\n        end\r\n    end,\r\n    demicoloncompat = true,",
      "config": {
        "name": "Ash Joker",
        "extras": {
          "chips": 35,
          "chips_gain": 15,
          "echips": 2,
          "odds": 4
        }
      },
      "ability": {
        "name": "Ash Joker",
        "extras": {
          "chips": 35,
          "chips_gain": 15,
          "echips": 2,
          "odds": 4
        }
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "chicken_jockey",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 9,
        "y": 2
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    pools = { [\"Meme\"] = true, },\r\n    key = \"chicken_jockey\",\r\n    pos = {\r\n        x = 9, y = 2\r\n    },\r\n    rarity = 3,\r\n    cost = 4,\r\n    config = {\r\n        name = \"Chicken Jockey\",\r\n        extras = {\r\n            xmult = 1,\r\n            xmult_inc = 2,\r\n            emult = 1,\r\n            emult_inc = 1,\r\n            decrease_popcorn = 9,\r\n            popcorn_original_absurd = 5,\r\n            decrease_popcorn_absurd = 1,\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        info_queue[#info_queue+1] = localize{key = \"j_popcorn\", vars = {20,4}}\r\n        if AKYRS.bal(\"absurd\") then\r\n            return {\r\n                key = self.key .. \"_absurd\",\r\n                vars = {\r\n                    card.ability.extras.emult_inc,\r\n                    card.ability.extras.emult,\r\n                    card.ability.extras.decrease_popcorn_absurd,\r\n                    card.ability.extras.popcorn_original_absurd,\r\n                }\r\n            }\r\n        end\r\n        return {\r\n            vars = {\r\n                card.ability.extras.xmult_inc,\r\n                card.ability.extras.xmult,\r\n                card.ability.extras.decrease_popcorn,\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if AKYRS.bal(\"absurd\") then\r\n            if context.setting_blind then\r\n                if AKYRS.has_room(G.jokers) then\r\n                    SMODS.add_card{key = \"j_popcorn\"}\r\n                end\r\n            end\r\n        end\r\n        if context.joker_main then\r\n            return AKYRS.bal_val({\r\n                xmult = card.ability.extras.xmult\r\n            },{\r\n                emult = card.ability.extras.emult\r\n            })\r\n        end\r\n\r\n        if context.akyrs_card_remove \r\n        and (context.card_getting_removed.config and context.card_getting_removed.config.center_key and context.card_getting_removed.config.center_key == \"j_popcorn\") then\r\n            if context.card_getting_removed.ability.mult - context.card_getting_removed.ability.extra <= 0 then\r\n                return {\r\n                    message = localize(\"k_upgrade_ex\"),\r\n                    func = function ()\r\n                        card.ability.extras.xmult = card.ability.extras.xmult + card.ability.extras.xmult_inc\r\n                        card.ability.extras.emult = card.ability.extras.emult + card.ability.extras.emult_inc\r\n                    end\r\n                }\r\n            end\r\n        end\r\n    end",
      "config": {
        "name": "Chicken Jockey",
        "extras": {
          "xmult": 1,
          "xmult_inc": 2,
          "emult": 1,
          "emult_inc": 1,
          "decrease_popcorn": 9,
          "popcorn_original_absurd": 5,
          "decrease_popcorn_absurd": 1
        }
      },
      "ability": {
        "name": "Chicken Jockey",
        "extras": {
          "xmult": 1,
          "xmult_inc": 2,
          "emult": 1,
          "emult_inc": 1,
          "decrease_popcorn": 9,
          "popcorn_original_absurd": 5,
          "decrease_popcorn_absurd": 1
        }
      },
      "vars": [
        1,
        1,
        1,
        5
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "tetoris",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 0,
        "y": 3
      },
      "raw": "key = \"tetoris\",\r\n    pools = { [\"Vocaloids\"] = true, [\"J-POP\"] = true },\r\n    atlas = 'AikoyoriJokers',\r\n    pos = {\r\n        x = 0, y = 3\r\n    },\r\n    rarity = 3,\r\n    cost = 7,\r\n    config = {\r\n        name = \"Tetoris\",\r\n        extras = {\r\n            chips = 10,\r\n            xchips = 2.1,\r\n            immutable = {\r\n                counter = 0\r\n            }\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        if AKYRS.bal(\"absurd\") then\r\n            return {\r\n                key = self.key..\"_absurd\"..(Cryptid and \"_cryptid\" or \"\")..(Entropy and \"_entropy\" or \"\"),\r\n                vars = {\r\n                    card.ability.extras.immutable.counter,\r\n                }\r\n            }\r\n        end\r\n        return {\r\n            vars = {\r\n                card.ability.extras.chips,\r\n                card.ability.extras.xchips,\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if AKYRS.bal(\"absurd\") then\r\n            \r\n            if context.akyrs_pre_play then\r\n                return {\r\n                    func = function ()\r\n                        card.ability.extras.immutable.counter = card.ability.extras.immutable.counter + #G.hand.highlighted\r\n                    end\r\n                }\r\n            end\r\n            if context.before then\r\n                card.ability.extras.immutable.counter = math.max(card.ability.extras.immutable.counter,0)\r\n                SMODS.calculate_effect({func = function() \r\n                    if Entropy and card.ability.extras.immutable.counter >= 50 then\r\n                        SMODS.add_card{ key = \"c_entr_beyond\", set = \"Omen\", edition = \"e_negative\"} \r\n                        card.ability.extras.immutable.counter = card.ability.extras.immutable.counter - 50\r\n                    end\r\n                end})\r\n                SMODS.calculate_effect({func = function() \r\n                    if Entropy and card.ability.extras.immutable.counter >= 40 then\r\n                        SMODS.add_card{ key = \"c_cry_gateway\", set = \"Spectral\", edition = \"e_negative\"} \r\n                        card.ability.extras.immutable.counter = card.ability.extras.immutable.counter - 40\r\n                    end\r\n                end})\r\n                SMODS.calculate_effect({func = function() \r\n                    if Entropy and card.ability.extras.immutable.counter >= 30 then\r\n                        SMODS.add_card{ key = \"c_soul\", set = \"Spectral\", edition = \"e_negative\"} \r\n                        card.ability.extras.immutable.counter = card.ability.extras.immutable.counter - 30\r\n                    end\r\n                end})\r\n                SMODS.calculate_effect({func = function() \r\n                    if Entropy and card.ability.extras.immutable.counter >= 4 then\r\n                        SMODS.add_card{ set = \"Spectral\", edition = \"e_negative\"} \r\n                        card.ability.extras.immutable.counter = card.ability.extras.immutable.counter - 4\r\n                    end\r\n                end})\r\n            end\r\n        else\r\n            if context.joker_main then\r\n                local c = AKYRS.get_letter_freq_from_cards(G.play.cards)\r\n                local r = AKYRS.get_ranks_freq_from_cards(G.play.cards)\r\n                local s = AKYRS.get_suit_freq_from_cards(G.play.cards)\r\n                if (c[\"l\"] or c[\"s\"] or c[\"o\"] or c[\"z\"] or c[\"j\"] or c[\"i\"] or c[\"t\"] or r[11] or r[10] or s[\"Spades\"]) and G.GAME.akyrs_character_stickers_enabled then\r\n                    return {\r\n                        xchips = card.ability.extras.xchips,\r\n                    }\r\n                end\r\n            end\r\n        end\r\n    end",
      "config": {
        "name": "Tetoris",
        "extras": {
          "chips": 10,
          "xchips": 2.1,
          "immutable": {
            "counter": 0
          }
        }
      },
      "ability": {
        "name": "Tetoris",
        "extras": {
          "chips": 10,
          "xchips": 2.1,
          "immutable": {
            "counter": 0
          }
        }
      },
      "vars": [
        0
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "aikoyori",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 1,
        "y": 3
      },
      "raw": "pools = { [\"Self-Insert\"] = true, },\r\n    key = \"aikoyori\",\r\n    atlas = 'AikoyoriJokers',\r\n    pos = {\r\n        x = 1, y = 3\r\n    },\r\n    soul_pos = {\r\n        x = 2, y = 3\r\n    },\r\n    rarity = 4,\r\n    cost = 50,\r\n    config = {\r\n        name = \"Aikoyori\",\r\n        extras = {\r\n            base = {\r\n                xmult = 1.984,\r\n                emult = 1.5,\r\n            }\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        if AKYRS.bal_val(\"adequate\") then\r\n            info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_aikoyori_base_ability\", vars = {card.ability.extras.base.xmult}}\r\n        else\r\n            info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_aikoyori_base_ability_absurd\", vars = {card.ability.extras.base.emult}}\r\n        end\r\n        if Cryptid then\r\n            info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_aikoyori_cryptid_ability\"}\r\n        end\r\n        if MoreFluff then\r\n            info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_aikoyori_more_fluff_ability\"}\r\n        end\r\n        if Entropy then\r\n            info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_aikoyori_entropy_ability\"}\r\n        end\r\n        if SDM_0s_Stuff_Mod then\r\n            info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_aikoyori_sdmstuff_ability\"}\r\n        end\r\n        if togabalatro then\r\n            info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_aikoyori_togasstuff_ability\"}\r\n        end\r\n        if PTASaka then\r\n            info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_aikoyori_pta_ability\"}\r\n        end\r\n        if Cryptposting then\r\n            info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_cryptposting_ability\"}\r\n        end\r\n        if AKYRS.is_mod_loaded(\"Prism\") then\r\n            info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_prism_ability\"}\r\n        end\r\n        if garb_enabled then\r\n            info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_garbshit_ability\"}\r\n        end\r\n        if AKYRS.is_mod_loaded(\"finity\") then\r\n            info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_finity_ability\"}\r\n        end\r\n        if Bakery_API then\r\n            info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_bakery_ability\"}\r\n        end\r\n        if AKYRS.is_mod_loaded(\"Astronomica\") then\r\n            info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_astronomica_ability\"}\r\n        end\r\n        return {\r\n        }\r\n    end,\r\n    add_to_deck = function (self, card, from_debuff)\r\n        if Bakery_API then\r\n            G.GAME.modifiers.Bakery_extra_charms = G.GAME.modifiers.Bakery_extra_charms and G.GAME.modifiers.Bakery_extra_charms + 1 or 1\r\n        end\r\n    end,\r\n    remove_from_deck = function (self, card, from_debuff)\r\n        if Bakery_API then\r\n            G.GAME.modifiers.Bakery_extra_charms = G.GAME.modifiers.Bakery_extra_charms and G.GAME.modifiers.Bakery_extra_charms - 1 or 1\r\n        end\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.skip_blind then\r\n            if Cryptposting then\r\n                local jkr = pseudorandom_element(cryptposting_joker,pseudoseed(\"aikocryptposting\"))\r\n                SMODS.add_card({set = \"Joker\", key = jkr})\r\n            end\r\n        end\r\n        if context.before then\r\n            if Cryptid and #G.play.cards == 1 and G.play.cards[1]:get_id() == 14 then\r\n                SMODS.add_card({set = \"Code\", area = G.consumeables, edition = \"e_negative\"})\r\n            end\r\n            if Entropy and #context.full_hand >= 4 then\r\n                local suits_in_hand = {}\r\n                local ranks_in_hand = {}\r\n                local all_card_unique = true\r\n                for i, k in ipairs(context.full_hand) do\r\n                    if not SMODS.has_no_suit(k) and not SMODS.has_no_rank(k) then\r\n                        if not suits_in_hand[k.base.suit] and not ranks_in_hand[k:get_id()] then\r\n                            suits_in_hand[k.base.suit] = true\r\n                            ranks_in_hand[k:get_id()] = true\r\n                        else\r\n                            all_card_unique = false\r\n                            break\r\n                        end\r\n                    end\r\n                end\r\n                if all_card_unique then\r\n                    SMODS.add_card({set = \"Spectral\", key = \"c_entr_flipside\", area = G.consumeables, edition = \"e_negative\"})\r\n                end\r\n            end\r\n            if SDM_0s_Stuff_Mod then\r\n                if next(context.poker_hands[\"Full House\"]) then\r\n                    SMODS.add_card({set = \"Bakery\", area = G.consumeables, edition = \"e_negative\"})\r\n                end\r\n            end\r\n            if AKYRS.is_mod_loaded(\"Prism\") then\r\n                if not next(context.poker_hands[\"Flush\"]) then\r\n                    SMODS.add_card({set = \"Myth\", area = G.consumeables, edition = \"e_negative\"})\r\n                end\r\n            end\r\n        end \r\n        if AKYRS.is_mod_loaded(\"Astronomica\") then\r\n            if context.after then\r\n                local cards_below_hand = math.max(G.hand.config.card_limit - #G.play.cards ,1)\r\n                if cards_below_hand > 1 then\r\n                    return {\r\n                        message = localize(\"k_akyrs_score_mult_pre\")..cards_below_hand..localize(\"k_akyrs_score_mult_append\"),\r\n                        colour = G.C.PURPLE,\r\n                        func = function ()\r\n                            AKYRS.mod_score({mult = cards_below_hand})\r\n                        end\r\n                    }\r\n                end\r\n            end\r\n        end\r\n        if AKYRS.is_mod_loaded(\"finity\") and context.blind_defeated and G.GAME.blind and G.GAME.blind.boss and G.GAME.blind.config.blind.boss.showdown then\r\n            SMODS.add_card({set = \"Spectral\", area = G.consumeables, edition = \"e_negative\", key = \"c_finity_finity\"})\r\n        end\r\n        if garb_enabled and context.selling_card and context.card.ability.set == \"Joker\" then\r\n            SMODS.add_card({set = \"Stamp\", area = G.consumeables, edition = \"e_negative\"})\r\n        end\r\n        if context.individual and context.cardarea == G.play then\r\n            if not context.other_card:is_face() then\r\n                return AKYRS.bal_val(\r\n                    {\r\n                        xmult = card.ability.extras.base.xmult\r\n                    },\r\n                    {\r\n                        emult = card.ability.extras.base.emult\r\n                    }\r\n                )\r\n            end\r\n        end\r\n        if context.akyrs_round_eval then\r\n            local d = Talisman and to_big(context.dollars) or context.dollars\r\n            local v = Talisman and to_big(10) or 10\r\n            local c = d < v\r\n            if togabalatro and c then\r\n                local tag = Tag(pseudorandom_element(toga_tags,pseudoseed(\"akyrs_aikoyori_toga_tags\")))\r\n                add_tag(tag)\r\n            end\r\n            if PTASaka then\r\n                if Talisman then\r\n                    ease_pyrox(to_number(context.dollars))\r\n                else\r\n                    ease_pyrox(context.dollars)\r\n                end\r\n            end\r\n        end\r\n    end,\r\n    blueprint_compat = true",
      "config": {
        "name": "Aikoyori",
        "extras": {
          "base": {
            "xmult": 1.984,
            "emult": 1.5
          }
        }
      },
      "ability": {
        "name": "Aikoyori",
        "extras": {
          "base": {
            "xmult": 1.984,
            "emult": 1.5
          }
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "mukuroju_no_hakamori",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 3,
        "y": 3
      },
      "raw": "pools = { [\"Rhythm Games\"] = true, [\"Maimai\"] = true },\r\n    key = \"mukuroju_no_hakamori\",\r\n    atlas = 'AikoyoriJokers',\r\n    pos = {\r\n        x = 3, y = 3\r\n    },\r\n    rarity = 3,\r\n    cost = 7,\r\n    config = {\r\n        name = \"èº¯æ¨¹ã®å¢å®\",\r\n        extras = {\r\n            xmult = 1,\r\n            xmult_absurd = 1,\r\n            xmult_add = 0.5,\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        if AKYRS.bal(\"absurd\") then\r\n            info_queue[#info_queue+1] = {key = 'dd_akyrs_mukuroju_en_absurd', vars = { card.ability.extras.xmult_absurd }, set = \"DescriptionDummy\"}\r\n        else\r\n            info_queue[#info_queue+1] = {key = 'dd_akyrs_mukuroju_en', vars = { card.ability.extras.xmult_add, card.ability.extras.xmult }, set = \"DescriptionDummy\"}\r\n        end\r\n\r\n        info_queue[#info_queue+1] = G.P_CENTERS['c_star']\r\n        if MoreFluff then\r\n            info_queue[#info_queue+1] = G.P_CENTERS['c_mf_rot_star']\r\n        end\r\n        return {\r\n            key = self.key .. AKYRS.bal_val(\"\",\"_absurd\"),\r\n            vars = AKYRS.bal_val({\r\n                card.ability.extras.xmult_add,\r\n                card.ability.extras.xmult\r\n            },{\r\n                card.ability.extras.xmult_absurd\r\n            })\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.using_consumeable and not context.blueprint and (\r\n        AKYRS.is_star(context.consumeable.config.center_key)\r\n        ) then\r\n            card.ability.extras.xmult_absurd = card.ability.extras.xmult_absurd * 8\r\n            card.ability.extras.xmult = card.ability.extras.xmult + card.ability.extras.xmult_add\r\n            return {\r\n                message = localize(\"k_upgrade_ex\"),\r\n            }\r\n        end\r\n        if context.joker_main then\r\n            return {\r\n                xmult = AKYRS.bal_val(card.ability.extras.xmult,card.ability.extras.xmult_absurd)\r\n            }\r\n        end\r\n    end,\r\n    blueprint_compat = true,\r\n    perishable_compat = false,",
      "config": {
        "name": "èº¯æ¨¹ã®å¢å®",
        "extras": {
          "xmult": 1,
          "xmult_absurd": 1,
          "xmult_add": 0.5
        }
      },
      "ability": {
        "name": "èº¯æ¨¹ã®å¢å®",
        "extras": {
          "xmult": 1,
          "xmult_absurd": 1,
          "xmult_add": 0.5
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "emerald",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 4,
        "y": 3
      },
      "raw": "pools = { [\"Minecraft\"] = true },\r\n    key = \"emerald\",\r\n    atlas = 'AikoyoriJokers',\r\n    pos = {\r\n        x = 4, y = 3\r\n    },\r\n    rarity = \"akyrs_emerald\",\r\n    cost = 2,\r\n    config = {\r\n        name = \"Emerald\",\r\n        extras = {\r\n            xcost = 4,\r\n            pluscost = 4,\r\n            ecost = 2,\r\n        }\r\n    },\r\n    add_to_deck = function (self, card, from_debuff)\r\n        G.GAME.akyrs_has_capability_to_trade = true\r\n    end,\r\n    loc_vars = function (self, info_queue, card)\r\n        if AKYRS.bal(\"absurd\") then\r\n            return {\r\n                key = self.key .. \"_absurd\",\r\n                vars = {\r\n                    card.ability.extras.pluscost,\r\n                    card.ability.extras.ecost,\r\n                    card.cost,\r\n                }\r\n            }\r\n        end\r\n        return {\r\n            vars = {\r\n                card.ability.extras.xcost,\r\n                card.cost,\r\n            }\r\n        }\r\n    end,\r\n    in_pool = function (self, args)\r\n        return true, {\r\n            allow_duplicates = next(SMODS.find_card(\"j_akyrs_emerald\"))\r\n        }       \r\n    end",
      "config": {
        "name": "Emerald",
        "extras": {
          "xcost": 4,
          "pluscost": 4,
          "ecost": 2
        }
      },
      "ability": {
        "name": "Emerald",
        "extras": {
          "xcost": 4,
          "pluscost": 4,
          "ecost": 2
        }
      },
      "vars": [
        4,
        2,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "shimmer_bucket",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 5,
        "y": 3
      },
      "raw": "pools = { [\"Terraria\"] = true, },\r\n    key = \"shimmer_bucket\",\r\n    atlas = 'AikoyoriJokers',\r\n    pos = {\r\n        x = 5, y = 3\r\n    },\r\n    rarity = 3,\r\n    cost = 15,\r\n    config = {\r\n        name = \"Shimmer Bucket\",\r\n        extras = {\r\n            create_factor = 2,\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras.create_factor,\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.ending_shop and not context.blueprint then\r\n            local index = AKYRS.find_index(G.jokers.cards,card)\r\n            if index and #G.jokers.cards > 1 and G.jokers.cards[index-1] and index > 1 then\r\n                local othercard = G.jokers.cards[index-1]\r\n                if not SMODS.is_eternal(othercard,card) then\r\n                    return {\r\n                        func = function ()\r\n                            local rarity = othercard.config.center.rarity\r\n                            othercard:start_dissolve({G.C.AKYRS_AKYRS_PLAYABLE},1.1)\r\n                            othercard:remove_from_deck()\r\n                            for i=1, card.ability.extras.create_factor do\r\n                                if AKYRS.has_room(G.jokers) then\r\n                                    SMODS.add_card{rarity = rarity, set = \"Joker\", legendary = (rarity == 4)}\r\n                                end\r\n                            end\r\n                            card:start_dissolve({G.C.AKYRS_PLAYABLE},1.1)\r\n                        end\r\n                    }\r\n                end\r\n            end\r\n        end\r\n    end,\r\n    eternal_compat = false",
      "config": {
        "name": "Shimmer Bucket",
        "extras": {
          "create_factor": 2
        }
      },
      "ability": {
        "name": "Shimmer Bucket",
        "extras": {
          "create_factor": 2
        }
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "space_elevator",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 6,
        "y": 3
      },
      "raw": "key = \"space_elevator\",\r\n    pools = { [\"Satisfactory\"] = true, },\r\n    atlas = 'AikoyoriJokers',\r\n    pos = {\r\n        x = 6, y = 3\r\n    },\r\n    rarity = 2,\r\n    cost = 7,\r\n    config = {\r\n        name = \"Space Elevator\",\r\n        extras = {\r\n            phase = 1,\r\n            target_play = 10,\r\n            played = 0,\r\n            target_rank = nil,\r\n            ranks_chosen = {}\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        card.ability.extras.phase = math.floor(card.ability.extras.phase)\r\n        card.ability.extras.target_play = math.floor(card.ability.extras.target_play)\r\n        \r\n        if card.ability.extras.phase > 5 or card.ability.extras.phase < 1 then \r\n            card.ability.extras.phase = 1\r\n        end\r\n        return {\r\n            vars = {\r\n                card.ability.extras.target_play,\r\n                localize(card.ability.extras.target_rank,\"ranks\"),\r\n                card.ability.extras.phase,\r\n                card.ability.extras.played,\r\n            }\r\n        }\r\n    end,\r\n    set_ability = function (self, card, initial, delay_sprites)\r\n        if initial then\r\n            local r = pseudorandom_element(AKYRS.get_p_card_ranks(card.ability.extras.ranks_chosen),pseudoseed(\"akyrs_space_elevator\")) \r\n                or pseudorandom_element(SMODS.Ranks,pseudoseed(\"akyrs_space_elevator\")) \r\n            if r then\r\n                card.ability.extras.target_rank = r.key\r\n                card.ability.extras.ranks_chosen[r.key] = true\r\n            end\r\n            card.ability.extras.played = 0\r\n        end\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.individual and not context.forcetrigger and not context.repetition and not context.repetition_only and not context.blueprint and not context.retrigger_joker and context.cardarea == G.play then\r\n            if not SMODS.has_no_rank(context.other_card) and context.other_card.base.value then\r\n                if context.other_card.base.value == card.ability.extras.target_rank then\r\n                    card.ability.extras.played = card.ability.extras.played + 1\r\n                    --print(card.ability.extras.played)\r\n                    if card.ability.extras.played >= card.ability.extras.target_play then\r\n                        card.ability.extras.phase = card.ability.extras.phase + 1\r\n                        local r = pseudorandom_element(AKYRS.get_p_card_ranks(card.ability.extras.ranks_chosen),pseudoseed(\"akyrs_space_elevator\"))\r\n                        if not r then\r\n                            EMPTY(card.ability.extras.ranks_chosen)\r\n                            r = pseudorandom_element(AKYRS.get_p_card_ranks(card.ability.extras.ranks_chosen),pseudoseed(\"akyrs_space_elevator\"))\r\n                        end\r\n                        if r then\r\n                            card.ability.extras.target_rank = r.key\r\n                            card.ability.extras.ranks_chosen[r.key] = true\r\n                        end\r\n                        if card.ability.extras.phase > 5 then\r\n                            SMODS.add_card{ key = \"c_soul\", set = \"Spectral\", edition = \"e_negative\"}\r\n                            card.ability.extras.phase = 1\r\n                        else\r\n                            SMODS.add_card{ set = \"Spectral\", edition = \"e_negative\" }\r\n                        end\r\n                        card.ability.extras.target_play = pseudorandom(pseudoseed(\"akyrs_space_elevator_num\"),5*card.ability.extras.phase+7,7*card.ability.extras.phase)\r\n                        card.ability.extras.played = 0\r\n                        return {\r\n                            message = localize(\"k_akyrs_sendoff\")\r\n                        }\r\n                    else\r\n                        return {\r\n                            message = localize(\"k_akyrs_received\")\r\n                        }\r\n                    end\r\n                end\r\n            end\r\n        end\r\n    end,\r\n    perishable_compat = false",
      "config": {},
      "ability": {},
      "vars": [
        null,
        null,
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "turret",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 7,
        "y": 3
      },
      "raw": "key = \"turret\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Portal\"] = true, },\r\n    pos = {\r\n        x = 7, y = 3\r\n    },\r\n    rarity = 2,\r\n    cost = 4, \r\n    loc_vars = function (self, info_queue, card)\r\n        if G.jokers then\r\n            local index = AKYRS.find_index(G.jokers.cards,card)\r\n            if index and #G.jokers.cards > 1 and G.jokers.cards[index+1] and index < #G.jokers.cards then\r\n                local othercard = G.jokers.cards[index+1]\r\n                return {\r\n                    vars = \r\n                    {\r\n                        math.max(othercard.cost,0)\r\n                    }\r\n                }\r\n            end\r\n        end\r\n        return {\r\n            vars = {\r\n                \"??\"\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.selling_card and context.card == card and not context.blueprint then\r\n            \r\n            local index = AKYRS.find_index(G.jokers.cards,card)\r\n            if index and #G.jokers.cards > 1 and G.jokers.cards[index+1] and index < #G.jokers.cards then\r\n                local othercard = G.jokers.cards[index+1]\r\n                return {\r\n                    func = function ()\r\n                        othercard:start_dissolve({G.C.RED},1.6)\r\n                    end,\r\n                    dollars = math.max(othercard.cost,0)\r\n                }\r\n            end\r\n        end\r\n    end,\r\n    eternal_compat = false,",
      "config": {},
      "ability": {},
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "aether_portal",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 8,
        "y": 3
      },
      "raw": "key = \"aether_portal\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Minecraft\"] = true, },\r\n    pos = {\r\n        x = 8, y = 3\r\n    },\r\n    rarity = 2,\r\n    cost = 7, \r\n    config = {\r\n        extras = {\r\n            odds = 4\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        local n,d = SMODS.get_probability_vars(card, 1, card.ability.extras.odds,\"akyrs_aether_chance\")\r\n        return {\r\n            vars = {\r\n                n,\r\n                d\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.setting_blind and not context.blueprint then\r\n            \r\n            local index = AKYRS.find_index(G.jokers.cards,card)\r\n            if index and #G.jokers.cards > 1 and G.jokers.cards[index-1] and index > 1 then\r\n                local other = G.jokers.cards[index-1]\r\n                local edition = pseudorandom_element(G.P_CENTER_POOLS.Edition,pseudoseed(\"akyrs_aether_chance\"))\r\n                repeat\r\n                local edition = pseudorandom_element(G.P_CENTER_POOLS.Edition,pseudoseed(\"akyrs_aether_chance\"))\r\n                until edition and edition.weight and edition.weight > 0 \r\n                if edition then\r\n                    other:set_edition(edition.key)\r\n                end\r\n                if SMODS.pseudorandom_probability(card,\"akyrs_aether_portal\",1,card.ability.extras.odds) then\r\n                    card:start_dissolve({G.C.BLUE},1.6)\r\n                end\r\n            end\r\n        end\r\n    end",
      "config": {
        "extras": {
          "odds": 4
        }
      },
      "ability": {
        "extras": {
          "odds": 4
        }
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "corkscrew",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 9,
        "y": 3
      },
      "raw": "key = \"corkscrew\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Hamsterball\"] = true, },\r\n    pos = {\r\n        x = 9, y = 3\r\n    },\r\n    rarity = 1,\r\n    cost = 3,\r\n    config = {\r\n        extras = { xmult = 2, emult = 1, immutable = {index = 1} }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        if AKYRS.bal(\"absurd\") then\r\n            local current = nil\r\n            if card.area then\r\n                current = AKYRS.find_index(card.area.cards,card)\r\n                card.ability.extras.emult = AKYRS.pos_to_val(card.ability.extras.immutable.index,#card.area.cards)\r\n            end\r\n            return {\r\n                key = self.key .. \"_absurd\",\r\n                vars = {\r\n                    (G.GAME and current) and card.ability.extras.emult or localize(\"ph_akyrs_unknown\")\r\n                }\r\n            }\r\n        end\r\n        return {\r\n            vars = {\r\n                card.ability.extras.xmult\r\n            }\r\n        }\r\n    end,\r\n    add_to_deck = function (self, card, from_debuff)\r\n        if card.area and card.area.cards then\r\n            local current = AKYRS.find_index(card.area.cards,card)\r\n            card.ability.extras.immutable.index = current\r\n            card.ability.extras.emult = AKYRS.pos_to_val(card.ability.extras.immutable.index,#card.area.cards)\r\n        end\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.before then\r\n            if card.area and card.area.cards then\r\n                return {\r\n                    func = function ()\r\n                        local where = pseudorandom(\"akyrs_corkscrew_move_target\",1,#card.area.cards)\r\n                        local current = AKYRS.find_index(card.area.cards,card)\r\n                        card.area.cards[where],card.area.cards[current or 1] = card.area.cards[current],card.area.cards[where]\r\n                        card.ability.extras.immutable.index = current\r\n                        card.area:align_cards()\r\n                        card.ability.extras.emult = AKYRS.pos_to_val(card.ability.extras.immutable.index,#card.area.cards)\r\n                    end\r\n                }\r\n            end\r\n        end\r\n        if context.joker_main then\r\n            if AKYRS.bal(\"adequate\") then\r\n                return {\r\n                    xmult = card.ability.extras.xmult\r\n                }\r\n            else\r\n                return {\r\n                    emult = card.ability.extras.emult\r\n                }\r\n            end\r\n\r\n        end\r\n    end,\r\n    blueprint_compat = true",
      "config": {
        "extras": {
          "xmult": 2,
          "emult": 1,
          "immutable": {
            "index": 1
          }
        }
      },
      "ability": {
        "extras": {
          "xmult": 2,
          "emult": 1,
          "immutable": {
            "index": 1
          }
        }
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "goodbye_sengen",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 0,
        "y": 4
      },
      "raw": "key = \"goodbye_sengen\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Vocaloids\"] = true, [\"J-POP\"] = true },\r\n    pos = {\r\n        x = 0, y = 4\r\n    },\r\n    rarity = 3,\r\n    cost = 8,\r\n    config = {\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        info_queue[#info_queue+1] = G.P_CENTERS[\"c_justice\"]\r\n        return {\r\n            key = self.key..AKYRS.bal_val(\"\",\"_absurd\")\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if AKYRS.bal(\"absurd\") then\r\n            if context.using_consumeable and context.consumeable.config.center_key == \"c_justice\" then\r\n                return {\r\n                    func = function ()\r\n                        level_up_hand(nil,\"High Card\",nil,G.GAME.hands[\"High Card\"].level)\r\n                    end\r\n                }\r\n            end\r\n        else\r\n            if context.joker_main then\r\n                if #context.full_hand == 1 and AKYRS.has_room(G.consumeables) then\r\n                    SMODS.add_card{ key = \"c_justice\", set = \"Tarot\" } \r\n                end\r\n            end\r\n            if context.destroy_card and context.cardarea == G.play and #context.full_hand == 1 then\r\n                return {\r\n                    remove = true\r\n                }\r\n            end\r\n        end\r\n\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "liar_dancer",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 1,
        "y": 4
      },
      "raw": "key = \"liar_dancer\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Vocaloids\"] = true, [\"J-POP\"] = true },\r\n    pos = {\r\n        x = 1, y = 4\r\n    },\r\n    rarity = 3,\r\n    cost = 7,\r\n    config = {\r\n        extras = {\r\n            level_down = 1,\r\n            level_up_mult = 1,\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_placeholder_art\"}\r\n        return {\r\n            key = self.key..AKYRS.bal_val(\"\",\"_absurd\"),\r\n            vars = {\r\n                card.ability.extras.level_down,\r\n                card.ability.extras.level_down * card.ability.extras.level_up_mult\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        \r\n        if AKYRS.bal(\"absurd\") then\r\n            if context.before and not context.blueprint then\r\n                return {\r\n                    func = function()\r\n                        local h = {}\r\n                        for mei, _ in pairs(G.GAME.hands) do\r\n                            if not next(context.poker_hands[mei]) then\r\n                                h[mei] = true\r\n                            end\r\n                        end\r\n                        AKYRS.blk_lvl_up(h)\r\n                    end\r\n                }\r\n            end\r\n        else\r\n            if context.before and not context.blueprint then\r\n                local cx = false\r\n                if Talisman then\r\n                    cx = G.GAME.hands[context.scoring_name].level:gt(to_big(1))\r\n                else\r\n                    cx = G.GAME.hands[context.scoring_name].level > 1\r\n                end\r\n                if not context.poker_hands[\"Straight\"] or (context.poker_hands[\"Straight\"] and not next(context.poker_hands[\"Straight\"])) and cx then\r\n                    level_up_hand(card,context.scoring_name,nil,-card.ability.extras.level_down)\r\n                    level_up_hand(card,\"Straight\",nil,card.ability.extras.level_down * card.ability.extras.level_up_mult)\r\n                    level_up_hand(card,\"Straight Flush\",nil,card.ability.extras.level_down * card.ability.extras.level_up_mult)\r\n                end\r\n            end\r\n        end\r\n    end",
      "config": {
        "extras": {
          "level_down": 1,
          "level_up_mult": 1
        }
      },
      "ability": {
        "extras": {
          "level_down": 1,
          "level_up_mult": 1
        }
      },
      "vars": [
        1,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "pissandshittium",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 4,
        "y": 4
      },
      "raw": "key = \"pissandshittium\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Meme\"] = true },\r\n    pos = {\r\n        x = 4, y = 4\r\n    },\r\n    rarity = 1,\r\n    cost = 2,\r\n    config = {\r\n        extras = {\r\n            mult = 4.000,\r\n            eeemult = 1.1\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            key = self.key .. AKYRS.bal_val(\"\",\"_absurd\"),\r\n            vars = {\r\n                AKYRS.bal_val(card.ability.extras.mult,card.ability.extras.eeemult)\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.joker_main then\r\n            return {\r\n                message = localize(\"k_akyrs_pissandshittium\"),\r\n                colour = AKYRS.C.PISSANDSHITTIUM,\r\n                remove_default_message = true,\r\n                mult = AKYRS.bal_val(card.ability.extras.mult,nil),\r\n                emult = AKYRS.bal_val(nil,card.ability.extras.eeemult),\r\n            }\r\n        end\r\n    end,\r\n    blueprint_compat = true",
      "config": {
        "extras": {
          "mult": 4,
          "eeemult": 1.1
        }
      },
      "ability": {
        "extras": {
          "mult": 4,
          "eeemult": 1.1
        }
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "pandora_paradoxxx",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 5,
        "y": 4
      },
      "raw": "key = \"pandora_paradoxxx\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Rhythm Games\"] = true, [\"Maimai\"] = true },\r\n    pos = {\r\n        x = 5, y = 4\r\n    },\r\n    rarity = 3,\r\n    cost = 9,\r\n    config = {\r\n        extras = {\r\n            count = 15,\r\n            current = 0,\r\n            odds_absurd = 3\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_placeholder_art\"}\r\n        info_queue[#info_queue+1] = {set = \"Tag\", key = \"tag_standard\"}\r\n        -- numerator & denominator :3\r\n        if AKYRS.bal(\"absurd\") then\r\n            local n, d = SMODS.get_probability_vars(card,1,card.ability.extras.odds_absurd,\"akyrs_pandora_paradoxx\")\r\n            return {\r\n                key = self.key..\"_absurd\",\r\n                vars = {\r\n                    n,d\r\n                }\r\n            } \r\n        end\r\n        return {\r\n            vars = {\r\n                card.ability.extras.count,\r\n                card.ability.extras.current\r\n            }\r\n        }\r\n\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.playing_card_added and AKYRS.bal(\"absurd\") then\r\n            return {\r\n                func = function ()\r\n                    for i = 1, #context.cards do\r\n                        if SMODS.pseudorandom_probability(card,\"akyrs_pandora_paradoxxx\",1,card.ability.extras.odds_absurd) then\r\n                            local tag = Tag(\"tag_standard\")\r\n                            add_tag(tag)\r\n                            SMODS.calculate_effect({\r\n                                message = localize(\"k_akyrs_pandora_give_tag\"),\r\n                            }, card)\r\n                        end\r\n                    end\r\n                end\r\n            }\r\n        end\r\n        if context.before and AKYRS.bal(\"adequate\") then\r\n            return {\r\n                func = function ()\r\n                    for _,_c in ipairs(context.scoring_hand) do\r\n                        card.ability.extras.current = card.ability.extras.current + 1\r\n                        SMODS.calculate_effect({\r\n                            juice_card = _c,\r\n                            message = card.ability.extras.current\r\n                        }, card)\r\n                        if card.ability.extras.current >= card.ability.extras.count then \r\n                            SMODS.calculate_effect({\r\n                                message = localize(\"k_akyrs_pandora_give_tag\"),\r\n                                func = function()\r\n                                local tag = Tag(\"tag_standard\")\r\n                                add_tag(tag)\r\n                                    card.ability.extras.current = 0\r\n                                end\r\n                            }, card)\r\n                        end\r\n                    end\r\n                end\r\n            }\r\n        end\r\n    end,\r\n    blueprint_compat = true",
      "config": {
        "extras": {
          "count": 15,
          "current": 0,
          "odds_absurd": 3
        }
      },
      "ability": {
        "extras": {
          "count": 15,
          "current": 0,
          "odds_absurd": 3
        }
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "story_of_undertale",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 6,
        "y": 4
      },
      "raw": "key = \"story_of_undertale\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Meme\"] = true,  [\"Undertale\"] = true, },\r\n    pos = {\r\n        x = 6, y = 4\r\n    },\r\n    rarity = 2,\r\n    cost = 6,\r\n    config = {\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        info_queue[#info_queue+1] = G.P_CENTERS['j_mr_bones']\r\n        info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_placeholder_art\"}\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.setting_blind then\r\n            SMODS.calculate_effect({\r\n                card = card,\r\n                message = localize(\"k_akyrs_woah_undertale\"),\r\n            })\r\n            return {\r\n                message = localize(\"k_akyrs_story_of_undertale\"),\r\n                func = function ()\r\n                    local destructable_jokers = {}\r\n                    for i = 1, #G.jokers.cards do\r\n                        if G.jokers.cards[i] ~= card and not G.jokers.cards[i].ability.eternal and not G.jokers.cards[i].ability.cry_absolute and not G.jokers.cards[i].getting_sliced then destructable_jokers[#destructable_jokers+1] = G.jokers.cards[i] end\r\n                    end\r\n                    local joker_to_destroy = #destructable_jokers > 0 and pseudorandom_element(destructable_jokers, pseudoseed('madness')) or nil\r\n    \r\n                    if joker_to_destroy and not (context.blueprint_card or card).getting_sliced then \r\n                        joker_to_destroy.getting_sliced = true\r\n                        G.E_MANAGER:add_event(Event({func = function()\r\n                            (context.blueprint_card or card):juice_up(0.8, 0.8)\r\n                            local digits = 0\r\n                            if Talisman then\r\n                                digits = math.log(to_number(joker_to_destroy.sell_cost),10)\r\n                            else\r\n                                digits = math.log(joker_to_destroy.sell_cost,10)\r\n                            end\r\n                            for i = 1,digits + 1 do\r\n                                SMODS.add_card{ key = \"j_mr_bones\", set = \"Joker\", edition = \"e_negative\"}\r\n                            end\r\n                            joker_to_destroy:start_dissolve({G.C.RED}, nil, 1.6)\r\n                            card:start_dissolve({G.C.RED}, nil, 1.6)\r\n                        return true end }))\r\n                    end\r\n                end\r\n            }\r\n        end\r\n    end,\r\n    blueprint_compat = false",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "no_hints_here",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 7,
        "y": 4
      },
      "raw": "key = \"no_hints_here\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Rhythm Games\"] = true, [\"ADOFAI\"] = true },\r\n    pos = {\r\n        x = 7, y = 4\r\n    },\r\n    rarity = 2,\r\n    cost = 6,\r\n    config = {\r\n        extras = {\r\n            xmult = 3,\r\n            emult = 2.5\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_placeholder_art\"}\r\n        if AKYRS.bal(\"absurd\") then\r\n            return {\r\n                key = self.key .. \"_absurd\",\r\n                vars = {\r\n                    card.ability.extras.emult,\r\n                }\r\n            }\r\n        end\r\n        return {\r\n            vars = {\r\n                card.ability.extras.xmult,\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.joker_main then\r\n            if AKYRS.bal(\"absurd\") then\r\n                return {\r\n                    emult = card.ability.extras.emult\r\n                }\r\n            else\r\n                return {\r\n                    xmult = card.ability.extras.xmult\r\n                }\r\n            end\r\n        end\r\n    end,\r\n    blueprint_compat = true",
      "config": {
        "extras": {
          "xmult": 3,
          "emult": 2.5
        }
      },
      "ability": {
        "extras": {
          "xmult": 3,
          "emult": 2.5
        }
      },
      "vars": [
        2.5
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "brushing_clothes_pattern",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 8,
        "y": 4
      },
      "raw": "key = \"brushing_clothes_pattern\",\r\n    enhancement_gate = \"m_wild\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Rhythm Games\"] = true, [\"Chunithm\"] = true },\r\n    pos = {\r\n        x = 8, y = 4\r\n    },\r\n    rarity = 2,\r\n    cost = 7,\r\n    config = {\r\n        extras = {\r\n            xchips = 1,\r\n            xchips_gain = 0.2,\r\n            xchips_absurd = 1,\r\n            xchips_gain_absurd = 2,\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_placeholder_art\"}\r\n        if AKYRS.bal(\"absurd\") then\r\n            return {\r\n                key = self.key .. \"_absurd\",\r\n                vars = {\r\n                card.ability.extras.xchips_gain_absurd,\r\n                card.ability.extras.xchips_absurd,\r\n                }\r\n            }\r\n        end\r\n        return {\r\n            vars = {\r\n                card.ability.extras.xchips_gain,\r\n                card.ability.extras.xchips,\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.individual and context.cardarea == G.play and next(context.poker_hands[\"Flush\"]) and not context.blueprint then\r\n            if context.other_card.ability.name == \"Wild Card\" then\r\n                return {\r\n                    message = localize(\"k_upgrade_ex\"),\r\n                    message_card = card,\r\n                    func = function ()\r\n                        card.ability.extras.xchips = card.ability.extras.xchips + card.ability.extras.xchips_gain\r\n                        card.ability.extras.xchips_absurd = card.ability.extras.xchips_absurd * card.ability.extras.xchips_gain_absurd\r\n                    end\r\n                }\r\n            end\r\n        end\r\n        if context.joker_main then                \r\n            return {\r\n                xchips = AKYRS.bal_val(card.ability.extras.xchips,card.ability.extras.xchips)\r\n            }\r\n        end\r\n    end,\r\n    blueprint_compat = true",
      "config": {
        "extras": {
          "xchips": 1,
          "xchips_gain": 0.2,
          "xchips_absurd": 1,
          "xchips_gain_absurd": 2
        }
      },
      "ability": {
        "extras": {
          "xchips": 1,
          "xchips_gain": 0.2,
          "xchips_absurd": 1,
          "xchips_gain_absurd": 2
        }
      },
      "vars": [
        2,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "you_tried",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 9,
        "y": 4
      },
      "raw": "key = \"you_tried\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Meme\"] = true, },\r\n    pos = {\r\n        x = 9, y = 4\r\n    },\r\n    rarity = 3,\r\n    cost = 12,\r\n    config = {\r\n        extras = {\r\n            ante_set = 3,\r\n            money_set = 4,\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_placeholder_art\"}\r\n        return {\r\n            key = self.key .. AKYRS.bal_val(\"\",\"_absurd\"),\r\n            vars = {\r\n                card.ability.extras.ante_set,\r\n                card.ability.extras.money_set,\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.end_of_round and context.game_over and not context.blueprint then\r\n            card:start_dissolve({G.C.YELLOW},1.6)\r\n            return {\r\n                saved = localize(\"k_akyrs_you_tried\"),\r\n                func = function ()\r\n                    if AKYRS.bal(\"adequate\") then\r\n                        for i,k in ipairs(G.jokers.cards) do\r\n                            if not SMODS.is_eternal(k) then\r\n                                k:start_dissolve({G.C.YELLOW},1.6)\r\n                            end\r\n                        end\r\n                    end\r\n                    local old_ante = G.GAME.round_resets.ante\r\n                    if AKYRS.bal(\"adequate\") then\r\n                        ease_ante((-math.floor(G.GAME.round_resets.ante/2)))\r\n                        ease_dollars(-G.GAME.dollars + card.ability.extras.money_set)\r\n                    else\r\n                        ease_ante(-G.GAME.round_resets.ante+card.ability.extras.ante_set)\r\n                    end\r\n                end\r\n            }\r\n        end\r\n    end,",
      "config": {
        "extras": {
          "ante_set": 3,
          "money_set": 4
        }
      },
      "ability": {
        "extras": {
          "ante_set": 3,
          "money_set": 4
        }
      },
      "vars": [
        3,
        4
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "don_chan",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 0,
        "y": 5
      },
      "raw": "key = \"don_chan\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Rhythm Games\"] = true, [\"Taiko no Tatsujin\"] = true, },\r\n    pos = {\r\n        x = 0, y = 5\r\n    },\r\n    rarity = 1,\r\n    cost = 5,\r\n    config = {\r\n        extras = {\r\n            percent = .1,\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_placeholder_art\"}\r\n        return {\r\n            key = self.key .. AKYRS.bal_val(\"\",\"_absurd\"),\r\n            vars = {\r\n                card.ability.extras.percent * 100,\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if AKYRS.bal_val(context.joker_main,context.individual and context.cardarea == G.play) or context.forcetrigger then\r\n            return {\r\n                mult = hand_chips * card.ability.extras.percent\r\n            }\r\n        end\r\n    end,\r\n\tdemicoloncompat = true,",
      "config": {
        "extras": {
          "percent": 0.1
        }
      },
      "ability": {
        "extras": {
          "percent": 0.1
        }
      },
      "vars": [
        10
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "katsu_chan",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 1,
        "y": 5
      },
      "raw": "key = \"katsu_chan\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Rhythm Games\"] = true, [\"Taiko no Tatsujin\"] = true, },\r\n    pos = {\r\n        x = 1, y = 5\r\n    },\r\n    rarity = 1,\r\n    cost = 5,\r\n    config = {\r\n        extras = {\r\n            percent = .1,\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_placeholder_art\"}\r\n        return {\r\n            key = self.key .. AKYRS.bal_val(\"\",\"_absurd\"),\r\n            vars = {\r\n                card.ability.extras.percent * 100,\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if AKYRS.bal_val(context.joker_main,context.individual and context.cardarea == G.play) or context.forcetrigger then\r\n            return {\r\n                chips = mult * card.ability.extras.percent\r\n            }\r\n        end\r\n    end,\r\n\tdemicoloncompat = true,",
      "config": {
        "extras": {
          "percent": 0.1
        }
      },
      "ability": {
        "extras": {
          "percent": 0.1
        }
      },
      "vars": [
        10
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "lagtrain",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 2,
        "y": 5
      },
      "raw": "key = \"lagtrain\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Vocaloids\"] = true, [\"J-POP\"] = true },\r\n    pos = {\r\n        x = 2, y = 5\r\n    },\r\n    rarity = 2,\r\n    cost = 8,\r\n    config = {\r\n        extras = {\r\n            chips = 0,\r\n            xchips = 1,\r\n            chips_g = 0.4,\r\n            xchips_g = 0.1,\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_placeholder_art\"}\r\n        local _,_2,c = love.window.getMode()\r\n        local x = math.max(c.refreshrate - love.timer.getFPS( ),0) \r\n        if AKYRS.bal(\"absurd\") then\r\n            return {\r\n                key = self.key .. \"_absurd\",\r\n                vars = {\r\n                    card.ability.extras.xchips_g * 240 / c.refreshrate,\r\n                    c.refreshrate,\r\n                    card.ability.extras.xchips,\r\n                }\r\n            }\r\n        end\r\n        return {\r\n            vars = {\r\n                card.ability.extras.chips_g * 240 / c.refreshrate,\r\n                c.refreshrate,\r\n                card.ability.extras.chips,\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.before and context.poker_hands[\"Straight\"] and next(context.poker_hands[\"Straight\"]) or context.forcetrigger then\r\n            return {\r\n                func = function ()\r\n                    local _,_2,c = love.window.getMode()\r\n                    local x = math.max((c.refreshrate or 0) - love.timer.getFPS( ),0)\r\n                    SMODS.calculate_effect({\r\n                        message = love.timer.getFPS( )..localize(\"k_akyrs_fps\"),\r\n                        message_card = card,\r\n                    }, card)\r\n                    card.ability.extras.xchips = card.ability.extras.xchips + card.ability.extras.xchips_g * x * 240 / c.refreshrate\r\n                    card.ability.extras.chips = card.ability.extras.chips + card.ability.extras.chips_g * x * 240 / c.refreshrate\r\n                end\r\n            }\r\n        end\r\n        if context.joker_main or context.forcetrigger then\r\n            if AKYRS.bal(\"absurd\") then\r\n                return {\r\n                    xchips = card.ability.extras.xchips\r\n                }\r\n            end\r\n            return {\r\n                chips = card.ability.extras.chips\r\n            }\r\n        end\r\n    end,\r\n\tdemicoloncompat = true,",
      "config": {
        "extras": {
          "chips": 0,
          "xchips": 1,
          "chips_g": 0.4,
          "xchips_g": 0.1
        }
      },
      "ability": {
        "extras": {
          "chips": 0,
          "xchips": 1,
          "chips_g": 0.4,
          "xchips_g": 0.1
        }
      },
      "vars": [
        null,
        null,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "bocchi",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 3,
        "y": 5
      },
      "raw": "key = \"bocchi\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Anime\"] = true, [\"Bocchi the Rock\"] = true, [\"Kessoku Band\"] = true, },\r\n    pos = {\r\n        x = 3, y = 5\r\n    },\r\n    rarity = 3,\r\n    cost = 9,\r\n    config = {\r\n        extras = {\r\n            xmult = 1,\r\n            xmult_absurd = 1.1,\r\n            xmult_g = 1,\r\n            xmult_g_absurd = 1.2,\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_placeholder_art\"}\r\n        if AKYRS.bal(\"absurd\") then\r\n            return {\r\n                key = self.key .. \"_absurd\",\r\n                vars = {\r\n                    card.ability.extras.xmult_g_absurd,\r\n                    card.ability.extras.xmult_absurd,\r\n                }\r\n            }\r\n        end\r\n        return {\r\n            vars = {\r\n                card.ability.extras.xmult_g,\r\n                card.ability.extras.xmult,\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.before or context.forcetrigger then\r\n            return {\r\n                func = function ()\r\n                    local x = AKYRS.filter_table(G.jokers.cards,function(t) return not AKYRS.is_in_pool(t,\"Kessoku Band\") end, true, true)\r\n                    local sts, stschk = AKYRS.get_suits(G.play.cards)\r\n                    if (#x == 0 and AKYRS.bal_val((#G.play.cards) == 1 and G.play.cards[1]:is_suit(\"Spades\"),stschk[\"Spades\"])) or context.forcetrigger then\r\n                        SMODS.calculate_effect({\r\n                            message = localize(\"k_upgrade_ex\"),\r\n                        }, card)\r\n                        if Talisman then\r\n                        card.ability.extras.xmult_absurd = to_big(card.ability.extras.xmult_absurd):pow(card.ability.extras.xmult_g_absurd)\r\n                        else\r\n                            card.ability.extras.xmult_absurd = card.ability.extras.xmult_absurd ^ card.ability.extras.xmult_g_absurd\r\n                        end\r\n                        card.ability.extras.xmult = card.ability.extras.xmult + card.ability.extras.xmult_g\r\n                    end\r\n                end\r\n            }\r\n        end\r\n        if context.joker_main or context.forcetrigger then\r\n            if AKYRS.bal(\"absurd\") then\r\n                return {\r\n                    xmult = card.ability.extras.xmult_absurd\r\n                }\r\n            end\r\n            return {\r\n                xmult = card.ability.extras.xmult\r\n            }\r\n        end\r\n    end,\r\n\tdemicoloncompat = true,",
      "config": {
        "extras": {
          "xmult": 1,
          "xmult_absurd": 1.1,
          "xmult_g": 1,
          "xmult_g_absurd": 1.2
        }
      },
      "ability": {
        "extras": {
          "xmult": 1,
          "xmult_absurd": 1.1,
          "xmult_g": 1,
          "xmult_g_absurd": 1.2
        }
      },
      "vars": [
        1.2,
        1.1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "kita",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 4,
        "y": 5
      },
      "raw": "key = \"kita\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Anime\"] = true, [\"Bocchi the Rock\"] = true, [\"Kessoku Band\"] = true, },\r\n    pos = {\r\n        x = 4, y = 5\r\n    },\r\n    rarity = 3,\r\n    cost = 6,\r\n    config = {\r\n        extras = {\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_placeholder_art\"}\r\n        info_queue[#info_queue+1] = {set = \"Tarot\", key = \"c_lovers\", vars = {1, localize(\"k_akyrs_wild_card\")}}\r\n        if AKYRS.bal(\"absurd\") then\r\n            return {\r\n                key = self.key .. \"_absurd\",\r\n            }\r\n        end\r\n        return {\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if (context.before or context.forcetrigger) and AKYRS.bal(\"adequate\") then\r\n            return {\r\n                message = localize(\"k_akyrs_kitan\"),\r\n                colour = G.C.RED,\r\n                func = function ()\r\n                    local sts, stschk = AKYRS.get_suits(G.play.cards)\r\n                    if (next(context.poker_hands[\"Flush\"]) and stschk[\"Hearts\"]) or context.forcetrigger then\r\n                        if AKYRS.has_room(G.consumeables) then\r\n                            SMODS.add_card({key = \"c_lovers\", set = \"Tarot\"})\r\n                        end\r\n                    end\r\n                end\r\n            }\r\n        end\r\n        if (context.individual and context.cardarea == G.play or context.forcetrigger) and AKYRS.bal(\"absurd\") then\r\n            return {\r\n                message = localize(\"k_akyrs_kitan\"),\r\n                colour = G.C.RED,\r\n                func = function ()\r\n                    if context.other_card:is_suit(\"Hearts\") then\r\n                        SMODS.add_card({key = \"c_lovers\", set = \"Tarot\", edition = \"e_negative\"})\r\n                    end\r\n                end\r\n            }\r\n        end\r\n    end,\r\n\tdemicoloncompat = true,",
      "config": {
        "extras": {}
      },
      "ability": {
        "extras": {}
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "ryou",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 5,
        "y": 5
      },
      "raw": "key = \"ryou\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Anime\"] = true, [\"Bocchi the Rock\"] = true, [\"Kessoku Band\"] = true, },\r\n    pos = {\r\n        x = 5, y = 5\r\n    },\r\n    rarity = 3,\r\n    cost = 1,\r\n    config = {\r\n        extras = {\r\n            debt = 12,\r\n            add_debt = 3,\r\n            debt_absurd = 6,\r\n            factor_debt_absurd = 2,\r\n        }\r\n    },\r\n    add_to_deck = function (self, card, from_debuff)\r\n        card.ability.extras.obtain_bal = AKYRS.bal_val()\r\n        G.GAME.bankrupt_at = G.GAME.bankrupt_at - AKYRS.bal_val_overridable(card.ability.extras.debt,card.ability.extras.debt_absurd,card.ability.extras.obtain_bal)\r\n    end,\r\n    remove_from_deck =function (self, card, from_debuff)\r\n        G.GAME.bankrupt_at = G.GAME.bankrupt_at + AKYRS.bal_val_overridable(card.ability.extras.debt,card.ability.extras.debt_absurd,card.ability.extras.obtain_bal)\r\n    end,\r\n    loc_vars = function (self, info_queue, card)\r\n        info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_placeholder_art\"}\r\n        if (card.ability.extras.obtain_bal or AKYRS.bal()) == \"absurd\" then\r\n            return {\r\n                key = self.key .. \"_absurd\",\r\n                vars = {\r\n                    card.ability.extras.debt_absurd,\r\n                    card.ability.extras.factor_debt_absurd,\r\n                }\r\n            }\r\n        end\r\n        return {\r\n            vars = {\r\n                card.ability.extras.debt,\r\n                card.ability.extras.add_debt,\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.before and context.poker_hands and #context.poker_hands[\"Pair\"] > 0 then\r\n            return {\r\n                message = localize(\"k_akyrs_ryo_borrowed_money\"),\r\n                func = function ()\r\n                    local pairs_of_clubs = 0\r\n                    for _,e_pair in ipairs(context.poker_hands[\"Pair\"]) do\r\n                        local is_pair_of_clubs = true\r\n                        for _,e_card in ipairs(e_pair) do\r\n                            if not e_card:is_suit(\"Clubs\") then\r\n                                is_pair_of_clubs = false\r\n                            end\r\n                        end\r\n                        if is_pair_of_clubs then\r\n                            pairs_of_clubs = pairs_of_clubs + 1\r\n                        end\r\n                        \r\n                    end\r\n                    \r\n                    if AKYRS.bal_overridable(\"absurd\",card.ability.extras.obtain_bal) then\r\n                        local old_bkrpt_at = card.ability.extras.debt_absurd -- 6,12,24\r\n                        -- new debt should be 12,24,48, etc.\r\n                        card.ability.extras.debt_absurd = card.ability.extras.debt_absurd * pairs_of_clubs * card.ability.extras.factor_debt_absurd\r\n                        -- the difference should also account for when, for some reason, the joker value changes like Cryptid's misprintize function\r\n                        -- all those numbers should be positive so i just absurd - old bkrpt ig\r\n                        G.GAME.bankrupt_at = G.GAME.bankrupt_at - (card.ability.extras.debt_absurd - old_bkrpt_at)\r\n                        \r\n                    else\r\n                        if pairs_of_clubs > 0 then\r\n                            G.GAME.bankrupt_at = G.GAME.bankrupt_at - card.ability.extras.add_debt\r\n                            card.ability.extras.debt = card.ability.extras.debt + card.ability.extras.add_debt\r\n                        end\r\n                    end\r\n                end\r\n            }\r\n        end\r\n    end,\r\n\tdemicoloncompat = true,",
      "config": {
        "extras": {
          "debt": 12,
          "add_debt": 3,
          "debt_absurd": 6,
          "factor_debt_absurd": 2
        }
      },
      "ability": {
        "extras": {
          "debt": 12,
          "add_debt": 3,
          "debt_absurd": 6,
          "factor_debt_absurd": 2
        }
      },
      "vars": [
        6,
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "nijika",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 6,
        "y": 5
      },
      "raw": "key = \"nijika\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Anime\"] = true, [\"Bocchi the Rock\"] = true, [\"Kessoku Band\"] = true, },\r\n    pos = {\r\n        x = 6, y = 5\r\n    },\r\n    rarity = 3,\r\n    cost = 9,\r\n    config = {\r\n        extras = {\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_placeholder_art\"}\r\n        if AKYRS.bal(\"absurd\") then\r\n            return {\r\n                key = self.key .. \"_absurd\",\r\n            }\r\n        end\r\n        return {\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if AKYRS.bal(\"absurd\") then\r\n            if context.individual and context.cardarea == G.play and context.other_card and context.other_card:is_suit(\"Diamonds\") and next(context.poker_hands.Straight) then\r\n                return {\r\n                    message = localize(\"k_akyrs_nijika_planet\"),\r\n                    func = function ()\r\n                        local pl = AKYRS.get_most_played()\r\n                        SMODS.add_card({soulable = true, key = pl, edition = \"e_negative\"})\r\n                    end\r\n                }\r\n            end\r\n        else\r\n            if context.joker_main and next(context.poker_hands.Straight) then\r\n                local diac = 0\r\n                for _,cr in ipairs(G.play.cards) do\r\n                    if cr:is_suit(\"Diamonds\") then\r\n                        diac = diac + 1\r\n                    end\r\n                end\r\n                if diac >= (#G.play.cards / 2) then\r\n                    return {\r\n                        message = localize(\"k_akyrs_nijika_planet\"),\r\n                        func = function ()\r\n                            local pl = AKYRS.get_most_played()\r\n                            SMODS.add_card({soulable = true, key = pl, edition = \"e_negative\"})\r\n                        end\r\n                    }\r\n                end\r\n            end\r\n        end\r\n    end,\r\n\tdzicoloncompat = true,",
      "config": {
        "extras": {}
      },
      "ability": {
        "extras": {}
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "blue_portal",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 2,
        "y": 4
      },
      "raw": "key = \"blue_portal\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Portal\"] = true, [\"Video Games\"] = true, },\r\n    pos = {\r\n        x = 2, y = 4\r\n    },\r\n    in_pool = function (self, args)\r\n        return false\r\n    end,\r\n    rarity = 3,\r\n    cost = 9,\r\n    config = {\r\n        extras = {\r\n            link = \"CCCCC\",\r\n        }\r\n    },",
      "config": {
        "extras": {
          "link": "CCCCC"
        }
      },
      "ability": {
        "extras": {
          "link": "CCCCC"
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "orange_portal",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 3,
        "y": 4
      },
      "raw": "key = \"orange_portal\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Portal\"] = true, [\"Video Games\"] = true, },\r\n    pos = {\r\n        x = 3, y = 4\r\n    },\r\n    in_pool = function (self, args)\r\n        return false\r\n    end,\r\n    rarity = \"akyrs_unique\",\r\n    cost = 9,\r\n    config = {\r\n        extras = {\r\n            link = \"CCCCC\",\r\n        }\r\n    },",
      "config": {
        "extras": {
          "link": "CCCCC"
        }
      },
      "ability": {
        "extras": {
          "link": "CCCCC"
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "planet_bishop_ring",
      "atlas": "aikoPlanets",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "set = \"Planet\",\r\n    key = \"planet_bishop_ring\",\r\n    atlas = \"aikoPlanets\",\r\n    pos = {x=0, y=0},\r\n    config = {\r\n        extra = 1\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                G.GAME.akyrs_pure_hand_modifier.level,\r\n                G.GAME.akyrs_pure_hand_modifier.multiplier,\r\n                card.ability.extra * 0.5 * G.GAME.akyrs_pure_hand_modifier.level\r\n            }\r\n        }\r\n    end,\r\n    can_use = function (self, card)\r\n        return true\r\n    end,\r\n    in_pool = function (self, args)\r\n        return G.GAME.akyrs_pure_unlocked\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        \r\n        G.GAME.akyrs_pure_unlocked = true\r\n        update_hand_text({sound = 'button', volume = 0.7, pitch = 0.8, delay = 0.3}, {handname=localize('k_akyrs_pure_hands'),chips = '...', mult = '...', level=''})\r\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.2, func = function()\r\n            play_sound('tarot1')\r\n            card:juice_up(0.8, 0.5)\r\n            G.TAROT_INTERRUPT_PULSE = true\r\n            return true end }))\r\n        update_hand_text({delay = 0}, {mult = '+', StatusText = true})\r\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.9, func = function()\r\n            play_sound('tarot1')\r\n            card:juice_up(0.8, 0.5)\r\n            return true end }))\r\n        update_hand_text({delay = 0}, {chips = '+', StatusText = true})\r\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.9, func = function()\r\n            play_sound('tarot1')\r\n            card:juice_up(0.8, 0.5)\r\n            G.TAROT_INTERRUPT_PULSE = nil\r\n            return true end }))\r\n        update_hand_text({sound = 'button', volume = 0.7, pitch = 0.9, delay = 0}, {level='+1'})\r\n        delay(1.3)\r\n        G.GAME.akyrs_pure_hand_modifier.level = G.GAME.akyrs_pure_hand_modifier.level + card.ability.extra\r\n        G.GAME.akyrs_pure_hand_modifier.multiplier = G.GAME.akyrs_pure_hand_modifier.multiplier + card.ability.extra * 0.5 * G.GAME.akyrs_pure_hand_modifier.level\r\n        update_hand_text({sound = 'button', volume = 0.7, pitch = 1.1, delay = 0}, {mult = 0, chips = 0, handname = '', level = ''})\r\n    end",
      "config": {
        "extra": 1
      },
      "ability": {
        "extra": 1
      },
      "vars": [
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "PokerHand",
      "key": "expression",
      "atlas": null,
      "pos": null,
      "raw": "key = \"expression\",\r\n    chips = 0,\r\n    mult = 0,\r\n    l_chips = 0,\r\n    l_mult = 0,\r\n    visible = false,\r\n    example = {\r\n        { \"\", true, nil, akyrs_letter = \"3\", is_null = true},\r\n        { \"\", true, nil, akyrs_letter = \"7\", is_null = true},\r\n        { \"\", true, nil, akyrs_letter = \"*\", is_null = true},\r\n        { \"\", true, nil, akyrs_letter = \"4\", is_null = true},\r\n        { \"\", true, nil, akyrs_letter = \"+\", is_null = true},\r\n        { \"\", true, nil, akyrs_letter = \"2\", is_null = true},\r\n        { \"\", true, nil, akyrs_letter = \"7\", is_null = true},\r\n    },\r\n    evaluate = function(parts, hand_in)\r\n        if ((not G.GAME.akyrs_character_stickers_enabled) or (not G.GAME.akyrs_mathematics_enabled)) then \r\n        return {} end\r\n        local word_hand = {}\r\n        local hand = AKYRS.shallow_indexed_table_copy(hand_in)\r\n        table.sort(hand, AKYRS.hand_sort_function)\r\n        for _, v in pairs(hand) do\r\n            if not v.ability or not v.ability.aikoyori_letters_stickers then return {} end\r\n            local alpha = v.ability.aikoyori_letters_stickers:lower()\r\n            if alpha == \"#\" and v.ability.aikoyori_pretend_letter then\r\n                -- if wild is set fr tbh\r\n                alpha = v.ability.aikoyori_pretend_letter:lower()\r\n            elseif alpha == \"#\" and AKYRS.config.wildcard_behaviour == 3 then -- if it's unset in mode 3 then just make it a random letter i guess\r\n                alpha = 'â'\r\n            end\r\n            table.insert(word_hand, alpha)\r\n                \r\n        end\r\n        \r\n        local expression = table.concat(word_hand)\r\n        \r\n        \r\n        local status, value = pcall(AKYRS.MathParser.solve,AKYRS.MathParser,expression)\r\n        if not status or #hand < 1 then return {} end\r\n        G.GAME.aikoyori_evaluation_value = value\r\n        G.GAME.aikoyori_evaluation_replace = false\r\n        if (G.STATE == G.STATES.HAND_PLAYED) then\r\n\r\n            G.GAME.aikoyori_evaluation_value = value\r\n           \r\n        end\r\n        return {hand}\r\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "PokerHand",
      "key": "modification",
      "atlas": null,
      "pos": null,
      "raw": "key = \"modification\",\r\n    chips = 0,\r\n    mult = 0,\r\n    l_chips = 0,\r\n    l_mult = 0,\r\n    visible = false,\r\n    example = {\r\n        { \"\", true, nil, akyrs_letter = \"/\", is_null = true},\r\n        { \"\", true, nil, akyrs_letter = \"2\", is_null = true},\r\n        { \"\", true, nil, akyrs_letter = \"5\", is_null = true},\r\n    },\r\n    evaluate = function(parts, hand_in)\r\n        if ((not G.GAME.akyrs_character_stickers_enabled) or (not G.GAME.akyrs_mathematics_enabled)) then \r\n        return {} end\r\n        local word_hand = {}\r\n        local hand = AKYRS.shallow_indexed_table_copy(hand_in)\r\n        table.sort(hand, AKYRS.hand_sort_function)\r\n        for _, v in pairs(hand) do\r\n            if not v.ability or not v.ability.aikoyori_letters_stickers then return {} end\r\n            local alpha = v.ability.aikoyori_letters_stickers:lower()\r\n            if alpha == \"#\" and v.ability.aikoyori_pretend_letter then\r\n                -- if wild is set fr tbh\r\n                alpha = v.ability.aikoyori_pretend_letter:lower()\r\n            elseif alpha == \"#\" and AKYRS.config.wildcard_behaviour == 3 then -- if it's unset in mode 3 then just make it a random letter i guess\r\n                alpha = 'â'\r\n            end\r\n            table.insert(word_hand, alpha)\r\n                \r\n        end\r\n        \r\n        local expression = table.concat(word_hand)\r\n        local to_number = to_number or function(l) return l end\r\n        local expression_with_chips = tostring(to_number(G.GAME.chips))..table.concat(word_hand)\r\n        \r\n        \r\n        local status_check, value_fake = pcall(AKYRS.MathParser.solve,AKYRS.MathParser,expression)\r\n        local status, value = pcall(AKYRS.MathParser.solve,AKYRS.MathParser,expression_with_chips)\r\n        if status_check or #hand < 1 then return {} end\r\n        if not status then return {} end\r\n        G.GAME.aikoyori_evaluation_value = value\r\n        G.GAME.aikoyori_evaluation_replace = true\r\n\r\n        if (G.STATE == G.STATES.HAND_PLAYED) then\r\n\r\n            G.GAME.aikoyori_evaluation_value = value\r\n           \r\n        end\r\n        return {hand}\r\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "PokerHand",
      "key": "assignment",
      "atlas": null,
      "pos": null,
      "raw": "key = \"assignment\",\r\n    chips = 0,\r\n    mult = 0,\r\n    l_chips = 0,\r\n    l_mult = 0,\r\n    visible = false,\r\n    example = {\r\n        { \"\", true, nil, akyrs_letter = \"x\", is_null = true},\r\n        { \"\", true, nil, akyrs_letter = \"=\", is_null = true},\r\n        { \"\", true, nil, akyrs_letter = \"7\", is_null = true},\r\n    },\r\n    evaluate = function(parts, hand_in)\r\n        if ((not G.GAME.akyrs_character_stickers_enabled) or (not G.GAME.akyrs_mathematics_enabled)) then \r\n        return {} end\r\n        local word_hand = {}\r\n        local hand = AKYRS.shallow_indexed_table_copy(hand_in)\r\n        table.sort(hand, AKYRS.hand_sort_function)\r\n        for _, v in pairs(hand) do\r\n            if not v.ability or not v.ability.aikoyori_letters_stickers then return {} end\r\n            local alpha = v.ability.aikoyori_letters_stickers:lower()\r\n            if alpha == \"#\" and v.ability.aikoyori_pretend_letter then\r\n                -- if wild is set fr tbh\r\n                alpha = v.ability.aikoyori_pretend_letter:lower()\r\n            elseif alpha == \"#\" and AKYRS.config.wildcard_behaviour == 3 then -- if it's unset in mode 3 then just make it a random letter i guess\r\n                alpha = 'â'\r\n            end\r\n            table.insert(word_hand, alpha)\r\n                \r\n        end\r\n        \r\n        local expression = table.concat(word_hand)\r\n        local parts = {}\r\n        for part in expression:gmatch(\"[^=]+\") do\r\n            table.insert(parts, part)\r\n        end\r\n\r\n        if #parts ~= 2 then\r\n            return {}\r\n        end\r\n\r\n        local variable, value_expression = parts[1], parts[2]\r\n        local status, value = pcall(AKYRS.MathParser.solve, AKYRS.MathParser, value_expression)\r\n\r\n        if not status then\r\n            return {}\r\n        end\r\n\r\n        G.GAME.aikoyori_variable_to_set = variable\r\n        G.GAME.aikoyori_value_to_set_to_variable = value\r\n        return {hand}\r\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Rarity",
      "key": "emerald",
      "atlas": null,
      "pos": null,
      "raw": "key = \"emerald\",\r\n    default_weight = 0.3,\r\n    badge_colour = HEX('73ff33'),\r\n    pools = {\r\n        [\"Joker\"] = true\r\n    },\r\n    get_weight = function(self, weight, object_type)\r\n        local x = SMODS.find_card(\"j_akyrs_emerald\")\r\n        return (G.GAME and next(x)) and 0.45 + 0.05 * #x or 0.02\r\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Rarity",
      "key": "supercommon",
      "atlas": null,
      "pos": null,
      "raw": "key = \"supercommon\",\r\n    default_weight = 0,\r\n    badge_colour = HEX('8c94a3'),\r\n    pools = {\r\n        [\"Joker\"] = true\r\n    },",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Rarity",
      "key": "unique",
      "atlas": null,
      "pos": null,
      "raw": "key = \"unique\",\r\n    default_weight = 0,\r\n    badge_colour = HEX('ed9a78'),\r\n    pools = {\r\n        [\"Joker\"] = true\r\n    },",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Stake",
      "key": "outer",
      "atlas": "aikoStakes",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"outer\",\r\n    atlas = \"aikoStakes\", pos = {x = 1, y = 1},\r\n    sticker_atlas = \"aikoStakeStickers\", sticker_pos = {x = 1, y = 1},\r\n    applied_stakes = {  },\r\n    modifiers = function ()\r\n        G.GAME.starting_params.hands = G.GAME.starting_params.hands + 1\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Stake",
      "key": "inner",
      "atlas": "aikoStakes",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"inner\",\r\n    atlas = \"aikoStakes\", pos = {x = 2, y = 1},\r\n    sticker_atlas = \"aikoStakeStickers\", sticker_pos = {x = 2, y = 1},\r\n    applied_stakes = {  },\r\n    modifiers = function ()\r\n        G.GAME.starting_params.hand_size = G.GAME.starting_params.hand_size + 1\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Stake",
      "key": "oxidising",
      "atlas": "aikoStakes",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"oxidising\",\r\n    atlas = \"aikoStakes\", pos = {x = 0, y = 0},\r\n    sticker_atlas = \"aikoStakeStickers\", sticker_pos = {x = 0, y = 0},\r\n    applied_stakes = { \"white\" },\r\n    prefix_config = { applied_stakes = { mod = false } },\r\n    colour = HEX(\"b74912\"),    \r\n    modifiers = function ()\r\n        G.GAME.modifiers.akyrs_spawn_oxidising = true\r\n    end",
      "config": {
        "applied_stakes": {
          "mod": false
        }
      },
      "ability": {
        "applied_stakes": {
          "mod": false
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sticker",
      "key": "self_destructs",
      "atlas": "aikoyoriStickers",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"self_destructs\",\r\n    default_compat = true,\r\n    atlas = \"aikoyoriStickers\",\r\n    pos = {x = 0, y = 0},\r\n    rate = 0,\r\n    badge_colour = G.C.RED,\r\n    sets =  all_sets,\r\n    calculate = function(self, card, context)\r\n    end,\r\n    apply = function(self, card, val)\r\n        card.ability[self.key] = val\r\n        card:set_cost()\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Seal",
      "key": "debuff",
      "atlas": "aikoyoriStickers",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"debuff\",\r\n    atlas = 'aikoyoriStickers',\r\n    pos = {x = 1, y = 0},\r\n    badge_colour = HEX('91777c'),\r\n    sound = { sound = 'generic1', per = 1.2, vol = 0.4 },\r\n\r\n    calculate = function(self, card, context)\r\n        if context.cardarea == G.hand and context.hand_drawn then\r\n            card.debuff = true\r\n        end\r\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sticker",
      "key": "sigma",
      "atlas": "aikoyoriStickers",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"sigma\",\r\n    default_compat = true,\r\n    atlas = \"aikoyoriStickers\",\r\n    pos = {x = 3, y = 0},\r\n    rate = 0,\r\n    badge_colour = HEX(\"ee36ff\"),\r\n    sets =  all_sets,\r\n    calculate = function(self, card, context)\r\n    end,\r\n    apply = function(self, card, val)\r\n        card.ability[self.key] = val\r\n        card.ability.akyrs_stay_sigma = true\r\n        card:set_cost()\r\n    end,\r\n    \r\n    draw = function (self, card, layer)\r\n        G.shared_stickers[self.key].role.draw_major = card\r\n        G.shared_stickers[self.key]:draw_shader('dissolve', nil, nil, nil, card.children.center)\r\n        G.shared_stickers[self.key]:draw_shader('akyrs_texelated', nil, card.ARGS.send_to_shader, nil, card.children.center)\r\n        G.shared_stickers[self.key]:draw_shader('voucher', nil, card.ARGS.send_to_shader, nil, card.children.center)\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sticker",
      "key": "oxidising",
      "atlas": "aikoyoriStickers",
      "pos": {
        "x": 5,
        "y": 0
      },
      "raw": "key = \"oxidising\",\r\n    default_compat = true,\r\n    atlas = \"aikoyoriStickers\",\r\n    pos = {x = 5, y = 0},\r\n    rate = 0,\r\n    badge_colour = HEX(\"b74912\"),\r\n    sets =  all_sets,\r\n    should_apply = function (self, card, center, area, bypass_reroll)\r\n        if true then\r\n            if G.GAME.modifiers.akyrs_spawn_oxidising and pseudorandom((area == G.pack_cards and 'akyrs_packs_oxi_' or 'akyrs_oxi_')..G.GAME.round_resets.ante) > 0.7 then\r\n                card.ability.akyrs_oxidising = 1\r\n                return true\r\n            end\r\n        end\r\n        return false\r\n    end,\r\n    loc_vars = function (self, info_queue, card)\r\n        info_queue[#info_queue+1] = AKYRS.DescriptionDummies[\"dd_akyrs_copper_scrape_tip\"]\r\n        return {\r\n            key = AKYRS.compare(card.ability[self.key],\">=\", 4) and self.key..\"_full\" or self.key,\r\n            vars = {\r\n                (card.ability[self.key] - 1) * 25,\r\n                localize(\"k_akyrs_copper_oxidation_stage_\"..card.ability[self.key]+1),\r\n                card.ability.akyrs_oxidising_round,\r\n                card.ability.akyrs_oxidising_round ~= 1 and localize(\"k_akyrs_round_plural\") or localize(\"k_akyrs_round_singular\"),\r\n                25\r\n            }\r\n        }\r\n    end,\r\n    apply = function(self, card, val)\r\n        if val == true then val = 1 end\r\n        card.ability[self.key] = val\r\n        card.ability.akyrs_oxidising_round = 2\r\n        card.cost = math.floor(card.cost / 2)\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.akyrs_copper_end_of_round then\r\n            return {\r\n                akyrs_ignore_copper_calculation = true,\r\n                func = function ()\r\n                    card.ability.akyrs_oxidising_round = card.ability.akyrs_oxidising_round - 1\r\n                    if AKYRS.compare(card.ability.akyrs_oxidising_round,\"<=\", 0) and AKYRS.compare(card.ability[self.key],\"<\", 4) then\r\n                        SMODS.calculate_effect({\r\n                            func = function ()\r\n                                card.ability[self.key] = card.ability[self.key] + 1\r\n                                card.ability.akyrs_oxidising_round = 2\r\n                            end\r\n                        }, card)\r\n                    end\r\n                end,\r\n                message = localize(\"k_akyrs_oxidise_ex\"),\r\n                colour = HEX(\"337a57\")\r\n            }\r\n        end\r\n        if context.using_consumeable then\r\n            return {\r\n                akyrs_ignore_copper_calculation = true,\r\n                func = function ()\r\n                    local psrd = pseudorandom(pseudoseed(\"akyrs_oxidising_scrape_\"..card.config.center_key))\r\n                    local cond = AKYRS.compare(card.ability[self.key],\">\", 1) or AKYRS.compare(card.ability.akyrs_oxidising_round,\"<\", 2)\r\n                    if cond and psrd >= 0.75 then\r\n                        SMODS.calculate_effect(\r\n                            {\r\n                                akyrs_ignore_copper_calculation = true,\r\n                                func = function ()\r\n                                    AKYRS.simple_event_add(\r\n                                        function ()\r\n                                            card.ability[self.key] = (card.ability[self.key] or 4) - 1\r\n                                            card.ability.akyrs_oxidising_round = 2\r\n                                            return true\r\n                                        end, 0\r\n                                    )\r\n                                end,\r\n                                message = localize(\"k_akyrs_scrape_ex\"),\r\n                                colour = HEX(\"994433\")\r\n                            }, card\r\n                        )\r\n                    elseif cond then\r\n                        SMODS.calculate_effect(\r\n                            {\r\n                                akyrs_ignore_copper_calculation = true,\r\n                                message = localize(\"k_nope_ex\"),\r\n                                colour = G.C.PURPLE\r\n                            }, card\r\n                        )\r\n                    end\r\n                end,\r\n            }\r\n        end\r\n    end,\r\n    draw = function (self, card, layer)\r\n        local val = card.ability.akyrs_oxidising and math.min(4,math.max(1,card.ability.akyrs_oxidising)) or 1\r\n        \r\n        AKYRS.copper_stickers[val] = AKYRS.copper_stickers[val] or Sprite(0, 0, G.CARD_W, G.CARD_H, G.ASSET_ATLAS[\"akyrs_aikoyoriStickers\"], { x = 4 + val, y = 0})\r\n        AKYRS.copper_stickers[val].role.draw_major = card\r\n        AKYRS.copper_stickers[val]:draw_shader('dissolve', nil, nil, nil, card.children.center)\r\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null,
        null,
        null,
        null,
        25
      ],
      "infoQueue": []
    },
    {
      "type": "Tag",
      "key": "spell_itself_tag",
      "atlas": "akyrs_aikoyoriTags",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"spell_itself_tag\",\r\n    in_pool = function(self, args)\r\n        return G.GAME.akyrs_character_stickers_enabled and G.GAME.akyrs_wording_enabled\r\n    end,\r\n    loc_vars = function (self, info_queue, tag)\r\n        info_queue[#info_queue+1] = G.P_CENTERS[\"p_akyrs_mega_letter_pack_1\"]\r\n    end,\r\n    atlas = \"akyrs_aikoyoriTags\", pos = { x = 0, y = 0},\r\n    apply = function (self, tag, context)\r\n        if context.type == 'new_blind_choice' then\r\n            local lock = tag.ID\r\n            G.CONTROLLER.locks[lock] = true\r\n            tag:yep(\"+\",G.C.BLUE,function ()\r\n                local key = 'p_akyrs_mega_letter_pack_'..(math.random(1,2))\r\n                local card = Card(G.play.T.x + G.play.T.w/2 - G.CARD_W*1.27/2,\r\n                G.play.T.y + G.play.T.h/2-G.CARD_H*1.27/2, G.CARD_W*1.27, G.CARD_H*1.27, G.P_CARDS.empty, G.P_CENTERS[key], {bypass_discovery_center = true, bypass_discovery_ui = true})\r\n                card.cost = 0\r\n                card.from_tag = true\r\n                G.FUNCS.use_card({config = {ref_table = card}})\r\n                card:start_materialize()\r\n                G.CONTROLLER.locks[lock] = nil\r\n                return true\r\n            end)\r\n            tag.triggered = true\r\n            return true\r\n        end \r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Tag",
      "key": "umbral_tag",
      "atlas": "akyrs_aikoyoriTags",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"umbral_tag\",\r\n    loc_vars = function (self, info_queue, tag)\r\n        info_queue[#info_queue+1] = G.P_CENTERS[\"p_akyrs_mega_umbral_pack_1\"]\r\n    end,\r\n    atlas = \"akyrs_aikoyoriTags\", pos = { x = 1, y = 0},\r\n    apply = function (self, tag, context)\r\n        if context.type == 'new_blind_choice' then\r\n            local lock = tag.ID\r\n            G.CONTROLLER.locks[lock] = true\r\n            tag:yep(\"+\",G.C.AKYRS_UMBRAL_P,function ()\r\n                local key = 'p_akyrs_mega_umbral_pack_'..(math.random(1,2))\r\n                local card = Card(G.play.T.x + G.play.T.w/2 - G.CARD_W*1.27/2,\r\n                G.play.T.y + G.play.T.h/2-G.CARD_H*1.27/2, G.CARD_W*1.27, G.CARD_H*1.27, G.P_CARDS.empty, G.P_CENTERS[key], {bypass_discovery_center = true, bypass_discovery_ui = true})\r\n                card.cost = 0\r\n                card.from_tag = true\r\n                G.FUNCS.use_card({config = {ref_table = card}})\r\n                card:start_materialize()\r\n                G.CONTROLLER.locks[lock] = nil\r\n                return true\r\n            end)\r\n            tag.triggered = true\r\n            return true\r\n        end \r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "ConsumableType",
      "key": "Umbral",
      "atlas": null,
      "pos": null,
      "raw": "key = \"Umbral\",\r\n    primary_colour = HEX(\"ffd45b\"),\r\n    secondary_colour = HEX(\"925ac3\"),\r\n    collection_rows = { 4, 5 },\r\n    shop_rate = 3,\r\n    default = \"c_akyrs_umbral_break_up\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "UndiscoveredSprite",
      "key": "Umbral",
      "atlas": "umbra_undisc",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"Umbral\",\r\n    atlas = \"umbra_undisc\",\r\n    pos = {x=0, y=0}",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_graduate",
      "atlas": "umbra",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_graduate\",\r\n    atlas = \"umbra\",\r\n    pos = {x=0,y=0},\r\n    loc_vars = function (self, info_queue, card)\r\n        local disallow = not not (G.GAME.akyrs_last_umbral == self.key or not G.GAME.akyrs_last_umbral)\r\n        local text = G.GAME.akyrs_last_umbral and localize{type = \"name_text\",key = G.GAME.akyrs_last_umbral, set = \"Umbral\"} or localize(\"ph_akyrs_unknown\")\r\n        if G.GAME.akyrs_last_umbral and not disallow then\r\n            info_queue[#info_queue+1] = G.P_CENTERS[G.GAME.akyrs_last_umbral]\r\n        end\r\n        return {\r\n            main_end = {\r\n                { n = G.UIT.R, config = { padding = 0.1, colour = disallow and G.C.RED or G.C.GREEN, r = 0.1}, nodes = {\r\n                    {\r\n                        n = G.UIT.T, config = {scale = 0.3, text = text}\r\n                    }\r\n                }}\r\n            }\r\n        }\r\n    end,\r\n    can_use = function (self, card)\r\n        return not (G.GAME.akyrs_last_umbral == self.key or not G.GAME.akyrs_last_umbral)\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        local disallow = not not (G.GAME.akyrs_last_umbral == self.key or not G.GAME.akyrs_last_umbral)\r\n        if not disallow then\r\n            SMODS.add_card{key = G.GAME.akyrs_last_umbral}\r\n        end\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_realist",
      "atlas": "umbra",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_realist\",\r\n    atlas = \"umbra\",\r\n    pos = {x=1,y=0},\r\n    config = {\r\n        max_highlighted = 1,\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        info_queue[#info_queue+1] = G.P_CENTERS[\"m_akyrs_insolate_card\"]\r\n        return {\r\n            vars = {\r\n                card.ability.max_highlighted\r\n            }\r\n        }\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        AKYRS.do_things_to_card(G.hand.highlighted,function (_card)\r\n            _card:set_ability(G.P_CENTERS[\"m_akyrs_insolate_card\"])\r\n        end, {stay_flipped_delay = 1,stagger = 0.1, fifo = true})\r\n    end",
      "config": {
        "max_highlighted": 1
      },
      "ability": {
        "max_highlighted": 1
      },
      "vars": [
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_tribal",
      "atlas": "umbra",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_tribal\",\r\n    atlas = \"umbra\",\r\n    pos = {x=2,y=0},\r\n    config = {\r\n        min_highlighted = 0,\r\n        max_highlighted = 99999,\r\n    },\r\n    use = function (self, card, area, copier)\r\n        table.sort(G.hand.highlighted,AKYRS.hand_sort_function_immute)\r\n        AKYRS.juice_like_tarot(card)\r\n        local h = G.FUNCS.get_poker_hand_info(G.hand.highlighted)\r\n        local pl = AKYRS.get_planet_for_hand(h)\r\n        if pl then\r\n            SMODS.add_card{key = pl}\r\n        end\r\n    end",
      "config": {
        "min_highlighted": 0,
        "max_highlighted": 99999
      },
      "ability": {
        "min_highlighted": 0,
        "max_highlighted": 99999
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_gambit",
      "atlas": "umbra",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_gambit\",\r\n    atlas = \"umbra\",\r\n    pos = {x=3,y=0},\r\n    config = {\r\n        extras = 3,\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras\r\n            }\r\n        }\r\n    end,\r\n    can_use = function (self, card)\r\n        return #G.hand.cards > 0\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        local cards = AKYRS.pseudorandom_elements(G.hand.cards,card.ability.extras,pseudoseed(\"akyrs_umbral_gambit_c\"))\r\n        local rank = pseudorandom_element({\"King\",\"Queen\",\"Ace\"},pseudoseed(\"akyrs_umbral_gambit_r\"))\r\n        AKYRS.do_things_to_card(cards,function (_card)\r\n            _card = SMODS.change_base(_card,nil,rank)\r\n        end, {stay_flipped_delay = 1,stagger = 0.5,finish_flipped_delay = 0.5, fifo = true})\r\n    end",
      "config": {
        "extras": 3
      },
      "ability": {
        "extras": 3
      },
      "vars": [
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_kingpin",
      "atlas": "umbra",
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_kingpin\",\r\n    atlas = \"umbra\",\r\n    pos = {x=4,y=0},\r\n    can_use = function (self, card)\r\n        return G.STATE == G.STATES.SELECTING_HAND or #G.hand.cards > 0\r\n    end,\r\n    config = {\r\n        extra = 2,\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extra\r\n            }\r\n        }\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        AKYRS.simple_event_add(\r\n            function ()\r\n                for i = 1, card.ability.extra do\r\n                    local c = SMODS.add_card{ area = G.hand, set = \"Base\", seal = SMODS.poll_seal({guaranteed = true,}), rank = \"King\" }\r\n                    c.pinned = true\r\n                    c:juice_up(0.3,0.3)\r\n                end\r\n                return true\r\n            end\r\n        )\r\n    end",
      "config": {
        "extra": 2
      },
      "ability": {
        "extra": 2
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_tea_time",
      "atlas": "umbra",
      "pos": {
        "x": 5,
        "y": 0
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_tea_time\",\r\n    atlas = \"umbra\",\r\n    pos = {x=5,y=0},\r\n    config = {\r\n        min_highlighted = 1,\r\n        max_highlighted = 1\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        for _,k in ipairs(AKYRS.tea_cards) do\r\n            info_queue[#info_queue+1] = G.P_CENTERS[k] \r\n        end\r\n        return {\r\n            vars = {\r\n                card.ability.max_highlighted\r\n            }\r\n        }\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        AKYRS.do_things_to_card(G.hand.highlighted,function (_card)\r\n            local ench = pseudorandom_element(AKYRS.tea_cards,pseudoseed(\"akyrs_umbral_tea_time\"))\r\n            _card:set_ability(G.P_CENTERS[ench])\r\n        end, {stay_flipped_delay = 1,stagger = 0.5,finish_flipped_delay = 0.5, fifo = true})\r\n    end",
      "config": {
        "min_highlighted": 1,
        "max_highlighted": 1
      },
      "ability": {
        "min_highlighted": 1,
        "max_highlighted": 1
      },
      "vars": [
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_break_up",
      "atlas": "umbra",
      "pos": {
        "x": 6,
        "y": 0
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_break_up\",\r\n    atlas = \"umbra\",\r\n    config = {\r\n        min_highlighted = 1,\r\n        max_highlighted = 1\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        info_queue[#info_queue+1] = AKYRS.DescriptionDummies[\"dd_akyrs_break_up_tip\"]\r\n        return {\r\n            vars = {\r\n                card.ability.max_highlighted\r\n            }\r\n        }\r\n    end,\r\n    can_use = function (self, card)\r\n        local has_no_rank, has_no_suit \r\n        for _, c in ipairs(G.hand.highlighted) do\r\n            if SMODS.has_no_suit(c) then\r\n                has_no_suit = true\r\n            end\r\n            if SMODS.has_no_rank(c) then\r\n                has_no_rank = true\r\n            end\r\n        end\r\n        return (#G.hand.highlighted <= card.ability.max_highlighted and #G.hand.highlighted >= card.ability.min_highlighted) and not (has_no_rank and has_no_suit)\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        for _, c in ipairs(G.hand.highlighted) do\r\n            if not SMODS.has_no_suit(c) then\r\n                local c2 = AKYRS.copy_p_card(c, nil, nil, G.playing_card)\r\n                c2.ability.akyrs_special_card_type = \"rank\"\r\n                c2:set_sprites(c2.config.center,c2.config.card)\r\n            end\r\n            if not SMODS.has_no_rank(c) then\r\n                local c2 = AKYRS.copy_p_card(c, nil, nil, G.playing_card)\r\n                c2.ability.akyrs_special_card_type = \"suit\"\r\n                c2:set_sprites(c2.config.center,c2.config.card)\r\n            end\r\n            -- requested by autumm\r\n            c.no_graveyard = true\r\n            c:start_dissolve({ G.C.AKYRS_UMBRAL_P, G.C.AKYRS_UMBRAL_Y, }, 1 )\r\n        end\r\n        \r\n    end,\r\n    pos = {x=6,y=0},",
      "config": {
        "min_highlighted": 1,
        "max_highlighted": 1
      },
      "ability": {
        "min_highlighted": 1,
        "max_highlighted": 1
      },
      "vars": [
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_public_transport",
      "atlas": "umbra",
      "pos": {
        "x": 7,
        "y": 0
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_public_transport\",\r\n    atlas = \"umbra\",\r\n    pos = {x=7,y=0},\r\n    config = {\r\n        max_highlighted = 1,\r\n        akyrs_create = 2,\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.akyrs_create,\r\n                card.ability.max_highlighted\r\n            }\r\n        }\r\n    end,\r\n    use = function (z, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        local ud = pseudorandom_element({1,-1},pseudoseed(\"akyrs_umbral_pubtp_updown\"))\r\n        for _,_c in ipairs(G.hand.highlighted) do\r\n            for i = 1, card.ability.akyrs_create do\r\n                local c2 = AKYRS.copy_p_card(_c, nil, nil, G.playing_card)\r\n                c2 = SMODS.modify_rank(c2, ud*i)\r\n                if c2 then c2:juice_up(0.3,0.3) end\r\n            end\r\n            AKYRS.deselect_from_area(_c)\r\n            \r\n        end\r\n    end",
      "config": {
        "max_highlighted": 1,
        "akyrs_create": 2
      },
      "ability": {
        "max_highlighted": 1,
        "akyrs_create": 2
      },
      "vars": [
        2,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_corruption",
      "atlas": "umbra",
      "pos": {
        "x": 8,
        "y": 0
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_corruption\",\r\n    atlas = \"umbra\",\r\n    pos = {x=8,y=0},\r\n    can_use = function (self, card)\r\n        return #G.hand.cards > 0 \r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        local ud = pseudorandom_element({\"dupe\",\"destroy\"},pseudoseed(\"akyrs_umbral_corrupt_pick\"))\r\n        local cds = AKYRS.pseudorandom_elements(G.hand.cards,math.ceil(#G.hand.cards/2),pseudoseed(\"akyrs_umbral_corrupt_cards\"))\r\n        for _,_card in ipairs(cds) do\r\n            if ud == \"dupe\" then\r\n                AKYRS.copy_p_card(_card)\r\n            else\r\n                _card:start_dissolve({G.C.AKYRS_UMBRAL_P,G.C.AKYRS_UMBRAL_P},1)\r\n            end\r\n        end\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_fomo",
      "atlas": "umbra",
      "pos": {
        "x": 9,
        "y": 0
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_fomo\",\r\n    atlas = \"umbra\",\r\n    pos = {x=9,y=0},\r\n    config = {\r\n        extras = {\r\n            create = 1,\r\n            take = 12\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras.create,\r\n                card.ability.extras.take\r\n            }\r\n        }\r\n    end,\r\n    can_use = function (self, card)\r\n        -- wtf? talisman\r\n        for _,v in ipairs(G.GAME.current_round.voucher) do\r\n            if G.GAME.akyrs_list_of_generated_but_not_redeemed_vouchers[v] then\r\n                return false\r\n            end\r\n        end\r\n        return #G.GAME.akyrs_list_of_generated_but_not_redeemed_vouchers > 0 and AKYRS.can_afford(card.ability.extras.take)\r\n    end,\r\n    in_pool = function (self, args)\r\n        return #G.GAME.akyrs_list_of_generated_but_not_redeemed_vouchers > 0\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        ease_dollars(-card.ability.extras.take)\r\n        for i = 1, card.ability.extras.create do\r\n            local to_redeem = pseudorandom_element(G.GAME.akyrs_list_of_generated_but_not_redeemed_vouchers,pseudoseed(\"akyrs_umbral_fomo_voucher\"))\r\n            local _c = SMODS.create_card{ set = \"Voucher\", key = to_redeem }\r\n            _c.cost = 0\r\n            G.play:emplace(_c)\r\n            _c:redeem()\r\n            if G.shop_vouchers and G.shop_vouchers.cards then\r\n                for _,_cds in ipairs(G.shop_vouchers.cards) do\r\n                    if _cds.config.center_key == to_redeem then\r\n                        _cds:remove()\r\n                    end\r\n                end\r\n            end\r\n            AKYRS.simple_event_add(\r\n                function ()\r\n                    _c:start_dissolve(nil,2)\r\n                    return true\r\n                end, 1\r\n            )\r\n        end\r\n    end",
      "config": {
        "extras": {
          "create": 1,
          "take": 12
        }
      },
      "ability": {
        "extras": {
          "create": 1,
          "take": 12
        }
      },
      "vars": [
        1,
        12
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_misfortune",
      "atlas": "umbra",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_misfortune\",\r\n    atlas = \"umbra\",\r\n    pos = {x=0,y=1},\r\n    config = {\r\n        max_highlighted = 2\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        info_queue[#info_queue+1] = G.P_CENTERS[\"m_akyrs_hatena\"]\r\n        info_queue[#info_queue+1] = G.P_CENTERS[\"m_akyrs_item_box\"]\r\n        return {\r\n            vars = {\r\n                card.ability.max_highlighted\r\n            }\r\n        }\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        AKYRS.do_things_to_card(G.hand.highlighted,\r\n            function (_c)\r\n                if _c.config.center_key == \"m_akyrs_hatena\" then\r\n                    _c:set_ability(G.P_CENTERS[\"m_akyrs_item_box\"])\r\n                else\r\n                    _c:set_ability(G.P_CENTERS[\"m_akyrs_hatena\"])\r\n                end\r\n                AKYRS.deselect_from_area(_c)\r\n            end\r\n        )\r\n    end",
      "config": {
        "max_highlighted": 2
      },
      "ability": {
        "max_highlighted": 2
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_book_smart",
      "atlas": "umbra",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_book_smart\",\r\n    atlas = \"umbra\",\r\n    pos = {x=1,y=1},\r\n    config = {\r\n        extras = 2,\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras\r\n            }\r\n        }\r\n    end,\r\n    can_use = function (self, card)\r\n        return true\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        for i = 1, card.ability.extras do\r\n            if not AKYRS.has_room(G.consumeables) then break end\r\n            local _c = SMODS.add_card{set = \"Umbral\"}\r\n            _c:juice_up(0.3,0.3)\r\n        end\r\n    end",
      "config": {
        "extras": 2
      },
      "ability": {
        "extras": 2
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_prisoner",
      "atlas": "umbra",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_prisoner\",\r\n    atlas = \"umbra\",\r\n    pos = {x=2,y=1},\r\n    config = {\r\n        max_highlighted = 1\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        info_queue[#info_queue+1] = G.P_CENTERS[\"m_akyrs_brick_card\"]\r\n        return {\r\n            vars = {\r\n                card.ability.max_highlighted\r\n            }\r\n        }\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        AKYRS.do_things_to_card(G.hand.highlighted,\r\n            function (_c)\r\n                _c:set_ability(G.P_CENTERS[\"m_akyrs_brick_card\"])\r\n                AKYRS.deselect_from_area(_c)\r\n            end\r\n        )\r\n    end",
      "config": {
        "max_highlighted": 1
      },
      "ability": {
        "max_highlighted": 1
      },
      "vars": [
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_overgrowth",
      "atlas": "umbra",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_overgrowth\",\r\n    atlas = \"umbra\",\r\n    pos = {x=3,y=1},\r\n    config = {\r\n        max_highlighted = 2\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        info_queue[#info_queue+1] = G.P_CENTERS[\"m_akyrs_canopy_card\"]\r\n        return {\r\n            vars = {\r\n                card.ability.max_highlighted\r\n            }\r\n        }\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        AKYRS.do_things_to_card(G.hand.highlighted,\r\n            function (_c)\r\n                _c:set_ability(G.P_CENTERS[\"m_akyrs_canopy_card\"])\r\n                AKYRS.deselect_from_area(_c)\r\n            end\r\n        )\r\n    end",
      "config": {
        "max_highlighted": 2
      },
      "ability": {
        "max_highlighted": 2
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_intrusive_thoughts",
      "atlas": "umbra",
      "pos": {
        "x": 4,
        "y": 1
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_intrusive_thoughts\",\r\n    atlas = \"umbra\",\r\n    pos = {x=4,y=1},\r\n    config = {\r\n        extras = {\r\n            emoney = 2\r\n        }\r\n    },\r\n    \r\n    calculate = function (self, card, context)\r\n        if context.selling_card and context.card == card then\r\n            local die_question_mark = pseudorandom(\"akyrs_umbral_intrusive\") >= 0.5\r\n            return {\r\n                message = localize(\"k_akyrs_umbral_intrusive_\"..(die_question_mark and \"would_die\" or \"would_win\")),\r\n                colour = (die_question_mark and G.C.GREEN or G.C.RED),\r\n                func = function ()\r\n                    AKYRS.force_save()\r\n                end\r\n            }\r\n        end\r\n    end,\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras.emoney,\r\n            }\r\n        }\r\n    end,\r\n    can_use = function (self, card)\r\n        return true\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        local die_question_mark = pseudorandom(\"akyrs_umbral_intrusive\") >= 0.5\r\n        if die_question_mark then\r\n            if G.STAGE == G.STAGES.RUN then G.STATE = G.STATES.GAME_OVER; G.STATE_COMPLETE = false end\r\n        end\r\n        if Talisman and type(to_big(G.GAME.dollars)) == \"table\" then\r\n            local d_dollar = to_big(G.GAME.dollars):pow(card.ability.extras.emoney) - to_big(G.GAME.dollars)\r\n            ease_dollars(d_dollar)\r\n        else\r\n            local d_dollar = G.GAME.dollars ^ card.ability.extras.emoney - G.GAME.dollars\r\n            ease_dollars(d_dollar)\r\n        end\r\n        AKYRS.force_save()\r\n    end",
      "config": {
        "extras": {
          "emoney": 2
        }
      },
      "ability": {
        "extras": {
          "emoney": 2
        }
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_weeping_angel",
      "atlas": "umbra",
      "pos": {
        "x": 5,
        "y": 1
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_weeping_angel\",\r\n    atlas = \"umbra\",\r\n    pos = {x=5,y=1},\r\n    config = {\r\n        extras = 2\r\n    },\r\n    can_use = function (self, card)\r\n        return #G.hand.cards > 0\r\n    end,\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras\r\n            }\r\n        }\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        for _,_c in ipairs(G.hand.cards) do\r\n            AKYRS.simple_event_add(\r\n                function ()\r\n                    play_sound('card1')\r\n                    _c:juice_up(0.3, 0.3)\r\n                    _c:flip()\r\n                    return true\r\n                end, 0.25\r\n            )\r\n        end\r\n        AKYRS.simple_event_add(\r\n            function ()\r\n                local money_obtain = 0\r\n                for _,_c in ipairs(G.hand.cards) do\r\n                    if _c.facing == \"back\" then\r\n                        money_obtain = money_obtain + card.ability.extras\r\n                    end\r\n                end\r\n                if money_obtain ~= 0 then\r\n                    ease_dollars(money_obtain)\r\n                end\r\n                return true\r\n            end, 0.25\r\n        )\r\n    end",
      "config": {
        "extras": 2
      },
      "ability": {
        "extras": 2
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_bunker",
      "atlas": "umbra",
      "pos": {
        "x": 6,
        "y": 1
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_bunker\",\r\n    atlas = \"umbra\",\r\n    pos = {x=6,y=1},\r\n    config = {\r\n        max_highlighted = 1\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.max_highlighted\r\n            }\r\n        }\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        AKYRS.do_things_to_card(\r\n            G.hand.highlighted,\r\n            function (_card)\r\n                local ench = SMODS.poll_enhancement({guaranteed = true, key = \"akyrs_umbral_bunker_ench\"})\r\n                local edition = poll_edition(\"akyrs_umbral_bunker_edition\", nil, nil, true)\r\n                local seal = SMODS.poll_seal({guaranteed = true, key = \"akyrs_umbral_bunker_seal\"})\r\n                _card:set_ability(G.P_CENTERS[ench])\r\n                _card:set_seal(seal)\r\n                _card:set_edition(edition)\r\n                _card.ability.akyrs_forced_selection = true\r\n            end\r\n        )\r\n    end",
      "config": {
        "max_highlighted": 1
      },
      "ability": {
        "max_highlighted": 1
      },
      "vars": [
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_rock",
      "atlas": "umbra",
      "pos": {
        "x": 7,
        "y": 1
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_rock\",\r\n    atlas = \"umbra\",\r\n    pos = {x=7,y=1},\r\n    config = {\r\n        extras = 10\r\n    },\r\n    can_use = function (self, card)\r\n        return #G.hand.cards > 0\r\n    end,\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras\r\n            }\r\n        }\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        for _,_c in ipairs(G.hand.cards) do\r\n            AKYRS.simple_event_add(\r\n                function ()\r\n                    _c.ability.perma_bonus = _c.ability.perma_bonus + card.ability.extras\r\n                    _c:juice_up(0.3, 0.3)\r\n                    play_sound(\"tarot1\")\r\n                    return true\r\n                end\r\n            )\r\n        end\r\n    end",
      "config": {
        "extras": 10
      },
      "ability": {
        "extras": 10
      },
      "vars": [
        10
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_crust",
      "atlas": "umbra",
      "pos": {
        "x": 8,
        "y": 1
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_crust\",\r\n    atlas = \"umbra\",\r\n    pos = {x=8,y=1},\r\n    config = {\r\n        extras = 0.1\r\n    },\r\n    can_use = function (self, card)\r\n        return #G.hand.cards > 0\r\n    end,\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras\r\n            }\r\n        }\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        for _,_c in ipairs(G.hand.cards) do\r\n            if _c:is_suit(\"Clubs\") then\r\n                AKYRS.simple_event_add(\r\n                    function ()\r\n                        _c.ability.perma_x_mult = _c.ability.perma_x_mult + card.ability.extras\r\n                        _c:juice_up(0.3, 0.3)\r\n                        play_sound(\"tarot1\")\r\n                        return true\r\n                    end\r\n                )\r\n            end\r\n        end\r\n    end",
      "config": {
        "extras": 0.1
      },
      "ability": {
        "extras": 0.1
      },
      "vars": [
        0.1
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_mantle",
      "atlas": "umbra",
      "pos": {
        "x": 9,
        "y": 1
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_mantle\",\r\n    atlas = \"umbra\",\r\n    pos = {x=9,y=1},\r\n    config = {\r\n        extras = 0.1\r\n    },\r\n    can_use = function (self, card)\r\n        return #G.hand.cards > 0\r\n    end,\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras\r\n            }\r\n        }\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        for _,_c in ipairs(G.hand.cards) do\r\n            if _c:is_suit(\"Spades\") then\r\n                AKYRS.simple_event_add(\r\n                    function ()\r\n                        _c.ability.perma_x_chips = _c.ability.perma_x_chips + card.ability.extras\r\n                        _c:juice_up(0.3, 0.3)\r\n                        play_sound(\"tarot1\")\r\n                        return true\r\n                    end\r\n                )\r\n            end\r\n        end\r\n    end",
      "config": {
        "extras": 0.1
      },
      "ability": {
        "extras": 0.1
      },
      "vars": [
        0.1
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_core",
      "atlas": "umbra",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_core\",\r\n    atlas = \"umbra\",\r\n    pos = {x=0,y=2},\r\n    config = {\r\n        extras = 2\r\n    },\r\n    can_use = function (self, card)\r\n        return #G.hand.cards > 0\r\n    end,\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras\r\n            }\r\n        }\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        for _,_c in ipairs(G.hand.cards) do\r\n            if _c:is_suit(\"Hearts\") then\r\n                AKYRS.simple_event_add(\r\n                    function ()\r\n                        _c.ability.perma_p_dollars = _c.ability.perma_p_dollars + card.ability.extras\r\n                        _c:juice_up(0.3, 0.3)\r\n                        play_sound(\"tarot1\")\r\n                        return true\r\n                    end\r\n                )\r\n            end\r\n        end\r\n    end",
      "config": {
        "extras": 2
      },
      "ability": {
        "extras": 2
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_atmosphere",
      "atlas": "umbra",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_atmosphere\",\r\n    atlas = \"umbra\",\r\n    pos = {x=1,y=2},\r\n    config = {\r\n    },\r\n    can_use = function (self, card)\r\n        return #G.hand.cards > 0\r\n    end,\r\n    loc_vars = function (self, info_queue, card)\r\n        G.GAME.akyrs_umbral_atmosphere_score_inc = G.GAME.akyrs_umbral_atmosphere_score_inc or 100\r\n        G.GAME.akyrs_umbral_atmosphere_uses = G.GAME.akyrs_umbral_atmosphere_uses or 0\r\n        return {\r\n            vars = {\r\n                G.GAME.akyrs_umbral_atmosphere_score_inc,\r\n                G.GAME.akyrs_umbral_atmosphere_score_inc + 100 * (G.GAME.akyrs_umbral_atmosphere_uses + 1)^2\r\n            }\r\n        }\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        G.GAME.akyrs_umbral_atmosphere_score_inc = G.GAME.akyrs_umbral_atmosphere_score_inc or 100\r\n        G.GAME.akyrs_umbral_atmosphere_uses = (G.GAME.akyrs_umbral_atmosphere_uses or 0) + 1\r\n        for _,_c in ipairs(G.hand.cards) do\r\n            if _c:is_suit(\"Diamonds\") then\r\n                AKYRS.simple_event_add(\r\n                    function ()\r\n                        _c.ability.akyrs_perma_score = _c.ability.akyrs_perma_score + G.GAME.akyrs_umbral_atmosphere_score_inc\r\n                        _c:juice_up(0.3, 0.3)\r\n                        play_sound(\"tarot1\")\r\n                        return true\r\n                    end\r\n                )\r\n            end\r\n        end\r\n        AKYRS.simple_event_add(\r\n            function ()\r\n                G.GAME.akyrs_umbral_atmosphere_score_inc =  G.GAME.akyrs_umbral_atmosphere_score_inc + 100 * (G.GAME.akyrs_umbral_atmosphere_uses)^2\r\n                return true\r\n            end, 0\r\n        )\r\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_nyctophobia",
      "atlas": "umbra",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_nyctophobia\",\r\n    atlas = \"umbra\",\r\n    pos = {x=2,y=2},\r\n    can_use = function (self, card)\r\n        return true\r\n    end,\r\n    config = {\r\n        extra = 2\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extra\r\n            }\r\n        }\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        for i = 1, card.ability.extra do\r\n            local c = SMODS.add_card{ edition = \"e_negative\", set = \"Tarot\"}\r\n            c:juice_up(0.3, 0.3)\r\n        end\r\n    end",
      "config": {
        "extra": 2
      },
      "ability": {
        "extra": 2
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_puzzle",
      "atlas": "umbra",
      "pos": {
        "x": 3,
        "y": 2
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_puzzle\",\r\n    atlas = \"umbra\",\r\n    pos = {x=3,y=2},\r\n    config = {\r\n        min_highlighted = 2,\r\n        max_highlighted = 2,\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.min_highlighted\r\n            }\r\n        }\r\n    end,\r\n    can_use = function (self, card)\r\n        return #G.hand.highlighted >= math.max(2,card.ability.min_highlighted) and #G.hand.highlighted <= card.ability.max_highlighted\r\n    end, \r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        table.sort(G.hand.highlighted,AKYRS.hand_sort_function_immute)\r\n        AKYRS.do_things_to_card(\r\n            G.hand.highlighted,\r\n            function (_card, index)\r\n                if index == 1 then\r\n                    if G.hand.highlighted[2] then\r\n                        local c2 = G.hand.highlighted[2]\r\n                        if c2.edition then\r\n                            _card:set_edition(c2.edition.key)\r\n                        end\r\n                        if c2.seal then\r\n                            _card:set_seal(c2.seal)\r\n                        end\r\n                        if not SMODS.has_no_suit(c2) and c2.base and c2.base.suit then\r\n                            _card = SMODS.change_base(_card, c2.base.suit )\r\n                            if _card and _card.ability.akyrs_special_card_type == \"rank\" then\r\n                                _card.ability.akyrs_special_card_type = nil\r\n                                _card:set_sprites(_card.config.center,_card.config.card)\r\n                            end\r\n                        end\r\n                    end\r\n                else\r\n                    _card:start_dissolve({G.C.AKYRS_UMBRAL_P, G.C.AKYRS_UMBRAL_Y})\r\n                end\r\n            end\r\n        )\r\n    end",
      "config": {
        "min_highlighted": 2,
        "max_highlighted": 2
      },
      "ability": {
        "min_highlighted": 2,
        "max_highlighted": 2
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_electrify",
      "atlas": "umbra",
      "pos": {
        "x": 4,
        "y": 2
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_electrify\",\r\n    atlas = \"umbra\",\r\n    pos = {x=4,y=2},\r\n    config = {\r\n        max_highlighted = 1,\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        \r\n        info_queue[#info_queue+1] = G.P_CENTERS[\"m_akyrs_zap_card\"]\r\n        return {\r\n            vars = {\r\n                card.ability.max_highlighted\r\n            }\r\n        }\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        AKYRS.do_things_to_card(\r\n            G.hand.highlighted,\r\n            function (_card)\r\n                _card:set_ability(G.P_CENTERS[\"m_akyrs_zap_card\"])\r\n            end\r\n        )\r\n    end",
      "config": {
        "max_highlighted": 1
      },
      "ability": {
        "max_highlighted": 1
      },
      "vars": [
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_d1",
      "atlas": "umbra",
      "pos": {
        "x": 5,
        "y": 2
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_d1\",\r\n    atlas = \"umbra\",\r\n    pos = {x=5,y=2},\r\n    config = {\r\n        extras = {\r\n            d = 1,\r\n            n = 1\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras.n,\r\n                card.ability.extras.d,\r\n            }\r\n        }\r\n    end,\r\n    can_use = function (self, card)\r\n        return true\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        G.GAME.akyrs_prob_mod = G.GAME.akyrs_prob_mod or {}\r\n        table.insert(G.GAME.akyrs_prob_mod, {n_add = card.ability.extras.n, d_add = card.ability.extras.d})\r\n    end",
      "config": {
        "extras": {
          "d": 1,
          "n": 1
        }
      },
      "ability": {
        "extras": {
          "d": 1,
          "n": 1
        }
      },
      "vars": [
        1,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_free_will",
      "atlas": "umbra",
      "pos": {
        "x": 6,
        "y": 2
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_free_will\",\r\n    atlas = \"umbra\",\r\n    pos = {x=6,y=2},\r\n    soul_pos = {x=9,y=2, draw=function (card, scale_mod, rotate_mod)\r\n        if card.children.floating_sprite then\r\n            rotate_mod = -G.TIMERS.REAL * 0.731\r\n            local sc = -0.25\r\n            local xm = 0.2 * math.cos(G.TIMERS.REAL)\r\n            local ym = 0.2 * math.sin(G.TIMERS.REAL)\r\n            card.children.floating_sprite:draw_shader('dissolve', 0, nil,nil,card.children.center,sc, rotate_mod,xm,ym+0.2,nil, 0.6)\r\n            card.children.floating_sprite:draw_shader('dissolve', nil, nil,nil,card.children.center,sc, rotate_mod,xm,ym,nil, 0.6)\r\n        end\r\n    end},\r\n    hidden = true,\r\n    soul_rate = 0.05,\r\n    can_repeat_soul = true,\r\n    config = {\r\n        extras = {\r\n            mod = 1\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras.mod\r\n            }\r\n        }\r\n    end,\r\n    can_use = function (self, card)\r\n        return true\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        SMODS.change_play_limit(card.ability.extras.mod)\r\n        SMODS.change_discard_limit(card.ability.extras.mod)\r\n    end",
      "config": {
        "extras": {
          "mod": 1
        }
      },
      "ability": {
        "extras": {
          "mod": 1
        }
      },
      "vars": [
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Voucher",
      "key": "alphabet_soup",
      "atlas": "aikoyoriVouchers",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"alphabet_soup\",\r\n    atlas = 'aikoyoriVouchers', pos = { x = 2, y = 0 } ,\r\n    cost = 10,\r\n    redeem = function (self, card) \r\n        G.GAME.akyrs_character_stickers_enabled = true\r\n        G.GAME.akyrs_wording_enabled = true\r\n        for _,c in ipairs(G.playing_cards) do\r\n            c:set_sprites(c.config.center,c.config.card)\r\n        end\r\n    end,\r\n    unredeem = function (self, card) \r\n        G.GAME.akyrs_character_stickers_enabled = false\r\n        G.GAME.akyrs_wording_enabled = false\r\n        for _,c in ipairs(G.playing_cards) do\r\n            c:set_sprites(c.config.center,c.config.card)\r\n        end\r\n    end,\r\n    in_pool = function (self, args)\r\n        return not G.GAME.akyrs_mathematics_enabled\r\n    end",
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Voucher",
      "key": "crossing_field",
      "atlas": "aikoyoriVouchers",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"crossing_field\",\r\n    atlas = 'aikoyoriVouchers', pos = { x = 3, y = 0 } ,\r\n    cost = 10,\r\n    requires = { \"v_akyrs_alphabet_soup\" },\r\n    redeem = function (self, card) \r\n        G.GAME.akyrs_letters_mult_enabled = true\r\n    end,\r\n    unredeem = function (self, card) \r\n        G.GAME.akyrs_letters_mult_enabled = false\r\n    end,\r\n    in_pool = function (self, args)\r\n        return not G.GAME.akyrs_mathematics_enabled\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "DrawStep",
      "key": "extras",
      "atlas": null,
      "pos": null,
      "raw": "key = \"extras\",\r\n    order = 50,\r\n    func = function (card, layer)\r\n        AKYRS.aikoyori_draw_extras(card,layer)\r\n    end,\r\n    conditions = { vortex = false, facing = 'front' },",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "DrawStep",
      "key": "pinned_sticker",
      "atlas": null,
      "pos": null,
      "raw": "key = \"pinned_sticker\",\r\n    order = 95,\r\n    func = function(self)\r\n        if self.pinned then\r\n            if not AKYRS.pinned_sticker then\r\n                AKYRS.pinned_sticker = Sprite(0, 0, G.CARD_W, G.CARD_H, G.ASSET_ATLAS[\"akyrs_aikoyoriStickers\"], {x = 4,y = 0}) \r\n            end\r\n            AKYRS.pinned_sticker.role.draw_major = self\r\n            AKYRS.pinned_sticker:draw_shader('dissolve', nil, nil, nil, self.children.center,nil,nil,nil,-0.3)\r\n            AKYRS.pinned_sticker:draw_shader('voucher', nil, nil, nil, self.children.center,nil,nil,nil,-0.3)\r\n        end\r\n    end,\r\n    conditions = { vortex = false, facing = 'front' },",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Font",
      "key": "NotoEmoji",
      "atlas": null,
      "pos": null,
      "raw": "key = \"NotoEmoji\",\r\n    path = \"NotoEmoji-Bold.ttf\",\r\n    render_scale = 140,\r\n    TEXT_HEIGHT_SCALE = 0.65, \r\n    TEXT_OFFSET = {x=0,y=0}, \r\n    FONTSCALE = 0.12,\r\n    squish = 1, \r\n    DESCSCALE = 1",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Font",
      "key": "MochiyPopOne",
      "atlas": null,
      "pos": null,
      "raw": "key = \"MochiyPopOne\",\r\n    path = \"MochiyPopOne-Regular.ttf\",\r\n    render_scale = 128,\r\n    TEXT_HEIGHT_SCALE = 0.9,\r\n    TEXT_OFFSET = {x=10,y=-10},\r\n    FONTSCALE = 0.11,\r\n    squish = 1,\r\n    DESCSCALE = 1",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "letter_booster_pack_music",
      "atlas": null,
      "pos": null,
      "raw": "key = \"letter_booster_pack_music\",\r\n    path = \"letterPack.ogg\",\r\n    sync = {\r\n        ['music1'] = true,\r\n        ['music2'] = true,\r\n        ['music3'] = true,\r\n        ['music4'] = true,\r\n        ['music5'] = true,\r\n        ['akyrs_umbral_booster_pack_music'] = true,\r\n    },\r\n    select_music_track = function(self) \r\n        return G.booster_pack and not G.booster_pack.REMOVED and SMODS.OPENED_BOOSTER and SMODS.OPENED_BOOSTER.config.center.kind == 'letter_pack' and 100 or nil\r\n    end",
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "umbral_booster_pack_music",
      "atlas": null,
      "pos": null,
      "raw": "key = \"umbral_booster_pack_music\",\r\n    path = \"umbralpack.ogg\",\r\n    sync = {\r\n        ['music1'] = true,\r\n        ['music2'] = true,\r\n        ['music3'] = true,\r\n        ['music4'] = true,\r\n        ['music5'] = true,\r\n        ['akyrs_letter_booster_pack_music'] = true,\r\n    },\r\n    select_music_track = function(self) \r\n        return G.booster_pack and not G.booster_pack.REMOVED and SMODS.OPENED_BOOSTER and SMODS.OPENED_BOOSTER.config.center.kind == 'umbral_pack' and 100 or nil\r\n    end",
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "noire_sfx",
      "atlas": null,
      "pos": null,
      "raw": "key = \"noire_sfx\",\r\n    path = \"noire.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "texelated_sfx",
      "atlas": null,
      "pos": null,
      "raw": "key = \"texelated_sfx\",\r\n    path = \"texelated.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "sliced_sfx",
      "atlas": null,
      "pos": null,
      "raw": "key = \"sliced_sfx\",\r\n    path = \"sliced.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "burnt_sfx",
      "atlas": null,
      "pos": null,
      "raw": "key = \"burnt_sfx\",\r\n    path = \"burnt.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "enchant1",
      "atlas": null,
      "pos": null,
      "raw": "key = \"enchant1\",\r\n    path = \"enchant/enchant1.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "enchant2",
      "atlas": null,
      "pos": null,
      "raw": "key = \"enchant2\",\r\n    path = \"enchant/enchant2.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "enchant3",
      "atlas": null,
      "pos": null,
      "raw": "key = \"enchant3\",\r\n    path = \"enchant/enchant3.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "loud_incorrect_buzzer",
      "atlas": null,
      "pos": null,
      "raw": "key = \"loud_incorrect_buzzer\",\r\n    path = \"loudbuzzer.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    }
  ],
  "version": "0.2.0-alpha-250801e"
}