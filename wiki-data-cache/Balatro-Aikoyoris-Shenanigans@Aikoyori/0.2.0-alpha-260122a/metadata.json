{
  "locMap": {
    "b_akyrs_letter_deck": {
      "name": "Letter Deck",
      "text": [
        "Letters-Only Deck",
        "Letters give {C:mult}Mult{}",
        "{C:red}X#1#{} base Blind Size",
        "{C:red}+#2#{} Discards",
        "{C:attention}+#3#{} Hand Size"
      ],
      "type": "Back"
    },
    "b_akyrs_math_deck": {
      "name": "Math Deck",
      "text": [
        "Make Maths Expressions",
        "Get within {C:red,f:6}±{C:red}#1#%{}",
        "of the Blind Requirements",
        "Gain {C:akyrs_playable}+#3#{} selection per Ante"
      ],
      "type": "Back"
    },
    "b_akyrs_hardcore_challenges": {
      "name": "Hardcore Challenge Deck",
      "text": [
        ""
      ],
      "type": "Back"
    },
    "b_akyrs_scuffed_misprint": {
      "name": "Scuffed Misprint Deck",
      "text": [
        "Values of most cards",
        "are {C:attention}randomized{}",
        "{C:inactive}(From X#1# to X#2#)",
        "me vs the guy she tells you not to worry about"
      ],
      "type": "Back"
    },
    "b_akyrs_freedom": {
      "name": "Freedom Deck",
      "text": [
        "You can drag cards",
        "to place them anywhere."
      ],
      "type": "Back"
    },
    "b_akyrs_ultimate_freedom": {
      "name": "Ultimate Freedom Deck",
      "text": [
        "You can drag {E:1,C:attention}any{} cards",
        "to place them anywhere."
      ],
      "type": "Back"
    },
    "b_akyrs_split_deck": {
      "name": "Split Deck",
      "text": [
        "Start with all cards",
        "{C:attention}split{} in half",
        "{C:red}+#1#{} Discard"
      ],
      "type": "Back"
    },
    "b_akyrs_ranking_deck": {
      "name": "Ranking Deck",
      "text": [
        "Start with {C:attention}no suit",
        "{C:red}X#1#{} blind size"
      ],
      "type": "Back"
    },
    "b_akyrs_suitable_deck": {
      "name": "Suitable Deck",
      "text": [
        "Start with {C:attention}no ranks",
        "{C:red}X#1#{} blind size"
      ],
      "type": "Back"
    },
    "b_akyrs_inversion_deck": {
      "name": "Inversion Deck",
      "text": [
        "Card selection is {C:attention}inverted"
      ],
      "type": "Back"
    },
    "b_akyrs_down_deck": {
      "name": "Down Deck",
      "text": [
        "{C:attention}+#1#{} Joker Slots",
        "All Jokers are {C:attention}flipped face down{}",
        "before purchase"
      ],
      "type": "Back"
    },
    "b_akyrs_cry_misprint_ultima": {
      "name": "Ultima Misprint Deck",
      "text": [
        "Values of cards",
        "and poker hands",
        "are {C:attention}randomized{}",
        "{C:inactive}(From X#1# to X#2#)",
        "The challenge is to not crash the game."
      ],
      "type": "Back"
    },
    "b_akyrs_mega_letter_deck": {
      "name": "Mega Letter Deck",
      "text": [
        "Letter Deck",
        "but {C:blue}+#3#{} Hand Size",
        "you only have {C:red}1 hand{}",
        "{C:red}X#1#{} base Blind Size"
      ],
      "type": "Back"
    },
    "bl_akyrs_the_thought": {
      "name": "The Thought",
      "text": [
        "Solve 5-letter puzzle to win!"
      ],
      "type": "Blind"
    },
    "bl_akyrs_the_libre": {
      "name": "The Libre",
      "text": [
        "Disabling this boss",
        "Sets Blind Req. to #1#"
      ],
      "type": "Blind"
    },
    "bl_akyrs_the_picker": {
      "name": "The Picker",
      "text": [
        "X#2# Score Requirement when you",
        "change the given card selection"
      ],
      "type": "Blind"
    },
    "bl_akyrs_the_height": {
      "name": "The Height",
      "text": [
        "Score Requirement becomes X#1#",
        "your round score on non-final hands"
      ],
      "type": "Blind"
    },
    "bl_akyrs_the_expiry": {
      "name": "The Expiry",
      "text": [
        "All consumables are",
        "permanently debuffed"
      ],
      "type": "Blind"
    },
    "bl_akyrs_the_nature": {
      "name": "The Nature",
      "text": [
        "Face cards (both held and played)",
        "give X#1# Mult each"
      ],
      "type": "Blind"
    },
    "bl_akyrs_the_key": {
      "name": "The Key",
      "text": [
        "Played cards have a #1# in #2#",
        "chance to be forever selected"
      ],
      "type": "Blind"
    },
    "bl_akyrs_the_alignment": {
      "name": "The Alignment",
      "text": [
        "First and last played cards",
        "will not score"
      ],
      "type": "Blind"
    },
    "bl_akyrs_the_duality": {
      "name": "The Duality",
      "text": [
        "First and last played cards",
        "are debuffed"
      ],
      "type": "Blind"
    },
    "bl_akyrs_the_collapse": {
      "name": "The Collapse",
      "text": [
        "Money cannot change during the round"
      ],
      "type": "Blind"
    },
    "bl_akyrs_the_bonsai": {
      "name": "The Bonsai",
      "text": [
        "Face cards have #1# in #2# chance",
        "to not score"
      ],
      "type": "Blind"
    },
    "bl_akyrs_the_base": {
      "name": "The Base",
      "text": [
        "No retriggers"
      ],
      "type": "Blind"
    },
    "bl_akyrs_final_periwinkle_pinecone": {
      "name": "Periwinkle Pinecone",
      "text": [
        "Shuffle remaining cards",
        "and draw to hand after hand played"
      ],
      "type": "Blind"
    },
    "bl_akyrs_final_razzle_raindrop": {
      "name": "Razzle Raindrop",
      "text": [
        "Discard held in hand cards",
        "per unique suits played"
      ],
      "type": "Blind"
    },
    "bl_akyrs_final_velvet_vapour": {
      "name": "Velvet Vapour",
      "text": [
        "#1# in #2# chance for each card",
        "with the same rank as first",
        "played card to be discarded"
      ],
      "type": "Blind"
    },
    "bl_akyrs_final_chamomile_cloud": {
      "name": "Chamomile Cloud",
      "text": [
        "Discard all cards with",
        "a random suit every hand drawn"
      ],
      "type": "Blind"
    },
    "bl_akyrs_final_salient_stream": {
      "name": "Salient Stream",
      "text": [
        "Must alternate between",
        "Play and Discard"
      ],
      "type": "Blind"
    },
    "bl_akyrs_final_luminous_lemonade": {
      "name": "Luminous Lemonade",
      "text": [
        "Non-final Hands",
        "will not score"
      ],
      "type": "Blind"
    },
    "bl_akyrs_final_glorious_glaive": {
      "name": "Glorious Glaive",
      "text": [
        "X#1# Score per card played"
      ],
      "type": "Blind"
    },
    "bl_akyrs_final_lilac_lasso": {
      "name": "Lilac Lasso",
      "text": [
        "All but #1# Jokers randomly",
        "debuffed every hand"
      ],
      "type": "Blind"
    },
    "bl_akyrs_forgotten_weights_of_the_past": {
      "name": "Weights of the Past",
      "text": [
        "X#1# Ante per Card scored"
      ],
      "type": "Blind"
    },
    "bl_akyrs_forgotten_prospects_of_the_future": {
      "name": "Prospects of the Future",
      "text": [
        "+#1# Ante per Card held in hand"
      ],
      "type": "Blind"
    },
    "bl_akyrs_forgotten_uncertainties_of_life": {
      "name": "Uncertainties of Life",
      "text": [
        "-#1# hand size permanently after hand played"
      ],
      "type": "Blind"
    },
    "bl_akyrs_forgotten_inevitability_of_death": {
      "name": "Inevitability of Death",
      "text": [
        "Lose money at the end of the round",
        "By Final Score divided by Blind Requirement"
      ],
      "type": "Blind"
    },
    "bl_akyrs_expert_confrontation": {
      "name": "Confrontation",
      "text": [
        "Hand must include face cards"
      ],
      "type": "Blind"
    },
    "bl_akyrs_expert_fluctuation": {
      "name": "Fluctuation",
      "text": [
        "Randomly multiply score by",
        "between #1# and #2# before hand played"
      ],
      "type": "Blind"
    },
    "bl_akyrs_expert_straightforwardness": {
      "name": "Straightforwardness",
      "text": [
        "All Hands starts with",
        "#1#% base Chip and #2#% base Mult"
      ],
      "type": "Blind"
    },
    "bl_akyrs_expert_entanglement": {
      "name": "Entanglement",
      "text": [
        "All but one cards from each suit",
        "are drawn face down"
      ],
      "type": "Blind"
    },
    "bl_akyrs_expert_manuscript": {
      "name": "Manuscript",
      "text": [
        "Lose money per hand equal to",
        "played Poker Hand's Base Mult"
      ],
      "type": "Blind"
    },
    "bl_akyrs_expert_inflation": {
      "name": "Inflation",
      "text": [
        "Absurdly large blind"
      ],
      "type": "Blind"
    },
    "bl_akyrs_the_choice": {
      "name": "The Choice",
      "text": [
        "Played words must contain '#1#'"
      ],
      "type": "Blind"
    },
    "bl_akyrs_the_reject": {
      "name": "The Reject",
      "text": [
        "Played words must not contain '#1#'"
      ],
      "type": "Blind"
    },
    "bl_akyrs_the_redo": {
      "name": "The Redo",
      "text": [
        "Played words must not contain letter",
        "from last played words this Blind"
      ],
      "type": "Blind"
    },
    "bl_akyrs_the_reverse": {
      "name": "The Reverse",
      "text": [
        "Words must be played in reverse"
      ],
      "type": "Blind"
    },
    "bl_akyrs_master_faraway_island": {
      "name": "Faraway Island",
      "text": [
        "Hand must contain at least",
        "one card without suit or rank"
      ],
      "type": "Blind"
    },
    "bl_akyrs_master_plywood_forest": {
      "name": "Plywood Forest",
      "text": [
        "All cards held in hand",
        "are destroyed after hand scores"
      ],
      "type": "Blind"
    },
    "bl_akyrs_master_golden_jade": {
      "name": "Golden Jade",
      "text": [
        "X#1# your money per card scored"
      ],
      "type": "Blind"
    },
    "bl_akyrs_master_milk_crown_on_sonnetica": {
      "name": "Milk Crown on Sonnetica",
      "text": [
        "X#1# Score when a face card scores"
      ],
      "type": "Blind"
    },
    "bl_akyrs_master_bug": {
      "name": "BUG",
      "text": [
        "One random Joker destroyed",
        "after hand scores"
      ],
      "type": "Blind"
    },
    "bl_akyrs_the_bomb": {
      "name": "The Bomb",
      "text": [
        "Defuse the bomb!"
      ],
      "type": "Blind"
    },
    "bl_akyrs_the_stomata": {
      "name": "The Stomata",
      "text": [
        "-$1 per Face Card Scored"
      ],
      "type": "Blind"
    },
    "bl_akyrs_the_rhizome": {
      "name": "The Rhizome",
      "text": [
        "#1#X blind size when",
        "repeating already played hands"
      ],
      "type": "Blind"
    },
    "bl_akyrs_the_shrink": {
      "name": "The Shrink",
      "text": [
        "#1#X blind size every",
        "unique hand played"
      ],
      "type": "Blind"
    },
    "bl_akyrs_the_harmonic": {
      "name": "The Harmonic",
      "text": [
        "Randomly select one card to",
        "discard after any hand is drawn"
      ],
      "type": "Blind"
    },
    "bl_akyrs_the_sinusoidal": {
      "name": "The Sinusoidal",
      "text": [
        "Last 2 cards drawn are",
        "drawn face down"
      ],
      "type": "Blind"
    },
    "bl_akyrs_the_saw": {
      "name": "The Saw",
      "text": [
        "First scored card is destroyed"
      ],
      "type": "Blind"
    },
    "bl_akyrs_the_selfish": {
      "name": "The Selfish",
      "text": [
        "#1# in #2# of vowels",
        "are debuffed"
      ],
      "type": "Blind"
    },
    "bl_akyrs_the_polite": {
      "name": "The Polite",
      "text": [
        "Vowels will not score"
      ],
      "type": "Blind"
    },
    "bl_akyrs_the_bent": {
      "name": "The Bent",
      "text": [
        "Play a #1#",
        "#2# times"
      ],
      "type": "Blind"
    },
    "bl_akyrs_ultima_lost_umbrella": {
      "name": "Lost Umbrella",
      "text": [
        "All Jokers debuffed until",
        "#1# playing cards destroyed"
      ],
      "type": "Blind"
    },
    "dd_akyrs_wildcard_behaviour_1": {
      "name": "Wildcard Behaviour",
      "text": [
        "{C:attention}Automatic",
        "Automatically find a letter for wildcards",
        "which do not have letters set. (Default)."
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_wildcard_behaviour_2": {
      "name": "Wildcard Behaviour",
      "text": [
        "{C:attention}Force No Unset",
        "The play button will be disabled",
        "if you selected an unset wild card."
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_wildcard_behaviour_3": {
      "name": "Wildcard Behaviour",
      "text": [
        "{C:attention}Always Manual",
        "Wildcards do not have letter assigned to them by default.",
        "When played, will not attempt to find letters. (Can help with performance)"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_wildcard_behaviour_4": {
      "name": "Wildcard Behaviour",
      "text": [
        "{C:attention}Auto Set",
        "Automatically find a letter for wildcard and",
        "also set the letter automatically to the target if it is unset."
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_balance_settings": {
      "name": "Balance Settings",
      "text": [
        "{C:green,E:2}Adequate",
        "Balanced towards vanilla",
        "{C:red,E:1}Absurd{C:inactive} (Requires Talisman)",
        "Bigger Number, Crazier Effects,",
        "Direr Consequences"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_card_preview_tooltip": {
      "name": "Card Preview Tooltip",
      "text": [
        "Some cards have a small \"Preview\" window where the effect of the cards",
        "is demonstrated. If you are experiencing crashes after hovering a card",
        "turning this off might help"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_crt_shader_toggle": {
      "name": "CRT Shader",
      "text": [
        "Normally, the game {C:attention}always{} render CRT shader despite",
        "you turning it to 0 in settings which is why everything looks so saturated",
        "Turning this off means everything will be less saturated {C:inactive}(If you like the faded look)"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_full_dictionary": {
      "name": "Full Dictionary",
      "text": [
        "Use the full dictionary of {C:attention,E:1}500k{} entries instead of 50k entries",
        "From a lot of testing, full dictionary {C:attention}can{} cause quite a lag spike",
        "when playing large words but you will have a lot more word choices.",
        "Reduced dictionary meanwhile means that things like many {C:attention}plural forms{}",
        "won't be available. But is less likely to be laggy",
        "This also impacts {C:attention}The Bomb{} boss blinds' prompt choice"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_experimental_feature": {
      "name": "Experimental Features",
      "text": [
        "{s:1.5}Here be dragons!",
        "{s:1.4}If you have to think to enable it, {s:1.4,E:akyrs_shrivel,C:red}don't.",
        "Enable experimental features for the mod",
        "These may be broken, nonfunctional at all, or {C:red}outright brick your saves{}",
        "{C:inactive}(very unlikely but it can and will happen)",
        "This is mainly for my use so that I can release bugfixes",
        "for the mod while working on new content at the same time",
        "I will not stop you from enabling it but it is unfinished after all"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_maxwell_example": {
      "name": "Example",
      "text": [
        "{C:inactive,s:0.8}For example, Spelling {C:spectral,s:0.8}'Spectral'",
        "{C:inactive,s:0.8}gives you a {C:spectral,s:0.8}Spectral{C:inactive,s:0.8} Card"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_yona_yona_ex": {
      "name": "Visual Example",
      "text": [],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_2fa_example": {
      "name": "Example Hand",
      "text": [],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_credit_larantula": {
      "name": "Art Credit",
      "text": [
        "{X:dark_edition,C:white}@larantula_l{}"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_credit_gud": {
      "name": "Art Credit",
      "text": [
        "{X:dark_edition,C:white}@gudusername_53951{}"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_credit_lyman": {
      "name": "Art Credit",
      "text": [
        "{X:dark_edition,C:white}@lyman{}"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_hibana_conditions": {
      "name": "Cycle Option",
      "text": [
        "{X:dark_edition,C:white}1{} - Aces",
        "{X:dark_edition,C:white}2{} - Face Cards",
        "{X:dark_edition,C:white}3{} - Hearts",
        "{X:dark_edition,C:white}4{} - 5"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_tldr_tldr": {
      "name": "Too Long; Ain't reading allat",
      "text": [
        "{C:mult}+#1#{} Mult per card",
        "played and in hand"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_tldr_tldr_absurd": {
      "name": "Too Long; Ain't reading allat",
      "text": [
        "{C:white,X:mult} X#1# {} Mult"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_aikoyori_base_ability": {
      "name": "Steamodded & Lovely Ability",
      "text": [
        "{X:mult,C:white} X#1# {} Mult per",
        "{C;attention}non-face{} cards scored"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_aikoyori_base_ability_absurd": {
      "name": "Steamodded, Lovely & Talisman Ability",
      "text": [
        "{X:dark_edition,C:white} ^#1# {} Mult per",
        "{C;attention}non-face{} cards scored"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_aikoyori_cryptid_ability": {
      "name": "Cryptid Ability",
      "text": [
        "If hand only contains {C:attention}a single Ace{}",
        "Create a {C:dark_edition}Negative{} {C:green}Code{} card"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_aikoyori_more_fluff_ability": {
      "name": "More Fluff Ability",
      "text": [
        "Add {C:attention}1{} round to {C:colourcard}Colour Cards{}",
        "when they gain a round"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_aikoyori_entropy_ability": {
      "name": "Entropy Ability",
      "text": [
        "If {C:attention}full hand{} contains at least",
        "{C:attention}4{} cards of different rank and suit,",
        "create a {C:dark_edition}Negative{} {C:spectral}Flipside{}"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_aikoyori_sdmstuff_ability": {
      "name": "SDM_0's Stuff Ability",
      "text": [
        "If {C:attention}played hand{} contains",
        "a {C:attention}Full House{}, create a",
        "{C:dark_edition}Negative{} {C:attention}Bakery{} card"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_aikoyori_togasstuff_ability": {
      "name": "TOGA's Stuff Ability",
      "text": [
        "If you gain less than {C:money}$10{}",
        "at the end of the round,",
        "create a random Booster tag",
        "from {C:attention}TOGA's Stuff{}"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_cryptposting_ability": {
      "name": "Cryptposting Ability",
      "text": [
        "Create a {X:attention,E:1}Joker{} when",
        "Blind is skipped",
        "{C:inactive}(No room needed)"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_aikoyori_pta_ability": {
      "name": "Paya's Terrible Additions Ability",
      "text": [
        "Earn extra {C:blue}Pyroxenes{}",
        "equal to {C:money}money{} earned this round"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_placeholder_art": {
      "name": "Placeholder Art",
      "text": [
        "This card is using a",
        "{C:attention}Placeholder art.",
        "It will be changed later"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_prism_ability": {
      "name": "Prism Ability",
      "text": [
        "Create a Negative {C:attention}Myth Card{}",
        "if Hand doesn't contain a {C:attention}Flush"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_garbshit_ability": {
      "name": "GARBSHIT Ability",
      "text": [
        "Create a {C:dark_edition}Negative {C:attention}Stamp Card{}",
        "When a {C:attention}Joker{} is sold"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_finity_ability": {
      "name": "Finity Ability",
      "text": [
        "Create a {C:dark_edition}Negative {C:spectral}Finity{}",
        "When a {C:attention}Showdown{} Blind is defeated"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_bakery_ability": {
      "name": "Bakery Ability",
      "text": [
        "{C:dark_edition} +1 {}{C:attention} Charm{} available in shop{}"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_astronomica_ability": {
      "name": "Astronomica Ability",
      "text": [
        "{C:purple}Multiply score{} by",
        "number of cards played",
        "below hand size"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_vallkarri_ability": {
      "name": "Vall-Karri Ability",
      "text": [
        "Create a {C:dark_edition}Negative{} {C:attention}Aesthetic Card",
        "If {C:blue}Hands{} = {C:red}Discards{} after pressing play"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_grab_bag_ability": {
      "name": "Grab Bag Ability",
      "text": [
        "Create a {C:dark_edition}Negative{} {C:attention}Ephemeral Card",
        "When blind is selected"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_ortalab_ability": {
      "name": "Ortalab Ability",
      "text": [
        "Upgrade the {C:attention}corresponding{} poker hand",
        "When {C:attention}Zodiac{} cards are used"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_hotpot_ability": {
      "name": "Hot Potato Ability",
      "text": [
        "Earn {C:blue,f:hpot_plincoin}͸icks{} equal to",
        "{C:attention}ten{} times the final {C:chips}Chips{} in scoring"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_phanta_ability": {
      "name": "Phanta Ability",
      "text": [
        "If {C:attention}played hand{} contains",
        "a {C:attention}Four of a Kind{}, create a",
        "{C:dark_edition}Negative{} {C:attention}Hanafuda{} card"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_kino_ability": {
      "name": "Balatro Goes Kino Ability",
      "text": [
        "Create a {C:dark_edition}Negative{} {C:Confection}Confection{}",
        "when playing on {C:attention}odd{} number of {C:blue}hands",
        "{C:inactive}(Number before clicking play)"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_maximus_ability": {
      "name": "Maximus Ability",
      "text": [
        "When selling a {C:planet}Planet{} Card",
        "Create a {C:dark_edition}Negative{} {C:horoscope}Horoscope{}"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_sagatro_ability": {
      "name": "Sagatro Ability",
      "text": [
        "When selling a {C:tarot}Tarot{} Card",
        "Create a {C:dark_edition}Negative{} {C:sgt_divinatio}Divinatio{}"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_qualatro_ability": {
      "name": "Qualatro Ability",
      "text": [
        "{C:attention}Rip{} gains 1 {C:attention}Quality"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_mukuroju_en": {
      "name": "Mukuroju no Hakamori",
      "text": [
        "This Joker gains {X:mult,C:white} X#1# {} Mult",
        "per {C:tarot}The Star{} used",
        "{C:inactive}(Currently {X:mult,C:white} X#2# {C:inactive} Mult)"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_mukuroju_en_absurd": {
      "name": "Mukuroju no Hakamori",
      "text": [
        "This Joker {C:attention}octuples{} ({X:mult,C:white} X8 {})",
        "its {X:mult,C:white} XMult {} every time {C:tarot}The Star{} is used",
        "{C:inactive}(Currently {X:mult,C:white} X#1# {C:inactive} Mult)"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_nhh_cryptid": {
      "name": "If Cryptid is installed...",
      "text": [
        "Gives {X:dark_edition,C:white} ^#1# {} Mult instead"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_expert_blind": {
      "name": "Expert Blind",
      "text": [
        "Blind with higher",
        "difficulty than usual"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_master_blind": {
      "name": "Master Blind",
      "text": [
        "Blind with even higher",
        "difficulty level"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_ultima_blind": {
      "name": "Ultima Blind",
      "text": [
        "Extremely difficult blind",
        "{scale:0.7,C:inactive}(I feel like I've seen this somewhere)"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_remaster_blind": {
      "name": "Re:Master Blind",
      "text": [
        "Buffed version of existing blinds",
        "{scale:0.7,C:inactive}(I feel like I've seen this somewhere too)"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_lunatic_blind": {
      "name": "Lunatic Blind",
      "text": [
        "Even more difficult than Ultima Blinds",
        "{scale:0.7,C:inactive}(I feel like I've seen this somewhere as well)"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_dx_blind": {
      "name": "DX Blind",
      "text": [
        "Upgraded Ante 8 Blinds",
        "from More Fluff"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_no_reroll": {
      "name": "No Rerolling",
      "text": [
        "This blind cannot be rerolled"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_no_disabling": {
      "name": "No Disabling",
      "text": [
        "This blind cannot be disabled"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_no_overriding": {
      "name": "No Overriding",
      "text": [
        "This blind cannot be overridden",
        "until it's defeated"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_no_skipping": {
      "name": "No Skipping",
      "text": [
        "This blind cannot be skipped"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_forgotten_blind": {
      "name": "Forgotten Blind",
      "text": [
        "This blind can only appear",
        "in Negative Antes"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_word_blind": {
      "name": "Word Blind",
      "text": [
        "This blind can only appear",
        "when it is possible to",
        "play words"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_puzzle_blind": {
      "name": "Puzzle Blind",
      "text": [
        "This blind can only be defeated",
        "by completing certain criteria"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_postwin_blind": {
      "name": "Post Win Blind",
      "text": [
        "This blind appears on Antes",
        "above winning Ante"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_endless_blind": {
      "name": "Endless Blind",
      "text": [
        "This blind only appears",
        "in Endless Mode"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_kessoku_band": {
      "name": "{f:5}結束バンド {}(Kessoku Band)",
      "text": [
        "This Joker looks like it",
        "wants to {C:akyrs_bocchi}R{C:akyrs_kita}o{C:akyrs_nijika}c{C:akyrs_ryou}k{}!"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_copper_scrape_tip": {
      "name": "Scraping",
      "text": [
        "Fixed {C:green}10% chance{}",
        "to {C:attention}scrape{} off",
        "{C:attention}a layer{} of oxidation",
        "when a consumable is {C:attention}used{}"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_break_up_tip": {
      "name": "Pure Cards",
      "text": [
        "{C:attention}Pure Cards{} can form {C:attention}Pure Hands",
        "{C:attention}Pure Hands{} give more",
        "base {C:chips}Chips{} and {C:mult}Mult",
        "but can only be played if played hand",
        "only has {C:attention}Pure Cards{}",
        "For example, this is a {C:attention}Pure Flush{}"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_break_up_tip_no_preview": {
      "name": "Pure Cards",
      "text": [
        "{C:attention}Pure Cards{} can form {C:attention}Pure Hands",
        "{C:attention}Pure Hands{} give more",
        "base {C:chips}Chips{} and {C:mult}Mult",
        "but can only be played if played hand",
        "only has {C:attention}Pure Cards{}",
        "For example, you can make a {C:attention}Pure Flush{}",
        "with five {C:clubs}Pure Clubs{} card"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_letter_puzzle_umbral_expl": {
      "name": "Letter & Puzzle",
      "text": [
        "{C:attention}Combine{} both letters",
        "onto one card"
      ],
      "type": "DescriptionDummy"
    },
    "j_hatena": {
      "name": "????????",
      "text": [
        "This card is {C:attention}completely{} unknown",
        "{C:inactive}(and you will never know what it is)"
      ],
      "type": "DescriptionDummy"
    },
    "dd_akyrs_neon_seal_ex": {
      "name": "Example",
      "text": [
        "If you play {C:attention}3{} cards with this seal",
        "and hold {C:green}1{} card with this seal in hand",
        "it will create {C:green}1{} {C:akyrs_umbral_p,X:akyrs_umbral_y}Umbral{} Card",
        "{C:inactive}(The lesser number)"
      ],
      "type": "DescriptionDummy"
    },
    "e_akyrs_texelated": {
      "name": "Texelated",
      "text": [
        "{C:white,X:chips}X#1#{} Chips",
        "{C:white,X:mult}X#2#{} Mult"
      ],
      "type": "Edition"
    },
    "e_akyrs_noire_joker": {
      "name": "Noire",
      "text": [
        "{C:dark_edition}+#1#{} Joker Slots",
        "{C:white,X:mult}X#2#{} Mult"
      ],
      "type": "Edition"
    },
    "e_akyrs_noire_consumable": {
      "name": "Noire",
      "text": [
        "{C:dark_edition}+#1#{} Consumable Slots",
        "{C:white,X:mult}X#2#{} Mult"
      ],
      "type": "Edition"
    },
    "e_akyrs_noire_hand": {
      "name": "Noire",
      "text": [
        "{C:dark_edition}+#1#{} Hand Size",
        "{C:white,X:mult}X#2#{} Mult"
      ],
      "type": "Edition"
    },
    "e_akyrs_noire": {
      "name": "Noire",
      "text": [
        "{C:dark_edition}+#1#{} Maximum Slot Size",
        "{C:white,X:mult}X#2#{} Mult"
      ],
      "type": "Edition"
    },
    "e_akyrs_dyed": {
      "name": "Dyed",
      "text": [
        "{C:purple}+#1#{} Score",
        "Gain {C:purple}+#2#{} every trigger"
      ],
      "type": "Edition"
    },
    "e_akyrs_sliced": {
      "name": "Sliced",
      "text": [
        "{C:attention}Halves{} all values",
        "Effects calculate {C:attention}twice"
      ],
      "type": "Edition"
    },
    "e_akyrs_burnt": {
      "name": "Burnt",
      "text": [
        "{C:green}#1# in #2#{} chance",
        "of disintegrating into Ash",
        "at the end of the round"
      ],
      "type": "Edition"
    },
    "e_akyrs_enchanted": {
      "name": "Enchanted",
      "text": [
        "[WIP]"
      ],
      "type": "Edition"
    },
    "ench_akyrs_unbreaking": {
      "name": "Unbreaking",
      "text": [
        "When this card gets {C:attention}destroyed{}",
        "{C:attention}Fixed {C:green}#1#%{} chance to",
        "duplicate this card"
      ],
      "type": "Enchantment"
    },
    "ench_akyrs_effeciency": {
      "name": "Efficiency",
      "text": [
        "When this card gets {C:attention}destroyed{}",
        "{C:attention}Fixed {C:green}#1#%{} chance to",
        "duplicate this card"
      ],
      "type": "Enchantment"
    },
    "m_akyrs_brick_card": {
      "name": "Brick Card",
      "text": [
        "{C:mult}+#1#{} Mult",
        "No Rank or Suit"
      ],
      "type": "Enhanced"
    },
    "m_akyrs_scoreless": {
      "name": "Scoreless",
      "text": [
        "Does not score"
      ],
      "type": "Enhanced"
    },
    "m_akyrs_ash_card": {
      "name": "Ash Card",
      "text": [
        "{C:blue}+#1#{} Chips",
        "{C:green}#2# in #3#{} chance",
        "of disintegrating into nothing",
        "at the end of the round"
      ],
      "type": "Enhanced"
    },
    "m_akyrs_ash_card_absurd": {
      "name": "Ash Card",
      "text": [
        "{C:purple,X:edition} ^#1# {} Chips",
        "{C:attention}Always{} disintegrating into nothing",
        "at the end of the round"
      ],
      "type": "Enhanced"
    },
    "m_akyrs_hatena": {
      "name": "? Card",
      "text": [
        "{C:green}#1# in #2#{} chance to gain {C:money}$#3#",
        "{C:green}#4# in #5#{} chance to gain {C:money}$#6#",
        "{C:green}#7# in #8#{} chance to give {C:mult}+#9#{} Mult",
        "on initial scoring and {X:mult,C:white} X#10# {} on retriggers",
        "No rank, no suit, always scores"
      ],
      "type": "Enhanced"
    },
    "m_akyrs_item_box": {
      "name": "Item Box Card",
      "text": [
        "Create a {C:attention}random{}",
        "{C:tarot}consumable{} card when {C:attention}scored",
        "{C:inactive}(Must have room)",
        "{C:red,E:1}Self-destructs{} and the end of the round",
        "if successfully triggered",
        "No rank, no suit, always scores"
      ],
      "type": "Enhanced"
    },
    "m_akyrs_insolate_card": {
      "name": "Insolate Card",
      "text": [
        "This card gains {C:white,X:mult} X#1# {} Mult when played",
        "if played hand {C:attention}contains NO{} repeating {C:attention}enhancements",
        "{C:inactive}(Currently {C:white,X:mult} X#2# {C:inactive} Mult){}"
      ],
      "type": "Enhanced"
    },
    "m_akyrs_canopy_card": {
      "name": "Canopy Card",
      "text": [
        "Reduce the rank of this card by {C:attention}1{}",
        "if {C:attention}held in hand{} after scoring"
      ],
      "type": "Enhanced"
    },
    "m_akyrs_thai_tea_card": {
      "name": "Thai Tea Card",
      "text": [
        "{X:mult,C:white} X#1# {} Mult",
        "{C:inactive,s:0.8}The {s:0.8}absurd{C:inactive,s:0.8}ly good smell of it {s:0.8}alone",
        "{C:inactive,s:0.8}is sure to make any {s:0.8}Mouth{s:0.8} water{C:inactive,s:0.8}s"
      ],
      "type": "Enhanced"
    },
    "m_akyrs_matcha_card": {
      "name": "Matcha Card",
      "text": [
        "{X:chips,C:white} X#1# {} Chips"
      ],
      "type": "Enhanced"
    },
    "m_akyrs_earl_grey_tea_card": {
      "name": "Earl Grey Tea Card",
      "text": [
        "{C:money} +$#1#{} if this card is played",
        "but not scored"
      ],
      "type": "Enhanced"
    },
    "m_akyrs_zap_card": {
      "name": "Zap Card",
      "text": [
        "{C:attention}Duplicates{} itself",
        "without the enhancement",
        "every {C:attention}#1#{} {C:inactive}(#2#){} times",
        "this card scores"
      ],
      "type": "Enhanced"
    },
    "m_akyrs_net_card": {
      "name": "Net Card",
      "text": [
        "{C:white,X:mult}X#1#{} Mult",
        "when held in hand",
        "{C:money}#2#{} when held in hand",
        "at the end of the round"
      ],
      "type": "Enhanced"
    },
    "m_akyrs_droplet_card": {
      "name": "Droplet Card",
      "text": [
        "{C:green}#1# in #2#{} chance to give",
        "{C:red}+#3#{} Discard when discarded"
      ],
      "type": "Enhanced"
    },
    "m_akyrs_semibreve_card": {
      "name": "Semibreve Card",
      "text": [
        "{C:chips}+#1#{} Chips",
        "{C:mult}+#2#{} Mult"
      ],
      "type": "Enhanced"
    },
    "m_akyrs_minim_card": {
      "name": "Minim Card",
      "text": [
        "{C:white,X:chips}X#1#{} Chips",
        "{C:mult}+#2#{} Mult"
      ],
      "type": "Enhanced"
    },
    "m_akyrs_crotchet_card": {
      "name": "Crotchet Card",
      "text": [
        "{C:white,X:chips}X#1#{} Chips",
        "{C:white,X:mult}X#2#{} Mult"
      ],
      "type": "Enhanced"
    },
    "m_akyrs_wafer_card": {
      "name": "Wafer Card",
      "text": [
        "{C:white,X:purple}X#1#{} Score",
        "on first hand of round"
      ],
      "type": "Enhanced"
    },
    "j_akyrs_toga_charmap": {
      "name": "Character Map",
      "text": [
        "Create an Alphabet {C:attention}Alphabet{} card for the most",
        "common letter played if there's only {C:attention}one{} most common letter"
      ],
      "type": "Joker"
    },
    "j_akyrs_toga_winword": {
      "name": "Microsoft Word",
      "text": [
        "This Joker gains {X:mult,C:white} X#1# {} Mult",
        "per letter if a word is played",
        "{C:inactive}(Currently {X:mult,C:white} X#2# {C:inactive} Mult)"
      ],
      "type": "Joker"
    },
    "j_akyrs_redstone_repeater": {
      "name": "Redstone Repeater",
      "text": [
        "Swaps the current {C:white,X:mult} Mult {} value",
        "with the stored {C:mult}Mult",
        "then {C:white,X:mult} X#2# {} Mult",
        "Start with X {C:white,X:mult}   #3#   {} {C:mult}Mult{}",
        "{C:inactive}(Currently X {C:white,X:mult}   #1#   {} {C:mult}Mult{}{C:inactive}){}"
      ],
      "type": "Joker"
    },
    "j_akyrs_redstone_repeater_absurd": {
      "name": "Redstone Repeater",
      "text": [
        "Swaps the current {C:white,X:mult} Mult {} value",
        "with the stored {C:mult}Mult",
        "then {C:white,X:dark_edition} ^#2# {} Mult",
        "Start with X {C:white,X:mult}   #3#   {} {C:mult}Mult{}",
        "{C:inactive}(Currently X {C:white,X:mult}   #1#   {} {C:mult}Mult{}{C:inactive}){}"
      ],
      "type": "Joker"
    },
    "j_akyrs_observer": {
      "name": "Observer",
      "text": [
        "This Joker gains {C:mult}#1#{} Mult",
        "for every{C:attention} #4# {}times {C:inactive}(#3#)",
        "a card gets triggered.",
        "{s:0.8}Times needed increases by {C:attention}#5#{}",
        "{s:0.8}every time this Joker gains {C:mult}Mult{}",
        "{C:inactive}(Currently {C:mult}+#2#{C:inactive} Mult){}"
      ],
      "type": "Joker"
    },
    "j_akyrs_observer_absurd": {
      "name": "Observer",
      "text": [
        "This Joker gains {X:mult,C:white} X#1# {} Mult",
        "for every{C:attention} #4# {}times {C:inactive}(#3#)",
        "{C:chips}Chips{} or {C:mult}Mult{} value changes",
        "{s:0.8}Times needed increases by {C:attention}#5#{}",
        "{s:0.8}every time this Joker gains {X:mult,C:white}XMult{}",
        "{C:inactive}(Currently {X:mult,C:white} X#2# {C:inactive} Mult){}"
      ],
      "type": "Joker"
    },
    "j_akyrs_quasi_connectivity": {
      "name": "Quasi Connectivity",
      "text": [
        "{C:white,X:mult} X#1# {} Mult",
        "Disables one {C:attention}random Joker{}",
        "after a hand is played",
        "{s:0.8}Debuffs itself if it's",
        "{s:0.8}the sole card"
      ],
      "type": "Joker"
    },
    "j_akyrs_quasi_connectivity_absurd": {
      "name": "Quasi Connectivity",
      "text": [
        "{C:white,X:dark_edition} ^#1# {} Mult",
        "Disables two {C:attention}random Jokers{}",
        "after a hand is played",
        "{s:0.8}Debuffs itself if you have",
        "{s:0.8}2 Jokers or less"
      ],
      "type": "Joker"
    },
    "j_akyrs_diamond_pickaxe": {
      "name": "Diamond Pickaxe",
      "text": [
        "Siphons {C:chips}#2#{} Chips",
        "from every {C:attention}Stone{} Card scored",
        "and {C:attention}adds{} that amount to this Joker",
        "{C:inactive}(Remove Stone if card has no Chips left)",
        "{C:inactive}(Currently {C:chips}+#1#{C:inactive} Chips)"
      ],
      "type": "Joker"
    },
    "j_akyrs_diamond_pickaxe_absurd": {
      "name": "Diamond Pickaxe",
      "text": [
        "After a hand is played, turn {C:attention}all{} cards",
        "you held into {C:attention}Stone Card{}",
        "Gives {C:attention}#2#{} stacks of {C:chips}+#1#{} Chips",
        "for every {C:attention}Stone{} Card scored",
        "and change every scored {C:attention}Stone{} card",
        "to a random {C:attention}non-Stone Upgrades{}"
      ],
      "type": "Joker"
    },
    "j_akyrs_netherite_pickaxe": {
      "name": "Netherite Pickaxe",
      "text": [
        "Destroy played {C:attention}Stone{} Cards",
        "and gain {X:chips,C:white} X#2# {} Chips each Stone Card {C:attention}destroyed",
        "{C:inactive}(Currently {X:chips,C:white} X#1# {C:inactive} Chips){}"
      ],
      "type": "Joker"
    },
    "j_akyrs_netherite_pickaxe_absurd": {
      "name": "Netherite Pickaxe",
      "text": [
        "Turn {C:attention}all Discarded{} cards",
        "into {C:attention}Stone Cards{}",
        "Gains {C:attention}#2#{} stacks of {X:chips,C:white} X#1# {} Chips",
        "for every {C:attention}Stone{} Card scored",
        "{C:red,E:1}Destroy all scored",
        "{C:attention,E:1}Stone{C:red,E:1} cards afterwards",
        "{C:inactive}(Currently {X:chips,C:white} X#3# {C:inactive} Chips){}"
      ],
      "type": "Joker"
    },
    "j_akyrs_utage_charts": {
      "name": "Utage Charts",
      "text": [
        "{C:akyrs_playable}+#1#{} Card Selection"
      ],
      "type": "Joker"
    },
    "j_akyrs_maxwells_notebook": {
      "name": "Maxwell's Notebook",
      "text": [
        "Spelling the type of a card",
        "gives you {C:attention}one{} of that card",
        "Spelling enhancements enhance",
        "the {C:attention}scored card{} to the one you spelled",
        "{C:inactive}(Must have room)"
      ],
      "type": "Joker"
    },
    "j_akyrs_it_is_forbidden_to_dog": {
      "name": "It is forbidden to dog",
      "text": [
        "When this Joker scores",
        "debuffed cards held in hand each",
        "give {X:mult,C:white} X#1#{} Mult",
        "{C:inactive}(Due to technical limitations)",
        "A {C:attention}random{} card in hand is debuffed",
        "every hand {C:attention}drawn"
      ],
      "type": "Joker"
    },
    "j_akyrs_it_is_forbidden_to_dog_absurd": {
      "name": "It is forbidden to dog",
      "text": [
        "{C:attention}Unscored{} played cards",
        "give {X:dark_edition,C:white} ^#1#{} Mult each",
        "{C:attention}All{} unscored cards becomes {C:attention}Scoreless{}"
      ],
      "type": "Joker"
    },
    "j_akyrs_eat_pant": {
      "name": "eat pant",
      "text": [
        "If played hand contains exactly {C:attention}4{} cards",
        "{C:red}destroys first two played cards{} and loses",
        "{X:mult,C:white} 1/#2# {} of its current {X:mult,C:white}XMult{} {C:inactive}(cumulative)",
        "per card destroyed",
        "{C:inactive}(Currently {X:mult,C:white} X#3# {C:inactive} Mult)",
        "{C:inactive}(Can underflow below {X:mult,C:white} X1 {C:inactive})"
      ],
      "type": "Joker"
    },
    "j_akyrs_eat_pant_absurd": {
      "name": "eat pant",
      "text": [
        "If played hand contains a {C:attention}Two Pair{}",
        "This joker gains {X:mult,C:white} X#2# {} Mult for every scored card",
        "{C:red}Destroys all played cards{}",
        "{C:inactive}(Currently {X:mult,C:white} X#3# {C:inactive} Mult)"
      ],
      "type": "Joker"
    },
    "j_akyrs_tsunagite": {
      "name": "{f:5,C:akyrs_luminous}系ぎて",
      "text": [
        "Played cards permanently gain {X:mult,C:white} X#2#{} Mult",
        "if played cards' {C:chips}chips{} is divisible by {C:attention}#1#"
      ],
      "type": "Joker"
    },
    "j_akyrs_tsunagite_absurd": {
      "name": "{f:5,C:akyrs_luminous}系ぎて{}",
      "text": [
        "Gives value listed",
        "Joker gain the value listed",
        "When a {C:tarot,T:c_wheel_of_fortune}Wheel of Fortune{} is used",
        "{C:tarot,T:c_wheel_of_fortune}Wheel of Fortune{} always fails"
      ],
      "type": "Joker"
    },
    "j_akyrs_yona_yona_dance": {
      "name": "Yona Yona Dance",
      "text": [
        "Retrigger each played {C:attention}4{} and {C:attention}7{}",
        "{C:attention}#1#{} additional times",
        "{C:inactive,s:0.9,f:akyrs_MochiyPopOne}ならば踊らにゃ損、踊らにゃ損です!{}"
      ],
      "type": "Joker"
    },
    "j_akyrs_tldr_joker": {
      "name": "TL;DR Joker",
      "text": [
        "In the immersive and strategic world of {C:attention,E:1,s:1.5}Balatro{}, a distinctive role is played by this special joker card,",
        "equipped with a potent ability known as the '{C:mult}+#1#{} Mult.' This ability dramatically enhances a player's score",
        "under specific conditions, primarily centered around the presence of any {C:attention}High Card{} in the hand, which includes",
        "but is not limited to traditional {C:attention}high-ranking cards{} like {C:attention}Aces, Kings, Queens, and Jacks.{}",
        "Even then, the ability of this card goes further. But let's not get ahead of ourselves by going through with it before learning that",
        "{C:attention,E:1,s:1.5}Balatro{} expands the definition of scoring to include key strategic cards that heighten gameplay impact.",
        "This transformative {C:mult}multiplier{} is not just an advantage but a central aspect of strategic planning in {C:attention,E:1,s:1.5}Balatro{}.",
        "It compels players to consider their hand composition carefully, aiming to incorporate {C:attention}High Cards{} and maximize benefits.",
        "Delving into the history of gambling, card games have been a corner{C:tarot}stone{} of gaming culture for centuries.",
        "by {C:attention}activating for every card in hand and at play{}, this ability ensures you will gain a high score by merely playing a {C:attention}High Card{}.",
        "From the ancient {C:white,X:red,f:4}中国人{} who are credited with inventing playing cards in the {C:attention}9th century{} to the spread of card",
        "games across Europe during the {C:chips}Middle Ages{}, gambling has evolved into a sophisticated form of entertainment and strategy.",
        "The concept of {C:mult}multipliers{}, like the '{C:mult}+#1#{} Mult' in {C:attention,E:1,s:1.5}Balatro{}, echoes innovations in probability and risk-taking found",
        "throughout gambling history, where players sharpened their skills to navigate the {C:green}uncertainties of chance.{}",
        "These elements of chance and strategy create a rich tapestry of gameplay where players harness both their intuition and",
        "analytical abilities. The presence of the '{C:mult}+#1#{} Mult' deepens {C:attention,E:1,s:1.5}Balatro{}'s complexity, fostering a richly engaging",
        "environment where tactical decision-making is crucial. Players dynamically shift the game balance by leveraging the {C:mult}multiplier{},",
        "turning potential {C:chips}deficits{} into {C:dark_edition,E:1}commanding leads{}. Thus, the '{C:mult}+#1#{} Mult' feature isn't merely a rule but a critical",
        "strategic tool and an exhilarating element."
      ],
      "type": "Joker"
    },
    "j_akyrs_tldr_joker_absurd": {
      "name": "TL;DR Joker",
      "text": [
        "In the beginning, there was {C:attention,E:1,s:1.1}Balatro{} - not a deity, but something more complex - an ever-shuffling embodiment of {C:akyrs_playable}chaos{} wrapped in crisp, digital playing cards. The game exists",
        "in a liminal space between logic and {C:tarot}lunacy{}, math and mirage, where {C:green}probability{} becomes pliable and poker mutates into myth with each {C:blue}hand{}. In {C:attention,E:1,s:1.1}Balatro{}, one doesn’t merely {E:2,C:attention}play{}",
        "poker. One communes with the improbable. Here, {C:attention}straights{} stretch into the surreal, and {C:attention}flushes whisper forbidden geometry. {C:akyrs_playable}The{} deck is alive, vibrating with potential energy",
        "and pixelated menace, as every draw feels like yanking {C:attention}Ceremonial Dagger{} from a haunted {C:attention}Mega Buffoon Pack{}. And looming large above the fray is the pantheon of the unholy: the",
        "Jokers. They are not jesters; they are gods. Mathematical spirits dressed as {C:akyrs_playable}clown{}s. Each Joker bends the rules, breaks them, and sometimes eats them whole, fueling strategies",
        "built on hubris, spreadsheets, and primal instinct alike. Enter the {C:attention}TL;DR Joker{}, a Joker whispered of in halls of madness and theory: a rectangular rune inscribed with a",
        "singular prophecy: “{C:white,X:mult} X#1# {} Mult if hand contains a high card” It is simple. It is divine. It is arbitrarily brilliant. Why {C:white,X:mult} X#1# {}? Why not {C:white,X:mult} X1.19542 {} Mult? Or {C:white,X:mult} X638.95 {}? Or {C:white,X:mult,f:6} Xπ {}",
        "Mult? Because {C:white,X:mult} X#1# {} is the sacred number of drama. Because three is the number of the holy sprit,  {C:attention}face cards{}, triangles in triforce, wheels on tricycles. Because to look upon a",
        "hand and see a {C:attention}King{}, and be told, {C:attention,E:1}“You may multiply,”{} is to witness design at the intersection of {C:akyrs_playable}chaos{} theory and stylish arrogance. The {C:attention}TL;DR Joker{} does not beg for synergy.",
        "It {C:attention}demands{} reverence and vigilance. It turns high cards into sacred relics, their mere presence {C:spectral}summoning{} power. No longer are {C:attention}Jacks{} just teenage nobility in a velvet blazer of",
        "mid-value. Now they are conduits of cosmic {C:white,X:mult} XMult {}, bridges to {C:dark_edition}exponentia{}l escalation. And let us speak plainly of {C:attention}“high cards”{} - those royal specters of cardboard rank. The",
        "{C:attention}Jack{}, swaggering in adolescent cunning. The {C:attention}Queen{}, dangerous and divine. The {C:attention}King{}, a heavy-headed monarch wielding {C:attention}tax{} burdens and {C:white,X:mult} XMult {}ipliers alike. And the {C:attention}Ace{} -",
        "ambiguous, adaptable, alpha and omega, god-tier wildness incarnate. To draw one is {C:tarot}lucky{}. To play one is strategy. To combine one with {C:attention}TL;DR Joker{} is to summon an equation so",
        "violent, it punches through the spreadsheet matrix. It’s not just a combo. It’s a lifestyle. A statement. A mathematical swagger. Decks warp around it. You start seeking",
        "{C:attention}royalty{} not out of vanity, but devotion. The {C:hearts}hearts{} beat faster. The {C:spades}spades{} dig deeper. The {C:diamonds}diamonds{} glint with purpose. Even the {C:clubs}clubs{}, usually so brutish, now {C:attention}shimmer{} with",
        "refined potential. Every draw becomes a prayer: please, let it be a {C:attention}Queen{}. Or a {C:attention}King{}. Or her {C:attention}Jack{}. Because even if the poker hand is garbage, a single face card sanctifies it.",
        "{C:attention,E:1,s:1.1}Balatro{} becomes not a game of best hands, but of best {C:attention}conditions{} for value. A trash hand with a King is not trash - it’s a {C:white,X:mult} X#1# {}-fueled engine of consequence. Let us now wander",
        "backward in time - centuries before Jokers, before {C:attention,E:1,s:1.1}Balatro{}, before silicon and CPUs - back to 9th century {C:white,X:red,f:4}中国{}, where {C:attention}playing cards{} began. There, amid scrolls and shadow puppets,",
        "the corner{C:tarot}stone{} of gaming was born. The uncertainty of paper, the dance of fate inked in {C:attention}characters{} and calligraphy. In that world, {C:green}luck{} was not an {C:attention}adversary{} - it was an",
        "{C:attention}elemental truth{}. {C:green}Dice{} were cast not for control, but for communion with the unknown. Chance was worshipped as a muse, not solved as a math problem. And so too, in {C:attention,E:1,s:1.1}Balatro{}, do",
        "we feel this ancient reverence for uncertainty. The {C:attention}TL;DR Joker{}, in its modern mask, is ancestor to those ancient principles. It is the phoenix feather embedded in a digital",
        "deck, the whisper of dynasties. It reminds us that no matter how far we've come - from silk cards to OLED screens - we are still haunted and humbled by the {C:green}uncertainties of",
        "chance{}. So when we draw a {C:attention}high card{}, and {C:attention}TL;DR Joker{} flickers into being, we do not merely multiply - we {C:attention}invoke{} the ancient. The timeless. The chaotic. We become both",
        "strategist and supplicant, mathematician and {C:red}myst{}ic. The run ends. The screen fades. The Joker remains. {C:attention}TL;DR Joker{}. {C:attention}High cards{}. High stakes. High living. It is not just a",
        "mechanic. It is a metaphor. {C:attention,E:1,s:1.1}Balatro{} teaches that success is built not only on full hands, but on full {C:hearts}hearts{}. Sometimes, all it takes is a King - and a Joker who notices"
      ],
      "type": "Joker"
    },
    "j_akyrs_reciprocal_joker": {
      "name": "Reciprocal Joker",
      "text": [
        "Set {X:mult,C:white}Mult{} to",
        "{X:chips,C:white}Chips{} divided by {X:mult,C:white}Mult{}"
      ],
      "type": "Joker"
    },
    "j_akyrs_reciprocal_joker_absurd": {
      "name": "Reciprocal Joker",
      "text": [
        "Set {X:chips,C:white}Chips{} to",
        "{X:mult,C:white}Mult{} divided by {X:chips,C:white}Chips{}"
      ],
      "type": "Joker"
    },
    "j_akyrs_kyoufuu_all_back": {
      "name": "Kyoufuu All Back",
      "text": [
        "Return previously {C:attention}played and discarded",
        "{C:attention and played{} cards back to deck"
      ],
      "type": "Joker"
    },
    "Partner": {
      "name": "smol Aiko",
      "text": [
        "Retrigger {C:attention}every{} card {C:attention}#1#{} times"
      ],
      "type": "Joker"
    },
    "Akyrs_Dialog": {
      "name": "",
      "text": [
        "Hello! Thank you and Welcome to {E:akyrs_rainbow_wiggle}Aikoyori's Shenanigans{}",
        "I am {E:2,C:dark_edition}Aikoyori{} and I will guide you through",
        "some necessary settings. Let's get started!"
      ],
      "type": "Joker"
    },
    "Other": {
      "name": "Self-Destructive",
      "text": [
        "{C:red}Self-Destructs{}",
        "at the end of the round"
      ],
      "type": "Joker"
    },
    "Planet": {
      "name": "Ara",
      "text": [
        "{S:0.8}({S:0.8,V:1}lvl.#1#{S:0.8}){} Level up",
        "{C:attention}#2#",
        "{C:mult}+#3#{} Mult and",
        "{C:chips}+#4#{} chips"
      ],
      "type": "Joker"
    },
    "Spectral": {
      "name": "",
      "text": [],
      "type": "Joker"
    },
    "Stake": {
      "name": "Copper Stake",
      "text": [
        "Cards can have {C:attention}Oxidising{} Sticker",
        "{s:0.8}Applies White Stake"
      ],
      "type": "Joker"
    },
    "Tag": {
      "name": "Tag that spells Tag",
      "text": [
        "Gives a free",
        "{C:blue}Mega Alphabet Pack"
      ],
      "type": "Joker"
    },
    "Tarot": {
      "name": "The Wheel of Fortune (Modified)",
      "text": [
        "Does not do anything."
      ],
      "type": "Joker"
    },
    "Voucher": {
      "name": "Alphabet Soup",
      "text": [
        "{C:attention}Letters{} appear on playing cards",
        "Words can be made with playing cards",
        "{C:akyrs_playable}+#1#{} Card Selection"
      ],
      "type": "Joker"
    },
    "AikoyoriExtraBases": {
      "name": "Null",
      "text": [
        "A simple and blank card",
        "with nothing on it"
      ],
      "type": "Joker"
    },
    "Sleeve": {
      "name": "Letter Sleeve",
      "text": [
        "Start with {C:red}Letters{} Enabled"
      ],
      "type": "Joker"
    },
    "Umbral": {
      "name": "Graduate",
      "text": [
        "Creates the last",
        "{C:akyrs_umbral_p,X:akyrs_umbral_y} Umbral {} card",
        "used during this run",
        "{s:0.8,C:akyrs_umbral_p,X:akyrs_umbral_y} Graduate {s:0.8} excluded"
      ],
      "type": "Joker"
    },
    "Replicant": {
      "name": "Forecast",
      "text": [
        "Receive up to {C:attention}#1#{}",
        "{C:akyrs_replicant_o}Replicant{} Cards",
        "{C:inactive}(Room must be accounted for)"
      ],
      "type": "Joker"
    },
    "achievement_names": {
      "name": "",
      "text": [],
      "type": "misc"
    },
    "achievement_descriptions": {
      "name": "",
      "text": [],
      "type": "misc"
    },
    "blind_states": {
      "name": "",
      "text": [],
      "type": "misc"
    },
    "akyrs_balancing_wizard": {
      "name": "",
      "text": [],
      "type": "misc"
    },
    "challenge_names": {
      "name": "",
      "text": [],
      "type": "misc"
    },
    "hardcore_challenge_names": {
      "name": "",
      "text": [],
      "type": "misc"
    },
    "collabs": {
      "name": "",
      "text": [],
      "type": "misc"
    },
    "dictionary": {
      "name": "",
      "text": [],
      "type": "misc"
    },
    "high_scores": {
      "name": "",
      "text": [],
      "type": "misc"
    },
    "labels": {
      "name": "",
      "text": [],
      "type": "misc"
    },
    "quips": {
      "name": "",
      "text": [],
      "type": "misc"
    },
    "ranks": {
      "name": "",
      "text": [],
      "type": "misc"
    },
    "suits_plural": {
      "name": "",
      "text": [],
      "type": "misc"
    },
    "suits_singular": {
      "name": "",
      "text": [],
      "type": "misc"
    },
    "tutorial": {
      "name": "",
      "text": [],
      "type": "misc"
    },
    "v_dictionary": {
      "name": "",
      "text": [],
      "type": "misc"
    },
    "v_text": {
      "name": "",
      "text": [],
      "type": "misc"
    }
  },
  "atlases": {
    "AikoyoriJokers": {
      "path": "AikoyoriJokers.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-260122a/AikoyoriJokers.png",
      "resolvedGitHubPath": "assets/1x/AikoyoriJokers.png"
    },
    "guestJokerArts": {
      "path": "guestJokerArts.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-260122a/guestJokerArts.png",
      "resolvedGitHubPath": "assets/1x/guestJokerArts.png"
    },
    "lettersStickers": {
      "path": "lettersStickers.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-260122a/lettersStickers.png",
      "resolvedGitHubPath": "assets/1x/lettersStickers.png"
    },
    "aikoyoriStickers": {
      "path": "aikoyoriStickersAndSeals.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-260122a/aikoyoriStickersAndSeals.png",
      "resolvedGitHubPath": "assets/1x/aikoyoriStickersAndSeals.png"
    },
    "cardUpgrades": {
      "path": "cardUpgrades.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-260122a/cardUpgrades.png",
      "resolvedGitHubPath": "assets/1x/cardUpgrades.png"
    },
    "deckBacks": {
      "path": "deckBacks.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-260122a/deckBacks.png",
      "resolvedGitHubPath": "assets/1x/deckBacks.png"
    },
    "consumablesAlphabetPacks": {
      "path": "consumablesAlphabetPacks.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-260122a/consumablesAlphabetPacks.png",
      "resolvedGitHubPath": "assets/1x/consumablesAlphabetPacks.png"
    },
    "aikoConstellationCards": {
      "path": "aikoConstellationCards.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-260122a/aikoConstellationCards.png",
      "resolvedGitHubPath": "assets/1x/aikoConstellationCards.png"
    },
    "aikoyoriBoosterPack": {
      "path": "aikoyoriBoosterPack.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-260122a/aikoyoriBoosterPack.png",
      "resolvedGitHubPath": "assets/1x/aikoyoriBoosterPack.png"
    },
    "aikoyoriBlindsChips": {
      "path": "aikoyoriBlindsChips.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-260122a/aikoyoriBlindsChips.png",
      "resolvedGitHubPath": "assets/1x/aikoyoriBlindsChips.png"
    },
    "aikoyoriBlindsChips2": {
      "path": "aikoyoriBlindsChips2.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-260122a/aikoyoriBlindsChips2.png",
      "resolvedGitHubPath": "assets/1x/aikoyoriBlindsChips2.png"
    },
    "aikoyoriVouchers": {
      "path": "aikoyoriVouchers.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-260122a/aikoyoriVouchers.png",
      "resolvedGitHubPath": "assets/1x/aikoyoriVouchers.png"
    },
    "aikoyoriSleeves": {
      "path": "aikoSleeves.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-260122a/aikoSleeves.png",
      "resolvedGitHubPath": "assets/1x/aikoSleeves.png"
    },
    "aikoyoriMiscIcons": {
      "path": "aikoyoriMiscIcons.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-260122a/aikoyoriMiscIcons.png",
      "resolvedGitHubPath": "assets/1x/aikoyoriMiscIcons.png"
    },
    "aikoyori_credits": {
      "path": "aikoyoriP.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-260122a/aikoyoriP.png",
      "resolvedGitHubPath": "assets/1x/aikoyoriP.png"
    },
    "aikoyoriTags": {
      "path": "aikoyoriTags.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-260122a/aikoyoriTags.png",
      "resolvedGitHubPath": "assets/1x/aikoyoriTags.png"
    },
    "misc_overlay": {
      "path": "misc_overlay.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-260122a/misc_overlay.png",
      "resolvedGitHubPath": "assets/1x/misc_overlay.png"
    },
    "aikoSelfInsert": {
      "path": "aikoSelfInsert.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-260122a/aikoSelfInsert.png",
      "resolvedGitHubPath": "assets/1x/aikoSelfInsert.png"
    },
    "togasstuff_crossmod": {
      "path": "crossmod/togasstuff.png",
      "px": 0,
      "py": 0,
      "resolvedGitHubPath": "assets/1x/crossmod/togasstuff.png"
    },
    "blank": {
      "path": "blank.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-260122a/blank.png",
      "resolvedGitHubPath": "assets/1x/blank.png"
    },
    "18blank": {
      "path": "blank.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-260122a/blank.png",
      "resolvedGitHubPath": "assets/1x/blank.png"
    },
    "special_suit_icon": {
      "path": "specialsuiticons.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-260122a/specialsuiticons.png",
      "resolvedGitHubPath": "assets/1x/specialsuiticons.png"
    },
    "villager": {
      "path": "villager.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-260122a/villager.png",
      "resolvedGitHubPath": "assets/1x/villager.png"
    },
    "aikoyori_intro": {
      "path": "aikoyoriintro.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-260122a/aikoyoriintro.png",
      "resolvedGitHubPath": "assets/1x/aikoyoriintro.png"
    },
    "umbra": {
      "path": "aikoUmbraTarot.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-260122a/aikoUmbraTarot.png",
      "resolvedGitHubPath": "assets/1x/aikoUmbraTarot.png"
    },
    "umbra_undisc": {
      "path": "undiscoveredUmbra.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-260122a/undiscoveredUmbra.png",
      "resolvedGitHubPath": "assets/1x/undiscoveredUmbra.png"
    },
    "rank_suit_cards": {
      "path": "ranksuitCards.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-260122a/ranksuitCards.png",
      "resolvedGitHubPath": "assets/1x/ranksuitCards.png"
    },
    "aikoPlanets": {
      "path": "aikoPlanetCards.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-260122a/aikoPlanetCards.png",
      "resolvedGitHubPath": "assets/1x/aikoPlanetCards.png"
    },
    "aikoStakes": {
      "path": "aikoyoriStakes.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-260122a/aikoyoriStakes.png",
      "resolvedGitHubPath": "assets/1x/aikoyoriStakes.png"
    },
    "aikoStakeStickers": {
      "path": "aikoyoriStakeStickers.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-260122a/aikoyoriStakeStickers.png",
      "resolvedGitHubPath": "assets/1x/aikoyoriStakeStickers.png"
    },
    "eggymariHatenaSprite": {
      "path": "eggymariHatenaSprite.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-260122a/eggymariHatenaSprite.png",
      "resolvedGitHubPath": "assets/1x/eggymariHatenaSprite.png"
    },
    "furina": {
      "path": "furina.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-260122a/furina.png",
      "resolvedGitHubPath": "assets/1x/furina.png"
    },
    "pressf": {
      "path": "pressf.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-260122a/pressf.png",
      "resolvedGitHubPath": "assets/1x/pressf.png"
    },
    "misc_icons": {
      "path": "misc_icons.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-260122a/misc_icons.png",
      "resolvedGitHubPath": "assets/1x/misc_icons.png"
    },
    "replicant": {
      "path": "aikoReplicancyCard.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-260122a/aikoReplicancyCard.png",
      "resolvedGitHubPath": "assets/1x/aikoReplicancyCard.png"
    },
    "replicant_undisc": {
      "path": "undiscoveredReplicancy.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-260122a/undiscoveredReplicancy.png",
      "resolvedGitHubPath": "assets/1x/undiscoveredReplicancy.png"
    },
    "larantula_l_credits": {
      "path": "credits/larantula_l.png",
      "px": 0,
      "py": 0,
      "resolvedGitHubPath": "assets/1x/credits/larantula_l.png"
    },
    "drmonty_credits": {
      "path": "credits/drmonty.png",
      "px": 0,
      "py": 0,
      "resolvedGitHubPath": "assets/1x/credits/drmonty.png"
    },
    "gud_credits": {
      "path": "credits/gud.png",
      "px": 0,
      "py": 0,
      "resolvedGitHubPath": "assets/1x/credits/gud.png"
    },
    "lyman_credits": {
      "path": "credits/lyman.png",
      "px": 0,
      "py": 0,
      "resolvedGitHubPath": "assets/1x/credits/lyman.png"
    },
    "plasma_credits": {
      "path": "credits/plasma.png",
      "px": 0,
      "py": 0,
      "resolvedGitHubPath": "assets/1x/credits/plasma.png"
    },
    "mystery": {
      "path": "mystery.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-260122a/mystery.png",
      "resolvedGitHubPath": "assets/1x/mystery.png"
    },
    "paperback_pure": {
      "path": "crossmod/paperbackPure.png",
      "px": 0,
      "py": 0,
      "resolvedGitHubPath": "assets/1x/crossmod/paperbackPure.png"
    },
    "aikoPartners": {
      "path": "aikoPartners.png",
      "px": 0,
      "py": 0,
      "localPath": "/wiki-data/Balatro-Aikoyoris-Shenanigans@Aikoyori/0.2.0-alpha-260122a/aikoPartners.png",
      "resolvedGitHubPath": "assets/1x/aikoPartners.png"
    }
  },
  "cards": [
    {
      "type": "Atlas",
      "key": "AikoyoriJokers",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"AikoyoriJokers\",\r\n    path = \"AikoyoriJokers.png\",\r\n    px = 71,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "guestJokerArts",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"guestJokerArts\",\r\n    path = \"guestJokerArts.png\",\r\n    px = 71,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "lettersStickers",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"lettersStickers\",\r\n    path = \"lettersStickers.png\",\r\n    px = 71,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "aikoyoriStickers",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"aikoyoriStickers\",\r\n    path = \"aikoyoriStickersAndSeals.png\",\r\n    px = 71,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "cardUpgrades",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"cardUpgrades\",\r\n    path = \"cardUpgrades.png\",\r\n    px = 71,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "deckBacks",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"deckBacks\",\r\n    path = \"deckBacks.png\",\r\n    px = 71,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "consumablesAlphabetPacks",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"consumablesAlphabetPacks\",\r\n    path = \"consumablesAlphabetPacks.png\",\r\n    px = 71,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "aikoConstellationCards",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"aikoConstellationCards\",\r\n    path = \"aikoConstellationCards.png\",\r\n    px = 71,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "aikoyoriBoosterPack",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"aikoyoriBoosterPack\",\r\n    path = \"aikoyoriBoosterPack.png\",\r\n    px = 71,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "aikoyoriBlindsChips",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"aikoyoriBlindsChips\",\r\n    path = \"aikoyoriBlindsChips.png\",\r\n    px = 34,\r\n    py = 34,\r\n    atlas_table = 'ANIMATION_ATLAS',\r\n    frames = 21,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "aikoyoriBlindsChips2",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"aikoyoriBlindsChips2\",\r\n    path = \"aikoyoriBlindsChips2.png\",\r\n    px = 34,\r\n    py = 34,\r\n    atlas_table = 'ANIMATION_ATLAS',\r\n    frames = 21,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "aikoyoriVouchers",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"aikoyoriVouchers\",\r\n    path = \"aikoyoriVouchers.png\",\r\n    px = 71,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "aikoyoriSleeves",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"aikoyoriSleeves\",\r\n    path = \"aikoSleeves.png\",\r\n    px = 73,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "aikoyoriMiscIcons",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"aikoyoriMiscIcons\",\r\n    path = \"aikoyoriMiscIcons.png\",\r\n    px = 34,\r\n    py = 34",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "aikoyori_credits",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"aikoyori_credits\",\r\n    path = \"aikoyoriP.png\",\r\n    px = 320,\r\n    py = 320",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "aikoyoriTags",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"aikoyoriTags\",\r\n    path = \"aikoyoriTags.png\",\r\n    px = 34,\r\n    py = 34",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "misc_overlay",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"misc_overlay\",\r\n    path = \"misc_overlay.png\",\r\n    px = 71,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "aikoSelfInsert",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"aikoSelfInsert\",\r\n    path = \"aikoSelfInsert.png\",\r\n    px = 71,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "modicon",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"modicon\",\r\n    path = \"aikoyoriModIcon.png\",\r\n    px = 32,\r\n    py = 32",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "togasstuff_crossmod",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"togasstuff_crossmod\",\r\n    path = \"crossmod/togasstuff.png\",\r\n    px = 72,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "blank",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"blank\",\r\n    path = \"blank.png\",\r\n    px = 71,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "18blank",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"18blank\",\r\n    path = \"blank.png\",\r\n    px = 18,\r\n    py = 18",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "special_suit_icon",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"special_suit_icon\",\r\n    path = \"specialsuiticons.png\",\r\n    px = 18,\r\n    py = 18",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "villager",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'villager',\r\n    path = 'villager.png',\r\n    px = 111,\r\n    py = 161",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "aikoyori_intro",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'aikoyori_intro',\r\n    path = 'aikoyoriintro.png',\r\n    px = 114,\r\n    py = 174",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "umbra",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"umbra\",\r\n    path = \"aikoUmbraTarot.png\",\r\n    px = 71,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "umbra_undisc",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"umbra_undisc\",\r\n    path = \"undiscoveredUmbra.png\",\r\n    px = 71,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "rank_suit_cards",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"rank_suit_cards\",\r\n    path = \"ranksuitCards.png\",\r\n    px = 71,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "aikoPlanets",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"aikoPlanets\",\r\n    path = \"aikoPlanetCards.png\",\r\n    px = 71,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "aikoStakes",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"aikoStakes\",\r\n    path = \"aikoyoriStakes.png\",\r\n    px = 29,\r\n    py = 29",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "aikoStakeStickers",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"aikoStakeStickers\",\r\n    path = \"aikoyoriStakeStickers.png\",\r\n    px = 71,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "eggymariHatenaSprite",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"eggymariHatenaSprite\",\r\n    path = \"eggymariHatenaSprite.png\",\r\n    px = 71,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "furina",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"furina\",\r\n    path = \"furina.png\",\r\n    px = 71,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "pressf",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"pressf\",\r\n    path = \"pressf.png\",\r\n    px = 71,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "misc_icons",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"misc_icons\",\r\n    path = \"misc_icons.png\",\r\n    px = 18,\r\n    py = 18",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "replicant",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"replicant\",\r\n    path = \"aikoReplicancyCard.png\",\r\n    px = 71,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "replicant_undisc",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"replicant_undisc\",\r\n    path = \"undiscoveredReplicancy.png\",\r\n    px = 71,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "larantula_l_credits",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"larantula_l_credits\",\r\n    path = \"credits/larantula_l.png\",\r\n    px = 400,\r\n    py = 400",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "drmonty_credits",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"drmonty_credits\",\r\n    path = \"credits/drmonty.png\",\r\n    px = 576,\r\n    py = 576",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "gud_credits",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"gud_credits\",\r\n    path = \"credits/gud.png\",\r\n    px = 379,\r\n    py = 379",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "lyman_credits",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"lyman_credits\",\r\n    path = \"credits/lyman.png\",\r\n    px = 128,\r\n    py = 128",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "plasma_credits",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"plasma_credits\",\r\n    path = \"credits/plasma.png\",\r\n    px = 600,\r\n    py = 600",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "mystery",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"mystery\",\r\n    path = \"mystery.png\",\r\n    px = 320,\r\n    py = 320",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Shader",
      "key": "texelated",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"texelated\",\r\n    path = \"texelated.fs\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Shader",
      "key": "noire",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"noire\",\r\n    path = \"noire.fs\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Shader",
      "key": "sliced",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"sliced\",\r\n    path = \"sliced.fs\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Shader",
      "key": "trimmed_flame",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"trimmed_flame\",\r\n    path = \"trimmed_flame.fs\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Shader",
      "key": "magenta_tint",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"magenta_tint\",\r\n    path = \"magenta_letter_tint.fs\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Shader",
      "key": "burnt",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"burnt\",\r\n    path = \"burnt.fs\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Shader",
      "key": "enchanted",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"enchanted\",\r\n    path = \"enchanted.fs\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Shader",
      "key": "color_shift",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"color_shift\",\r\n    path = \"color_shift.fs\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Shader",
      "key": "aiko_splash",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"aiko_splash\",\r\n    path = \"aiko_splash.fs\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Shader",
      "key": "dyed",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"dyed\",\r\n    path = \"dyed.fs\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Rank",
      "key": "non_playing",
      "name": null,
      "atlas": "blank",
      "pos": null,
      "raw": "key = \"non_playing\",\r\n    card_key = \"SP\",\r\n    pos = { x = 0 },\r\n    lc_atlas = 'blank',\r\n    hc_atlas = 'blank',\r\n    nominal = 0,\r\n    suit_map = {\r\n        akyrs_joker = 0\r\n    },\r\n    shorthand = \"-\",\r\n    strength_effect = {\r\n        ignore = true\r\n    },\r\n    in_pool = function (self, args)\r\n        return false\r\n    end,\r\n    inject = function(self)\r\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Suit",
      "key": "joker",
      "name": null,
      "atlas": "blank",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"joker\",\r\n    card_key = \"j\",\r\n    pos = { y = 0 },\r\n    ui_pos = { x = 0, y = 0 },\r\n    akyrs_hidden = true,\r\n    lc_atlas = 'blank',\r\n    hc_atlas = 'blank',\r\n    lc_ui_atlas  = 'special_suit_icon',\r\n    hc_ui_atlas  = 'special_suit_icon',\r\n    \r\n    inject = function(self)\r\n        --SMODS.inject_p_card(self, SMODS.Ranks[l.key])\r\n    end,\r\n    lc_colour = AKYRS.C.JOKER_LC,\r\n    hc_colour = AKYRS.C.JOKER_HC,\r\n    in_pool = function (self, args)\r\n        return false\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Suit",
      "key": "consumable",
      "name": null,
      "atlas": "blank",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"consumable\",\r\n    card_key = \"c\",\r\n    pos = { y = 0 },\r\n    ui_pos = { x = 1, y = 0 },\r\n    akyrs_hidden = true,\r\n    lc_atlas = 'blank',\r\n    hc_atlas = 'blank',\r\n    lc_ui_atlas  = 'special_suit_icon',\r\n    hc_ui_atlas  = 'special_suit_icon',\r\n    \r\n    inject = function(self)\r\n        --SMODS.inject_p_card(self, SMODS.Ranks[l.key])\r\n    end,\r\n    lc_colour = AKYRS.C.CONSU_LC,\r\n    hc_colour = AKYRS.C.CONSU_HC,\r\n    in_pool = function (self, args)\r\n        return false\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Suit",
      "key": "booster",
      "name": null,
      "atlas": "blank",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"booster\",\r\n    card_key = \"b\",\r\n    pos = { y = 0 },\r\n    ui_pos = { x = 2, y = 0 },\r\n    akyrs_hidden = true,\r\n    lc_atlas = 'blank',\r\n    hc_atlas = 'blank',\r\n    lc_ui_atlas  = 'special_suit_icon',\r\n    hc_ui_atlas  = 'special_suit_icon',\r\n    \r\n    inject = function(self)\r\n        --SMODS.inject_p_card(self, SMODS.Ranks[l.key])\r\n    end,\r\n    lc_colour = AKYRS.C.BOOST_LC,\r\n    hc_colour = AKYRS.C.BOOST_HC,\r\n    in_pool = function (self, args)\r\n        return false\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Suit",
      "key": "voucher",
      "name": null,
      "atlas": "blank",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"voucher\",\r\n    card_key = \"v\",\r\n    pos = { y = 0 },\r\n    ui_pos = { x = 3, y = 0 },\r\n    akyrs_hidden = true,\r\n    lc_atlas = 'blank',\r\n    hc_atlas = 'blank',\r\n    lc_ui_atlas  = 'special_suit_icon',\r\n    hc_ui_atlas  = 'special_suit_icon',\r\n    \r\n    inject = function(self)\r\n        --SMODS.inject_p_card(self, SMODS.Ranks[l.key])\r\n    end,\r\n    lc_colour = AKYRS.C.VOUCH_LC,\r\n    hc_colour = AKYRS.C.VOUCH_HC,\r\n    in_pool = function (self, args)\r\n        return false\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Suit",
      "key": "thing",
      "name": null,
      "atlas": "blank",
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "key = \"thing\",\r\n    card_key = \"th\",\r\n    pos = { y = 0 },\r\n    ui_pos = { x = 4, y = 0 },\r\n    akyrs_hidden = true,\r\n    lc_atlas = 'blank',\r\n    hc_atlas = 'blank',\r\n    lc_ui_atlas  = 'special_suit_icon',\r\n    hc_ui_atlas  = 'special_suit_icon',\r\n    \r\n    inject = function(self)\r\n        --SMODS.inject_p_card(self, SMODS.Ranks[l.key])\r\n    end,\r\n    lc_colour = AKYRS.C.THING_LC,\r\n    hc_colour = AKYRS.C.THING_HC,\r\n    in_pool = function (self, args)\r\n        return false\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Gradient",
      "key": "akyrs_mod_title",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"akyrs_mod_title\",\r\n    colours = {\r\n        HEX(\"ef4444\"),\r\n        HEX(\"eab308\"),\r\n        HEX(\"2dd4bf\"),\r\n    },\r\n    cycle = 5",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Gradient",
      "key": "akyrs_unset_letter",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"akyrs_unset_letter\",\r\n    colours = {\r\n        G.C.GREEN,\r\n        G.C.BLUE,\r\n        G.C.RED,\r\n    },\r\n    cycle = 1",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Gradient",
      "key": "akyrs_luminous",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"akyrs_luminous\",\r\n    colours = {\r\n        HEX(\"ff71b1\"),\r\n        HEX(\"48a2ff\"),\r\n        HEX(\"f29d2e\"),\r\n    },\r\n    cycle = 10",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Gradient",
      "key": "akyrs_glorious",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"akyrs_glorious\",\r\n    colours = {\r\n        HEX(\"47cbff\"),\r\n        HEX(\"a98dda\"),\r\n        HEX(\"ff58bb\"),\r\n    },\r\n    cycle = 10",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Gradient",
      "key": "akyrs_money_x",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"akyrs_money_x\",\r\n    colours = {\r\n        HEX(\"ffea29\"),\r\n        HEX(\"6e914a\"),\r\n        HEX(\"319137\"),\r\n    },\r\n    cycle = 10",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Gradient",
      "key": "akyrs_money_c",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"akyrs_money_c\",\r\n    colours = {\r\n        HEX(\"319137\"),\r\n        HEX(\"ffea29\"),\r\n        HEX(\"bfe34b\"),\r\n    },\r\n    cycle = 10",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Gradient",
      "key": "akyrs_money_c",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"akyrs_money_c\",\r\n    colours = {\r\n        HEX(\"319137\"),\r\n        HEX(\"ffea29\"),\r\n    },\r\n    cycle = 10",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "cry_misprint_ultima",
      "name": null,
      "atlas": "deckBacks",
      "pos": {
        "x": 6,
        "y": 0
      },
      "raw": "key = \"cry_misprint_ultima\",\r\n        atlas = \"deckBacks\",\r\n        pos = { x = 6, y = 0},\r\n        config = { cry_misprint_min = 1e-4, cry_misprint_max = 1e4 },\r\n        set_badges = function (self, card, badges)\r\n            SMODS.create_mod_badges({ mod = Cryptid }, badges)\r\n        end,\r\n        loc_vars = function (self, info_queue, card)\r\n            return {\r\n                vars = {\r\n                    self.config.cry_misprint_min,\r\n                    self.config.cry_misprint_max\r\n                }\r\n            }\r\n        end,\r\n        apply = function(self)\r\n            G.GAME.modifiers.cry_misprint_min = (G.GAME.modifiers.cry_misprint_min or to_big(1)) * self.config.cry_misprint_min\r\n            G.GAME.modifiers.cry_misprint_max = (G.GAME.modifiers.cry_misprint_max or to_big(1)) * self.config.cry_misprint_max\r\n        end,",
      "config": {
        "cry_misprint_min": 0.0001,
        "cry_misprint_max": 10000
      },
      "ability": {
        "cry_misprint_min": 0.0001,
        "cry_misprint_max": 10000
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "paperback_pure",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"paperback_pure\",\n        path = \"crossmod/paperbackPure.png\",\n        px = 71,\n        py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "aikoPartners",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"aikoPartners\",\r\n        path = \"aikoPartners.png\",\r\n        px = 46,\r\n        py = 58",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "toga_charmap",
      "name": null,
      "atlas": "togasstuff_crossmod",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"toga_charmap\",\r\n        atlas = \"togasstuff_crossmod\",\r\n        rarity = 1,\r\n        cost = 3,\r\n        pos = { x = 0, y = 0},\r\n        in_pool = function (self, args)\r\n            return G.GAME.akyrs_character_stickers_enabled\r\n        end,\r\n        set_badges = function (self, card, badges)\r\n            if self.discovered then SMODS.create_mod_badges({ mod = togabalatro },badges) end\r\n        end,\r\n        config = {\r\n            extras = { money = 1 }\r\n        },\r\n        blueprint_compat = true,\r\n        calculate = function (self, card, context)\r\n            if context.joker_main and G.GAME.akyrs_character_stickers_enabled then\r\n                local w = AKYRS.get_letter_freq_from_cards(G.play.cards)\r\n                local max_freq = 0\r\n                local most_common_letter = nil\r\n                for letter, freq in pairs(w) do\r\n                    if freq > max_freq then\r\n                        max_freq = freq\r\n                        most_common_letter = letter\r\n                    elseif freq == max_freq then\r\n                        most_common_letter = nil -- Tie, no single most common letter\r\n                    end\r\n                end\r\n                if most_common_letter then\r\n                    return {\r\n                        func = function ()\r\n                            if AKYRS.has_room(G.consumeables) then\r\n                                SMODS.add_card({area = G.consumeables, set = 'Alphabet', key = 'c_akyrs_alphabet_'..most_common_letter})\r\n                            end\r\n                        end\r\n                    }\r\n                end\r\n            end\r\n        end",
      "config": {
        "extras": {
          "money": 1
        }
      },
      "ability": {
        "extras": {
          "money": 1
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "toga_winword",
      "name": null,
      "atlas": "togasstuff_crossmod",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"toga_winword\",\r\n        atlas = \"togasstuff_crossmod\",\r\n        pos = { x = 1, y = 0},\r\n        in_pool = function (self, args)\r\n            return G.GAME.akyrs_character_stickers_enabled\r\n        end,\r\n        set_badges = function (self, card, badges)\r\n            if self.discovered then SMODS.create_mod_badges({ mod = togabalatro },badges) end\r\n        end,\r\n        loc_vars = function (self, info_queue, card)\r\n            return {\r\n                vars = {\r\n                    card.ability.extras.xmult_gain,\r\n                    card.ability.extras.xmult\r\n                }\r\n            }\r\n        end,\r\n        rarity = 3,\r\n        cost = 8,\r\n        config = {\r\n            extras = { xmult_gain = 0.1992, xmult = 1 }\r\n        },\r\n        calculate = function (self, card, context)\r\n            if context.individual and context.cardarea == G.play then\r\n                if G.GAME.aiko_current_word and not context.blueprint then\r\n                    return {\r\n                        message = localize(\"k_upgrade_ex\"),\r\n                        func = function ()\r\n                            card.ability.extras.xmult = card.ability.extras.xmult + card.ability.extras.xmult_gain\r\n                        end\r\n                    }\r\n                end\r\n            end\r\n            if context.joker_main then\r\n                return {\r\n                    xmult = card.ability.extras.xmult\r\n                }\r\n            end\r\n        end,\r\n        blueprint_compat = true",
      "config": {
        "extras": {
          "xmult_gain": 0.1992,
          "xmult": 1
        }
      },
      "ability": {
        "extras": {
          "xmult_gain": 0.1992,
          "xmult": 1
        }
      },
      "vars": [
        0.1992,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Achievement",
      "key": "spell_aikoyori",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"spell_aikoyori\",\n    hidden_name = false,\n    hidden_text = true,\n    bypass_all_unlocked = true,\n    unlock_condition = function (self, args)\n        if args and (args.type == \"akyrs_spell_word\" and args.lowercase_word == \"aikoyori\") then\n            return true\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Achievement",
      "key": "happy_ghast_grown",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"happy_ghast_grown\",\n    bypass_all_unlocked = true,\n    unlock_condition = function (self, args)\n        if args and (args.type == \"akyrs_happy_ghast_grown_from_dried\") then\n            return true\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Achievement",
      "key": "repeater_into_another_one",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"repeater_into_another_one\",\n    bypass_all_unlocked = true,\n    unlock_condition = function (self, args)\n        if args and (args.type == \"akyrs_repeater_into_another_one\") then\n            return true\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Achievement",
      "key": "repeater_into_another_one",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"repeater_into_another_one\",\n    bypass_all_unlocked = true,\n    unlock_condition = function (self, args)\n        if args and (args.type == \"akyrs_repeater_into_another_one\") then\n            return true\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Achievement",
      "key": "both_pickaxe",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"both_pickaxe\",\n    bypass_all_unlocked = true,\n    unlock_condition = function (self, args)\n        if args and (args.type == \"akyrs_both_pickaxe\") then\n            return true\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Achievement",
      "key": "win_klondike",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"win_klondike\",\n    bypass_all_unlocked = true,\n    unlock_condition = function (self, args)\n        if args and (args.type == \"akyrs_win_solitaire\") then\n            return true\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Achievement",
      "key": "spell_very_long_word",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"spell_very_long_word\",\n    bypass_all_unlocked = true,\n    unlock_condition = function (self, args)\n        if args and (args.type == \"akyrs_spell_valid_word\" and (very_long_words[args.lowercase_word] or string.len(args.lowercase_word) >= 25)) then\n            return true\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Achievement",
      "key": "spell_long_word",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"spell_long_word\",\n    bypass_all_unlocked = true,\n    unlock_condition = function (self, args)\n        if args and (args.type == \"akyrs_spell_valid_word\" and string.len(args.lowercase_word) >= 12) then\n            return true\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Achievement",
      "key": "we_no_speak_americano",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"we_no_speak_americano\",\n    bypass_all_unlocked = true,\n    unlock_condition = function (self, args)\n        if args and (args.type == \"win\") then\n            if G.GAME.akyrs_has_not_spelled_a_single_word then\n                return true\n            end\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Achievement",
      "key": "resist_the_temptation",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"resist_the_temptation\",\n    bypass_all_unlocked = true,\n    unlock_condition = function (self, args)\n        if args and (args.type == \"win\") then\n            if G.GAME.akyrs_temptation_resisted then\n                return true\n            end\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Achievement",
      "key": "thatll_be_5_wheat",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"thatll_be_5_wheat\",\n    bypass_all_unlocked = true,\n    unlock_condition = function (self, args)\n        if args and (args.type == \"full_emerald_in_slot\") then\n            return true\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Achievement",
      "key": "div_0_math",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"div_0_math\",\n    bypass_all_unlocked = true,\n    hidden_name = false,\n    hidden_text = true,\n    unlock_condition = function (self, args)\n        if args and (args.type == \"akyrs_division_by_zero\") then\n            return true\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Achievement",
      "key": "average_daily_scrandle",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"average_daily_scrandle\",\n    bypass_all_unlocked = true,\n    unlock_condition = function (self, args)\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Achievement",
      "key": "literally_cryptid",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"literally_cryptid\",\n    bypass_all_unlocked = true,\n    unlock_condition = function (self, args)\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "UndiscoveredSprite",
      "key": "Alphabet",
      "name": null,
      "atlas": "consumablesAlphabetPacks",
      "pos": {
        "x": 6,
        "y": 2
      },
      "raw": "atlas = \"consumablesAlphabetPacks\",\r\n    key = \"Alphabet\",\r\n    pos = {x = 6, y = 2}",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "ConsumableType",
      "key": "Alphabet",
      "name": null,
      "atlas": "consumablesAlphabetPacks",
      "pos": null,
      "raw": "atlas = \"consumablesAlphabetPacks\",\r\n    key = \"Alphabet\",\r\n    primary_colour = HEX(\"747482\"),\r\n    secondary_colour = HEX(\"3e63c2\"),\r\n    collection_rows = {6,6,6},\r\n    shop_rate = 0,\r\n    default = \"c_akyrs_alphabet_a\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "alphabet_",
      "name": null,
      "atlas": "consumablesAlphabetPacks",
      "pos": null,
      "raw": "key = \"alphabet_\"..v,\r\n        set = \"Alphabet\",\r\n        atlas = 'consumablesAlphabetPacks',\r\n        pos = { x = math.fmod(k-1,20), y = math.floor((k-1)/20) } ,\r\n        loc_vars = function(self, info_queue, card)\r\n            info_queue[#info_queue+1] = {key = 'letters'..string.upper(card.ability.extra.letter), set = 'AikoyoriExtraBases' ,vars = {\r\n                card.ability.extra.letter,\r\n                (AKYRS.get_scrabble_score(card.ability.extra.letter)),\r\n                1 + (AKYRS.get_scrabble_score(card.ability.extra.letter)/10),\r\n            }}\r\n            return {\r\n                vars = {\r\n                    string.upper(card.ability.extra.letter),\r\n                },\r\n            }\r\n        end,\r\n        \r\n        config = {extra = {letter = v, max_selected = 999999}},\r\n        \r\n        can_use = function(self, card)\r\n            return #G.hand.highlighted > 0\r\n        end,\r\n        use = function(self, card, area, copier)\r\n            for i=1, #G.hand.highlighted do\r\n                local percent = math.abs(1.15 - (i-0.999)/(#G.hand.highlighted-0.998)*0.3)\r\n                G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.15,func = function() G.hand.highlighted[i]:flip();play_sound('card1', percent);G.hand.highlighted[i]:juice_up(0.3, 0.3);return true end }))\r\n            end\r\n            \r\n            delay(0.5)\r\n            \r\n            for i=1, #G.hand.highlighted do\r\n                local percent = math.abs(0.85 + (i-0.999)/(#G.hand.highlighted-0.998)*0.3)\r\n                G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.15,func = function()\r\n                    G.hand.highlighted[i]:set_letters(card.ability.extra.letter)\r\n                    G.hand.highlighted[i]:flip();play_sound('tarot2', percent, 0.6);G.hand.highlighted[i]:juice_up(0.3, 0.3);return true end }))\r\n            end\r\n        end,\r\n        in_pool = function(self, args)\r\n            return G.GAME.akyrs_character_stickers_enabled\r\n        end,",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "alphabet_wild",
      "name": null,
      "atlas": "consumablesAlphabetPacks",
      "pos": {
        "x": 6,
        "y": 1
      },
      "raw": "key = \"alphabet_wild\",\r\n    set = \"Alphabet\",\r\n    atlas = 'consumablesAlphabetPacks',\r\n    pos = { x = 6, y = 1 } ,\r\n    cost = 6,\r\n    loc_vars = function(self, info_queue, card)\r\n        info_queue[#info_queue+1] = {key = 'letters'..string.upper(card.ability.extra.letter), set = 'AikoyoriExtraBases' ,vars = {\r\n            card.ability.extra.letter,\r\n            (AKYRS.get_scrabble_score(card.ability.extra.letter)),\r\n            1 + (AKYRS.get_scrabble_score(card.ability.extra.letter)/10),\r\n        }}\r\n        return {\r\n            vars = {\r\n                string.upper(card.ability.extra.letter),\r\n                card.ability.extra.max_selected,\r\n            },\r\n        }\r\n    end,\r\n    config = {extra = {letter = \"#\", max_selected = 1}},\r\n    \r\n    can_use = function(self, card)\r\n        return #G.hand.highlighted <= card.ability.extra.max_selected and #G.hand.highlighted > 0\r\n    end,\r\n    use = function(self, card, area, copier)\r\n        for i=1, #G.hand.highlighted do\r\n            local percent = math.abs(1.15 - (i-0.999)/(#G.hand.highlighted-0.998)*0.3)\r\n            G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.15,func = function() G.hand.highlighted[i]:flip();play_sound('card1', percent);G.hand.highlighted[i]:juice_up(0.3, 0.3);return true end }))\r\n        end\r\n        \r\n        delay(0.5)\r\n        \r\n        for i=1, #G.hand.highlighted do\r\n            local percent = math.abs(0.85 + (i-0.999)/(#G.hand.highlighted-0.998)*0.3)\r\n            G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.15,func = function()\r\n                G.hand.highlighted[i]:set_letters(card.ability.extra.letter)\r\n                G.hand.highlighted[i]:flip();play_sound('tarot2', percent, 0.6);G.hand.highlighted[i]:juice_up(0.3, 0.3);return true end }))\r\n        end\r\n    end,\r\n    in_pool = function(self, args)\r\n        return G.GAME.akyrs_character_stickers_enabled\r\n    end,",
      "config": {
        "extra": {
          "letter": "#",
          "max_selected": 1
        }
      },
      "ability": {
        "extra": {
          "letter": "#",
          "max_selected": 1
        }
      },
      "vars": [
        null,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "letter_deck",
      "name": "Letter Deck",
      "atlas": "deckBacks",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"letter_deck\",\n    name = \"Letter Deck\",\n    atlas = 'deckBacks',\n    pos = {x = 0, y = 0},\n    loc_vars = function (self, info_queue, card)\n        return { vars = {\n            self.config.ante_scaling,\n            self.config.discards,\n            self.config.hand_size\n        } }\n    end,\n    config = {\n        akyrs_starting_letters = AKYRS.scrabble_letters,\n        starting_deck_size = 100,\n        akyrs_selection = 1e100,\n        discards = 2,\n        akyrs_wording_enabled = true,\n        akyrs_start_with_no_cards = true,\n        akyrs_letters_mult_enabled = true,\n        akyrs_hide_normal_hands = true,\n        ante_scaling = 2,\n        hand_size = 2,\n        vouchers = {'v_akyrs_alphabet_soup','v_akyrs_crossing_field'}\n    },",
      "config": {},
      "ability": {},
      "vars": [
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "mega_letter_deck",
      "name": "Mega Letter Deck",
      "atlas": "deckBacks",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"mega_letter_deck\",\n    name = \"Mega Letter Deck\",\n    atlas = 'deckBacks',\n    pos = {x = 3, y = 0},\n    loc_vars = function (self, info_queue, card)\n        return { vars = {\n            self.config.ante_scaling,\n            self.config.discards,\n            self.config.hand_size\n        } }\n    end,\n    config = {\n        akyrs_starting_letters = AKYRS.scrabble_letters,\n        starting_deck_size = 100,\n        akyrs_selection = 1e100,\n        discards = 2,\n        akyrs_wording_enabled = true,\n        akyrs_start_with_no_cards = true,\n        akyrs_letters_mult_enabled = true,\n        akyrs_hide_normal_hands = true,\n        ante_scaling = 40,\n        hand_size = 25,\n        vouchers = {'v_akyrs_alphabet_soup','v_akyrs_crossing_field'}\n    },\n    apply = function (self, back)\n        G.GAME.starting_params.hands = 1\n        G.GAME.round_resets.hands = 1\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "math_deck",
      "name": "Math Deck",
      "atlas": "deckBacks",
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "key = \"math_deck\",\n    name = \"Math Deck\",\n    atlas = 'deckBacks',\n    pos = {x = 4, y = 0},\n    loc_vars = function (self, info_queue, card)\n        return { vars = {\n            self.config.akyrs_math_threshold,\n            5 + self.config.akyrs_selection,\n            self.config.akyrs_gain_selection_per_ante\n        } }\n    end,\n    config = {\n        akyrs_starting_letters = AKYRS.math_deck_characters,\n        akyrs_start_with_no_cards = true,\n        akyrs_mathematics_enabled = true,\n        akyrs_character_stickers_enabled = true,\n        akyrs_no_skips = true,\n        akyrs_selection = 0,\n        akyrs_gain_selection_per_ante = 1,\n        discards = 1,\n        --akyrs_always_skip_shops = true,\n        akyrs_math_threshold = 1,\n        hand_size = 6,\n        akyrs_power_of_x_scaling = 13.69,\n        akyrs_hide_normal_hands = true,\n        akyrs_hide_high_card = true,\n        akyrs_hand_to_not_hide = {[\"akyrs_expression\"] = true,[\"akyrs_modification\"] = true },\n        akyrs_random_scale = {min = 0.5, max = 9.5},\n    },",
      "config": {},
      "ability": {},
      "vars": [
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "hardcore_challenges",
      "name": "Hardcore Challenge Deck",
      "atlas": "deckBacks",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"hardcore_challenges\",\n    name = \"Hardcore Challenge Deck\",\n    atlas = 'deckBacks',\n    pos = {x = 3, y = 1},\n    omit = true,\n    draw = function (self, card, layer)\n        \n    end,\n    config = {\n    },",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "scuffed_misprint",
      "name": null,
      "atlas": "deckBacks",
      "pos": {
        "x": 7,
        "y": 0
      },
      "raw": "key = \"scuffed_misprint\",\n        atlas = \"deckBacks\",\n        pos = { x = 7, y = 0},\n        config = { akyrs_misprint_min = 1e-4, akyrs_misprint_max = 1e4 },\n        set_badges = function (self, card, badges)\n        end,\n        loc_vars = function (self, info_queue, card)\n            --info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_placeholder_art\"}\n            return {\n                vars = {\n                    self.config.akyrs_misprint_min,\n                    self.config.akyrs_misprint_max\n                }\n            }\n        end,\n        apply = function(self)\n            G.GAME.modifiers.akyrs_misprint = true\n        end,",
      "config": {
        "akyrs_misprint_min": 0.0001,
        "akyrs_misprint_max": 10000
      },
      "ability": {
        "akyrs_misprint_min": 0.0001,
        "akyrs_misprint_max": 10000
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "freedom",
      "name": null,
      "atlas": "deckBacks",
      "pos": {
        "x": 8,
        "y": 0
      },
      "raw": "key = \"freedom\",\n    atlas = \"deckBacks\",\n    pos = { x = 8, y = 0},\n    config = { akyrs_any_drag = true },\n    set_badges = function (self, card, badges)\n    end,\n    loc_vars = function (self, info_queue, card)\n    end,",
      "config": {
        "akyrs_any_drag": true
      },
      "ability": {
        "akyrs_any_drag": true
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "ultimate_freedom",
      "name": null,
      "atlas": "deckBacks",
      "pos": {
        "x": 9,
        "y": 0
      },
      "raw": "key = \"ultimate_freedom\",\n    atlas = \"deckBacks\",\n    pos = { x = 9, y = 0},\n    config = { akyrs_any_drag = true, akyrs_ultimate_freedom = true },\n    set_badges = function (self, card, badges)\n    end,\n    loc_vars = function (self, info_queue, card)\n    end,",
      "config": {
        "akyrs_any_drag": true,
        "akyrs_ultimate_freedom": true
      },
      "ability": {
        "akyrs_any_drag": true,
        "akyrs_ultimate_freedom": true
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "ranking_deck",
      "name": "Ranking Deck",
      "atlas": "deckBacks",
      "pos": {
        "x": 4,
        "y": 1
      },
      "raw": "key = \"ranking_deck\",\n    name = \"Ranking Deck\",\n    atlas = 'deckBacks',\n    pos = {x = 4, y = 1},\n    loc_vars = function (self, info_queue, card)\n        return {\n            vars = {\n                self.config.ante_scaling\n            }\n        }\n    end,\n    config = {\n        akyrs_split_rank_deck = true,\n        ante_scaling = 2.5,\n    },",
      "config": {
        "akyrs_split_rank_deck": true,
        "ante_scaling": 2.5
      },
      "ability": {
        "akyrs_split_rank_deck": true,
        "ante_scaling": 2.5
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "suitable_deck",
      "name": "Suitable Deck",
      "atlas": "deckBacks",
      "pos": {
        "x": 5,
        "y": 1
      },
      "raw": "key = \"suitable_deck\",\n    name = \"Suitable Deck\",\n    atlas = 'deckBacks',\n    pos = {x = 5, y = 1},\n    loc_vars = function (self, info_queue, card)\n        return {\n            vars = {\n                self.config.ante_scaling\n            }\n        }\n    end,\n    config = {\n        akyrs_split_suit_deck = true,\n        ante_scaling = 1.5,\n    },",
      "config": {
        "akyrs_split_suit_deck": true,
        "ante_scaling": 1.5
      },
      "ability": {
        "akyrs_split_suit_deck": true,
        "ante_scaling": 1.5
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "split_deck",
      "name": "Split Deck",
      "atlas": "deckBacks",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"split_deck\",\n    name = \"Split Deck\",\n    atlas = 'deckBacks',\n    pos = {x = 2, y = 1},\n    loc_vars = function (self, info_queue, card)\n        return {\n            vars = {\n                self.config.discards\n            }\n        }\n    end,\n    config = {\n        akyrs_split_deck = true, discards = 2\n    },",
      "config": {
        "akyrs_split_deck": true,
        "discards": 2
      },
      "ability": {
        "akyrs_split_deck": true,
        "discards": 2
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "inversion_deck",
      "name": "Inversion Deck",
      "atlas": "deckBacks",
      "pos": {
        "x": 6,
        "y": 1
      },
      "raw": "key = \"inversion_deck\",\n    name = \"Inversion Deck\",\n    atlas = 'deckBacks',\n    pos = {x = 6, y = 1},\n    loc_vars = function (self, info_queue, card)\n        return {\n        }\n    end,\n    config = {\n        akyrs_inversion_deck = true,\n    },",
      "config": {
        "akyrs_inversion_deck": true
      },
      "ability": {
        "akyrs_inversion_deck": true
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "down_deck",
      "name": "Down Deck",
      "atlas": "deckBacks",
      "pos": {
        "x": 8,
        "y": 1
      },
      "raw": "key = \"down_deck\",\n    name = \"Down Deck\",\n    atlas = 'deckBacks',\n    pos = {x = 8, y = 1},\n    loc_vars = function (self, info_queue, card)\n        return {\n            vars = {\n                self.config.joker_slot\n            }\n        }\n    end,\n    config = {\n        joker_slot = 1,\n        akyrs_down_deck = true,\n    },",
      "config": {
        "joker_slot": 1,
        "akyrs_down_deck": true
      },
      "ability": {
        "joker_slot": 1,
        "akyrs_down_deck": true
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "the_choice",
      "name": null,
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"the_choice\",\r\n    dollars = 5,\r\n    mult = 2,\r\n    boss_colour = HEX(\"918b8b\"),\r\n    atlas = 'aikoyoriBlindsChips',\r\n    debuff = {\r\n        akyrs_is_word_blind = true,\r\n    },\r\n    boss = {min = 3, max = 10},\r\n    pos = { x = 0, y = 1 },\r\n    in_pool = function(self)\r\n        return (G.GAME.akyrs_character_stickers_enabled and G.GAME.akyrs_wording_enabled)\r\n    end,\r\n    loc_vars = function (self)\r\n        return {\r\n            vars = {\r\n                string.upper(G.GAME.akyrs_letter_target)\r\n            }\r\n        }\r\n    end,\r\n    debuff_hand = function (self, cards, hand, handname, check)\r\n        if not G.GAME.akyrs_character_stickers_enabled or self.disabled then return false end\r\n        for i, v in ipairs(cards) do\r\n            local l = string.upper(v:get_letter_with_pretend())\r\n            if l and l == string.upper(G.GAME.akyrs_letter_target) then\r\n                return false\r\n            end\r\n        end\r\n        return true\r\n    end,\r\n    collection_loc_vars = function (self)\r\n        return {\r\n            vars = {\r\n                localize(\"k_akyrs_random_letter\")\r\n            }\r\n        }\r\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "the_reject",
      "name": null,
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = \"the_reject\",\r\n    dollars = 5,\r\n    mult = 2,\r\n    boss_colour = HEX(\"a2a2a2\"),\r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = 1, max = 10},\r\n    pos = { x = 0, y = 2 },\r\n    debuff = {\r\n        akyrs_is_word_blind = true,\r\n    },\r\n    in_pool = function(self)\r\n        return (G.GAME.akyrs_character_stickers_enabled and G.GAME.akyrs_wording_enabled)\r\n    end,\r\n    loc_vars = function (self)\r\n        return {\r\n            vars = {\r\n                string.upper(G.GAME.akyrs_letter_target)\r\n            }\r\n        }\r\n    end,\r\n    debuff_hand = function (self, cards, hand, handname, check)\r\n        if not G.GAME.akyrs_character_stickers_enabled or self.disabled then return false end\r\n        for i, v in ipairs(cards) do\r\n            local l = string.upper(v:get_letter_with_pretend())\r\n            if l and G.GAME.akyrs_last_played_letters[string.upper(G.GAME.akyrs_letter_target)] then\r\n                return true\r\n            end\r\n        end\r\n        return false\r\n    end,\r\n    collection_loc_vars = function (self)\r\n        return {\r\n            vars = {\r\n                localize(\"k_akyrs_random_letter\")\r\n            }\r\n        }\r\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "the_redo",
      "name": null,
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 3
      },
      "raw": "key = \"the_redo\",\r\n    dollars = 5,\r\n    mult = 2,\r\n    boss_colour = HEX(\"ffd611\"),\r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = 3, max = 10},\r\n    pos = { x = 0, y = 3 },\r\n    debuff = {\r\n        akyrs_is_word_blind = true,\r\n    },\r\n    in_pool = function(self)\r\n        return (G.GAME.akyrs_character_stickers_enabled and G.GAME.akyrs_wording_enabled)\r\n    end,\r\n    debuff_hand = function (self, cards, hand, handname, check)\r\n        if not G.GAME.akyrs_character_stickers_enabled or self.disabled then return false end\r\n        for i, v in ipairs(cards) do\r\n            local l = string.upper(v:get_letter_with_pretend())\r\n            if l and G.GAME.akyrs_last_played_letters[l] then\r\n                return true\r\n            end\r\n        end\r\n        return false\r\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "the_reverse",
      "name": null,
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 4
      },
      "raw": "key = \"the_reverse\",\r\n    dollars = 5,\r\n    mult = 2,\r\n    boss_colour = HEX(\"ff7d49\"),\r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = 1, max = 10},\r\n    pos = { x = 0, y = 4 },\r\n    debuff = {\r\n        akyrs_is_word_blind = true,\r\n    },\r\n    in_pool = function(self)\r\n        return (G.GAME.akyrs_character_stickers_enabled and G.GAME.akyrs_wording_enabled)\r\n    end,\r\n    loc_vars = function (self)\r\n        return {\r\n            vars = {\r\n                string.upper(G.GAME.akyrs_letter_target)\r\n            }\r\n        }\r\n    end,\r\n    set_blind = function (self)\r\n        G.GAME.words_reversed = true\r\n    end,\r\n    disable = function (self)\r\n        G.GAME.words_reversed = nil\r\n    end,\r\n    defeat = function (self)\r\n        G.GAME.words_reversed = nil\r\n    end,",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "the_selfish",
      "name": null,
      "atlas": "aikoyoriBlindsChips2",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"the_selfish\",\r\n    dollars = 5,\r\n    mult = 2,\r\n    boss_colour = HEX(\"5dd6ff\"),\r\n    atlas = 'aikoyoriBlindsChips2',\r\n    debuff = {\r\n        akyrs_is_word_blind = true,\r\n        akyrs_num = 1, akyrs_denom = 3\r\n    },\r\n    boss = {min = 2, max = 10},\r\n    pos = { x = 0, y = 1 },\r\n    in_pool = function(self)\r\n        return (G.GAME.akyrs_character_stickers_enabled and G.GAME.akyrs_wording_enabled)\r\n    end,\r\n    loc_vars = function (self)\r\n        local n, d = SMODS.get_probability_vars(self, self.debuff.akyrs_num,  self.debuff.akyrs_denom, \"akyrs_the_selfish_flip\")\r\n        return {\r\n            vars = {\r\n                n, d\r\n            }\r\n        }\r\n    end,\r\n    collection_loc_vars = function (self)\r\n        local n, d = SMODS.get_probability_vars(self, self.debuff.akyrs_num,  self.debuff.akyrs_denom, \"akyrs_the_selfish_flip\")\r\n        return {\r\n            vars = {\r\n                n, d\r\n            }\r\n        }\r\n    end,\r\n    recalc_debuff = function (self, card, from_blind)\r\n        if card and (card:get_letter_with_pretend()) and vowels_list[string.lower(card:get_letter_with_pretend())] then\r\n            if SMODS.pseudorandom_probability(self, \"akyrs_the_selfish_flip\", self.debuff.akyrs_num,  self.debuff.akyrs_denom) then\r\n                return true\r\n            end\r\n        end\r\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "the_polite",
      "name": null,
      "atlas": "aikoyoriBlindsChips2",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = \"the_polite\",\r\n    dollars = 5,\r\n    mult = 2,\r\n    boss_colour = HEX(\"ff9430\"),\r\n    atlas = 'aikoyoriBlindsChips2',\r\n    debuff = {\r\n        akyrs_is_word_blind = true,\r\n    },\r\n    boss = {min = 2, max = 10},\r\n    pos = { x = 0, y = 2 },\r\n    in_pool = function(self)\r\n        return (G.GAME.akyrs_character_stickers_enabled and G.GAME.akyrs_wording_enabled)\r\n    end,\r\n    calculate = function (self, blind, context)\r\n        if not blind.disabled then\r\n            if context.modify_scoring_hand then\r\n                ---@type Card\r\n                local oth = context.other_card\r\n                if oth and oth:get_letter_with_pretend() and vowels_list[string.lower(oth:get_letter_with_pretend())] then\r\n                    return {\r\n                        remove_from_hand = true\r\n                    }\r\n                end\r\n            end\r\n        end\r\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "the_libre",
      "name": null,
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 5
      },
      "raw": "key = \"the_libre\",\r\n    dollars = 5,\r\n    mult = 2,\r\n    boss_colour = HEX('a74ce8'),\r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = 3, max = 10},\r\n    pos = { x = 0, y = 5 },\r\n    debuff = {\r\n        disable_chip_x = 2\r\n    },\r\n    loc_vars = function(self)\r\n        local orig_chips = to_big(AKYRS.get_true_original_blind_amount(self.mult))\r\n        return { vars = {orig_chips  * to_big(G.GAME.round_resets.ante * self.debuff.disable_chip_x) }, key = self.key }\r\n    end,\r\n    collection_loc_vars = function(self)\r\n        return { vars = { \"X 2X\"..localize(\"k_akyrs_power_ante\")}, key = self.key }\r\n    end,\r\n    set_blind = function(self)\r\n    end,\r\n    drawn_to_hand = function(self)\r\n        \r\n    end,\r\n    in_pool = function(self)\r\n        return true\r\n    end,\r\n    disable = function(self)\r\n        AKYRS.modify_blind_size({ set = to_big(AKYRS.get_true_original_blind_amount(self.mult)) * to_big(G.GAME.round_resets.ante) * to_big(self.debuff.disable_chip_x)})\r\n            \r\n    end,\r\n    defeat = function(self)\r\n        \r\n    end,\r\n    press_play = function(self)\r\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "the_picker",
      "name": null,
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 6
      },
      "raw": "key = \"the_picker\",\r\n    dollars = 5,\r\n    mult = 1.25,\r\n    boss_colour = HEX('67e38b'),\r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = 2, max = 10},\r\n    pos = { x = 0, y = 6 },\r\n    debuff = {\r\n        primed = false,\r\n        acted = false,\r\n        initial_action_acted = false,\r\n        initial_action_act_set = false,\r\n        hand_per_hand = 3,\r\n        lock = false,\r\n        score_change = 1.25,\r\n        akyrs_pick_cards = true,\r\n    },\r\n    loc_vars = function(self)\r\n        return { vars = {G.hand.config.highlighted_limit, self.debuff.score_change}, key = self.key }\r\n    end,\r\n    collection_loc_vars = function(self)\r\n        return { vars = { localize(\"k_akyrs_up_to_sel\"), 1.2 }, key = self.key }\r\n    end,\r\n    set_blind = function(self)\r\n        G.GAME.blind.debuff.orig_chips = G.GAME.blind.chips\r\n    end,\r\n    drawn_to_hand = function(self)\r\n    end,\r\n    in_pool = function(self)\r\n        return true\r\n    end,\r\n    disable = function(self)\r\n        G.GAME.blind.chips = G.GAME.blind.debuff.orig_chips * 2\r\n    end,\r\n    defeat = function(self)\r\n    end,\r\n    press_play = function(self)\r\n        G.GAME.blind.debuff.primed = false\r\n        G.GAME.blind.debuff.acted = false\r\n        G.E_MANAGER:add_event(Event{\r\n            trigger = \"after\",\r\n            func = function ()\r\n                G.GAME.blind.debuff.initial_action_act_set = false\r\n                return true\r\n            end\r\n        })\r\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "the_height",
      "name": null,
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 7
      },
      "raw": "key = \"the_height\",\r\n    dollars = 7,\r\n    mult = 0.5,\r\n    boss_colour = HEX('36adff'),\r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = 3, max = 10},\r\n    pos = { x = 0, y = 7 },\r\n    debuff = {\r\n        requirement_scale = 2\r\n    },\r\n    loc_vars = function(self)\r\n        return { vars = {self.debuff.requirement_scale}, key = self.key }\r\n    end,\r\n    collection_loc_vars = function(self)\r\n        return { vars = { \"2\"}, key = self.key }\r\n    end,",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "the_expiry",
      "name": null,
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 8
      },
      "raw": "key = \"the_expiry\",\r\n    dollars = 5,\r\n    mult = 2,\r\n    boss_colour = HEX('ca60ff'),\r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = 2, max = 10},\r\n    pos = { x = 0, y = 8 },\r\n    set_blind = function (self)\r\n        for i,k in ipairs(G.consumeables.cards) do\r\n            k.ability.akyrs_perma_debuff = true\r\n        end\r\n    end,\r\n    \r\n    disable = function (self)\r\n        for i,k in ipairs(G.consumeables.cards) do\r\n            k.ability.akyrs_perma_debuff = false\r\n            k.debuff = false\r\n        end\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "the_nature",
      "name": null,
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 9
      },
      "raw": "key = \"the_nature\",\r\n    dollars = 5,\r\n    mult = 2,\r\n    boss_colour = HEX('3d8a55'),\r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = 4, max = 10},\r\n    debuff = {\r\n        dec_mult = 0.9,\r\n    },\r\n    \r\n    loc_vars = function (self)\r\n        return {\r\n            vars = { self.debuff.dec_mult }\r\n        }\r\n    end,\r\n    collection_loc_vars = function (self)\r\n        return {\r\n            vars = { 0.9 }\r\n        }\r\n    end,\r\n    calculate = function (self, blind, context)\r\n        if context.individual and not context.end_of_round and (context.cardarea == G.hand or context.cardarea == G.play or context.cardarea == \"unscored\") then\r\n            if context.other_card:is_face(true) then\r\n                return { Xmult = blind.debuff.dec_mult }\r\n            end\r\n        end\r\n    end,\r\n    pos = { x = 0, y = 9 },",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "the_key",
      "name": null,
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 12
      },
      "raw": "key = \"the_key\",\r\n    dollars = 5,\r\n    mult = 2,\r\n    boss_colour = HEX('8c7d36'),\r\n    debuff = {\r\n        akyrs_perma_selection = { num = 1, denum = 4, seed = \"akyrs_boss_the_key\" }\r\n    },\r\n    loc_vars = function(self)\r\n        local n, d = SMODS.get_probability_vars(self, self.debuff.akyrs_perma_selection.num,self.debuff.akyrs_perma_selection.denum,self.debuff.akyrs_perma_selection.seed )\r\n        return {\r\n            vars = {\r\n                n, d\r\n            }\r\n        }\r\n    end,\r\n    collection_loc_vars = function (self)\r\n        return {\r\n            vars = {\r\n                1, 4\r\n            }\r\n        }\r\n    end,\r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = 3, max = 10},\r\n    pos = { x = 0, y = 12 },\r\n    calculate = function (self, card, context)\r\n        \r\n    end,\r\n    press_play = function (self)\r\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "the_reverse",
      "name": null,
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 4
      },
      "raw": "key = \"the_reverse\",\r\n    dollars = 5,\r\n    mult = 2,\r\n    boss_colour = HEX(\"ff7d49\"),\r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = 1, max = 10},\r\n    pos = { x = 0, y = 4 },\r\n    debuff = {\r\n        akyrs_is_word_blind = true,\r\n    },\r\n    in_pool = function(self)\r\n        return (G.GAME.akyrs_character_stickers_enabled and G.GAME.akyrs_wording_enabled)\r\n    end,\r\n    loc_vars = function (self)\r\n        return {\r\n            vars = {\r\n                string.upper(G.GAME.akyrs_letter_target)\r\n            }\r\n        }\r\n    end,\r\n    set_blind = function (self)\r\n        G.GAME.words_reversed = true\r\n    end,\r\n    disable = function (self)\r\n        G.GAME.words_reversed = nil\r\n    end,\r\n    defeat = function (self)\r\n        G.GAME.words_reversed = nil\r\n    end,",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "the_alignment",
      "name": null,
      "atlas": "aikoyoriBlindsChips2",
      "pos": {
        "x": 0,
        "y": 15
      },
      "raw": "key = \"the_alignment\",\r\n    dollars = 5,\r\n    mult = 2,\r\n    boss_colour = HEX(\"825bff\"),\r\n    atlas = 'aikoyoriBlindsChips2', \r\n    boss = {min = 4, max = 10},\r\n    pos = { x = 0, y = 15 },\r\n    debuff = {\r\n        \r\n    },\r\n    in_pool = function(self)\r\n        return true\r\n    end,\r\n    calculate = function (self, blind, context)\r\n        if context.modify_scoring_hand and not blind.disabled then\r\n            local index = AKYRS.find_index(context.full_hand, context.other_card)\r\n            if index and index == 1 or index == #context.full_hand then\r\n                return {\r\n                    remove_from_hand = true\r\n                }\r\n            end\r\n            \r\n        end\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "the_duality",
      "name": null,
      "atlas": "aikoyoriBlindsChips2",
      "pos": {
        "x": 0,
        "y": 16
      },
      "raw": "key = \"the_duality\",\r\n    dollars = 5,\r\n    mult = 2,\r\n    boss_colour = HEX(\"ff6e96\"),\r\n    atlas = 'aikoyoriBlindsChips2', \r\n    boss = {min = 4, max = 10},\r\n    pos = { x = 0, y = 16 },\r\n    debuff = {\r\n        \r\n    },\r\n    in_pool = function(self)\r\n        return true\r\n    end,\r\n    calculate = function (self, blind, context)\r\n        if context.before and not blind.disabled then\r\n            for i = 1, #G.play.cards do\r\n                if i == 1 or i ==  #G.play.cards then\r\n                    G.play.cards[i]:set_debuff(true)\r\n                end\r\n            end\r\n            \r\n        end\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "the_collapse",
      "name": null,
      "atlas": "aikoyoriBlindsChips2",
      "pos": {
        "x": 0,
        "y": 17
      },
      "raw": "key = \"the_collapse\",\r\n    dollars = 5,\r\n    mult = 2,\r\n    boss_colour = HEX(\"ffcb7b\"),\r\n    atlas = 'aikoyoriBlindsChips2', \r\n    boss = {min = 1, max = 10},\r\n    pos = { x = 0, y = 17 },\r\n    debuff = {\r\n        akyrs_no_gain_cash = true\r\n    },\r\n    in_pool = function(self)\r\n        return true\r\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "the_bonsai",
      "name": null,
      "atlas": "aikoyoriBlindsChips2",
      "pos": {
        "x": 0,
        "y": 18
      },
      "raw": "key = \"the_bonsai\",\r\n    dollars = 5,\r\n    mult = 2,\r\n    boss_colour = HEX(\"b8f083\"),\r\n    atlas = 'aikoyoriBlindsChips2', \r\n    boss = {min = 4, max = 10},\r\n    pos = { x = 0, y = 18 },\r\n    config = {\r\n        numer = 1,\r\n        denum = 3,\r\n    },\r\n    in_pool = function(self)\r\n        return true\r\n    end,\r\n    loc_vars = function (self)\r\n        local n, d = SMODS.get_probability_vars(self, self.config.numer, self.config.denum, \"akyrs_bonsai_blind\")\r\n        return {\r\n            vars = {\r\n                n, d\r\n            }\r\n        }\r\n    end,\r\n    collection_loc_vars = function (self)\r\n        local n, d = SMODS.get_probability_vars(self, self.config.numer, self.config.denum, \"akyrs_bonsai_blind\")\r\n        return {\r\n            vars = {\r\n                n, d\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, blind, context)\r\n        if context.modify_scoring_hand and not blind.disabled then\r\n            if SMODS.pseudorandom_probability(self, \"akyrs_bonsai_blind\",self.config.numer, self.config.denum) and context.other_card:is_face() then\r\n                return {\r\n                    remove_from_hand = true\r\n                }\r\n            end\r\n        end\r\n    end",
      "config": {
        "numer": 1,
        "denum": 3
      },
      "ability": {
        "numer": 1,
        "denum": 3
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "the_base",
      "name": null,
      "atlas": "aikoyoriBlindsChips2",
      "pos": {
        "x": 0,
        "y": 19
      },
      "raw": "key = \"the_base\",\r\n    dollars = 5,\r\n    mult = 1,\r\n    boss_colour = HEX(\"32f9ff\"),\r\n    atlas = 'aikoyoriBlindsChips2', \r\n    boss = {min = 2, max = 10},\r\n    pos = { x = 0, y = 19 },\r\n    debuff = {\r\n        akyrs_no_retriggers = true\r\n    },",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "the_stomata",
      "name": null,
      "atlas": "aikoyoriBlindsChips2",
      "pos": {
        "x": 0,
        "y": 20
      },
      "raw": "key = \"the_stomata\",\r\n    dollars = 5,\r\n    mult = 2,\r\n    boss_colour = HEX(\"72b06d\"),\r\n    atlas = 'aikoyoriBlindsChips2', \r\n    boss = {min = 3, max = 10},\r\n    pos = { x = 0, y = 20 },\r\n    debuff = {\r\n        akyrs_deduct_play = 1\r\n    },\r\n    calculate = function (self, blind, context)\r\n        if not blind.disabled then\r\n            if context.individual and context.cardarea == G.play then\r\n                if context.other_card:is_face(true) then\r\n                    return {\r\n                        dollars = -blind.debuff.akyrs_deduct_play\r\n                    }\r\n                end\r\n            end\r\n        end\r\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "the_rhizome",
      "name": null,
      "atlas": "aikoyoriBlindsChips2",
      "pos": {
        "x": 0,
        "y": 21
      },
      "raw": "key = \"the_rhizome\",\r\n    dollars = 5,\r\n    mult = 1.5,\r\n    boss_colour = HEX(\"c89bcf\"),\r\n    atlas = 'aikoyoriBlindsChips2', \r\n    boss = {min = 3, max = 10},\r\n    pos = { x = 0, y = 21 },\r\n    debuff = {\r\n        akyrs_mult_blind_size = 1.5\r\n    },\r\n    loc_vars = function (self)\r\n        return {\r\n            vars = {\r\n                self.debuff.akyrs_mult_blind_size\r\n            }\r\n        }\r\n    end,\r\n    collection_loc_vars = function (self)\r\n        return {\r\n            vars = {\r\n                self.debuff.akyrs_mult_blind_size\r\n            }\r\n        }\r\n    end,\r\n    disable = function (self)\r\n        AKYRS.modify_blind_size({set = AKYRS.get_true_original_blind_amount(self.mult)})\r\n    end,\r\n    calculate = function (self, blind, context)\r\n        if context.before and G.GAME.current_round.akyrs_hands_played[context.scoring_name] and not blind.disabled then\r\n            return {\r\n                func = function ()\r\n                    AKYRS.modify_blind_size({ mult = blind.debuff.akyrs_mult_blind_size })\r\n                end\r\n            }\r\n        end\r\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "the_shrink",
      "name": null,
      "atlas": "aikoyoriBlindsChips2",
      "pos": {
        "x": 0,
        "y": 22
      },
      "raw": "key = \"the_shrink\",\r\n    dollars = 5,\r\n    mult = 12,\r\n    boss_colour = HEX(\"8087ff\"),\r\n    atlas = 'aikoyoriBlindsChips2', \r\n    boss = {min = 3, max = 10},\r\n    pos = { x = 0, y = 22 },\r\n    debuff = {\r\n        akyrs_mult_blind_size = 0.5\r\n    },\r\n    loc_vars = function (self)\r\n        return {\r\n            vars = {\r\n                self.debuff.akyrs_mult_blind_size\r\n            }\r\n        }\r\n    end,\r\n    collection_loc_vars = function (self)\r\n        return {\r\n            vars = {\r\n                self.debuff.akyrs_mult_blind_size\r\n            }\r\n        }\r\n    end,\r\n    disable = function (self)\r\n        AKYRS.modify_blind_size({set = AKYRS.get_true_original_blind_amount(self.mult)})\r\n    end,\r\n    calculate = function (self, blind, context)\r\n        if context.before and not G.GAME.current_round.akyrs_hands_played[context.scoring_name] and not blind.disabled then\r\n            return {\r\n                func = function ()\r\n                    AKYRS.modify_blind_size({ mult = blind.debuff.akyrs_mult_blind_size })\r\n                end\r\n            }\r\n        end\r\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "the_harmonic",
      "name": null,
      "atlas": "aikoyoriBlindsChips2",
      "pos": {
        "x": 0,
        "y": 23
      },
      "raw": "key = \"the_harmonic\",\r\n    dollars = 5,\r\n    mult = 2,\r\n    boss_colour = HEX(\"f0ad82\"),\r\n    atlas = 'aikoyoriBlindsChips2', \r\n    boss = {min = 1, max = 10},\r\n    pos = { x = 0, y = 23 },\r\n    debuff = {\r\n    },\r\n    calculate = function (self, blind, context)\r\n        if not blind.disabled then\r\n            if context.hand_drawn then\r\n                return {\r\n                    func = function ()\r\n                        AKYRS.simple_event_add(\r\n                            function ()\r\n                                local cards_candidate = AKYRS.filter_table(G.hand.cards, function(cds, inx) \r\n                                    return not cds.highlighted\r\n                                end, true, true)\r\n                                local picks = AKYRS.pseudorandom_elements(cards_candidate, 1, \"akyrs_blind_harmonics\")\r\n                                for _, cd in ipairs(picks) do\r\n                                    G.hand:add_to_highlighted(cd)\r\n                                end\r\n                                G.FUNCS.discard_cards_from_highlighted(nil, true)\r\n                                return true\r\n                            end\r\n                        )\r\n                    end\r\n                }\r\n            end\r\n        end\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "the_sinusoidal",
      "name": null,
      "atlas": "aikoyoriBlindsChips2",
      "pos": {
        "x": 0,
        "y": 24
      },
      "raw": "key = \"the_sinusoidal\",\r\n    dollars = 5,\r\n    mult = 2,\r\n    boss_colour = HEX(\"ffb4ea\"),\r\n    atlas = 'aikoyoriBlindsChips2', \r\n    boss = {min = 2, max = 10},\r\n    pos = { x = 0, y = 24 },\r\n    debuff = {\r\n    },\r\n    calculate = function (self, blind, context)\r\n        if not blind.disabled then\r\n            if context.stay_flipped then\r\n                if context.other_card and context.from_area == G.deck and context.to_area == G.hand then\r\n                    if G.hand.config.card_limit - #G.hand.cards <= 2 then\r\n                        return {\r\n                            stay_flipped = true\r\n                        }\r\n                    end\r\n                end\r\n            end\r\n        end\r\n    end",
      "config": {
        "stay_flipped": true
      },
      "ability": {
        "stay_flipped": true
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "the_saw",
      "name": null,
      "atlas": "aikoyoriBlindsChips2",
      "pos": {
        "x": 0,
        "y": 25
      },
      "raw": "key = \"the_saw\",\r\n    dollars = 5,\r\n    mult = 2,\r\n    boss_colour = HEX(\"8becc4\"),\r\n    atlas = 'aikoyoriBlindsChips2', \r\n    boss = {min = 4, max = 10},\r\n    pos = { x = 0, y = 25 },\r\n    debuff = {\r\n    },\r\n    calculate = function (self, blind, context)\r\n        if not blind.disabled then\r\n            if context.destroy_card and context.cardarea == G.play and context.destroy_card == context.scoring_hand[1] then\r\n                return {\r\n                    remove = true\r\n                }\r\n            end\r\n        end\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "final_periwinkle_pinecone",
      "name": null,
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 10
      },
      "raw": "key = \"final_periwinkle_pinecone\",\r\n    dollars = 8,\r\n    mult = 2,\r\n    boss_colour = HEX('7da8f0'),\r\n    atlas = 'aikoyoriBlindsChips', \r\n    debuff = {\r\n        --akyrs_all_seals_perma_debuff = true\r\n    },\r\n    boss = {min = 1, max = 10, showdown = true},\r\n    pos = { x = 0, y = 10 },\r\n    recalc_debuff = function (self, card, from_blind)\r\n        if card.seal then \r\n            return true\r\n        end\r\n        return false\r\n    end,\r\n    calculate = function (self, blind, context)\r\n        if context.akyrs_pre_play and not blind.disabled then\r\n            return {\r\n                func = function ()\r\n                    local hcard = #G.hand.cards\r\n                    for i = hcard, 1, -1 do\r\n                        AKYRS.simple_event_add(function ()\r\n                            local drawn_c = G.hand:remove_card()\r\n                            if not drawn_c or drawn_c.highlighted then return true end\r\n                            G.deck:emplace(drawn_c)\r\n                            play_sound('card1')\r\n                            return true\r\n                        end, 0.1)\r\n                    end\r\n                    local dcard = #G.discard.cards\r\n                    for i = dcard, 1, -1 do\r\n                        AKYRS.simple_event_add(function ()\r\n                            local drawn_c = G.discard:remove_card()\r\n                            if not drawn_c then return true end\r\n                            G.deck:emplace(drawn_c)\r\n                            play_sound('card1')\r\n                            return true\r\n                        end, 0.1)\r\n                    end\r\n                    AKYRS.simple_event_add(function ()\r\n                        G.deck:shuffle(\"akyrs_razzle_shuffle\")\r\n                        return true\r\n                    end, 1)\r\n                    for i = 1, G.hand.config.card_limit do\r\n                        AKYRS.simple_event_add(function ()\r\n                            local drawn_c = G.deck:remove_card()\r\n                            G.hand:emplace(drawn_c)\r\n                            play_sound('card1')\r\n                            return true\r\n                        end, 0.1)\r\n                    end\r\n                end\r\n            }\r\n        end\r\n    end",
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "final_razzle_raindrop",
      "name": null,
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 11
      },
      "raw": "key = \"final_razzle_raindrop\",\r\n    dollars = 8,\r\n    mult = 2,\r\n    boss_colour = HEX('ff40ac'),\r\n    debuff = {\r\n    },\r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = 1, max = 10, showdown = true},\r\n    pos = { x = 0, y = 11 },\r\n    calculate = function (self, blind, context)\r\n        if context.press_play and not blind.disabled then\r\n            return {\r\n                func = function ()\r\n                    AKYRS.simple_event_add(\r\n                        function ()\r\n                            local suits_played = 0\r\n                            local suit_checked = {}\r\n                            for ke, va in pairs(SMODS.Suits) do\r\n                                for _, card_2_check in ipairs(G.play.cards) do\r\n                                    if card_2_check:is_suit(ke) and not suit_checked[ke] then\r\n                                        suit_checked[ke] = true\r\n                                        suits_played = suits_played + 1\r\n                                        break\r\n                                    end\r\n                                end\r\n                            end\r\n                            local picks = AKYRS.pseudorandom_elements(G.hand.cards, suits_played, \"akyrs_blind_harmonics\")\r\n                            for _, cd in ipairs(picks) do\r\n                                G.hand:add_to_highlighted(cd)\r\n                            end\r\n                            G.FUNCS.discard_cards_from_highlighted(nil, true)\r\n                            return true\r\n                        end\r\n                    )\r\n                end\r\n            }\r\n        end\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "final_velvet_vapour",
      "name": null,
      "atlas": "aikoyoriBlindsChips2",
      "pos": {
        "x": 0,
        "y": 10
      },
      "raw": "key = \"final_velvet_vapour\",\r\n    dollars = 8,\r\n    mult = 2,\r\n    boss_colour = HEX('911468'),    \r\n    atlas = 'aikoyoriBlindsChips2', \r\n    boss = {min = 1, max = 10, showdown = true},\r\n    pos = { x = 0, y = 10 },\r\n    debuff = {\r\n    },\r\n    config = {\r\n        numer = 2, denom = 3,\r\n    },\r\n    loc_vars = function (self)\r\n        local n, d = SMODS.get_probability_vars(self, self.config.numer, self.config.denom, \"akyrs_velvet_chance\")\r\n        return {\r\n            vars = {\r\n                n, d,\r\n            }\r\n        }\r\n    end,\r\n    collection_loc_vars = function (self)\r\n        local n, d = SMODS.get_probability_vars(self, self.config.numer, self.config.denom, \"akyrs_velvet_chance\")\r\n        return {\r\n            vars = {\r\n                n, d,\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, blind, context)\r\n        if context.press_play and not blind.disabled then\r\n            return {\r\n                func = function ()\r\n                    AKYRS.simple_event_add(\r\n                        function ()\r\n                            local card_to_check = G.play.cards[1]\r\n                            if not card_to_check or SMODS.has_no_rank(card_to_check) then return true end\r\n                            local cards_candidate = AKYRS.filter_table(G.hand.cards, function(cds, inx) \r\n                                return cds:get_id() == card_to_check:get_id() and not cds.highlighted\r\n                            end, true, true)\r\n                            for _, cd in ipairs(cards_candidate) do\r\n                                if SMODS.pseudorandom_probability(blind, \"akyrs_velvet_chance\", blind.effect.numer, blind.effect.denom) then\r\n                                    G.hand:add_to_highlighted(cd)\r\n                                end\r\n                            end\r\n                            G.FUNCS.discard_cards_from_highlighted(nil, true)\r\n                            return true\r\n                        end\r\n                    )\r\n                end\r\n            }\r\n        end\r\n    end,",
      "config": {
        "numer": 2,
        "denom": 3
      },
      "ability": {
        "numer": 2,
        "denom": 3
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "final_chamomile_cloud",
      "name": null,
      "atlas": "aikoyoriBlindsChips2",
      "pos": {
        "x": 0,
        "y": 9
      },
      "raw": "key = \"final_chamomile_cloud\",\r\n    dollars = 8,\r\n    mult = 2,\r\n    boss_colour = HEX('f0ae22'),    \r\n    atlas = 'aikoyoriBlindsChips2', \r\n    boss = {min = 1, max = 10, showdown = true},\r\n    pos = { x = 0, y = 9 },\r\n    debuff = {\r\n    },\r\n    calculate = function (self, blind, context)\r\n        if context.press_play and not blind.disabled then\r\n            return {\r\n                func = function ()\r\n                    AKYRS.simple_event_add(\r\n                        function ()\r\n                            local suit_checked = {}\r\n                            local suit_list = {}\r\n                            for ke, va in pairs(SMODS.Suits) do\r\n                                for _, card_2_check in ipairs(G.hand.cards) do\r\n                                    if card_2_check:is_suit(ke) and not suit_checked[ke] then\r\n                                        suit_checked[ke] = true\r\n                                        table.insert(suit_list, ke)\r\n                                        break\r\n                                    end\r\n                                end\r\n                            end\r\n                            local suit = pseudorandom_element(suit_list,\"akyrs_chamomile_pick_suit\")\r\n                            local cards_candidate = AKYRS.filter_table(G.hand.cards, function(cds, inx) \r\n                                return cds:is_suit(suit) and not cds.highlighted\r\n                            end, true, true)\r\n                            for _, cd in ipairs(cards_candidate) do\r\n                                G.hand:add_to_highlighted(cd)\r\n                            end\r\n                            G.FUNCS.discard_cards_from_highlighted(nil, true)\r\n                            return true\r\n                        end\r\n                    )\r\n                end\r\n            }\r\n        end\r\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "final_lilac_lasso",
      "name": null,
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 13
      },
      "raw": "key = \"final_lilac_lasso\",\r\n    dollars = 8,\r\n    mult = 2,\r\n    boss_colour = HEX('973fd5'),\r\n    debuff = {\r\n        jokers_not_debuffed = 4,\r\n    },\r\n    \r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = 1, max = 10, showdown = true},\r\n    pos = { x = 0, y = 13 },\r\n    \r\n    loc_vars = function (self)\r\n        return {\r\n            vars = { self.debuff.jokers_not_debuffed }\r\n        }\r\n    end,\r\n    collection_loc_vars = function (self)\r\n        return {\r\n            vars = { 4 }\r\n        }\r\n    end,\r\n    set_blind = function (self)\r\n        self.prepped = true\r\n    end,\r\n    drawn_to_hand = function (self)\r\n        if self.prepped and G.jokers.cards[1] then\r\n            local jokers = {}\r\n            local undebuffed = {}\r\n            for i = 1, #G.jokers.cards do\r\n                G.jokers.cards[i]:set_debuff(false)\r\n                jokers[#jokers+1] = G.jokers.cards[i] \r\n            end \r\n            for i = 1, (self.debuff.jokers_not_debuffed or 4) do\r\n                if #jokers == 0 then break end\r\n                local _card = pseudorandom_element(jokers, pseudoseed('lilac_lasso'))\r\n                for l,j in ipairs(jokers) do\r\n                    if j == _card then\r\n                        table.insert(undebuffed, j)\r\n                        table.remove(jokers, l)\r\n                        break\r\n                    end\r\n                end\r\n            end \r\n            \r\n            for i, jkr in ipairs(jokers) do\r\n                jkr:set_debuff(true)\r\n            end\r\n            local r_und = {}\r\n            for i = #undebuffed, 1, -1 do\r\n                table.insert(r_und, undebuffed[i])\r\n            end\r\n            for i, carder in ipairs(r_und) do\r\n                G.E_MANAGER:add_event(\r\n                    Event{\r\n                        trigger = \"after\",\r\n                        delay = AKYRS.get_speed_mult(carder)*0.05,\r\n                        func = function ()\r\n                            carder:juice_up(0.5,1)\r\n                            return true\r\n                        end\r\n                    }\r\n                )\r\n            end\r\n        end\r\n        self.prepped = nil\r\n        \r\n    end,\r\n    press_play =function (self)\r\n        if G.jokers.cards[1] then\r\n            self.triggered = true\r\n            self.prepped = true\r\n        end\r\n    end,\r\n    disable = function (self)\r\n        \r\n        for i = 1, #G.jokers.cards do\r\n            G.jokers.cards[i]:set_debuff(false)\r\n        end \r\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "final_salient_stream",
      "name": null,
      "atlas": "aikoyoriBlindsChips2",
      "pos": {
        "x": 0,
        "y": 11
      },
      "raw": "key = \"final_salient_stream\",\r\n    dollars = 8,\r\n    mult = 2,\r\n    boss_colour = HEX('358dff'),    \r\n    atlas = 'aikoyoriBlindsChips2', \r\n    boss = {min = 1, max = 10, showdown = true},\r\n    pos = { x = 0, y = 11 },\r\n    debuff = {\r\n        akyrs_alternate_action = true\r\n    },\r\n    debuff_hand = function (self, cards, hand, handname, check)\r\n        if G.GAME.current_round.akyrs_last_action and G.GAME.current_round.akyrs_last_action == \"play\" and not G.GAME.blind.disabled  then\r\n            return true\r\n        end\r\n        return false\r\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "final_luminous_lemonade",
      "name": null,
      "atlas": "aikoyoriBlindsChips2",
      "pos": {
        "x": 0,
        "y": 12
      },
      "raw": "key = \"final_luminous_lemonade\",\r\n    dollars = 8,\r\n    mult = 2,\r\n    boss_colour = SMODS.Gradients['akyrs_luminous'],    \r\n    atlas = 'aikoyoriBlindsChips2', \r\n    boss = {min = 1, max = 10, showdown = true},\r\n    pos = { x = 0, y = 12 },\r\n    debuff = {\r\n    },\r\n    calculate = function (self, blind, context)\r\n        if not blind.disabled then\r\n            if context.debuff_hand then\r\n                if G.GAME.current_round.hands_left ~= (G.STATE == G.STATES.SELECTING_HAND and 1 or 0) then\r\n                    return {\r\n                        debuff = true\r\n                    }\r\n                end\r\n            end\r\n        end\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "final_glorious_glaive",
      "name": null,
      "atlas": "aikoyoriBlindsChips2",
      "pos": {
        "x": 0,
        "y": 13
      },
      "raw": "key = \"final_glorious_glaive\",\r\n    dollars = 8,\r\n    mult = 2,\r\n    boss_colour = SMODS.Gradients['akyrs_glorious'],    \r\n    atlas = 'aikoyoriBlindsChips2', \r\n    boss = {min = 1, max = 10, showdown = true},\r\n    pos = { x = 0, y = 13 },\r\n    debuff = {\r\n        akyrs_mult_per_played = 0.85\r\n    },\r\n    loc_vars = function (self)\r\n        return {\r\n            vars = {\r\n                self.debuff.akyrs_mult_per_played\r\n            }\r\n        }\r\n    end,\r\n    collection_loc_vars = function (self)\r\n        return {\r\n            vars = {\r\n                self.debuff.akyrs_mult_per_played\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, blind, context)\r\n        if context.individual and not context.repetition and context.cardarea == G.play and not G.GAME.blind.disabled then\r\n            return {\r\n                akyrs_xscore = blind.debuff.akyrs_mult_per_played,\r\n            }\r\n        end\r\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "forgotten_weights_of_the_past",
      "name": null,
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 14
      },
      "raw": "key = \"forgotten_weights_of_the_past\",\r\n    dollars = 8,\r\n    mult = 2,\r\n    boss_colour = HEX('60203f'),\r\n    debuff = {\r\n        ante_scaler = 2,\r\n        current_ante = nil,\r\n        akyrs_is_forgotten_blind = true,\r\n        akyrs_cannot_be_overridden = true,\r\n    },\r\n    \r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = -999999999999, max = 10},\r\n    pos = { x = 0, y = 14 },\r\n    \r\n    loc_vars = function (self)\r\n        return {\r\n            vars = { self.debuff.ante_scaler }\r\n        }\r\n    end,\r\n    collection_loc_vars = function (self)\r\n        return {\r\n            vars = { 2 }\r\n        }\r\n    end,\r\n    in_pool = function (self)\r\n        return G.GAME.round_resets.ante < 0  -- :3\r\n    end,\r\n    set_blind = function (self)\r\n        G.GAME.blind.debuff.current_ante = G.GAME.round_resets.ante\r\n    end,\r\n    calculate = function (self, blind, context)\r\n        if context.individual and context.cardarea == G.play and not context.repetition and not blind.disabled then\r\n            local old_ante = blind.debuff.current_ante\r\n            blind.debuff.current_ante = blind.debuff.current_ante*blind.debuff.ante_scaler\r\n            ease_ante(-old_ante + blind.debuff.current_ante)\r\n        end\r\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "forgotten_prospects_of_the_future",
      "name": null,
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 15
      },
      "raw": "key = \"forgotten_prospects_of_the_future\",\r\n    dollars = 8,\r\n    mult = 2,\r\n    boss_colour = HEX('2b664f'),\r\n    debuff = {\r\n        ante_scaler = 1,\r\n        akyrs_is_forgotten_blind = true,\r\n        akyrs_cannot_be_overridden = true,\r\n    },\r\n    \r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = -999999999999, max = 10},\r\n    pos = { x = 0, y = 15 },\r\n    \r\n    loc_vars = function (self)\r\n        return {\r\n            vars = { self.debuff.ante_scaler }\r\n        }\r\n    end,\r\n    collection_loc_vars = function (self)\r\n        return {\r\n            vars = { 1 }\r\n        }\r\n    end,\r\n    in_pool = function (self)\r\n        return G.GAME.round_resets.ante < 1  -- :3\r\n    end,\r\n    set_blind = function (self)\r\n        G.GAME.blind.debuff.current_ante = G.GAME.round_resets.ante\r\n    end,\r\n    calculate = function (self, blind, context)\r\n        if context.after and not blind.disabled then\r\n            ease_ante(blind.debuff.ante_scaler * #G.hand.cards)\r\n        end\r\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "forgotten_uncertainties_of_life",
      "name": null,
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 16
      },
      "raw": "key = \"forgotten_uncertainties_of_life\",\r\n    dollars = 8,\r\n    mult = 2,\r\n    boss_colour = HEX('2c5c6c'),\r\n    debuff = {\r\n        hand_shrinker = 1,\r\n        akyrs_is_forgotten_blind = true,\r\n        akyrs_cannot_be_overridden = true,\r\n    },\r\n    \r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = -999999999999, max = 10},\r\n    pos = { x = 0, y = 16 },\r\n    \r\n    loc_vars = function (self)\r\n        return {\r\n            vars = { self.debuff.hand_shrinker }\r\n        }\r\n    end,\r\n    collection_loc_vars = function (self)\r\n        return {\r\n            vars = { 1 }\r\n        }\r\n    end,\r\n    in_pool = function (self)\r\n        return G.GAME.round_resets.ante < 1  -- :3\r\n    end,\r\n    calculate = function (self, blind, context)\r\n        if context.after and not context.end_of_round and not blind.disabled then\r\n            G.hand:change_size(-blind.debuff.hand_shrinker)\r\n        end\r\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "forgotten_inevitability_of_death",
      "name": null,
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 17
      },
      "raw": "key = \"forgotten_inevitability_of_death\",\r\n    dollars = 8,\r\n    mult = 2,\r\n    boss_colour = HEX('4d494b'),\r\n    debuff = {\r\n        discard_dealer = 1,\r\n        akyrs_is_forgotten_blind = true,\r\n        akyrs_cannot_be_overridden = true,\r\n    },\r\n    \r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = -999999999999, max = 10},\r\n    pos = { x = 0, y = 17 },\r\n    \r\n    loc_vars = function (self)\r\n        return {\r\n            vars = { self.debuff.discard_dealer }\r\n        }\r\n    end,\r\n    collection_loc_vars = function (self)\r\n        return {\r\n            vars = { 1 }\r\n        }\r\n    end,\r\n    in_pool = function (self)\r\n        return G.GAME.round_resets.ante < 1  -- :3\r\n    end,\r\n    calculate = function (self, blind, context)\r\n        if context.blind_defeated and not blind.disabled then\r\n            return{\r\n                func = function ()\r\n                    ease_dollars(-G.GAME.chips / G.GAME.blind.chips)\r\n                end\r\n            }\r\n        end\r\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "expert_confrontation",
      "name": null,
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 18
      },
      "raw": "key = \"expert_confrontation\",\r\n    dollars = 10,\r\n    mult = 1,\r\n    boss_colour = HEX('ce36ff'),\r\n    debuff = {\r\n        akyrs_blind_difficulty = \"expert\",\r\n    },\r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = 7, max = 10},\r\n    pos = { x = 0, y = 18 },\r\n    debuff_hand = function (self, cards, hand, handname, check)\r\n        local has_face = false\r\n        for i,j in ipairs(cards) do\r\n            if j:is_face() then\r\n                has_face = true\r\n                break\r\n            end\r\n        end\r\n        return not has_face\r\n    end,\r\n    loc_vars = function (self)\r\n        return {\r\n        }\r\n    end,\r\n    collection_loc_vars = function (self)\r\n        return {\r\n        }\r\n    end,\r\n    in_pool = function (self)\r\n        return G.GAME.round_resets.ante >= G.GAME.win_ante\r\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "expert_fluctuation",
      "name": null,
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 19
      },
      "raw": "key = \"expert_fluctuation\",\r\n    dollars = 10,\r\n    mult = 2.25,\r\n    boss_colour = HEX('ff6c9a'),\r\n    debuff = {\r\n        mult_min = 0.01,\r\n        mult_max = 1.1,\r\n        akyrs_blind_difficulty = \"expert\",\r\n    },\r\n    \r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = 9, max = 10},\r\n    pos = { x = 0, y = 19 },\r\n    \r\n    loc_vars = function (self)\r\n        return {\r\n            vars = { self.debuff.mult_min, self.debuff.mult_max }\r\n        }\r\n    end,\r\n    collection_loc_vars = function (self)\r\n        return {\r\n            vars = { 0.01, 1.1 }\r\n        }\r\n    end,\r\n    in_pool = function (self)\r\n        return G.GAME.round_resets.ante > G.GAME.win_ante\r\n    end,\r\n    calculate = function (self, blind, context)\r\n        if context.before and not blind.disabled then\r\n            local xm = pseudorandom(pseudoseed(\"akyrs_fluctuation\"))*(blind.debuff.mult_max - blind.debuff.mult_min) + blind.debuff.mult_min\r\n            return {\r\n                akyrs_xscore = xm\r\n            }\r\n        end\r\n    end,",
      "config": {},
      "ability": {},
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "expert_straightforwardness",
      "name": null,
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 20
      },
      "raw": "key = \"expert_straightforwardness\",\r\n    dollars = 10,\r\n    mult = 1.75,\r\n    boss_colour = HEX('4d77ff'),\r\n    debuff = {\r\n        akyrs_blind_difficulty = \"expert\",\r\n        ch = 0.25,\r\n        mul = 0.25\r\n    },\r\n    \r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = 7, max = 10},\r\n    pos = { x = 0, y = 20 },\r\n    loc_vars = function (self)\r\n        return {\r\n            vars = {\r\n                self.debuff.ch * 100,\r\n                self.debuff.mul * 100,\r\n            }\r\n        }\r\n    end,\r\n    collection_loc_vars = function (self)\r\n        return {\r\n            vars = {\r\n                self.debuff.ch * 100,\r\n                self.debuff.mul * 100,\r\n            }\r\n        }\r\n    end,\r\n    in_pool = function (self)\r\n        return G.GAME.round_resets.ante > G.GAME.win_ante\r\n    end,\r\n    modify_hand = function (self, cards, poker_hands, text, mult, hand_chips)\r\n        if Talisman then\r\n            return to_big(self.debuff.mul) * mult, to_big(self.debuff.ch) * hand_chips, true\r\n        end\r\n        return self.debuff.mul  * mult , self.debuff.ch * hand_chips, true\r\n        -- return mult, hand_chips, false\r\n    end,",
      "config": {},
      "ability": {},
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "expert_entanglement",
      "name": null,
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 21
      },
      "raw": "key = \"expert_entanglement\",\r\n    dollars = 10,\r\n    mult = 2,\r\n    boss_colour = HEX('1fb643'),\r\n    debuff = {\r\n        akyrs_blind_difficulty = \"expert\",\r\n    },\r\n    stay_flipped = function (self, area, card)\r\n        if area == G.hand and G.hand.cards then\r\n            local ranks = {}\r\n            for i, v in ipairs(G.hand.cards) do\r\n                if v.base and v.base.suit and not SMODS.has_no_suit(v) and v.facing == 'front' then\r\n                    ranks[v.base.suit] = true\r\n                end\r\n            end\r\n            if card.base and card.base.suit and ranks[card.base.suit] and not SMODS.has_no_suit(card) then\r\n                return true\r\n            end\r\n        end\r\n        return false\r\n    end,\r\n    \r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = 7, max = 10},\r\n    pos = { x = 0, y = 21 },\r\n    \r\n    loc_vars = function (self)\r\n        return {\r\n        }\r\n    end,\r\n    collection_loc_vars = function (self)\r\n        return {\r\n        }\r\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "expert_manuscript",
      "name": null,
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 22
      },
      "raw": "key = \"expert_manuscript\",\r\n    dollars = 10,\r\n    mult = 2,\r\n    boss_colour = HEX('ffa530'),\r\n    debuff = {\r\n        akyrs_blind_difficulty = \"expert\",\r\n    },\r\n    \r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = 7, max = 10},\r\n    pos = { x = 0, y = 22 },\r\n    modify_hand = function (self, cards, poker_hands, text, mult, hand_chips)\r\n        AKYRS.simple_event_add(\r\n            function ()\r\n                ease_dollars(-mult)\r\n                return true\r\n            end, 0\r\n        )\r\n        return mult, hand_chips, true\r\n    end,\r\n    --[[\r\n    calculate = function (self, blind, context)\r\n        if context.individual and context.area == G.play and not context.repetition then\r\n            local x = localize(context.scoring_name,\"poker_hands\")\r\n            local y = G.GAME.hands[scoring_hand]\r\n            return {\r\n                dollars = -y.mult\r\n            }\r\n                \r\n        end\r\n    end]]",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "expert_inflation",
      "name": null,
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 23
      },
      "raw": "key = \"expert_inflation\",\r\n    dollars = 10,\r\n    mult = 2,\r\n    boss_colour = HEX('7371ff'),\r\n    debuff = {\r\n        akyrs_blind_difficulty = \"expert\",\r\n        akyrs_anteth_power_of_x_blind_req = 1.5,\r\n        akyrs_anteth_power_of_x_blind_req_multiplier = 1,\r\n        akyrs_anteth_power_of_x_blind_req_power = 0.5,\r\n        akyrs_is_postwin_blind = true,\r\n    },\r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = 8, max = 10},\r\n    pos = { x = 0, y = 23 },",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "master_faraway_island",
      "name": null,
      "atlas": "aikoyoriBlindsChips2",
      "pos": {
        "x": 0,
        "y": 3
      },
      "raw": "key = \"master_faraway_island\",\r\n    dollars = 14,\r\n    mult = 2,\r\n    boss_colour = HEX('4bbdff'),\r\n    debuff = {\r\n        akyrs_blind_difficulty = \"master\",\r\n    },\r\n    \r\n    in_pool = function (self)\r\n        return G.GAME.round_resets.ante >= G.GAME.win_ante, {ignore_showdown_check = true}\r\n    end,\r\n    atlas = 'aikoyoriBlindsChips2', \r\n    boss = {min = 8, max = 10},\r\n    pos = { x = 0, y = 3 },\r\n    set_blind = function (self)\r\n        SMODS.change_play_limit(1)\r\n    end,\r\n    disable = function (self)\r\n        SMODS.change_play_limit(-1)\r\n    end,\r\n    defeat = function (self)\r\n        SMODS.change_play_limit(-1)\r\n    end,\r\n    debuff_hand = function (self, cards, hand, handname, check)\r\n        for i, c in ipairs(cards) do\r\n            if SMODS.has_no_rank(c) or SMODS.has_no_suit(c) then\r\n                return false\r\n            end\r\n        end\r\n        return true\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "master_plywood_forest",
      "name": null,
      "atlas": "aikoyoriBlindsChips2",
      "pos": {
        "x": 0,
        "y": 4
      },
      "raw": "key = \"master_plywood_forest\",\r\n    dollars = 14,\r\n    mult = 2,\r\n    boss_colour = HEX('f74d4d'),\r\n    debuff = {\r\n        akyrs_blind_difficulty = \"master\",\r\n    },\r\n    \r\n    in_pool = function (self)\r\n        return G.GAME.round_resets.ante >= G.GAME.win_ante, {ignore_showdown_check = true}\r\n    end,\r\n    atlas = 'aikoyoriBlindsChips2', \r\n    boss = {min = 8, max = 10},\r\n    pos = { x = 0, y = 4 },\r\n    calculate = function (self, blind, context)\r\n        if not blind.disabled then\r\n            if context.destroy_card and context.cardarea == G.hand then\r\n                return {\r\n                    remove = true,\r\n                }\r\n            end\r\n        end\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "master_golden_jade",
      "name": null,
      "atlas": "aikoyoriBlindsChips2",
      "pos": {
        "x": 0,
        "y": 5
      },
      "raw": "key = \"master_golden_jade\",\r\n    dollars = 14,\r\n    mult = 2,\r\n    boss_colour = HEX('d0521a'),\r\n    debuff = {\r\n        akyrs_blind_difficulty = \"master\",\r\n        akyrs_deduct_mult = 0.75,\r\n    },\r\n    loc_vars = function (self)\r\n        return {\r\n            vars = {self.debuff.akyrs_deduct_mult}\r\n        }\r\n    end,\r\n\r\n    collection_loc_vars = function (self)\r\n        return {\r\n            vars = { self.debuff.akyrs_deduct_mult }\r\n        }\r\n    end,    \r\n    in_pool = function (self)\r\n        return G.GAME.round_resets.ante >= G.GAME.win_ante, {ignore_showdown_check = true}\r\n    end,\r\n    atlas = 'aikoyoriBlindsChips2', \r\n    boss = {min = 12, max = 10},\r\n    pos = { x = 0, y = 5 },\r\n    calculate = function (self, blind, context)\r\n        if context.individual and context.cardarea == G.play and not blind.disabled then\r\n            \r\n            blind.debuff.current_money = blind.debuff.current_money or G.GAME.dollars\r\n            local old_money = blind.debuff.current_money or G.GAME.dollars\r\n            blind.debuff.current_money = blind.debuff.current_money * blind.debuff.akyrs_deduct_mult\r\n            return {\r\n                func = function ()\r\n                    ease_dollars(-old_money + blind.debuff.current_money)\r\n                end\r\n            }\r\n        end\r\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "master_milk_crown_on_sonnetica",
      "name": null,
      "atlas": "aikoyoriBlindsChips2",
      "pos": {
        "x": 0,
        "y": 6
      },
      "raw": "key = \"master_milk_crown_on_sonnetica\",\r\n    dollars = 14,\r\n    mult = 2,\r\n    boss_colour = HEX('5f848c'),\r\n    debuff = {\r\n        akyrs_blind_difficulty = \"master\",\r\n    },\r\n    config = {\r\n        xscore = 0.75,\r\n    },\r\n    \r\n    in_pool = function (self)\r\n        return G.GAME.round_resets.ante >= G.GAME.win_ante, {ignore_showdown_check = true}\r\n    end,\r\n    loc_vars = function (self)\r\n        return {\r\n            vars = {\r\n                self.config.xscore\r\n            }\r\n        }\r\n    end,\r\n    collection_loc_vars = function (self)\r\n        return {\r\n            vars = {\r\n                self.config.xscore\r\n            }\r\n        }\r\n    end,\r\n    atlas = 'aikoyoriBlindsChips2', \r\n    boss = {min = 12, max = 10},\r\n    pos = { x = 0, y = 6 },\r\n    calculate = function (self, blind, context)\r\n        if context.individual and context.cardarea == G.play and not blind.disabled then\r\n            if context.other_card:is_face() then\r\n                return {\r\n                    akyrs_xscore = blind.effect.xscore\r\n                }\r\n            end\r\n        end\r\n    end",
      "config": {
        "xscore": 0.75
      },
      "ability": {
        "xscore": 0.75
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "master_bug",
      "name": null,
      "atlas": "aikoyoriBlindsChips2",
      "pos": {
        "x": 0,
        "y": 7
      },
      "raw": "key = \"master_bug\",\r\n    dollars = 14,\r\n    mult = 2,\r\n    boss_colour = HEX('4de740'),\r\n    debuff = {\r\n        akyrs_blind_difficulty = \"master\",\r\n    },\r\n    \r\n    in_pool = function (self)\r\n        return G.GAME.round_resets.ante >= G.GAME.win_ante, {ignore_showdown_check = true}\r\n    end,\r\n    atlas = 'aikoyoriBlindsChips2', \r\n    boss = {min = 12, max = 10},\r\n    pos = { x = 0, y = 7 },\r\n    calculate = function (self, blind, context)\r\n        if context.after and not context.repetition and not blind.disabled then\r\n            return {\r\n                func = function ()\r\n                    local jkrs = AKYRS.get_non_eternals(G.jokers, blind)\r\n                    if #jkrs > 0 then\r\n                        local card_to_destroy = pseudorandom_element(jkrs, \"akyrs_bug_destroy\")\r\n                        if card_to_destroy then\r\n                            card_to_destroy.akyrs_removed = true\r\n                            AKYRS.simple_event_add(\r\n                                function ()\r\n                                    card_to_destroy:start_dissolve({ G.C.RED }, nil, 1.6)\r\n                                    return true\r\n                                end, 0\r\n                            )\r\n                        end\r\n                    end\r\n                end\r\n            }\r\n\r\n        end\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "ultima_lost_umbrella",
      "name": null,
      "atlas": "aikoyoriBlindsChips2",
      "pos": {
        "x": 0,
        "y": 8
      },
      "raw": "key = \"ultima_lost_umbrella\",\r\n    dollars = 14,\r\n    mult = 3,\r\n    boss_colour = HEX('595959'),\r\n    debuff = {\r\n        akyrs_cannot_be_disabled = true,\r\n        akyrs_blind_difficulty = \"ultima\",\r\n        akyrs_is_endless_blind = true,\r\n        akyrs_cannot_be_overridden = true,\r\n        akyrs_cannot_be_skipped = true,\r\n    },\r\n    config = {\r\n        cards_left = 2  \r\n    },\r\n    loc_vars = function (self)\r\n        return {\r\n            vars = {\r\n                self.config.cards_left,\r\n            }\r\n        }\r\n    end,\r\n    collection_loc_vars = function (self)\r\n        return {\r\n            vars = {\r\n                self.config.cards_left,\r\n            }\r\n        }\r\n    end,\r\n    in_pool = function (self)\r\n        return G.GAME.round_resets.ante >= self.boss.min and G.GAME.won, {ignore_showdown_check = true}\r\n    end,\r\n    drawn_to_hand = function (self)\r\n        for i = 1, #G.jokers.cards do\r\n            G.jokers.cards[i]:set_debuff(true)\r\n        end\r\n    end,\r\n    press_play =function (self)\r\n        if G.jokers.cards[1] then\r\n            self.triggered = true\r\n            self.prepped = true\r\n        end\r\n    end,\r\n    disable = function (self)\r\n        for i = 1, #G.jokers.cards do\r\n            G.jokers.cards[i]:set_debuff(false)\r\n        end \r\n    end,\r\n    atlas = 'aikoyoriBlindsChips2', \r\n    boss = {min = 9, max = 10},\r\n    pos = { x = 0, y = 8 },\r\n    calculate = function (self, blind, context)\r\n        if context.remove_playing_cards then\r\n            return {\r\n                func = function ()\r\n                    blind.effect.cards_left = blind.effect.cards_left - #context.removed\r\n                    if blind.effect.cards_left <= 0 then\r\n                        AKYRS.force_disable_blind()\r\n                    end\r\n                end\r\n            }\r\n        end\r\n    end",
      "config": {
        "cards_left": 2
      },
      "ability": {
        "cards_left": 2
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "the_thought",
      "name": null,
      "atlas": "aikoyoriBlindsChips",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"the_thought\",\r\n    dollars = 5,\r\n    mult = 2,\r\n    boss_colour =HEX('95df3e'),\r\n    atlas = 'aikoyoriBlindsChips', \r\n    boss = {min = 1, max = 10},\r\n    pos = { x = 0, y = 0 },\r\n    debuff = {\r\n        special_blind = true,\r\n        infinite_discards = true,\r\n        akyrs_is_word_blind = true,\r\n        akyrs_is_puzzle_blind = true,\r\n    },\r\n    vars = {},\r\n    set_blind = function(self)\r\n        G.GAME.aiko_puzzle_win = false\r\n        G.GAME.current_round.advanced_blind = true\r\n        G.GAME.word_todo = AKYRS.aiko_pickRandomInTable(AKYRS.puzzle_words)\r\n        \r\n        \r\n        for _,c in ipairs(G.playing_cards) do\r\n            c:set_sprites(c.config.center,c.config.card)\r\n        end\r\n        \r\n        --print (\"Word is \"..G.GAME.word_todo)\r\n        G.E_MANAGER:add_event(\r\n            Event({\r\n                delay = 10,\r\n                func = function()\r\n                    G.hand:change_size(3)                    \r\n                    G.GAME.current_round.discards_sub = G.GAME.current_round.discards_left + 1\r\n                    self.discards_sub = G.GAME.current_round.discards_left + 1 -- math.max(G.GAME.current_round.discards_left, 0)\r\n                    ease_discard(-self.discards_sub)\r\n                    \r\n                    G.GAME.current_round.hand_sub = G.GAME.round_resets.hands-math.max(G.GAME.round_resets.hands,6)\r\n                    self.hands_sub = G.GAME.round_resets.hands-math.max(G.GAME.round_resets.hands,6)\r\n                    ease_hands_played(-self.hands_sub)\r\n                    ease_background_colour{new_colour = HEX('95df3e'), special_colour = HEX('ffd856'), tertiary_colour = G.C.BLACK, contrast = 3}\r\n                    \r\n                    return true\r\n                end\r\n            })\r\n        )\r\n        G.E_MANAGER:add_event(\r\n            Event({\r\n                delay = 10,\r\n                func = function()\r\n                    recalculateHUDUI()\r\n                    recalculateBlindUI()\r\n                    return true\r\n                end\r\n            })\r\n        )\r\n        -- add 5 temp wilds to hand so players don't get fucked royally\r\n        AKYRS.simple_event_add(\r\n            function ()\r\n                AKYRS.fill_hand()\r\n                for i = 1, 5 do\r\n                    AKYRS.simple_event_add(\r\n                        function ()\r\n                            local wldcrd = Card(11.5,15,G.CARD_W,G.CARD_H,pseudorandom_element(G.P_CARDS,pseudoseed(\"thethoughtblind\")),G.P_CENTERS['c_base'],{playing_card = G.playing_card})\r\n                            wldcrd.is_null = true\r\n                            wldcrd.ability.akyrs_self_destructs = true\r\n                            AKYRS.change_letter_to(wldcrd,\"#\")\r\n                            G.hand:emplace(wldcrd)\r\n                            return true\r\n                        end, 0.1\r\n                    )\r\n                end\r\n                return true\r\n            end, 0\r\n        )\r\n    end,\r\n    drawn_to_hand = function(self)\r\n        AKYRS.simple_event_add(\r\n            function()\r\n                G.deck:shuffle(\"akyrsthought\")\r\n                G.FUNCS.draw_from_discard_to_deck()\r\n                return true\r\n            end,0.2\r\n        )\r\n    end,\r\n    in_pool = function(self)\r\n        return (G.GAME.akyrs_character_stickers_enabled and G.GAME.akyrs_wording_enabled)\r\n    end,\r\n    disable = function(self)\r\n        G.GAME.current_round.advanced_blind = false\r\n        G.hand:change_size(-3)\r\n        \r\n        ease_hands_played(self.hands_sub or G.GAME.current_round.hand_sub)\r\n        ease_discard(self.discards_sub or G.GAME.current_round.discards_sub)\r\n        \r\n        recalculateHUDUI()\r\n        recalculateBlindUI()\r\n        \r\n    end,\r\n    defeat = function(self)\r\n        G.GAME.current_round.advanced_blind = false\r\n        G.hand:change_size(-3)\r\n        \r\n        for _,c in ipairs(G.playing_cards) do\r\n            c:set_sprites(c.config.center,c.config.card)\r\n        end\r\n        recalculateHUDUI()\r\n        recalculateBlindUI()\r\n    end,\r\n    calculate = function (self, blind, context)\r\n        if context.after then\r\n            return {\r\n                func =function ()\r\n                    \r\n                    if true then\r\n                        AKYRS.simple_event_add(\r\n                            function()\r\n                                AKYRS.force_check_win({ force_draw = true})\r\n                                return true\r\n                            end, 0\r\n                        )\r\n                    end\r\n                end\r\n            }\r\n        end\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "the_bomb",
      "name": null,
      "atlas": "aikoyoriBlindsChips2",
      "pos": {
        "x": 0,
        "y": 14
      },
      "raw": "key = \"the_bomb\",\r\n    dollars = 5,\r\n    mult = 2,\r\n    boss_colour = HEX('FF6F4B'),\r\n    atlas = 'aikoyoriBlindsChips2', \r\n    boss = {min = 1, max = 10},\r\n    pos = { x = 0, y = 14 },\r\n    debuff = {\r\n        special_blind = true,\r\n        infinite_discards = true,\r\n        akyrs_is_word_blind = true,\r\n        akyrs_is_puzzle_blind = true,\r\n        akyrs_cannot_be_disabled = true,\r\n    },\r\n    vars = {},\r\n    set_blind = function(self)\r\n        G.GAME.aiko_puzzle_win = false\r\n        G.GAME.current_round.advanced_blind = true\r\n        \r\n        \r\n        for _,c in ipairs(G.playing_cards) do\r\n            c:set_sprites(c.config.center,c.config.card)\r\n        end\r\n        \r\n        --print (\"Word is \"..G.GAME.word_todo)\r\n        G.E_MANAGER:add_event(\r\n            Event({\r\n                delay = 10,\r\n                func = function()\r\n                    --ease_background_colour{new_colour = HEX('95df3e'), special_colour = HEX('ffd856'), tertiary_colour = G.C.BLACK, contrast = 3}\r\n                    G.hand:change_size(9)\r\n                    SMODS.change_play_limit(1e4)\r\n                    SMODS.change_discard_limit(1e4)\r\n                    \r\n                    for _, _c in ipairs(G.jokers.cards) do\r\n                        ---@type Card\r\n                        _c = _c\r\n                        _c:set_debuff(true)\r\n                    end\r\n                    for _, _c in ipairs(G.consumeables.cards) do\r\n                        ---@type Card\r\n                        _c = _c\r\n                        _c:set_debuff(true)\r\n                    end\r\n                    return true\r\n                end\r\n            })\r\n        )\r\n        G.E_MANAGER:add_event(\r\n            Event({\r\n                delay = 10,\r\n                func = function()\r\n                    recalculateHUDUI()\r\n                    recalculateBlindUI()\r\n                    return true\r\n                end\r\n            })\r\n        )\r\n        -- add 5 temp wilds to hand so players don't get fucked royally\r\n        AKYRS.simple_event_add(\r\n            function ()\r\n                AKYRS.fill_hand()\r\n                for i = 2, 5 do\r\n                    AKYRS.simple_event_add(\r\n                        function ()\r\n                            local prompt_card = Card(11.5,15,G.CARD_W,G.CARD_H,pseudorandom_element(G.P_CARDS,pseudoseed(\"thebombblind\")),G.P_CENTERS['c_base'],{playing_card = G.playing_card})\r\n                            prompt_card.is_null = true\r\n                            prompt_card.ability.akyrs_attention = true\r\n                            AKYRS.simple_event_add(\r\n                                function ()\r\n                                    local ante = Talisman and to_number(G.GAME.round_resets.ante) or G.GAME.round_resets.ante\r\n                                    local fct = 2 * (i - 1) - 1\r\n                                    local max_freq = (70000/(fct))/ante^1.5 / (AKYRS.config.full_dictionary and 1 or 10)\r\n                                    local min_freq = (15000/(fct))/ante^1.03 / (AKYRS.config.full_dictionary and 1 or 10)\r\n                                    local prompt, freq = AKYRS.get_bomb_prompt(\r\n                                    {\r\n                                        min_freq = min_freq, \r\n                                        max_freq = max_freq, \r\n                                        min_length = i, \r\n                                        max_length = i, \r\n                                        seed = \"thebombblind_carder\"\r\n                                    })\r\n                                    if prompt then\r\n                                        AKYRS.change_letter_to(prompt_card,prompt)\r\n                                        prompt_card.ability.akyrs_word_freq = freq\r\n                                        G.hand:emplace(prompt_card)\r\n                                        table.insert(G.playing_cards, prompt_card)\r\n                                    end\r\n                                    return true\r\n                                end, 0)\r\n                            return true\r\n                        end, 0.2\r\n                    )\r\n                end\r\n                return true\r\n            end, 0\r\n        )\r\n    end,\r\n    drawn_to_hand = function(self)\r\n        AKYRS.simple_event_add(\r\n            function()\r\n                G.deck:shuffle(\"akyrsthought\")\r\n                G.FUNCS.draw_from_discard_to_deck()\r\n                return true\r\n            end,0.2\r\n        )\r\n    end,\r\n    in_pool = function(self)\r\n        return (G.GAME.akyrs_character_stickers_enabled and G.GAME.akyrs_wording_enabled)\r\n    end,\r\n    disable = function(self)\r\n        G.GAME.current_round.advanced_blind = false\r\n        \r\n        for _, _c in ipairs(G.jokers.cards) do\r\n            ---@type Card\r\n            _c = _c\r\n            _c:set_debuff(false)\r\n        end\r\n        for _, _c in ipairs(G.consumeables.cards) do\r\n            ---@type Card\r\n            _c = _c\r\n            _c:set_debuff(false)\r\n        end\r\n        for _,c in ipairs(G.playing_cards) do\r\n            c:set_sprites(c.config.center,c.config.card)\r\n        end\r\n        G.hand:change_size(-9)\r\n        SMODS.change_play_limit(-1e4)\r\n        SMODS.change_discard_limit(-1e4)\r\n        \r\n        recalculateHUDUI()\r\n        recalculateBlindUI()\r\n        \r\n    end,\r\n    defeat = function(self)\r\n        G.GAME.current_round.advanced_blind = false\r\n        for _,c in ipairs(G.playing_cards) do\r\n            c:set_sprites(c.config.center,c.config.card)\r\n        end\r\n        G.hand:change_size(-9)\r\n        SMODS.change_play_limit(-1e4)\r\n        SMODS.change_discard_limit(-1e4)\r\n        recalculateHUDUI()\r\n        recalculateBlindUI()\r\n        for _, _c in ipairs(G.consumeables.cards) do\r\n            ---@type Card\r\n            _c = _c\r\n            _c:set_debuff(false)\r\n        end\r\n    end,\r\n    press_play = function(self)\r\n        \r\n    end,\r\n    calculate = function (self, blind, context)\r\n        if context.debuff_hand then \r\n            \r\n            local hand = context.full_hand\r\n            table.sort(hand, AKYRS.hand_sort_function)\r\n            local s = AKYRS.word_hand_combine(hand)\r\n            local hand_return, word_data = AKYRS.word_hand_search(s, hand, #s)\r\n            if not ((word_data or {}).valid) then\r\n            return {\r\n                debuff = true,\r\n                debuff_text = localize(\"k_akyrs_must_contain_word\"),\r\n                func = function ()\r\n                    AKYRS.simple_event_add(\r\n                        function()\r\n                            if G.STATE == G.STATES.HAND_PLAYED then\r\n                                G.FUNCS.akyrs_force_draw_from_discard_to_hand()\r\n                            else\r\n                        end\r\n                        return true\r\n                    end, 0)\r\n                end\r\n                }\r\n            end\r\n            \r\n        end\r\n        if context.after then\r\n            return {\r\n                func = function ()\r\n                    \r\n                    for _, _c in ipairs(G.jokers.cards) do\r\n                        ---@type Card\r\n                        _c = _c\r\n                        _c:set_debuff(true)\r\n                    end\r\n                    for _, _c in ipairs(G.consumeables.cards) do\r\n                        ---@type Card\r\n                        _c = _c\r\n                        _c:set_debuff(true)\r\n                    end\r\n                    \r\n                    AKYRS.simple_event_add(\r\n                        function()\r\n                            G.deck:shuffle(\"akyrsbombblind\")\r\n                            G.FUNCS.draw_from_discard_to_deck()\r\n                            return true\r\n                        end,0.2\r\n                    )\r\n                    AKYRS.simple_event_add(\r\n                        function()\r\n                            if not G.GAME.akyrs_win_checked then\r\n                                \r\n                                AKYRS.simple_event_add(\r\n                                function()\r\n                                    local attention_no_longer_in_hand = true\r\n                                    for _,_c in ipairs(G.playing_cards) do\r\n                                        if _c.ability.akyrs_attention then\r\n                                            attention_no_longer_in_hand = false\r\n                                        end\r\n                                    end\r\n                                    G.GAME.aiko_puzzle_win = attention_no_longer_in_hand\r\n                                    if true then\r\n                                        AKYRS.simple_event_add(\r\n                                            function()\r\n                                                AKYRS.force_check_win({ force_draw = true})\r\n                                                return true\r\n                                            end, 0\r\n                                        )\r\n                                    end\r\n                                    return true\r\n                                end, 0.2)\r\n                            end\r\n                            return true\r\n                        end,0.2\r\n                    )\r\n                end\r\n            }\r\n        end\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "the_bent",
      "name": null,
      "atlas": "aikoyoriBlindsChips2",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"the_bent\",\r\n    dollars = 5,\r\n    mult = 2,\r\n    boss_colour = HEX(\"ff5454\"),\r\n    atlas = 'aikoyoriBlindsChips2',\r\n    debuff = {\r\n        special_blind = true,\r\n        akyrs_is_puzzle_blind = true,\r\n    },\r\n    config = {\r\n        times_left = 2,\r\n    },\r\n    boss = {min = 2, max = 10},\r\n    pos = { x = 0, y = 0 },\r\n    in_pool = function(self)\r\n        return G.GAME.round_resets.hands > 1 and G.GAME.round_resets.ante >= self.boss.min\r\n    end,\r\n    loc_vars = function (self)\r\n        return {\r\n            vars = {\r\n                localize(G.GAME.current_round.akyrs_picked_poker_hands, \"poker_hands\") or \"????\",\r\n                self.config.times_left,\r\n            }\r\n        }\r\n    end,\r\n    collection_loc_vars = function (self)\r\n        return {\r\n            vars = {\r\n                localize(\"k_akyrs_random_played_hand\"),\r\n                self.config.times_left,\r\n            }\r\n        }\r\n    end,\r\n    set_blind = function (self)\r\n        G.GAME.aiko_puzzle_win = false\r\n        G.GAME.current_round.advanced_blind = true\r\n        recalculateBlindUI()\r\n    end,\r\n    disable = function(self)\r\n        G.GAME.current_round.advanced_blind = false\r\n        recalculateBlindUI()\r\n    end,\r\n    calculate = function (self, blind, context)\r\n        if not blind.disabled then\r\n            if context.before then\r\n                if context.scoring_name == G.GAME.current_round.akyrs_picked_poker_hands then\r\n                    SMODS.calculate_effect({\r\n                        func = function ()\r\n                            blind.effect.times_left = (blind.effect.times_left) - 1\r\n                            if blind.effect.times_left <= 0 then\r\n                                G.GAME.aiko_puzzle_win = true\r\n                            end                         \r\n                        end\r\n                    }, blind)\r\n                end\r\n                return {\r\n                    func = function ()\r\n                        AKYRS.simple_event_add(\r\n                            function()\r\n                                AKYRS.force_check_win({ force_draw = true, state_to_go = G.STATES.SELECTING_HAND })\r\n                                return true\r\n                            end, 0\r\n                        )\r\n                        recalculateBlindUI()\r\n\r\n                    end\r\n                }\r\n            end\r\n        end\r\n    end,",
      "config": {
        "times_left": 2
      },
      "ability": {
        "times_left": 2
      },
      "vars": [
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "letter_pack_1",
      "name": null,
      "atlas": "aikoyoriBoosterPack",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"letter_pack_1\",\r\n    set = \"Booster\",\r\n    config = { extra = 3, choose = 1 },\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.choose,\r\n                card.ability.extra,\r\n            },\r\n            key = \"p_akyrs_letter_pack_normal\"\r\n        }\r\n    end,\r\n    atlas = 'aikoyoriBoosterPack', pos = { x = 0, y = 0 },\r\n    group_key = \"k_akyrs_alphabet_pack\",\r\n    cost = 4,\r\n    select_card = 'consumeables',\r\n    weight = 1,\r\n    kind = \"letter_pack\",\r\n    create_card = function (self, card, i) \r\n        return create_card(\"Alphabet\", G.pack_cards, nil, nil, true, true, nil, \"_letter\")\r\n    end,\r\n    in_pool = function(self, args)\r\n        return G.GAME.akyrs_character_stickers_enabled and G.GAME.akyrs_wording_enabled\r\n    end,\r\n    cry_digital_hallucinations = alphabet_digital_hallucinations_compat,",
      "config": {
        "extra": 3,
        "choose": 1
      },
      "ability": {
        "extra": 3,
        "choose": 1
      },
      "vars": [
        1,
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "letter_pack_2",
      "name": null,
      "atlas": "aikoyoriBoosterPack",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"letter_pack_2\",\r\n    set = \"Booster\",\r\n    config = { extra = 3, choose = 1 },\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.choose,\r\n                card.ability.extra,\r\n            },\r\n            key = \"p_akyrs_letter_pack_normal\"\r\n        }\r\n    end,\r\n    atlas = 'aikoyoriBoosterPack', pos = { x = 1, y = 0 },\r\n    group_key = \"k_akyrs_alphabet_pack\",\r\n    cost = 4,\r\n    select_card = 'consumeables',\r\n    weight = 1,\r\n    kind = \"letter_pack\",\r\n    create_card = function (self, card, i) \r\n        return create_card(\"Alphabet\", G.pack_cards, nil, nil, true, true, nil, \"_letter\")\r\n    end,\r\n    in_pool = function(self, args)\r\n        return G.GAME.akyrs_character_stickers_enabled and G.GAME.akyrs_wording_enabled\r\n    end,\r\n    cry_digital_hallucinations = alphabet_digital_hallucinations_compat,",
      "config": {
        "extra": 3,
        "choose": 1
      },
      "ability": {
        "extra": 3,
        "choose": 1
      },
      "vars": [
        1,
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "letter_pack_3",
      "name": null,
      "atlas": "aikoyoriBoosterPack",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"letter_pack_3\",\r\n    set = \"Booster\",\r\n    config = { extra = 3, choose = 1 },\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.choose,\r\n                card.ability.extra,\r\n            },\r\n            key = \"p_akyrs_letter_pack_normal\"\r\n        }\r\n    end,\r\n    atlas = 'aikoyoriBoosterPack', pos = { x = 2, y = 0 },\r\n    group_key = \"k_akyrs_alphabet_pack\",\r\n    cost = 4,\r\n    select_card = 'consumeables',\r\n    weight = 1,\r\n    kind = \"letter_pack\",\r\n    create_card = function (self, card, i) \r\n        return create_card(\"Alphabet\", G.pack_cards, nil, nil, true, true, nil, \"_letter\")\r\n    end,\r\n    in_pool = function(self, args)\r\n        return G.GAME.akyrs_character_stickers_enabled and G.GAME.akyrs_wording_enabled\r\n    end,\r\n    cry_digital_hallucinations = alphabet_digital_hallucinations_compat,",
      "config": {
        "extra": 3,
        "choose": 1
      },
      "ability": {
        "extra": 3,
        "choose": 1
      },
      "vars": [
        1,
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "letter_pack_4",
      "name": null,
      "atlas": "aikoyoriBoosterPack",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"letter_pack_4\",\r\n    set = \"Booster\",\r\n    config = { extra = 3, choose = 1 },\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.choose,\r\n                card.ability.extra,\r\n            },\r\n            key = \"p_akyrs_letter_pack_normal\"\r\n        }\r\n    end,\r\n    atlas = 'aikoyoriBoosterPack', pos = { x = 3, y = 0 },\r\n    group_key = \"k_akyrs_alphabet_pack\",\r\n    cost = 4,\r\n    select_card = 'consumeables',\r\n    weight = 1,\r\n    kind = \"letter_pack\",\r\n    create_card = function (self, card, i) \r\n        return create_card(\"Alphabet\", G.pack_cards, nil, nil, true, true, nil, \"_letter\")\r\n    end,\r\n    in_pool = function(self, args)\r\n        return G.GAME.akyrs_character_stickers_enabled and G.GAME.akyrs_wording_enabled\r\n    end,\r\n    cry_digital_hallucinations = alphabet_digital_hallucinations_compat,",
      "config": {
        "extra": 3,
        "choose": 1
      },
      "ability": {
        "extra": 3,
        "choose": 1
      },
      "vars": [
        1,
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "jumbo_letter_pack_1",
      "name": null,
      "atlas": "aikoyoriBoosterPack",
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "key = \"jumbo_letter_pack_1\",\r\n    set = \"Booster\",\r\n    config = { extra = 5, choose = 1 },\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.choose,\r\n                card.ability.extra,\r\n            },\r\n            key = \"p_akyrs_letter_pack_jumbo\"\r\n        }\r\n    end,\r\n    atlas = 'aikoyoriBoosterPack', pos = { x = 4, y = 0 },\r\n    group_key = \"k_akyrs_alphabet_pack\",\r\n    cost = 6,\r\n    select_card = 'consumeables',\r\n    weight = 1,\r\n    kind = \"letter_pack\",\r\n    create_card = function (self, card, i) \r\n        return create_card(\"Alphabet\", G.pack_cards, nil, nil, true, true, nil, \"_letter\")\r\n    end,\r\n    in_pool = function(self, args)\r\n        return G.GAME.akyrs_character_stickers_enabled and G.GAME.akyrs_wording_enabled\r\n    end,\r\n    cry_digital_hallucinations = alphabet_digital_hallucinations_compat,",
      "config": {
        "extra": 5,
        "choose": 1
      },
      "ability": {
        "extra": 5,
        "choose": 1
      },
      "vars": [
        1,
        5
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "jumbo_letter_pack_2",
      "name": null,
      "atlas": "aikoyoriBoosterPack",
      "pos": {
        "x": 5,
        "y": 0
      },
      "raw": "key = \"jumbo_letter_pack_2\",\r\n    set = \"Booster\",\r\n    config = { extra = 5, choose = 1 },\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.choose,\r\n                card.ability.extra,\r\n            },\r\n            key = \"p_akyrs_letter_pack_jumbo\"\r\n        }\r\n    end,\r\n    atlas = 'aikoyoriBoosterPack', pos = { x = 5, y = 0 },\r\n    group_key = \"k_akyrs_alphabet_pack\",\r\n    cost = 6,\r\n    select_card = 'consumeables',\r\n    weight = 1,\r\n    kind = \"letter_pack\",\r\n    create_card = function (self, card, i) \r\n        return create_card(\"Alphabet\", G.pack_cards, nil, nil, true, true, nil, \"_letter\")\r\n    end,\r\n    in_pool = function(self, args)\r\n        return G.GAME.akyrs_character_stickers_enabled and G.GAME.akyrs_wording_enabled\r\n    end,\r\n    cry_digital_hallucinations = alphabet_digital_hallucinations_compat,",
      "config": {
        "extra": 5,
        "choose": 1
      },
      "ability": {
        "extra": 5,
        "choose": 1
      },
      "vars": [
        1,
        5
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "mega_letter_pack_1",
      "name": null,
      "atlas": "aikoyoriBoosterPack",
      "pos": {
        "x": 6,
        "y": 0
      },
      "raw": "key = \"mega_letter_pack_1\",\r\n    set = \"Booster\",\r\n    config = { extra = 5, choose = 2 },\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.choose,\r\n                card.ability.extra,\r\n            },\r\n            key = \"p_akyrs_letter_pack_mega\"\r\n        }\r\n    end,\r\n    atlas = 'aikoyoriBoosterPack', pos = { x = 6, y = 0 },\r\n    group_key = \"k_akyrs_alphabet_pack\",\r\n    cost = 8,\r\n    select_card = 'consumeables',\r\n    weight = 0.25,\r\n    kind = \"letter_pack\",\r\n    create_card = function (self, card, i) \r\n        return create_card(\"Alphabet\", G.pack_cards, nil, nil, true, true, nil, \"_letter\")\r\n    end,\r\n    in_pool = function(self, args)\r\n        return G.GAME.akyrs_character_stickers_enabled and G.GAME.akyrs_wording_enabled\r\n    end,\r\n    cry_digital_hallucinations = alphabet_digital_hallucinations_compat,",
      "config": {
        "extra": 5,
        "choose": 2
      },
      "ability": {
        "extra": 5,
        "choose": 2
      },
      "vars": [
        2,
        5
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "mega_letter_pack_2",
      "name": null,
      "atlas": "aikoyoriBoosterPack",
      "pos": {
        "x": 7,
        "y": 0
      },
      "raw": "key = \"mega_letter_pack_2\",\r\n    set = \"Booster\",\r\n    config = { extra = 5, choose = 2 },\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.choose,\r\n                card.ability.extra,\r\n            },\r\n            key = \"p_akyrs_letter_pack_mega\"\r\n        }\r\n    end,\r\n    atlas = 'aikoyoriBoosterPack', pos = { x = 7, y = 0 },\r\n    group_key = \"k_akyrs_alphabet_pack\",\r\n    cost = 8,\r\n    select_card = 'consumeables',\r\n    weight = 0.25,\r\n    kind = \"letter_pack\",\r\n    create_card = function (self, card, i) \r\n        return create_card(\"Alphabet\", G.pack_cards, nil, nil, true, true, nil, \"_letter\")\r\n    end,\r\n    in_pool = function(self, args)\r\n        return G.GAME.akyrs_character_stickers_enabled and G.GAME.akyrs_wording_enabled\r\n    end,\r\n    cry_digital_hallucinations = alphabet_digital_hallucinations_compat,",
      "config": {
        "extra": 5,
        "choose": 2
      },
      "ability": {
        "extra": 5,
        "choose": 2
      },
      "vars": [
        2,
        5
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "umbral_pack_1",
      "name": null,
      "atlas": "aikoyoriBoosterPack",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"umbral_pack_1\",\r\n    set = \"Booster\",\r\n    config = { extra = 3, choose = 1 },\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.choose,\r\n                card.ability.extra,\r\n            },\r\n            key = \"p_akyrs_umbral_pack_normal\"\r\n        }\r\n    end,\r\n    atlas = 'aikoyoriBoosterPack', pos = { x = 0, y = 1 },\r\n    group_key = \"k_akyrs_umbral_pack\",\r\n    cost = 4,\r\n    weight = 0.5,\r\n    draw_hand = true,\r\n    kind = \"umbral_pack\",\r\n    create_card = function (self, card, i) \r\n        return SMODS.create_card{ set = \"Umbral\", area = G.pack_cards, skip_materialize = true }\r\n    end,\r\n    ease_background_colour = ease_bg_umbral,\r\n    cry_digital_hallucinations = umbral_digital_hallucinations_compat,",
      "config": {
        "extra": 3,
        "choose": 1
      },
      "ability": {
        "extra": 3,
        "choose": 1
      },
      "vars": [
        1,
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "umbral_pack_2",
      "name": null,
      "atlas": "aikoyoriBoosterPack",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"umbral_pack_2\",\r\n    set = \"Booster\",\r\n    config = { extra = 3, choose = 1 },\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.choose,\r\n                card.ability.extra,\r\n            },\r\n            key = \"p_akyrs_umbral_pack_normal\"\r\n        }\r\n    end,\r\n    atlas = 'aikoyoriBoosterPack', pos = { x = 1, y = 1 },\r\n    group_key = \"k_akyrs_umbral_pack\",\r\n    cost = 4,\r\n    weight = 0.5,\r\n    draw_hand = true,\r\n    kind = \"umbral_pack\",\r\n    create_card = function (self, card, i) \r\n        return SMODS.create_card{ set = \"Umbral\", area = G.pack_cards, skip_materialize = true }\r\n    end,\r\n    ease_background_colour = ease_bg_umbral,\r\n    cry_digital_hallucinations = umbral_digital_hallucinations_compat,",
      "config": {
        "extra": 3,
        "choose": 1
      },
      "ability": {
        "extra": 3,
        "choose": 1
      },
      "vars": [
        1,
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "umbral_pack_3",
      "name": null,
      "atlas": "aikoyoriBoosterPack",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"umbral_pack_3\",\r\n    set = \"Booster\",\r\n    config = { extra = 3, choose = 1 },\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.choose,\r\n                card.ability.extra,\r\n            },\r\n            key = \"p_akyrs_umbral_pack_normal\"\r\n        }\r\n    end,\r\n    atlas = 'aikoyoriBoosterPack', pos = { x = 2, y = 1 },\r\n    group_key = \"k_akyrs_umbral_pack\",\r\n    cost = 4,\r\n    weight = 0.5,\r\n    draw_hand = true,\r\n    kind = \"umbral_pack\",\r\n    create_card = function (self, card, i) \r\n        return SMODS.create_card{ set = \"Umbral\", area = G.pack_cards, skip_materialize = true }\r\n    end,\r\n    ease_background_colour = ease_bg_umbral,\r\n    cry_digital_hallucinations = umbral_digital_hallucinations_compat,",
      "config": {
        "extra": 3,
        "choose": 1
      },
      "ability": {
        "extra": 3,
        "choose": 1
      },
      "vars": [
        1,
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "umbral_pack_4",
      "name": null,
      "atlas": "aikoyoriBoosterPack",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"umbral_pack_4\",\r\n    set = \"Booster\",\r\n    config = { extra = 3, choose = 1 },\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.choose,\r\n                card.ability.extra,\r\n            },\r\n            key = \"p_akyrs_umbral_pack_normal\"\r\n        }\r\n    end,\r\n    atlas = 'aikoyoriBoosterPack', pos = { x = 3, y = 1 },\r\n    group_key = \"k_akyrs_umbral_pack\",\r\n    cost = 4,\r\n    weight = 0.5,\r\n    create_card = function (self, card, i) \r\n        return SMODS.create_card{ set = \"Umbral\", area = G.pack_cards, skip_materialize = true }\r\n    end,\r\n    draw_hand = true,\r\n    kind = \"umbral_pack\",\r\n    ease_background_colour = ease_bg_umbral,\r\n    cry_digital_hallucinations = umbral_digital_hallucinations_compat,",
      "config": {
        "extra": 3,
        "choose": 1
      },
      "ability": {
        "extra": 3,
        "choose": 1
      },
      "vars": [
        1,
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "jumbo_umbral_pack_1",
      "name": null,
      "atlas": "aikoyoriBoosterPack",
      "pos": {
        "x": 4,
        "y": 1
      },
      "raw": "key = \"jumbo_umbral_pack_1\",\r\n    set = \"Booster\",\r\n    config = { extra = 5, choose = 1 },\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.choose,\r\n                card.ability.extra,\r\n            },\r\n            key = \"p_akyrs_umbral_pack_jumbo\"\r\n        }\r\n    end,\r\n    atlas = 'aikoyoriBoosterPack', pos = { x = 4, y = 1 },\r\n    group_key = \"k_akyrs_umbral_pack\",\r\n    cost = 6,\r\n    weight = 0.5,\r\n    draw_hand = true,\r\n    kind = \"umbral_pack\",\r\n    create_card = function (self, card, i) \r\n        return SMODS.create_card{ set = \"Umbral\", area = G.pack_cards, skip_materialize = true }\r\n    end,\r\n    ease_background_colour = ease_bg_umbral,\r\n    cry_digital_hallucinations = umbral_digital_hallucinations_compat,",
      "config": {
        "extra": 5,
        "choose": 1
      },
      "ability": {
        "extra": 5,
        "choose": 1
      },
      "vars": [
        1,
        5
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "jumbo_umbral_pack_2",
      "name": null,
      "atlas": "aikoyoriBoosterPack",
      "pos": {
        "x": 5,
        "y": 1
      },
      "raw": "key = \"jumbo_umbral_pack_2\",\r\n    set = \"Booster\",\r\n    config = { extra = 5, choose = 1 },\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.choose,\r\n                card.ability.extra,\r\n            },\r\n            key = \"p_akyrs_umbral_pack_jumbo\"\r\n        }\r\n    end,\r\n    atlas = 'aikoyoriBoosterPack', pos = { x = 5, y = 1 },\r\n    group_key = \"k_akyrs_umbral_pack\",\r\n    cost = 6,\r\n    weight = 0.5,\r\n    draw_hand = true,\r\n    kind = \"umbral_pack\",\r\n    create_card = function (self, card, i) \r\n        return SMODS.create_card{ set = \"Umbral\", area = G.pack_cards, skip_materialize = true }\r\n    end,\r\n    ease_background_colour = ease_bg_umbral,\r\n    cry_digital_hallucinations = umbral_digital_hallucinations_compat,",
      "config": {
        "extra": 5,
        "choose": 1
      },
      "ability": {
        "extra": 5,
        "choose": 1
      },
      "vars": [
        1,
        5
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "mega_umbral_pack_1",
      "name": null,
      "atlas": "aikoyoriBoosterPack",
      "pos": {
        "x": 6,
        "y": 1
      },
      "raw": "key = \"mega_umbral_pack_1\",\r\n    set = \"Booster\",\r\n    config = { extra = 5, choose = 2 },\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.choose,\r\n                card.ability.extra,\r\n            },\r\n            key = \"p_akyrs_umbral_pack_mega\"\r\n        }\r\n    end,\r\n    atlas = 'aikoyoriBoosterPack', pos = { x = 6, y = 1 },\r\n    group_key = \"k_akyrs_umbral_pack\",\r\n    cost = 8,\r\n    weight = 0.125,\r\n    draw_hand = true,\r\n    kind = \"umbral_pack\",\r\n    create_card = function (self, card, i) \r\n        return SMODS.create_card{ set = \"Umbral\", area = G.pack_cards, skip_materialize = true }\r\n    end,\r\n    ease_background_colour = ease_bg_umbral,\r\n    cry_digital_hallucinations = umbral_digital_hallucinations_compat,",
      "config": {
        "extra": 5,
        "choose": 2
      },
      "ability": {
        "extra": 5,
        "choose": 2
      },
      "vars": [
        2,
        5
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "mega_umbral_pack_2",
      "name": null,
      "atlas": "aikoyoriBoosterPack",
      "pos": {
        "x": 7,
        "y": 1
      },
      "raw": "key = \"mega_umbral_pack_2\",\r\n    set = \"Booster\",\r\n    config = { extra = 5, choose = 2 },\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.choose,\r\n                card.ability.extra,\r\n            },\r\n            key = \"p_akyrs_umbral_pack_mega\"\r\n        }\r\n    end,\r\n    atlas = 'aikoyoriBoosterPack', pos = { x = 7, y = 1 },\r\n    group_key = \"k_akyrs_umbral_pack\",\r\n    draw_hand = true,\r\n    cost = 8,\r\n    weight = 0.125,\r\n    kind = \"umbral_pack\",\r\n    create_card = function (self, card, i) \r\n        return SMODS.create_card{ set = \"Umbral\", area = G.pack_cards, skip_materialize = true }\r\n    end,\r\n    ease_background_colour = ease_bg_umbral,\r\n    cry_digital_hallucinations = umbral_digital_hallucinations_compat,",
      "config": {
        "extra": 5,
        "choose": 2
      },
      "ability": {
        "extra": 5,
        "choose": 2
      },
      "vars": [
        2,
        5
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "replica_pack_1",
      "name": null,
      "atlas": "aikoyoriBoosterPack",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = \"replica_pack_1\",\r\n    set = \"Booster\",\r\n    config = { extra = 2, choose = 1 },\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.choose,\r\n                card.ability.extra,\r\n            },\r\n            key = \"p_akyrs_replica_pack_normal\"\r\n        }\r\n    end,\r\n    atlas = 'aikoyoriBoosterPack', pos = { x = 0, y = 2 },\r\n    group_key = \"k_akyrs_replica_pack\",\r\n    cost = 4,\r\n    weight = 0.2,\r\n    draw_hand = true,\r\n    kind = \"replica_pack\",\r\n    create_card = function (self, card, i) \r\n        return SMODS.create_card{ set = \"Replicant\", area = G.pack_cards, skip_materialize = true }\r\n    end,\r\n    ease_background_colour = ease_bg_replicant,\r\n    cry_digital_hallucinations = replicant_digital_hallucinations_compat,",
      "config": {
        "extra": 2,
        "choose": 1
      },
      "ability": {
        "extra": 2,
        "choose": 1
      },
      "vars": [
        1,
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "replica_pack_2",
      "name": null,
      "atlas": "aikoyoriBoosterPack",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "key = \"replica_pack_2\",\r\n    set = \"Booster\",\r\n    config = { extra = 2, choose = 1 },\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.choose,\r\n                card.ability.extra,\r\n            },\r\n            key = \"p_akyrs_replica_pack_normal\"\r\n        }\r\n    end,\r\n    atlas = 'aikoyoriBoosterPack', pos = { x = 1, y = 2 },\r\n    group_key = \"k_akyrs_replica_pack\",\r\n    cost = 4,\r\n    weight = 0.2,\r\n    draw_hand = true,\r\n    kind = \"replica_pack\",\r\n    create_card = function (self, card, i) \r\n        return SMODS.create_card{ set = \"Replicant\", area = G.pack_cards, skip_materialize = true }\r\n    end,\r\n    ease_background_colour = ease_bg_replicant,\r\n    cry_digital_hallucinations = replicant_digital_hallucinations_compat,",
      "config": {
        "extra": 2,
        "choose": 1
      },
      "ability": {
        "extra": 2,
        "choose": 1
      },
      "vars": [
        1,
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "jumbo_replica_pack_1",
      "name": null,
      "atlas": "aikoyoriBoosterPack",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "key = \"jumbo_replica_pack_1\",\r\n    set = \"Booster\",\r\n    config = { extra = 3, choose = 1 },\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.choose,\r\n                card.ability.extra,\r\n            },\r\n            key = \"p_akyrs_replica_pack_jumbo\"\r\n        }\r\n    end,\r\n    atlas = 'aikoyoriBoosterPack', pos = { x = 2, y = 2 },\r\n    group_key = \"k_akyrs_replica_pack\",\r\n    cost = 6,\r\n    weight = 0.2,\r\n    draw_hand = true,\r\n    kind = \"replica_pack\",\r\n    create_card = function (self, card, i) \r\n        return SMODS.create_card{ set = \"Replicant\", area = G.pack_cards, skip_materialize = true }\r\n    end,\r\n    ease_background_colour = ease_bg_replicant,\r\n    cry_digital_hallucinations = replicant_digital_hallucinations_compat,",
      "config": {
        "extra": 3,
        "choose": 1
      },
      "ability": {
        "extra": 3,
        "choose": 1
      },
      "vars": [
        1,
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "mega_replica_pack_1",
      "name": null,
      "atlas": "aikoyoriBoosterPack",
      "pos": {
        "x": 3,
        "y": 2
      },
      "raw": "key = \"mega_replica_pack_1\",\r\n    set = \"Booster\",\r\n    config = { extra = 4, choose = 1 },\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.choose,\r\n                card.ability.extra,\r\n            },\r\n            key = \"p_akyrs_replica_pack_mega\"\r\n        }\r\n    end,\r\n    atlas = 'aikoyoriBoosterPack', pos = { x = 3, y = 2 },\r\n    group_key = \"k_akyrs_replica_pack\",\r\n    cost = 8,\r\n    weight = 0.04,\r\n    draw_hand = true,\r\n    kind = \"replica_pack\",\r\n    create_card = function (self, card, i) \r\n        return SMODS.create_card{ set = \"Replicant\", area = G.pack_cards, skip_materialize = true }\r\n    end,\r\n    ease_background_colour = ease_bg_replicant,\r\n    cry_digital_hallucinations = replicant_digital_hallucinations_compat,",
      "config": {
        "extra": 4,
        "choose": 1
      },
      "ability": {
        "extra": 4,
        "choose": 1
      },
      "vars": [
        1,
        4
      ],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "null",
      "name": "Null",
      "atlas": "cardUpgrades",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "--    key = \"null\",\r\n--    atlas = 'cardUpgrades',\r\n--    pos = {x = 0, y = 0},\r\n--    loc_txt =  \t{\r\n--        name = 'Null',\r\n--        text = { 'No Base Chips' },\r\n--    },\r\n--    replace_base_card = true,\r\n--    no_rank = true,\r\n--    no_suit = true,\r\n--    always_scores = true,\r\n--    weight = 0,\r\n--    config = {\r\n--        bonus = 0,\r\n--        bonus_chips = 0,\r\n--        mult = 0,\r\n--    }\r\n--",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "brick_card",
      "name": null,
      "atlas": "cardUpgrades",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"brick_card\",\r\n    atlas = 'cardUpgrades',\r\n    pos = {x = 1, y = 0},\r\n    loc_vars = function (self, info_queue, card)\r\n        return { vars = {\r\n            card.ability.extra.mult\r\n        } }\r\n    end,\r\n    config = {\r\n        extra = {\r\n            mult = 10\r\n        }\r\n    },\r\n    calculate = function (self, card, context)\r\n        if context.main_scoring and context.cardarea == G.play then\r\n            return {\r\n                mult = card.ability.extra.mult\r\n            }\r\n        end\r\n    end,\r\n    no_rank = true,\r\n    no_suit = true,\r\n    always_scores = true,\r\n    replace_base_card = true,",
      "config": {
        "extra": {
          "mult": 10
        }
      },
      "ability": {
        "extra": {
          "mult": 10
        }
      },
      "vars": [
        10
      ],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "scoreless",
      "name": null,
      "atlas": "cardUpgrades",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"scoreless\",\r\n    atlas = 'cardUpgrades',\r\n    pos = {x = 0, y = 0},\r\n    loc_vars = function (self, info_queue, card)\r\n        return { vars = {\r\n        } }\r\n    end,\r\n    in_pool = function (self, args)\r\n        return false\r\n    end,\r\n    never_scores = true,\r\n    replace_base_card = false,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "ash_card",
      "name": null,
      "atlas": "cardUpgrades",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"ash_card\",\r\n    atlas = 'cardUpgrades',\r\n    pos = {x = 2, y = 0},\r\n    loc_vars = function (self, info_queue, card)\r\n        \r\n        if AKYRS.bal(\"absurd\") then\r\n            return {\r\n                key = self.key .. \"_absurd\",\r\n                vars = {\r\n                    card.ability.extras.echips,\r\n                }\r\n            }\r\n        end\r\n        local n,d = SMODS.get_probability_vars(card,1,card.ability.extras.odds,\"akyrs_ash_card\")\r\n        return { vars = {\r\n            card.ability.extras.chips,\r\n            n,d\r\n        } }\r\n    end,\r\n    config = {\r\n        extras = {\r\n            chips = 35,\r\n            echips = 2,\r\n            odds = 4\r\n        }\r\n    },\r\n    in_pool = function (self, args)\r\n        return false\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.main_scoring and context.cardarea == G.play then\r\n            return AKYRS.bal_val({\r\n                chips = card.ability.extras.chips\r\n            }, {\r\n                echips = card.ability.extras.echips\r\n            })\r\n        end\r\n    end,\r\n    no_rank = true,\r\n    no_suit = true,\r\n    always_scores = true,\r\n    replace_base_card = true,",
      "config": {
        "extras": {
          "chips": 35,
          "echips": 2,
          "odds": 4
        }
      },
      "ability": {
        "extras": {
          "chips": 35,
          "echips": 2,
          "odds": 4
        }
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "hatena",
      "name": null,
      "atlas": "cardUpgrades",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"hatena\",\r\n    atlas = 'cardUpgrades',\r\n    pos = {x = 3, y = 0},\r\n    no_rank = true,\r\n    no_suit = true,\r\n    always_scores = true,\r\n    replace_base_card = true,\r\n    config = {\r\n        extras = {\r\n            odds_d = 2,\r\n            d = 1, \r\n            odds_d10 = 10,\r\n            d10 = 10,\r\n            nom_mults = 4,\r\n            denom_mults = 5,\r\n            mult_init = 6,\r\n            xmult_retrig = 1.3\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        local n_dollar_1, d_dollar_1 = SMODS.get_probability_vars(card,1,card.ability.extras.odds_d,\"akyrs_hatena_d1\") -- odds of getting 1 money\r\n        local n_dollar_10, d_dollar_10 = SMODS.get_probability_vars(card,1,card.ability.extras.odds_d10,\"akyrs_hatena_d10\") -- odds of getting 10 money\r\n        local n_dollar_mult, d_dollar_mult = SMODS.get_probability_vars(card,card.ability.extras.nom_mults,card.ability.extras.denom_mults,\"akyrs_hatena_mults\") -- odds of getting mults\r\n        return {\r\n            vars = {\r\n                n_dollar_1, d_dollar_1,card.ability.extras.d,\r\n                n_dollar_10, d_dollar_10,card.ability.extras.d10,\r\n                n_dollar_mult, d_dollar_mult,card.ability.extras.mult_init,card.ability.extras.xmult_retrig,\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.main_scoring and context.cardarea == G.play then\r\n            if SMODS.pseudorandom_probability(card,\"akyrs_hatena_d1\",1,card.ability.extras.odds_d) then\r\n                return {\r\n                    dollars = card.ability.extras.d\r\n                }\r\n            end\r\n            if SMODS.pseudorandom_probability(card,\"akyrs_hatena_d10\",1,card.ability.extras.odds_d10) then\r\n                return {\r\n                    dollars = card.ability.extras.d10\r\n                }\r\n            end\r\n            if SMODS.pseudorandom_probability(card,\"akyrs_hatena_mults\",card.ability.extras.nom_mults,card.ability.extras.denom_mults) then\r\n                if card.akyrs_triggered then\r\n                    return {\r\n                        xmult = card.ability.extras.xmult_retrig\r\n                    }\r\n                else\r\n                    return {\r\n                        mult = card.ability.extras.mult_init,\r\n                        func = function()\r\n                            card.akyrs_triggered = true\r\n                        end\r\n                    }\r\n                end\r\n            end\r\n            if context.final_scoring_step then\r\n                return {\r\n                    func = function()\r\n                        card.akyrs_triggered = nil\r\n                    end\r\n                }\r\n            end\r\n        end\r\n    end",
      "config": {
        "extras": {
          "odds_d": 2,
          "d": 1,
          "odds_d10": 10,
          "d10": 10,
          "nom_mults": 4,
          "denom_mults": 5,
          "mult_init": 6,
          "xmult_retrig": 1.3
        }
      },
      "ability": {
        "extras": {
          "odds_d": 2,
          "d": 1,
          "odds_d10": 10,
          "d10": 10,
          "nom_mults": 4,
          "denom_mults": 5,
          "mult_init": 6,
          "xmult_retrig": 1.3
        }
      },
      "vars": [
        null,
        null,
        1,
        null,
        null,
        10,
        null,
        null,
        6,
        1.3
      ],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "item_box",
      "name": null,
      "atlas": "cardUpgrades",
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "key = \"item_box\",\r\n    atlas = 'cardUpgrades',\r\n    pos = {x = 4, y = 0},\r\n    no_rank = true,\r\n    no_suit = true,\r\n    always_scores = true,\r\n    replace_base_card = true,\r\n    config = {\r\n        extras = {\r\n        }\r\n    },\r\n    calculate = function (self, card, context)\r\n        if context.main_scoring and context.cardarea == G.play then\r\n            return {\r\n                message = localize(\"k_akyrs_item_box_trigger\"),\r\n                func = function ()\r\n                    AKYRS.simple_event_add(\r\n                        function ()\r\n                            --[[\r\n                            -- this is just me being stupid\r\n                            if AKYRS.has_room(G.consumeables) then\r\n                                card.ability.akyrs_triggered = true\r\n                                local k, lim = nil, 0\r\n                                repeat\r\n                                    lim = lim + 1\r\n                                    k = pseudorandom_element(G.P_CENTER_POOLS.Consumeables,pseudoseed(\"akyrs_item_box_consumable_pick\"))\r\n                                until (not k.hidden and (not k.in_pool or k:in_pool({})) and not G.GAME.banned_keys[k.key]) or lim >= #G.P_CENTER_POOLS.Consumeables\r\n                                if not lim >= #G.P_CENTER_POOLS.Consumeables then\r\n                                    SMODS.add_card{key = k.key}\r\n                                end\r\n                            end\r\n                            ]]\r\n                            if AKYRS.has_room(G.consumeables) then\r\n                                SMODS.add_card{set = \"Consumeables\", area = G.consumeables}\r\n                            end\r\n                            card.ability.akyrs_triggered = true\r\n                            return true\r\n                        end, 0\r\n                    )\r\n                end\r\n            }\r\n        end\r\n    end",
      "config": {
        "extras": {}
      },
      "ability": {
        "extras": {}
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "insolate_card",
      "name": null,
      "atlas": "cardUpgrades",
      "pos": {
        "x": 5,
        "y": 0
      },
      "raw": "key = \"insolate_card\",\r\n    atlas = 'cardUpgrades',\r\n    pos = {x = 5, y = 0},\r\n    config = {\r\n        extras = {\r\n            xmult = 1,\r\n            xmult_add = 0.1,\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras.xmult_add,\r\n                card.ability.extras.xmult,\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.before and context.cardarea == G.play then\r\n            return {\r\n                func = function ()\r\n                    local r = AKYRS.get_enhancements_freq_from_cards(G.play.cards)\r\n                    local s = true\r\n                    for k,v in pairs(r) do\r\n                        if v > 1 then\r\n                            s = false\r\n                            break\r\n                        end\r\n                    end\r\n                    if s then\r\n                        SMODS.calculate_effect({\r\n                            message = localize(\"k_upgrade_ex\"),\r\n                            func = function ()\r\n                                card.ability.extras.xmult = card.ability.extras.xmult + card.ability.extras.xmult_add\r\n                            end\r\n                        }, card)\r\n                    end\r\n                end\r\n            }\r\n        end\r\n        if context.main_scoring and context.cardarea == G.play then\r\n            return {\r\n                xmult = card.ability.extras.xmult\r\n            }\r\n        end\r\n    end",
      "config": {
        "extras": {
          "xmult": 1,
          "xmult_add": 0.1
        }
      },
      "ability": {
        "extras": {
          "xmult": 1,
          "xmult_add": 0.1
        }
      },
      "vars": [
        0.1,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "canopy_card",
      "name": null,
      "atlas": "cardUpgrades",
      "pos": {
        "x": 6,
        "y": 0
      },
      "raw": "key = \"canopy_card\",\r\n    atlas = 'cardUpgrades',\r\n    pos = {x = 6, y = 0},\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.after and context.cardarea == G.hand then\r\n            return {\r\n                func = function ()\r\n                    AKYRS.simple_event_add(\r\n                        function ()\r\n                            card:akyrs_flip_y()\r\n                            AKYRS.simple_event_add(\r\n                                function ()\r\n                                    card:akyrs_flip_y()\r\n                                    card = SMODS.modify_rank(card, -1)\r\n                                    return true\r\n                                end\r\n                            )\r\n                            return true\r\n                        end\r\n                    )\r\n                end\r\n            }\r\n        end\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "thai_tea_card",
      "name": null,
      "atlas": "cardUpgrades",
      "pos": {
        "x": 7,
        "y": 0
      },
      "raw": "key = \"thai_tea_card\",\r\n    atlas = 'cardUpgrades',\r\n    pos = {x = 7, y = 0},\r\n    config = {\r\n        extras = {\r\n            xmult = 1.6,\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras.xmult\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.main_scoring and context.cardarea == G.play then\r\n            if AKYRS.bal(\"absurd\") and AKYRS.checkBlindKey(\"bl_mouth\") and #G.play.cards == 1 then\r\n                SMODS.calculate_effect(\r\n                    {\r\n                        func = function ()\r\n                            G.GAME.blind:set_blind(G.P_BLINDS['bl_water'])\r\n                        end\r\n                    },card\r\n                )\r\n            end\r\n            return {\r\n                xmult = card.ability.extras.xmult\r\n            }\r\n        end\r\n    end",
      "config": {
        "extras": {
          "xmult": 1.6
        }
      },
      "ability": {
        "extras": {
          "xmult": 1.6
        }
      },
      "vars": [
        1.6
      ],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "matcha_card",
      "name": null,
      "atlas": "cardUpgrades",
      "pos": {
        "x": 8,
        "y": 0
      },
      "raw": "key = \"matcha_card\",\r\n    atlas = 'cardUpgrades',\r\n    pos = {x = 8, y = 0},\r\n    config = {\r\n        extras = {\r\n            xchips = 1.4,\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras.xchips\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.main_scoring and context.cardarea == G.play then\r\n            return {\r\n                xchips = card.ability.extras.xchips\r\n            }\r\n        end\r\n    end",
      "config": {
        "extras": {
          "xchips": 1.4
        }
      },
      "ability": {
        "extras": {
          "xchips": 1.4
        }
      },
      "vars": [
        1.4
      ],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "earl_grey_tea_card",
      "name": null,
      "atlas": "cardUpgrades",
      "pos": {
        "x": 9,
        "y": 0
      },
      "raw": "key = \"earl_grey_tea_card\",\r\n    atlas = 'cardUpgrades',\r\n    pos = {x = 9, y = 0},\r\n    config = {\r\n        extras = {\r\n            dollars = 3,\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras.dollars\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.main_scoring and context.cardarea == 'unscored' then\r\n            return {\r\n                dollars = card.ability.extras.dollars\r\n            }\r\n        end\r\n    end",
      "config": {
        "extras": {
          "dollars": 3
        }
      },
      "ability": {
        "extras": {
          "dollars": 3
        }
      },
      "vars": [
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "net_card",
      "name": null,
      "atlas": "cardUpgrades",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"net_card\",\r\n    atlas = 'cardUpgrades',\r\n    pos = {x = 1, y = 1},\r\n    config = {\r\n        extras = {\r\n            xmult = 0.5,\r\n        },\r\n        h_dollars = 8\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras.xmult,\r\n                SMODS.signed_dollars(card.ability.h_dollars),\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.main_scoring and context.cardarea == G.hand then\r\n            return {\r\n                xmult = card.ability.extras.xmult\r\n            }\r\n        end\r\n    end",
      "config": {
        "extras": {
          "xmult": 0.5
        },
        "h_dollars": 8
      },
      "ability": {
        "extras": {
          "xmult": 0.5
        },
        "h_dollars": 8
      },
      "vars": [
        0.5,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "droplet_card",
      "name": null,
      "atlas": "cardUpgrades",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"droplet_card\",\r\n    atlas = 'cardUpgrades',\r\n    pos = {x = 2, y = 1},\r\n    config = {\r\n        extras = {\r\n            n = 1,\r\n            d = 3,\r\n            discard = 1,\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        local n, d = SMODS.get_probability_vars(card,card.ability.extras.n,card.ability.extras.d,\"akyrs_droplet\")\r\n        return {\r\n            vars = {\r\n                n,d,\r\n                card.ability.extras.discard,\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.discard and context.other_card == card then\r\n            return {\r\n                func = function ()\r\n                    local success = SMODS.pseudorandom_probability(card,\"akyrs_droplet\",card.ability.extras.n,card.ability.extras.d)\r\n                    if success then\r\n                        ease_discard(card.ability.extras.discard)\r\n                        SMODS.calculate_effect({\r\n                            localize(\"k_akyrs_gain_discard\")\r\n                        })\r\n                    end\r\n                end,\r\n            }\r\n        end\r\n    end",
      "config": {
        "extras": {
          "n": 1,
          "d": 3,
          "discard": 1
        }
      },
      "ability": {
        "extras": {
          "n": 1,
          "d": 3,
          "discard": 1
        }
      },
      "vars": [
        null,
        null,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "zap_card",
      "name": null,
      "atlas": "cardUpgrades",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"zap_card\",\r\n    atlas = 'cardUpgrades',\r\n    pos = {x = 0, y = 1},\r\n    config = {\r\n        extras = {\r\n            trigger_triggered = 0,\r\n            trigger_needed = 3,\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras.trigger_needed,\r\n                card.ability.extras.trigger_triggered\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.main_scoring and context.cardarea == G.play then\r\n            return {\r\n                func = function ()\r\n                    card.ability.extras.trigger_triggered = (card.ability.extras.trigger_triggered or 0) + 1\r\n                    if card.ability.extras.trigger_triggered >= card.ability.extras.trigger_needed then\r\n                        local times = card.ability.extras.trigger_triggered / card.ability.extras.trigger_needed\r\n                        local remainder = card.ability.extras.trigger_triggered - (card.ability.extras.trigger_needed * math.floor(times))\r\n                        \r\n                        card.ability.extras.trigger_triggered = remainder\r\n                        for i = 1, times do\r\n                            SMODS.calculate_effect({\r\n                                message = localize(\"k_duplicated_ex\"),\r\n                                func = function ()\r\n                                    AKYRS.simple_event_add(\r\n                                        function ()\r\n                                            local c2 = AKYRS.copy_p_card(card,nil,nil,nil,nil,G.hand)\r\n                                            c2:set_ability(G.P_CENTERS.c_base)\r\n                                            SMODS.calculate_context({ playing_card_added = true, cards = { c2 } })\r\n                                            return true\r\n                                        end\r\n                                    )\r\n                                end\r\n                            }, card)\r\n                        end\r\n                    end\r\n                end,\r\n                message = localize(\"k_upgrade_ex\")\r\n            }\r\n        end\r\n    end",
      "config": {
        "extras": {
          "trigger_triggered": 0,
          "trigger_needed": 3
        }
      },
      "ability": {
        "extras": {
          "trigger_triggered": 0,
          "trigger_needed": 3
        }
      },
      "vars": [
        3,
        0
      ],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "semibreve_card",
      "name": null,
      "atlas": "cardUpgrades",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"semibreve_card\",\r\n    atlas = 'cardUpgrades',\r\n    pos = {x = 3, y = 1},\r\n    config = {\r\n        bonus = 10,\r\n        mult = 3,\r\n    },\r\n    akyrs_note_card = {\r\n        weight = 8\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.bonus,\r\n                card.ability.mult,\r\n            }\r\n        }\r\n    end,",
      "config": {
        "bonus": 10,
        "mult": 3
      },
      "ability": {
        "bonus": 10,
        "mult": 3
      },
      "vars": [
        10,
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "minim_card",
      "name": null,
      "atlas": "cardUpgrades",
      "pos": {
        "x": 4,
        "y": 1
      },
      "raw": "key = \"minim_card\",\r\n    atlas = 'cardUpgrades',\r\n    pos = {x = 4, y = 1},\r\n    config = {\r\n        extras = {\r\n            bonus_X_chips = 1.2,\r\n            mult = 5,\r\n        }\r\n    },\r\n    akyrs_note_card = {\r\n        weight = 3\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras.bonus_X_chips,\r\n                card.ability.extras.mult,\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.main_scoring and context.cardarea == G.play then\r\n            return {\r\n                xchips = card.ability.extras.bonus_X_chips,\r\n                mult = card.ability.extras.mult,\r\n            }\r\n        end\r\n    end",
      "config": {
        "extras": {
          "bonus_X_chips": 1.2,
          "mult": 5
        }
      },
      "ability": {
        "extras": {
          "bonus_X_chips": 1.2,
          "mult": 5
        }
      },
      "vars": [
        1.2,
        5
      ],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "crotchet_card",
      "name": null,
      "atlas": "cardUpgrades",
      "pos": {
        "x": 5,
        "y": 1
      },
      "raw": "key = \"crotchet_card\",\r\n    atlas = 'cardUpgrades',\r\n    pos = {x = 5, y = 1},\r\n    config = {\r\n        extras = {\r\n            bonus_X_chips = 1.41,\r\n            bonus_X_mult = 1.41,\r\n        }\r\n    },\r\n    akyrs_note_card = {\r\n        weight = 1\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras.bonus_X_chips,\r\n                card.ability.extras.bonus_X_mult,\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.main_scoring and context.cardarea == G.play then\r\n            return {\r\n                xchips = card.ability.extras.bonus_X_chips,\r\n                xmult = card.ability.extras.bonus_X_mult,\r\n            }\r\n        end\r\n    end",
      "config": {
        "extras": {
          "bonus_X_chips": 1.41,
          "bonus_X_mult": 1.41
        }
      },
      "ability": {
        "extras": {
          "bonus_X_chips": 1.41,
          "bonus_X_mult": 1.41
        }
      },
      "vars": [
        1.41,
        1.41
      ],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "wafer_card",
      "name": null,
      "atlas": "cardUpgrades",
      "pos": {
        "x": 6,
        "y": 1
      },
      "raw": "key = \"wafer_card\",\r\n    atlas = 'cardUpgrades',\r\n    pos = {x = 6, y = 1},\r\n    config = {\r\n        extras = {\r\n            xscore = 2.5,\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras.xscore,\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.main_scoring and context.cardarea == G.play and G.GAME.current_round.hands_played == 0 then\r\n            return {\r\n                akyrs_xscore = card.ability.extras.xscore,\r\n            }\r\n        end\r\n    end",
      "config": {
        "extras": {
          "xscore": 2.5
        }
      },
      "ability": {
        "extras": {
          "xscore": 2.5
        }
      },
      "vars": [
        2.5
      ],
      "infoQueue": []
    },
    {
      "type": "Challenge",
      "key": "space_oddity",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"space_oddity\",\n    jokers = {\n        AKYRS.crypternity{\n            id = \"j_space\",\n            edition = \"akyrs_sliced\",\n            akyrs_sell_cost = 0,\n        },\n        AKYRS.crypternity{\n            id = \"j_oops\",\n            edition = \"akyrs_noire\",\n            akyrs_sell_cost = 0,\n        },\n    }",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Challenge",
      "key": "4_hibanas",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"4_hibanas\",\n    jokers = {\n        AKYRS.crypternity{\n            id = \"j_akyrs_hibana\",\n            edition = \"negative\",\n            pinned = true,\n            eternal = true,\n            akyrs_sell_cost = 0,\n            akyrs_card_ability = {\n                immutable = {\n                    akyrs_cycler = 4,\n                    akyrs_priority_draw_rank = \"5\"\n                }\n\n            }\n        },\n        AKYRS.crypternity{\n            id = \"j_akyrs_hibana\",\n            edition = \"negative\",\n            pinned = true,\n            eternal = true,\n            akyrs_sell_cost = 0,\n            akyrs_card_ability = {\n                immutable = {\n                    akyrs_cycler = 3,\n                    akyrs_priority_draw_suit = \"Hearts\"\n                }\n            }\n        },\n        AKYRS.crypternity{\n            id = \"j_akyrs_hibana\",\n            edition = \"negative\",\n            pinned = true,\n            eternal = true,\n            akyrs_sell_cost = 0,\n            akyrs_card_ability = {\n                immutable = {\n                    akyrs_cycler = 2,\n                    akyrs_priority_draw_conditions = \"Face Cards\"\n                }\n            }\n        },\n        AKYRS.crypternity{\n            id = \"j_akyrs_hibana\",\n            edition = \"negative\",\n            eternal = true,\n            pinned = true,\n            akyrs_sell_cost = 0,\n            akyrs_card_ability = {\n                immutable = {\n                    akyrs_cycler = 1,\n                    akyrs_priority_draw_rank = \"Ace\"\n                }\n            }\n        },\n    },\n    rules = {\n        modifiers = {\n            { id = \"discards\", value = 1 },\n            { id = \"dollars\", value = 10 },\n        }\n    }",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Planet",
      "key": "p_",
      "name": null,
      "atlas": "aikoConstellationCards",
      "pos": null,
      "raw": "atlas = \"aikoConstellationCards\",\r\n        pos = { x = i-1 , y=0},\r\n        key = \"p_\"..k,\r\n        config = {\r\n            hand_type = hand,\r\n            softlock = true\r\n        },\r\n        set_card_type_badge = function(self, card, badges)\r\n            badges[1] = create_badge(localize('k_akyrs_constellation'), get_type_colour(self or card.config, card), nil, 1.2)\r\n        end,\r\n        loc_vars = function (self,iq,_c)\r\n            local level = AKYRS.get_hand_in_game(_c) and AKYRS.get_hand_in_game(_c).level or 1\r\n            local handlevelcol = G.C.HAND_LEVELS[math.min(7, level)]\r\n            if Talisman then\r\n                handlevelcol = G.C.HAND_LEVELS[math.min(7, to_number(level))]\r\n            end\r\n            return {\r\n                vars = {\r\n                    level,\r\n                    localize(hand, 'poker_hands') or \"???\", \r\n                    SMODS.PokerHands[hand].l_mult or 1, \r\n                    SMODS.PokerHands[hand].l_chips or 1,\r\n                    colours = {\r\n                        (to_number(level) == 1 and \r\n                        G.C.UI.TEXT_DARK or \r\n                        handlevelcol)\r\n                    }\r\n                },\r\n            }\r\n        end,\r\n        \r\n        calculate = function(self, card, context)\r\n            if G.GAME.used_vouchers.v_observatory\r\n                and context.joker_main\r\n                and (\r\n                    context.scoring_name == hand\r\n                )\r\n            then\r\n                local value = G.P_CENTERS.v_observatory.config.extra\r\n                return {\r\n                    Xmult = value,\r\n                }\r\n            end\r\n        end,\r\n        in_pool = function(self, args)\r\n            return (G.GAME.akyrs_character_stickers_enabled and G.GAME.akyrs_wording_enabled) and true or false\r\n        end,",
      "config": {},
      "ability": {},
      "vars": [
        null,
        null,
        null,
        1,
        1,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Planet",
      "key": "p_microscopium",
      "name": null,
      "atlas": "aikoConstellationCards",
      "pos": {
        "x": 9,
        "y": 0
      },
      "raw": "atlas = \"aikoConstellationCards\",\r\n    pos = { x = 9 , y=0},\r\n    key = \"p_microscopium\",\r\n    config = {\r\n        akyrs_hand_types = hands_multi,\r\n        softlock = true\r\n    },\r\n    set_card_type_badge = function(self, card, badges)\r\n        badges[1] = create_badge(localize('k_akyrs_constellation'), get_type_colour(self or card.config, card), nil, 1.2)\r\n    end,\r\n    loc_vars = function (self,iq,_c)\r\n        local level = AKYRS.get_hand_in_game(_c) and AKYRS.get_hand_in_game(_c).level or 1\r\n        return {\r\n            vars = {\r\n                localize(hands_multi[1], 'poker_hands') or \"???\", \r\n            },\r\n        }\r\n    end,\r\n    use = function (self,card,area,copier)\r\n        AKYRS.silent_bulk_level_up(self, card, area, copier, 1)\r\n    end,\r\n\r\n    can_use = function(self, card) return true end,\r\n    calculate = function(self, card, context)\r\n        if G.GAME.used_vouchers.v_observatory\r\n            and context.joker_main\r\n            and (\r\n                hands_multi_rev[context.scoring_name]\r\n            )\r\n        then\r\n            local value = G.P_CENTERS.v_observatory.config.extra\r\n            return {\r\n                Xmult = value,\r\n            }\r\n        end\r\n    end,\r\n    in_pool = function(self, args)\r\n        return (G.GAME.akyrs_character_stickers_enabled and G.GAME.akyrs_wording_enabled) and true or false\r\n    end,",
      "config": {},
      "ability": {},
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Edition",
      "key": "texelated",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"texelated\",\r\n    shader = \"akyrs_texelated\",\r\n    config = {\r\n        extra = {\r\n            x_chip = 0.8,\r\n            x_mult = 2;\r\n        }\r\n    },\r\n    \r\n    calculate =  function (self, card, context)\r\n        if context.main_scoring and context.cardarea == G.play then\r\n            return {\r\n                xchips = card.edition.extra.x_chip,\r\n                Xmult = card.edition.extra.x_mult\r\n            }\r\n        end\r\n        if context.pre_joker and (context.cardarea == G.jokers)  then\r\n            return {\r\n                xchips = card.edition.extra.x_chip,\r\n                Xmult = card.edition.extra.x_mult\r\n            }\r\n        end\r\n    end,\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.edition.extra.x_chip,\r\n                card.edition.extra.x_mult,\r\n            }\r\n        }\r\n    end,\r\n    sound = { sound = \"akyrs_texelated_sfx\", per = 1.2, vol = 0.4 },\r\n    in_shop = true,\r\n    weight = 7,",
      "config": {},
      "ability": {},
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Edition",
      "key": "noire",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"noire\",\r\n    shader = \"akyrs_noire\",\r\n    config = {\r\n        extra ={\r\n            x_mult = 0.5,\r\n        },\r\n        card_limit = 2\r\n    },\r\n    calculate =  function (self, card, context)\r\n        if context.main_scoring and (context.cardarea == G.hand or context.cardarea == G.play)  then\r\n            return {\r\n                Xmult = card.edition.extra.x_mult\r\n            }\r\n        end\r\n        if context.pre_joker and (context.cardarea == G.jokers)  then\r\n            return {\r\n                Xmult = card.edition.extra.x_mult\r\n            }\r\n        end\r\n    end,\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            key = self.key .. AKYRS.edition_loc_center_key_getter(card),\r\n            vars = {\r\n                self.config.card_limit,\r\n                self.config.extra.x_mult,\r\n            }\r\n        }\r\n    end,\r\n    sound = { sound = \"akyrs_noire_sfx\", per = 0.8, vol = 0.3 },\r\n    in_shop = true,\r\n    weight = 3,",
      "config": {
        "extra": {
          "x_mult": 0.5
        },
        "card_limit": 2
      },
      "ability": {
        "extra": {
          "x_mult": 0.5
        },
        "card_limit": 2
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Edition",
      "key": "sliced",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"sliced\",\r\n    shader = \"akyrs_sliced\",\r\n    config = {\r\n        extra = {\r\n            mod_mult = 0.5,\r\n        },\r\n        akyrs_card_extra_triggers = 1\r\n    },\r\n    disable_base_shader = true,\r\n    sound = { sound = \"akyrs_sliced_sfx\", per = 0.8, vol = 0.3 },\r\n    in_shop = true,\r\n    on_apply = function (card)\r\n        if not card.ability.akyrs_upgrade_sliced and card.config and card.config.center_key and G.P_CENTERS[card.config.center_key] then\r\n            local x = AKYRS.deep_copy(G.P_CENTERS[card.config.center_key].config)\r\n            AKYRS.mod_card_values(x,{multiply = 0.5, unkeywords = AKYRS.blacklist_mod})\r\n            for n, v in pairs(x) do\r\n                card.ability[n] = x[n] or card.ability[n]\r\n            end\r\n            AKYRS.simple_event_add(\r\n                function ()        \r\n                    card.ability.akyrs_upgrade_sliced = true\r\n                    return true\r\n                end, 0\r\n            )\r\n        end\r\n    end,\r\n    on_remove = function (card)\r\n        card:set_ability(G.P_CENTERS[card.config.center_key])\r\n        card.ability.akyrs_upgrade_sliced = false\r\n    end,\r\n    weight = 5,",
      "config": {
        "extra": {
          "mod_mult": 0.5
        },
        "akyrs_card_extra_triggers": 1
      },
      "ability": {
        "extra": {
          "mod_mult": 0.5
        },
        "akyrs_card_extra_triggers": 1
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Edition",
      "key": "burnt",
      "name": "akyrs_burnt",
      "atlas": null,
      "pos": null,
      "raw": "key = \"burnt\",\r\n    shader = \"akyrs_burnt\",\r\n    config = {\r\n        extras = {\r\n            odds = 7,\r\n        },\r\n        name = \"akyrs_burnt\"\r\n    },\r\n    disable_base_shader = true,\r\n    sound = { sound = \"akyrs_burnt_sfx\", per = 1.2, vol = 0.3 },\r\n    in_shop = false,\r\n    loc_vars = function (self, info_queue, card)\r\n        info_queue[#info_queue+1] = G.P_CENTERS[\"m_akyrs_ash_card\"]\r\n        info_queue[#info_queue+1] = G.P_CENTERS[\"j_akyrs_ash_joker\"]\r\n        local n,d = SMODS.get_probability_vars(card,1,self.config.extras.odds,\"akyrs_burnt_edition\")\r\n        return {\r\n            vars = {\r\n                n,d\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        \r\n    end,\r\n    weight = 0,",
      "config": {
        "extras": {
          "odds": 7
        },
        "name": "akyrs_burnt"
      },
      "ability": {
        "extras": {
          "odds": 7
        },
        "name": "akyrs_burnt"
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Edition",
      "key": "dyed",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"dyed\",\r\n    shader = \"akyrs_dyed\",\r\n    config = {\r\n        extra = {\r\n            score = 100,\r\n            score_gain = 20,\r\n        },\r\n    },\r\n    sound = { sound = \"akyrs_dyed\", per = 0.8, vol = 0.3 },\r\n    in_shop = true,\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                (card.edition or self.config).extra.score,\r\n                (card.edition or self.config).extra.score_gain,\r\n            }\r\n        }\r\n    end,\r\n    calculate =  function (self, card, context)\r\n        if context.main_scoring and (context.cardarea == G.play)  then\r\n            SMODS.calculate_effect({\r\n                akyrs_score = card.edition.extra.score\r\n            }, card)\r\n            return {\r\n                func = function ()\r\n                    card.edition.extra.score = card.edition.extra.score + card.edition.extra.score_gain\r\n                end\r\n            }\r\n        end\r\n        if context.pre_joker and (context.cardarea == G.jokers)  then\r\n            SMODS.calculate_effect({\r\n                akyrs_score = card.edition.extra.score\r\n            }, card)\r\n            return {\r\n                func = function ()\r\n                    card.edition.extra.score = card.edition.extra.score + card.edition.extra.score_gain\r\n                end\r\n            }\r\n        end\r\n    end,\r\n    weight = 5,",
      "config": {
        "extra": {
          "score": 100,
          "score_gain": 20
        }
      },
      "ability": {
        "extra": {
          "score": 100,
          "score_gain": 20
        }
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Edition",
      "key": "enchanted",
      "name": "akyrs_enchanted",
      "atlas": null,
      "pos": null,
      "raw": "key = \"enchanted\",\r\n    shader = \"akyrs_enchanted\",\r\n    config = {\r\n        name = \"akyrs_enchanted\"\r\n    },\r\n    sound = { sound = \"akyrs_enchanted\", per = 1, vol = 0.7 },\r\n    in_shop = false,\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n    end,\r\n    weight = 0,",
      "config": {
        "name": "akyrs_enchanted"
      },
      "ability": {
        "name": "akyrs_enchanted"
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "redstone_repeater",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    pos = {\r\n        x = 0,\r\n        y = 0\r\n    },\r\n    pools = { [\"Minecraft\"] = true, [\"Redstone\"] = true },\r\n    key = \"redstone_repeater\",\r\n    rarity = 2,\r\n    cost = 5,\r\n    config = {\r\n        extra = {\r\n            mult_stored = 1,\r\n            mult = 2.25,\r\n            starting_mult = 1,\r\n            exp = 1.5\r\n        }\r\n    },\r\n\r\n    loc_vars = function(self, info_queue, card)\r\n        local multer = {\r\n            {\r\n                n = G.UIT.R,\r\n                config = { alin = \"cm\", padding = 0.05},\r\n                nodes = {\r\n                    {\r\n                        n = G.UIT.C,\r\n                        config = { align = \"cm\" },\r\n                        nodes = {\r\n                            {\r\n                                n = G.UIT.T,\r\n                                config = { text = localize(\"akyrs_start_with\"), colour = G.C.UI.TEXT_INACTIVE, scale = 0.3 }\r\n                            }\r\n                        }\r\n                    },\r\n                    {\r\n                        n = G.UIT.C,\r\n                        config = { align = \"cm\" },\r\n                        nodes = {\r\n                            SMODS.GUI.operator(0.2),\r\n                            {\r\n                                n = G.UIT.C,\r\n                                config = { align = \"cm\", padding = 0.1 },\r\n                                nodes = {\r\n                                    AKYRS.faux_score_container(card.ability.extra, \"starting_mult\", { align = 'lc', w = 1, h = 0.5, scale = 0.15 })\r\n                                }\r\n                            },\r\n                        }\r\n                    },\r\n                    \r\n                }\r\n            },\r\n            {\r\n                n = G.UIT.R,\r\n                config = { alin = \"cm\", padding = 0.05},\r\n                nodes = {\r\n                    {\r\n                        n = G.UIT.C,\r\n                        config = { align = \"cm\" },\r\n                        nodes = {\r\n                            {\r\n                                n = G.UIT.T,\r\n                                config = { text = localize(\"akyrs_stored_open\"), colour = G.C.UI.TEXT_INACTIVE, scale = 0.3 }\r\n                            }\r\n                        }\r\n                    },\r\n                    {\r\n                        n = G.UIT.C,\r\n                        config = { align = \"cm\" },\r\n                        nodes = {\r\n                            SMODS.GUI.operator(0.2),\r\n                            {\r\n                                n = G.UIT.C,\r\n                                config = { align = \"cm\", padding = 0.1 },\r\n                                nodes = {\r\n                                    AKYRS.faux_score_container(card.ability.extra, \"mult_stored\", { align = 'lc', w = 1, h = 0.5, scale = 0.15 })\r\n                                }\r\n                            },\r\n                        }\r\n                    },\r\n                    {\r\n                        n = G.UIT.C,\r\n                        config = { align = \"cm\" },\r\n                        nodes = {\r\n                            {\r\n                                n = G.UIT.T,\r\n                                config = { text = localize(\"akyrs_stored_close\"), colour = G.C.UI.TEXT_INACTIVE, scale = 0.3 }\r\n                            }\r\n                        }\r\n                    },\r\n                    \r\n                }\r\n            },\r\n        }\r\n        if AKYRS.bal(\"absurd\") then\r\n            return {\r\n                key = self.key..'_absurd',\r\n                vars = { card.ability.extra.mult_stored, card.ability.extra.exp, card.ability.extra.starting_mult },\r\n                main_end = multer,\r\n            }\r\n        end\r\n        return {\r\n            vars = { card.ability.extra.mult_stored, card.ability.extra.mult, card.ability.extra.starting_mult },\r\n            main_end = multer,\r\n        }\r\n    end,\r\n    calculate = function(self, card, context)\r\n        if context.joker_main and card or context.forcetrigger then\r\n            stored = mult\r\n            mult = mod_mult(card.ability.extra.mult_stored)\r\n            card.ability.extra.mult_stored = stored\r\n            update_hand_text({ immediate = true, nopulse = true, delay = 0 }, { mult_stored = stored })\r\n            \r\n            local ind = AKYRS.find_index(card.area.cards, card)\r\n            if ind and ind > 1 and card.area.cards[ind - 1].config.center_key == card.config.center_key then\r\n                check_for_unlock({type = \"akyrs_repeater_into_another_one\"})\r\n            end\r\n            if AKYRS.bal(\"absurd\") then\r\n                return {\r\n                    message = \"Swapped!\",\r\n                    emult = card.ability.extra.exp,\r\n                }\r\n            end\r\n            return {\r\n                message = \"Swapped!\",\r\n                xmult = card.ability.extra.mult,\r\n            }\r\n        end\r\n    end,\r\n    blueprint_compat = true,\r\n\tdemicoloncompat = true,",
      "config": {
        "extra": {
          "mult_stored": 1,
          "mult": 2.25,
          "starting_mult": 1,
          "exp": 1.5
        }
      },
      "ability": {
        "extra": {
          "mult_stored": 1,
          "mult": 2.25,
          "starting_mult": 1,
          "exp": 1.5
        }
      },
      "vars": [
        1,
        1.5,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "observer",
      "name": "Observer",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    pos = {\r\n        x = 1,\r\n        y = 0\r\n    },\r\n    key = \"observer\",\r\n    rarity = 2,\r\n    cost = 5,\r\n    config = {\r\n        extra = {\r\n            mult_stored = 0,\r\n            xmult_stored = 1,\r\n            mult = 4,\r\n            xmult = 1,\r\n            times = 2,\r\n            total_times = 2,\r\n            times_increment = 1,\r\n            mult_change = 0,\r\n            chip_change = 0\r\n        },\r\n        name = \"Observer\"\r\n    },\r\n\r\n    loc_vars = function(self, info_queue, card)\r\n        if AKYRS.bal(\"absurd\") then\r\n            return {\r\n                key = self.key..'_absurd',\r\n                vars = { card.ability.extra.xmult, card.ability.extra.xmult_stored, card.ability.extra.times,\r\n                    card.ability.extra.total_times, card.ability.extra.times_increment }\r\n            }\r\n        end\r\n        return {\r\n            vars = { card.ability.extra.mult, card.ability.extra.mult_stored, card.ability.extra.times,\r\n                card.ability.extra.total_times, card.ability.extra.times_increment }\r\n        }\r\n    end,\r\n    calculate = function(self, card, context)\r\n        if context.akyrs_score_change and AKYRS.bal(\"absurd\") and not context.blueprint then\r\n            -- this does not need scaling\r\n            card.ability.extra.times = card.ability.extra.times - 1\r\n            return {\r\n                func = function()\r\n                    card_eval_status_text(card, 'jokers', nil, 0.5, nil, {\r\n                        instant = true,\r\n                        card_align = \"m\",\r\n                        message = localize {\r\n                            type = 'variable',\r\n                            key = 'a_remaining',\r\n                            vars = { card.ability.extra.times }\r\n                        },\r\n                    })\r\n                    --update_hand_text({ immediate = true, nopulse = true, delay = 0 }, { mult_stored = stored })\r\n\r\n                    if card.ability.extra.times <= 0 then\r\n                        card_eval_status_text(card, 'jokers', nil, 0.5, nil, {\r\n                            instant = true,\r\n                            card_align = \"m\",\r\n                            message = localize {\r\n                                type = 'variable',\r\n                                key = 'a_remaining',\r\n                                vars = { card.ability.extra.times }\r\n                            },\r\n                        })\r\n                        -- this also does NOT need scaling\r\n                        card.ability.extra.total_times = card.ability.extra.total_times + card.ability.extra.times_increment\r\n                        card.ability.extra.times = card.ability.extra.total_times\r\n                        -- this however do\r\n                        SMODS.scale_card(card,{\r\n                            ref_table = card.ability.extra,\r\n                            ref_value = \"xmult_stored\",\r\n                            scalar_value = \"xmult\",\r\n                        })\r\n                    end\r\n                    card.ability.extra.mult_change = mult\r\n                    card.ability.extra.chip_change = chips\r\n                end\r\n            }\r\n        end\r\n        if context.individual and AKYRS.bal(\"adequate\") and (context.cardarea == G.hand or context.cardarea == G.jokers or context.cardarea == G.play) and not context.blueprint then\r\n            SMODS.calculate_effect({\r\n                message = localize { type = 'variable', key = 'a_remaining', vars = { card.ability.extra.times }},\r\n                card = card,\r\n                func = function ()\r\n                    card.ability.extra.times = card.ability.extra.times - 1\r\n                    if card.ability.extra.times <= 0 then\r\n                        SMODS.calculate_effect({\r\n                            func = function ()\r\n                                -- same deal here\r\n                                SMODS.scale_card(card,{\r\n                                    ref_table = card.ability.extra,\r\n                                    ref_value = \"mult_stored\",\r\n                                    scalar_value = \"mult\",\r\n                                })\r\n                                if context.other_card then\r\n                                    AKYRS.simple_event_add(\r\n                                        function()\r\n                                        if context.other_card then AKYRS.juice_like_tarot(context.other_card) \r\n                                        end return true end\r\n                                    )\r\n                                end\r\n                                card.ability.extra.total_times = card.ability.extra.total_times + card.ability.extra.times_increment\r\n                                card.ability.extra.times = card.ability.extra.total_times\r\n                            end,\r\n                            card = card,\r\n                        })\r\n                    end\r\n                end\r\n            })\r\n        end\r\n        if context.joker_main or context.forcetrigger then\r\n            return AKYRS.bal_val(\r\n                {\r\n                    mult = card.ability.extra.mult_stored,\r\n                },\r\n                {\r\n                    xmult = card.ability.extra.xmult_stored,\r\n                }\r\n            )\r\n        end\r\n    end,\r\n\tdemicoloncompat = true,\r\n    blueprint_compat = true",
      "config": {
        "extra": {
          "mult_stored": 0,
          "xmult_stored": 1,
          "mult": 4,
          "xmult": 1,
          "times": 2,
          "total_times": 2,
          "times_increment": 1,
          "mult_change": 0,
          "chip_change": 0
        },
        "name": "Observer"
      },
      "ability": {
        "extra": {
          "mult_stored": 0,
          "xmult_stored": 1,
          "mult": 4,
          "xmult": 1,
          "times": 2,
          "total_times": 2,
          "times_increment": 1,
          "mult_change": 0,
          "chip_change": 0
        },
        "name": "Observer"
      },
      "vars": [
        1,
        1,
        2,
        2,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "quasi_connectivity",
      "name": "Quasi Connectivity",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "pools = { [\"Minecraft\"] = true, [\"Redstone\"] = true },\r\n    atlas = 'AikoyoriJokers',\r\n    pos = {\r\n        x = 2,\r\n        y = 0\r\n    },\r\n    key = \"quasi_connectivity\",\r\n    rarity = 3,\r\n    cost = 6,\r\n    loc_vars = function(self, info_queue, card)\r\n        if AKYRS.bal(\"absurd\") then\r\n            return {\r\n                key = self.key..'_absurd',\r\n            vars = { card.ability.extra.emult }\r\n            }\r\n        end\r\n        return {\r\n            vars = { card.ability.extra.mult }\r\n        }\r\n    end,\r\n    config = {\r\n        name = \"Quasi Connectivity\",\r\n        extra = {\r\n            mult = 6,\r\n            emult = 4,\r\n            first_hand = true\r\n        }\r\n    },\r\n    calculate = function(self, card, context)\r\n        if context.before and not context.blueprint then\r\n            return {\r\n                func = function()\r\n                local quasiCount = 0\r\n                local jokers = {}\r\n                for i = 1, #G.jokers.cards do\r\n                    if G.jokers.cards[i].ability.name == \"Quasi Connectivity\" then\r\n                        quasiCount = quasiCount + 1\r\n                    end\r\n                    if (G.jokers.cards[i] ~= card or #G.jokers.cards < 2) then\r\n                        jokers[#jokers + 1] = G.jokers.cards[i]\r\n                    end\r\n\r\n                    G.jokers.cards[i]:set_debuff(false)\r\n                end\r\n                -- remove the current card from the list\r\n                if not G.GAME.aiko_has_quasi then\r\n                    jokers[card] = nil\r\n                    G.GAME.aiko_has_quasi = true\r\n                end\r\n                for i = 1, quasiCount do\r\n                    if (#jokers > 0) then\r\n                        local re = AKYRS.bal(\"absurd\") and 2 or 1\r\n                        for i = 1, re do\r\n                            local _card = pseudorandom_element(jokers, pseudoseed('akyrs:quasi_connectivity'))\r\n                            local iter = 1\r\n                            while _card and _card.debuff and iter < #jokers do\r\n                                local _card = pseudorandom_element(jokers, pseudoseed('akyrs:quasi_connectivity'))\r\n                                iter = iter + 1\r\n                            end\r\n                            if _card then\r\n                                _card:set_debuff(true)\r\n                                _card:juice_up(1, 1)\r\n                            end\r\n                            jokers[_card] = nil\r\n                        end\r\n                    end\r\n                end\r\n                G.GAME.aiko_has_quasi = false\r\n                card.ability.extra.first_hand = false\r\n            end\r\n            }\r\n        end\r\n        if context.joker_main or context.forcetrigger then\r\n            return AKYRS.bal_val(\r\n                {\r\n                    xmult = card.ability.extra.mult,\r\n                },\r\n                {\r\n                    emult = card.ability.extra.emult,\r\n                }\r\n            )\r\n        end\r\n        if context.selling_card then\r\n            for i = 1, #G.jokers.cards do\r\n                if G.jokers.cards[i].debuff then\r\n                    G.jokers.cards[i]:set_debuff(false)\r\n                end\r\n            end\r\n        end\r\n    end,\r\n\tdemicoloncompat = true,\r\n    blueprint_compat = true",
      "config": {
        "name": "Quasi Connectivity",
        "extra": {
          "mult": 6,
          "emult": 4,
          "first_hand": true
        }
      },
      "ability": {
        "name": "Quasi Connectivity",
        "extra": {
          "mult": 6,
          "emult": 4,
          "first_hand": true
        }
      },
      "vars": [
        4
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "diamond_pickaxe",
      "name": "Diamond Pickaxe",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    enhancement_gate = \"m_stone\",\r\n    pools = { [\"Minecraft\"] = true },\r\n    pos = {\r\n        x = 3,\r\n        y = 0\r\n    },\r\n    key = \"diamond_pickaxe\",\r\n    rarity = 2,\r\n    cost = 4,\r\n    loc_vars = function(self, info_queue, card)\r\n        info_queue[#info_queue+1] = G.P_CENTERS[\"m_stone\"]\r\n        if AKYRS.bal(\"absurd\") then\r\n            return {\r\n                key = self.key..'_absurd',\r\n                vars = { card.ability.extra.chip_add, card.ability.extra.chip_add_stack_absurd }\r\n            }\r\n        end\r\n        return {\r\n            vars = { card.ability.extra.chips_adequate, card.ability.extra.chips_take }\r\n        }\r\n    end,\r\n    config = {\r\n        name = \"Diamond Pickaxe\",\r\n        extra = {\r\n            chip_add = 64,\r\n            chips_adequate = 0,\r\n            chips_take = 10,\r\n            chip_add_stack_absurd = 12,\r\n        }\r\n    },\r\n    add_to_deck = function (self, card, from_debuff)\r\n        if #SMODS.find_card(\"j_akyrs_netherite_pickaxe\") > 0 then\r\n            check_for_unlock({ type = \"akyrs_both_pickaxe\" })\r\n        end\r\n    end,\r\n    calculate = function(self, card, context)\r\n        if AKYRS.bal(\"absurd\") then\r\n            if context.before and not context.blueprint or context.forcetrigger then\r\n                AKYRS.simple_event_add(\r\n                    function()\r\n                        for _,cardhand in ipairs(G.hand.cards) do\r\n                            cardhand:set_ability(G.P_CENTERS[\"m_stone\"])\r\n                            cardhand:juice_up(0.5, 2)\r\n                        end\r\n                        return true\r\n                    end\r\n                )\r\n            end\r\n            if context.individual and context.cardarea == G.play then\r\n                if context.other_card.config.center_key == \"m_stone\" then\r\n                    for i = 1, to_number(card.ability.extra.chip_add_stack_absurd) do\r\n                        context.other_card:juice_up(0.5, 2)\r\n                        SMODS.calculate_effect({\r\n                            chips = card.ability.extra.chip_add,\r\n                            juice_card = context.other_card,\r\n                        },card)\r\n                    end\r\n                    return {\r\n                        juice_card = context.other_card,\r\n                        func = function ()\r\n                            if  not context.blueprint then\r\n                            context.other_card:set_ability(\r\n                                pseudorandom_element(NON_STONE_UPGRADES, pseudoseed('akyrj:pickaxe')), nil, true)\r\n                            end\r\n                        end\r\n                    }\r\n                end\r\n            end    \r\n        else\r\n            if context.before and not context.blueprint then\r\n                for _, _c in ipairs(context.full_hand) do\r\n                    SMODS.calculate_effect({\r\n                        func = function ()\r\n                            if _c.config.center_key == \"m_stone\" then\r\n                                AKYRS.simple_event_add(\r\n                                    function ()\r\n                                        if AKYRS.compare(_c.ability.bonus - card.ability.extra.chips_take,\">\",0) then\r\n                                            AKYRS.juice_like_tarot(_c)\r\n                                            _c.ability.bonus = _c.ability.bonus - card.ability.extra.chips_take\r\n                                            card.ability.extra.chips_adequate = card.ability.extra.chips_adequate + card.ability.extra.chips_take\r\n                                        else\r\n                                            AKYRS.juice_like_tarot(_c)\r\n                                            card.ability.extra.chips_adequate = card.ability.extra.chips_adequate + _c.ability.bonus\r\n                                            _c:set_ability(G.P_CENTERS[\"c_base\"])\r\n                                            _c.ability.bonus = 0\r\n                                        end\r\n                                        return true\r\n                                    end\r\n                                )\r\n                            end\r\n                        end,\r\n                        message = localize(\"k_upgrade_ex\")\r\n                    }, card)\r\n                end\r\n            end\r\n            if context.joker_main then\r\n                return {\r\n                    chips = card.ability.extra.chips_adequate\r\n                }\r\n            end\r\n        end\r\n\r\n    end,\r\n\tdemicoloncompat = true,\r\n    blueprint_compat = true",
      "config": {
        "name": "Diamond Pickaxe",
        "extra": {
          "chip_add": 64,
          "chips_adequate": 0,
          "chips_take": 10,
          "chip_add_stack_absurd": 12
        }
      },
      "ability": {
        "name": "Diamond Pickaxe",
        "extra": {
          "chip_add": 64,
          "chips_adequate": 0,
          "chips_take": 10,
          "chip_add_stack_absurd": 12
        }
      },
      "vars": [
        64,
        12
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "netherite_pickaxe",
      "name": "Netherite Pickaxe",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    enhancement_gate = \"m_stone\",\r\n    pools = { [\"Minecraft\"] = true },\r\n    pos = {\r\n        x = 4,\r\n        y = 0\r\n    },\r\n    key = \"netherite_pickaxe\",\r\n    rarity = 3,\r\n    cost = 8,\r\n    loc_vars = function(self, info_queue, card)\r\n        info_queue[#info_queue+1] = G.P_CENTERS[\"m_stone\"]\r\n        if AKYRS.bal(\"absurd\") then\r\n            return {\r\n                key = self.key..'_absurd',\r\n                vars = { card.ability.extra.xchip_add, card.ability.extra.chip_add_stack_absurd, card.ability.extra.xchip_storage  }\r\n            }\r\n        end\r\n        return {\r\n            vars = { card.ability.extra.xchips_adequate, card.ability.extra.xchips_add_when_stone_gone }\r\n        }\r\n    end,\r\n    add_to_deck = function (self, card, from_debuff)\r\n        if #SMODS.find_card(\"j_akyrs_diamond_pickaxe\") > 0 then\r\n            check_for_unlock({ type = \"akyrs_both_pickaxe\" })\r\n        end\r\n    end,\r\n    config = {\r\n        name = \"Netherite Pickaxe\",\r\n        extra = {\r\n            xchip_add = 0.64,\r\n            xchip_storage = 1,\r\n            \r\n            xchips_adequate = 1,\r\n            xchips_add_when_stone_gone = 0.1,\r\n\r\n            \r\n            chip_add = 64,\r\n            chip_add_stack_absurd = 18,\r\n        }\r\n    },\r\n    generate_ui = function(self, info_queue, card, desc_nodes, specific_vars, full_UI_table)\r\n        SMODS.Center.generate_ui(self, info_queue, card, desc_nodes, specific_vars, full_UI_table)\r\n        \r\n        if AKYRS.should_show_card_previews() then\r\n            local cards = {}\r\n            for i = 1,5 do\r\n                local carder = AKYRS.create_random_card(\"netheritepick\")\r\n                carder:set_ability(G.P_CENTERS[\"m_stone\"], true)\r\n                table.insert(cards, carder)\r\n            end\r\n            AKYRS.card_area_preview(G.akyrsCardsPrev, desc_nodes, {\r\n                cards = cards,\r\n                override = true,\r\n                w = 2.2,\r\n                h = 0.6,\r\n                ml = 0,\r\n                scale = 0.5,\r\n                func_delay = 1.0,\r\n                func_after = function(ca) \r\n                    if ca and ca.cards then\r\n                        for i,k in ipairs(ca.cards) do\r\n                            if not k.removed then\r\n                                SMODS.calculate_context({ remove_playing_cards = true, removed = k})\r\n                                k:start_dissolve({G.C.CHIPS}, true)\r\n                            end\r\n                        end\r\n                    end\r\n                end,\r\n            })\r\n        end\r\n    end,\r\n    calculate = function(self, card, context)\r\n        if AKYRS.bal(\"absurd\") then\r\n            if context.individual and context.cardarea == G.play and not context.blueprint then\r\n                if context.other_card.config.center_key == \"m_stone\" then\r\n                    context.other_card.ability.aiko_about_to_be_destroyed = true\r\n                    SMODS.calculate_effect({\r\n                        func = function ()\r\n                            SMODS.scale_card(card,{\r\n                                ref_table = card.ability.extra,\r\n                                ref_value = \"xchip_storage\",\r\n                                scalar_value = \"xchip_add\",\r\n                                -- smods whyyyyy\r\n                                operation = function (ref_t,ref_v,initial,scalar)\r\n                                    ref_t[ref_v] = initial + scalar * card.ability.extra.chip_add_stack_absurd\r\n                                end\r\n                            })\r\n                            \r\n                        end\r\n                    },card)\r\n                end\r\n            end\r\n\r\n            if (context.joker_main or context.forcetrigger) then\r\n                return {\r\n                    xchips = card.ability.extra.xchip_storage\r\n                }\r\n            end\r\n\r\n            if context.pre_discard and not context.forcetrigger then\r\n                return {\r\n                    func = function ()\r\n                        AKYRS.simple_event_add(\r\n                            function()\r\n                                for _,cardhand in ipairs(context.full_hand) do\r\n                                    cardhand:set_ability(G.P_CENTERS[\"m_stone\"])\r\n                                    cardhand:juice_up(0.5, 2)\r\n                                end\r\n                                return true\r\n                            end\r\n                        )\r\n                    end\r\n                }\r\n            end\r\n\r\n            if context.destroy_card and context.cardarea == G.play and not context.blueprint and not context.destroy_card.ability.eternal then\r\n                if context.destroy_card.ability.aiko_about_to_be_destroyed then\r\n                    return { remove = true }\r\n                end\r\n            end\r\n        else\r\n            if context.destroy_card and not context.blueprint then\r\n                for _, _c in ipairs(context.full_hand) do\r\n                    if _c.config.center_key == \"m_stone\" and context.destroy_card == _c then\r\n                        AKYRS.simple_event_add(\r\n                            function ()\r\n                                card.ability.extra.xchips_adequate = card.ability.extra.xchips_adequate + card.ability.extra.xchips_add_when_stone_gone\r\n                                return true\r\n                            end\r\n                        )\r\n                        return {\r\n                            message = localize(\"k_upgrade_ex\"),\r\n                            remove = true\r\n                        }\r\n                    end\r\n                end\r\n            end\r\n            if context.joker_main then\r\n                return {\r\n                    xchips = card.ability.extra.xchips_adequate\r\n                }\r\n            end\r\n        end\r\n\r\n    end,\r\n\tdemicoloncompat = true,\r\n    blueprint_compat = true",
      "config": {
        "name": "Netherite Pickaxe",
        "extra": {
          "xchip_add": 0.64,
          "xchip_storage": 1,
          "xchips_adequate": 1,
          "xchips_add_when_stone_gone": 0.1,
          "chip_add": 64,
          "chip_add_stack_absurd": 18
        }
      },
      "ability": {
        "name": "Netherite Pickaxe",
        "extra": {
          "xchip_add": 0.64,
          "xchip_storage": 1,
          "xchips_adequate": 1,
          "xchips_add_when_stone_gone": 0.1,
          "chip_add": 64,
          "chip_add_stack_absurd": 18
        }
      },
      "vars": [
        0.64,
        18,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "utage_charts",
      "name": "Playable Cards",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 5,
        "y": 0
      },
      "raw": "pools = { [\"Rhythm Games\"] = true, [\"Maimai\"] = true },\r\n    atlas = 'AikoyoriJokers',\r\n    pos = {\r\n        x = 5,\r\n        y = 0\r\n    },\r\n    key = \"utage_charts\",\r\n    rarity = 3,\r\n    cost = 4,\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n            vars = { card.ability.play_mod }\r\n        }\r\n    end,\r\n    config = {\r\n        name = \"Playable Cards\",\r\n        play_mod = 3,\r\n    },\r\n    add_to_deck = function(self, card, from_debuff)\r\n        SMODS.change_play_limit(card.ability.play_mod)\r\n        SMODS.change_discard_limit(card.ability.play_mod)\r\n    end,\r\n    remove_from_deck = function(self, card, from_debuff)\r\n        SMODS.change_play_limit(-card.ability.play_mod)\r\n        SMODS.change_discard_limit(-card.ability.play_mod)\r\n    end,\r\n    blueprint_compat = false,",
      "config": {
        "name": "Playable Cards",
        "play_mod": 3
      },
      "ability": {
        "name": "Playable Cards",
        "play_mod": 3
      },
      "vars": [
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "it_is_forbidden_to_dog",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 7,
        "y": 0
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    pos = {\r\n        x = 7,\r\n        y = 0\r\n    },\r\n    key = \"it_is_forbidden_to_dog\",\r\n    rarity = 3,\r\n    cost = 6,\r\n    loc_vars = function(self, info_queue, card)\r\n        if AKYRS.bal(\"absurd\") then\r\n            info_queue[#info_queue+1] = G.P_CENTERS[\"m_akyrs_scoreless\"]\r\n        end\r\n        return {\r\n            key = AKYRS.bal_val(self.key, self.key..\"_absurd\"),\r\n            vars = { \r\n                AKYRS.bal_val(card.ability.extra.mult, card.ability.extra.emult_absurd)\r\n            }\r\n        }\r\n    end,\r\n    config = {\r\n        extra = {\r\n            mult = 1.5,\r\n            emult_absurd = 1.2,\r\n        }\r\n    },\r\n    calculate = function(self, card, context)\r\n        if AKYRS.bal(\"absurd\") then\r\n            if context.individual and context.cardarea == 'unscored' then\r\n                return {\r\n                    emult = card.ability.extra.emult_absurd,\r\n                    func = function ()\r\n                        context.other_card:set_ability(G.P_CENTERS[\"m_akyrs_scoreless\"])\r\n                        context.other_card:juice_up(0.5,1)\r\n                    end\r\n                }\r\n            end\r\n        else\r\n            if context.hand_drawn and not context.blueprint then\r\n                local to_be_debuffed = {}\r\n                for _, _card in ipairs(G.play.cards) do if not _card.debuff then table.insert(to_be_debuffed, _card) end end\r\n                for _, _card in ipairs(G.hand.cards) do if not _card.debuff then table.insert(to_be_debuffed, _card) end end\r\n                local card_to_debuff = pseudorandom_element(to_be_debuffed, \"akyrs_forbiddendog\")\r\n                if card_to_debuff then\r\n                    return {\r\n                        func = function ()\r\n                            card_to_debuff:set_debuff(true)\r\n                        end\r\n                    }\r\n                end\r\n            end\r\n            if context.joker_main then\r\n                local debuffed = {}\r\n                for _, _card in ipairs(G.hand.cards) do if _card.debuff then table.insert(debuffed, _card) end end\r\n                for _, _card in ipairs(debuffed) do\r\n                    SMODS.calculate_effect({ xmult = card.ability.extra.mult }, _card)\r\n                end\r\n            end\r\n        end\r\n    end,\r\n\tdemicoloncompat = true,\r\n    blueprint_compat = true,",
      "config": {
        "extra": {
          "mult": 1.5,
          "emult_absurd": 1.2
        }
      },
      "ability": {
        "extra": {
          "mult": 1.5,
          "emult_absurd": 1.2
        }
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "eat_pant",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 8,
        "y": 0
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    pos = {\r\n        x = 8,\r\n        y = 0\r\n    },\r\n    pools = { [\"Meme\"] = true },\r\n    key = \"eat_pant\",\r\n    rarity = 3,\r\n    cost = 6,\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n            key = AKYRS.bal_val(self.key, self.key..\"_absurd\"), \r\n            vars = AKYRS.bal_val({ \r\n                math.floor(card.ability.extra.card_target),\r\n                card.ability.extra.extra,\r\n                card.ability.extra.Xmult,\r\n             }, { \r\n                \"heheheha\",\r\n                card.ability.extra.extra_absurd,\r\n                card.ability.extra.Xmult_absurd,\r\n             })\r\n        }\r\n    end,\r\n    config = {\r\n        extra = {\r\n            extra = 16,\r\n            extra_absurd = 2,\r\n            card_target = 4,\r\n            Xmult = 1,\r\n            Xmult_absurd = 1,\r\n        }\r\n    },\r\n    calculate = function(self, card, context)\r\n        if context.joker_main then\t\r\n            return {\r\n                xmult = AKYRS.bal_val(card.ability.extra.Xmult,card.ability.extra.Xmult_absurd)\r\n            }\r\n        end\r\n        if AKYRS.bal(\"absurd\") then\r\n            if context.individual and context.cardarea == G.play and next(context.poker_hands[\"Two Pair\"]) or context.forcetrigger then\r\n                return {\r\n                    message = localize('k_upgrade_ex'),\r\n                    colour = G.C.MULT,\r\n                    card = card,\r\n                    func = function ()\r\n                        SMODS.scale_card(card, {\r\n                            ref_table = card.ability.extra,\r\n                            ref_value = \"Xmult_absurd\",\r\n                            scalar_value = \"extra_absurd\"\r\n                        })\r\n                    end\r\n                }\r\n            end\r\n            if context.destroy_card and (context.cardarea == G.play or context.cardarea == 'unscored') and not context.blueprint and not context.destroy_card.ability.eternal and not context.forcetrigger then\r\n                if next(context.poker_hands[\"Two Pair\"]) then\r\n                    return { remove = true }\r\n                end\r\n            end\r\n        else\r\n            if context.destroy_card then\r\n                if #context.full_hand == 4 then\r\n                    if context.destroy_card == context.full_hand[1] or context.destroy_card == context.full_hand[2] then\r\n                        return {\r\n                            message = localize('k_akyrs_downgrade_ex'),\r\n                            colour = G.C.MULT,\r\n                            remove = true,\r\n                            func = function ()\r\n                                card.ability.extra.Xmult = card.ability.extra.Xmult * (1-(1)/card.ability.extra.extra)\r\n                            end\r\n                        }\r\n                    end\r\n                end\r\n            end\r\n        end\r\n    end,\r\n\tdemicoloncompat = true,\r\n    blueprint_compat = true,",
      "config": {
        "extra": {
          "extra": 16,
          "extra_absurd": 2,
          "card_target": 4,
          "Xmult": 1,
          "Xmult_absurd": 1
        }
      },
      "ability": {
        "extra": {
          "extra": 16,
          "extra_absurd": 2,
          "card_target": 4,
          "Xmult": 1,
          "Xmult_absurd": 1
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "yona_yona_dance",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    pos = {\r\n        x = 0,\r\n        y = 1\r\n    },\r\n    pools = { [\"J-POP\"] = true },\r\n    key = \"yona_yona_dance\",\r\n    rarity = 3,\r\n    cost = 8,\r\n    loc_vars = function(self, info_queue, card)\r\n        if AKYRS.config.show_joker_preview then\r\n            info_queue[#info_queue+1] = AKYRS.DescriptionDummies[\"dd_akyrs_yona_yona_ex\"]\r\n        end\r\n        return {\r\n            vars = { \r\n                card.ability.extra.times,\r\n            }\r\n        }\r\n    end,\r\n    config = {\r\n        extra = {\r\n            times = 2\r\n        },\r\n    },\r\n\r\n    calculate = function(self, card, context)\r\n        if context.repetition and (context.other_card:get_id() == 4 or context.other_card:get_id() == 7) then\r\n            return {\r\n                message = localize('k_again_ex'),\r\n                repetitions = card.ability.extra.times,\r\n            }\r\n        end\r\n    end,\r\n    blueprint_compat = true,\r\n\tdemicoloncompat = true,",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "tldr_joker",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 6,
        "y": 1
      },
      "raw": "key = \"tldr_joker\",\r\n    atlas = 'AikoyoriJokers',\r\n\tpools = { [\"Meme\"] = true },\r\n    pos = {\r\n        x = 6,\r\n        y = 1\r\n    },\r\n    soul_pos = {\r\n        x = 7,\r\n        y = 1\r\n    },\r\n    rarity = 1,\r\n    cost = 2,\r\n    loc_vars = function(self, info_queue, card)\r\n        if AKYRS.bal(\"absurd\") then\r\n            info_queue[#info_queue+1] = G.P_CENTERS[\"j_chaos\"]\r\n            info_queue[#info_queue+1] = G.P_CENTERS[\"c_moon\"]\r\n            info_queue[#info_queue+1] = G.P_CENTERS[\"v_grabber\"]\r\n            info_queue[#info_queue+1] = G.P_CENTERS[\"j_ceremonial\"]\r\n            if AKYRS.is_mod_loaded(\"Cryptid\") then\r\n                info_queue[#info_queue+1] = G.P_CENTERS[\"c_cry_summoning\"]\r\n                info_queue[#info_queue+1] = G.P_CENTERS[\"j_cry_exponentia\"]\r\n                info_queue[#info_queue+1] = G.P_BLINDS[\"bl_cry_tax\"]\r\n            end\r\n            info_queue[#info_queue+1] = G.P_CENTERS[\"m_lucky\"]\r\n            info_queue[#info_queue+1] = G.P_CENTERS[\"j_akyrs_shimmer_bucket\"]\r\n            info_queue[#info_queue+1] = G.P_CENTERS[\"m_stone\"]\r\n            info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_tldr_tldr_absurd\", vars = {card.ability.extra.xmult}}\r\n            info_queue[#info_queue+1] = G.P_CENTERS[\"v_akyrs_alphabet_soup\"]\r\n            info_queue[#info_queue+1] = G.P_CENTERS[\"j_oops\"]\r\n        else\r\n            info_queue[#info_queue+1] = G.P_CENTERS[\"m_stone\"]\r\n            info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_tldr_tldr\", vars = {card.ability.extra.mult}}\r\n        end\r\n        return {\r\n            key = AKYRS.bal_val(self.key, self.key..\"_absurd\"), \r\n            scale = 0.7,\r\n            vars = { \r\n                AKYRS.bal_val(card.ability.extra.mult,card.ability.extra.xmult)\r\n            }\r\n        }\r\n    end,\r\n    config = {\r\n        extra = {\r\n            mult = 2,\r\n            xmult = 3\r\n        },\r\n    },\r\n    calculate = function(self, card, context)\r\n        if AKYRS.bal(\"absurd\") then\r\n                if context.joker_main or context.forcetrigger then\r\n                return {\r\n                    xmult = card.ability.extra.xmult\r\n                }\r\n            end\r\n        else\r\n            if context.joker_main or context.individual and not context.end_of_round and (context.cardarea == G.hand or context.cardarea == G.play) or context.forcetrigger then\r\n                return AKYRS.bal_val(\r\n                    {\r\n                        mult = card.ability.extra.mult\r\n                    }\r\n                )\r\n            end\r\n        end\r\n    end,\r\n    blueprint_compat = true,\r\n\tdemicoloncompat = true,",
      "config": {
        "extra": {
          "mult": 2,
          "xmult": 3
        }
      },
      "ability": {
        "extra": {
          "mult": 2,
          "xmult": 3
        }
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "reciprocal_joker",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    key = \"reciprocal_joker\",\r\n    pos = {\r\n        x = 1,\r\n        y = 1\r\n    },\r\n    rarity = 1,\r\n    cost = 2,\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n            key = AKYRS.bal_val(self.key, self.key..\"_absurd\"), \r\n            vars = {\r\n            }\r\n        }\r\n    end,\r\n    config = {\r\n        extra = {\r\n        },\r\n    },\r\n    calculate = function(self, card, context)\r\n        if context.joker_main or context.forcetrigger then\r\n            return {\r\n                message = localize('k_akyrs_reciprocaled'),\r\n                func = function()\r\n                    if AKYRS.bal(\"absurd\") then\r\n                        hand_chips = mod_mult(mult / hand_chips)\r\n                    else\r\n                        mult = mod_mult(hand_chips / mult)\r\n                    end\r\n                    update_hand_text({ delay = 0, immediate = false }, { mult = mult, chips = hand_chips })\r\n                end\r\n            }\r\n        end\r\n    end,\r\n\tdemicoloncompat = true,\r\n    blueprint_compat = true,",
      "config": {
        "extra": {}
      },
      "ability": {
        "extra": {}
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "kyoufuu_all_back",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    key = \"kyoufuu_all_back\",\r\n    pools = { [\"Vocaloids\"] = true, [\"J-POP\"] = true },\r\n    pos = {\r\n        x = 2,\r\n        y = 1\r\n    },\r\n    rarity = 1,\r\n    cost = 3,\r\n    loc_vars = function(self, info_queue, card)\r\n        return {\r\n        }\r\n    end,\r\n    config = {\r\n        extra = {\r\n        },\r\n    },\r\n    calculate = function(self, card, context)\r\n        if context.hand_drawn or context.forcetrigger then\r\n            return {\r\n                message = localize('k_akyrs_drawn_discard'),\r\n                func = function()\r\n                    AKYRS.simple_event_add(\r\n                        function ()\r\n                            G.FUNCS.draw_from_discard_to_deck()\r\n\r\n                            AKYRS.simple_event_add(\r\n                                function ()\r\n                                    AKYRS.remove_dupes(G.deck.cards)\r\n                                    return true\r\n                                end, 0\r\n                            )\r\n                            return true\r\n                        end, 0\r\n                    )\r\n                end\r\n            }\r\n        end\r\n    end,\r\n    blueprint_compat = false,",
      "config": {
        "extra": {}
      },
      "ability": {
        "extra": {}
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "2fa",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    pools = { [\"Tech\"] = true, },\r\n    key = \"2fa\",\r\n    pos = {\r\n        x = 3,\r\n        y = 1\r\n    },\r\n    rarity = 1,\r\n    cost = 3,\r\n    loc_vars = function(self, info_queue, card)\r\n        if AKYRS.config.show_joker_preview then\r\n            info_queue[#info_queue + 1] = AKYRS.DescriptionDummies[\"dd_akyrs_2fa_example\"]\r\n        end\r\n        if AKYRS.bal(\"absurd\") then\r\n            return {\r\n                key = self.key .. \"_absurd\",\r\n                vars = {\r\n                    card.ability.extra.xchips_gain,\r\n                    card.ability.extra.xmult_gain,\r\n                    card.ability.extra.xchips,\r\n                    card.ability.extra.xmult,\r\n                }\r\n            }            \r\n        end\r\n        return {\r\n            vars = {\r\n                card.ability.extra.extra,\r\n                card.ability.extra.chips\r\n            }\r\n        }\r\n    end,\r\n    config = {\r\n        extra = {\r\n            chips = 0,\r\n            extra = 8,\r\n\r\n            xmult = 1,\r\n            xchips = 1,\r\n            xmult_gain = .1,\r\n            xchips_gain = 0.3,\r\n        },\r\n    },\r\n    calculate = function(self, card, context)\r\n        if context.before or context.forcetrigger then\r\n            for i, _card in ipairs(G.play.cards) do\r\n                SMODS.scale_card(card, { ref_table = card.ability.extra, ref_value = \"chips\", scalar_value = \"extra\" })\r\n            end\r\n            return {\r\n                message = localize(\"k_akyrs_2fa_generate\")\r\n            }\r\n        end\r\n        if (context.joker_main or context.forcetrigger) and AKYRS.bal(\"adequate\") then\r\n            return {\r\n                chips = card.ability.extra.chips\r\n            }\r\n        end\r\n        if (context.joker_main or context.forcetrigger) and AKYRS.bal(\"absurd\") then\r\n            return {\r\n                xchips = card.ability.extra.xchips,\r\n                xmult = card.ability.extra.xmult\r\n            }\r\n        end\r\n        if context.end_of_round and context.cardarea == G.jokers and AKYRS.bal(\"adequate\") then\r\n            return {\r\n                message = localize(\"k_akyrs_2fa_reset\"),\r\n                func = function()\r\n                    card.ability.extra.chips = card.ability.extra.chips / 2\r\n                end\r\n            }\r\n        end\r\n        if context.after and not context.blueprint then\r\n            return {\r\n                func = function()\r\n                    for i, _card in ipairs(G.play.cards) do\r\n                        local original_rank = _card:get_id()\r\n                        local original_suit = _card.base.suit\r\n                        G.E_MANAGER:add_event(Event {\r\n                            trigger = 'after',\r\n                            blocking = false,\r\n                            delay = 0.2 * AKYRS.get_speed_mult(_card),\r\n                            func = function()\r\n                                if G.play and G.play.cards then\r\n                                    local percent = math.abs(1.15 - (i - 0.999) / (#G.play.cards - 0.998) * 0.3)\r\n                                    if G.play.cards[i] then\r\n                                        G.play.cards[i]:flip()\r\n                                    end\r\n                                    --G.play.cards[i]:a_cool_fucking_spin(1,math.pi * 100)\r\n                                    play_sound('card1', percent);\r\n                                end\r\n                                return true\r\n                            end\r\n                        })\r\n                        G.E_MANAGER:add_event(Event {\r\n                            trigger = 'after',\r\n                            delay = 0.5 * AKYRS.get_speed_mult(card),\r\n                            blocking = false,\r\n                            func = function()\r\n                                if G.play and G.play.cards then\r\n                                    local _rank = nil\r\n                                    local _suit = nil\r\n                                    while _rank == nil or _suit == nil do\r\n                                        _rank = pseudorandom_element(SMODS.Ranks, pseudoseed('akyrs2far'))\r\n                                        _suit = pseudorandom_element(SMODS.Suits, pseudoseed('akyrs2fas'))\r\n                                    end\r\n                                    if G.play.cards[i] then\r\n                                        assert(SMODS.change_base(G.play.cards[i], _suit.key, _rank.key))\r\n                                        G.play.cards[i]:flip()\r\n                                        if G.play.cards[i]:get_id() == original_rank and AKYRS.bal(\"absurd\") then\r\n                                            SMODS.scale_card(card, { ref_table = card.ability.extra, ref_value = \"xchips\", scalar_value = \"xchips_gain\" })\r\n                                        end\r\n                                        if G.play.cards[i].base.suit == original_suit and AKYRS.bal(\"absurd\") then\r\n                                            SMODS.scale_card(card, { ref_table = card.ability.extra, ref_value = \"xmult\", scalar_value = \"xmult_gain\" })\r\n                                        end\r\n                                    end\r\n                                end\r\n\r\n                                return true\r\n                            end\r\n                        })\r\n                    end\r\n                    delay((0.5 * AKYRS.get_speed_mult(card) + 0.2 * #G.play.cards))\r\n                end,\r\n                message = localize(\"k_akyrs_2fa_regen\"),\r\n            }\r\n        end\r\n    end,\r\n    demicoloncompat = true,\r\n    blueprint_compat = false,",
      "config": {},
      "ability": {},
      "vars": [
        null,
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "gaslighting",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 4,
        "y": 1
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    key = \"gaslighting\",\r\n    pos = {\r\n        x = 4,\r\n        y = 1\r\n    },\r\n    rarity = 1,\r\n    cost = 4,\r\n    config = {\r\n        extra = {\r\n            xmult = 1,\r\n            extra = 0.5,\r\n            eemult = 1.21,\r\n            eemult_negative = 0.35,\r\n            chance = 3,\r\n            super_mario = 1,\r\n        },\r\n    },\r\n    loc_vars = function(self, info_queue, card)\r\n        if AKYRS.bal(\"absurd\") then\r\n            local num, denom = SMODS.get_probability_vars(card, 1, card.ability.extra.chance, 'akyrs_gaslighting_absurd')\r\n            return {\r\n                key = self.key .. \"_absurd\",\r\n                vars = {\r\n                    card.ability.extra.eemult,\r\n                    card.ability.extra.eemult_negative,\r\n                    num,\r\n                    denom,\r\n                }\r\n            }\r\n        end\r\n        return {\r\n            vars = {\r\n                card.ability.extra.extra,\r\n                card.ability.extra.xmult,\r\n            }\r\n        }\r\n    end,\r\n    calculate = function(self, card, context)\r\n        if AKYRS.bal(\"absurd\") and (context.joker_main or context.forcetrigger) then\r\n            local odder = SMODS.pseudorandom_probability(card, \"akyrs_gaslighting_absurd\",1, card.ability.extra.chance, 'akyrs_gaslighting_absurd')\r\n            if odder then\r\n                return {\r\n                    eemult = card.ability.extra.eemult\r\n                }\r\n            else\r\n                return {\r\n                    eemult = card.ability.extra.eemult_negative\r\n\r\n                }\r\n            end\r\n        end\r\n        if AKYRS.bal(\"adequate\") then\r\n            if context.joker_main or context.forcetrigger then\r\n                return {\r\n                    xmult = card.ability.extra.xmult\r\n                }\r\n            end\r\n            if context.final_scoring_step and G.GAME.blind then\r\n                \r\n                    G.E_MANAGER:add_event(\r\n                        Event{\r\n                            func = function ()\r\n                                if SMODS.last_hand_oneshot then\r\n                                    card.ability.extra.xmult = 1\r\n                                else \r\n                                    \r\n                                    SMODS.scale_card(card, { ref_table = card.ability.extra, ref_value = \"xmult\", scalar_value = \"extra\" })\r\n                                end\r\n                                return true\r\n                            end\r\n                        }\r\n                    )\r\n                    if SMODS.last_hand_oneshot then\r\n                        return {\r\n                            message = localize(\"k_akyrs_extinguish\")\r\n                        }\r\n                    else \r\n                        return {\r\n                            message = localize(\"k_akyrs_burn\"),\r\n                        }\r\n                    end\r\n            end\r\n        end\r\n \r\n    end,\r\n    demicoloncompat = true,\r\n    blueprint_compat = true,",
      "config": {
        "extra": {
          "xmult": 1,
          "extra": 0.5,
          "eemult": 1.21,
          "eemult_negative": 0.35,
          "chance": 3,
          "super_mario": 1
        }
      },
      "ability": {
        "extra": {
          "xmult": 1,
          "extra": 0.5,
          "eemult": 1.21,
          "eemult_negative": 0.35,
          "chance": 3,
          "super_mario": 1
        }
      },
      "vars": [
        1.21,
        0.35,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "hibana",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 5,
        "y": 1
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    key = \"hibana\",\r\n    pools = { [\"Vocaloids\"] = true, [\"J-POP\"] = true },\r\n    pos = {\r\n        x = 5,\r\n        y = 1\r\n    },\r\n    soul_pos = {\r\n        x = 8,\r\n        y = 1\r\n    },\r\n    rarity = 3,\r\n    cost = 7,\r\n    config = {\r\n        possible_table = {\r\n            {\"Ace\", \"Rank\", {\"k_aces\", \"dictionary\"}},\r\n            {\"Face Cards\", \"Condition\", {\"k_face_cards\",\"dictionary\"}},\r\n            {\"Hearts\", \"Suit\", {\"Hearts\", 'suits_plural'}},\r\n            {\"5\", \"Rank\", {\"5\", \"ranks\"}}\r\n        },\r\n        immutable = {\r\n            akyrs_cycler = 1,\r\n            akyrs_priority_draw_rank = \"Ace\",\r\n            akyrs_priority_draw_suit = nil,\r\n            akyrs_priority_draw_conditions = nil,\r\n        },\r\n    },\r\n    set_ability = function (self, card, initial, delay_sprites)\r\n        if card.ability.immutable.akyrs_cycler ~= 1 and card.ability.immutable.akyrs_cycler ~= 2 and card.ability.immutable.akyrs_cycler ~= 3 and card.ability.immutable.akyrs_cycler ~= 4 then\r\n            card.ability.immutable.akyrs_cycler = 1\r\n        end\r\n    end,\r\n    loc_vars = function(self, info_queue, card)\r\n        if card.ability.immutable.akyrs_cycler ~= 1 and card.ability.immutable.akyrs_cycler ~= 2 and card.ability.immutable.akyrs_cycler ~= 3 and card.ability.immutable.akyrs_cycler ~= 4 then\r\n            card.ability.immutable.akyrs_cycler = 1\r\n        end\r\n        local table = card.ability.possible_table[math.floor(card.ability.immutable.akyrs_cycler)]\r\n        info_queue[#info_queue+1] = { key = \"dd_akyrs_hibana_conditions\", set = \"DescriptionDummy\"}\r\n        return {\r\n            vars = {\r\n                localize(table[3][1],table[3][2]),\r\n                card.ability.immutable.akyrs_cycler,\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if (context.end_of_round or context.forcetrigger) and context.cardarea == G.jokers then\r\n            if card.ability.immutable.akyrs_cycler ~= 1 and card.ability.immutable.akyrs_cycler ~= 2 and card.ability.immutable.akyrs_cycler ~= 3 and card.ability.immutable.akyrs_cycler ~= 4 then\r\n                card.ability.immutable.akyrs_cycler = 1\r\n            end\r\n            card.ability.immutable.akyrs_priority_draw_rank = nil\r\n            card.ability.immutable.akyrs_priority_draw_suit = nil\r\n            card.ability.immutable.akyrs_priority_draw_conditions = nil\r\n            card.ability.immutable.akyrs_cycler = math.fmod(card.ability.immutable.akyrs_cycler,#(card.ability.possible_table)) + 1\r\n            local curr = card.ability.possible_table[card.ability.immutable.akyrs_cycler]\r\n            if curr[2] == \"Rank\" then\r\n                card.ability.immutable.akyrs_priority_draw_rank = curr[1]\r\n            end\r\n            if curr[2] == \"Suit\" then\r\n                card.ability.immutable.akyrs_priority_draw_suit = curr[1]\r\n            end\r\n            if curr[2] == \"Condition\" then\r\n                card.ability.immutable.akyrs_priority_draw_conditions = curr[1]\r\n            end\r\n            return {\r\n                message = localize('k_akyrs_hibana_change')\r\n            }\r\n        end\r\n    end,\r\n    add_to_deck = function (self, card, from_debuff)        \r\n        card.ability.immutable.akyrs_cycler = math.floor(card.ability.immutable.akyrs_cycler)\r\n        card.ability.immutable.akyrs_priority_draw_rank = nil\r\n        card.ability.immutable.akyrs_priority_draw_suit = nil\r\n        card.ability.immutable.akyrs_priority_draw_conditions = nil\r\n        local curr = card.ability.possible_table[card.ability.immutable.akyrs_cycler]\r\n        if curr[2] == \"Rank\" then\r\n            card.ability.immutable.akyrs_priority_draw_rank = curr[1]\r\n        end\r\n        if curr[2] == \"Suit\" then\r\n            card.ability.immutable.akyrs_priority_draw_suit = curr[1]\r\n        end\r\n        if curr[2] == \"Condition\" then\r\n            card.ability.immutable.akyrs_priority_draw_conditions = curr[1]\r\n        end\r\n        if G.deck then\r\n            G.deck:shuffle()\r\n        end\r\n    end,\r\n    remove_from_deck = function (self, card, from_debuff)\r\n        if G.deck then\r\n            G.deck:shuffle()\r\n        end\r\n    end,\r\n    demicoloncompat = true,\r\n    hpot_unbreedable = true,",
      "config": {},
      "ability": {},
      "vars": [
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "centrifuge",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    key = \"centrifuge\",\r\n    pools = { [\"Science\"] = true },\r\n    pos = {\r\n        x = 0, y = 2\r\n    },\r\n    rarity = 2,\r\n    cost = 2,\r\n    config = {\r\n        extra = {\r\n            rank_delta = 1,\r\n            chips = 4,\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        if AKYRS.bal(\"absurd\") then\r\n            info_queue[#info_queue+1] = G.P_CENTERS[\"m_akyrs_scoreless\"]\r\n            return {\r\n                key = self.key .. \"_absurd\",\r\n                vars = {\r\n                    1,\r\n                }\r\n            }\r\n        end\r\n        return {\r\n            vars = {\r\n                1,\r\n                card.ability.extra.chips\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.after and #G.play.cards >= 3 and not context.blueprint then\r\n\r\n            for i, card2 in ipairs(G.play.cards) do\r\n                \r\n                G.E_MANAGER:add_event(Event{\r\n                    trigger = 'after',\r\n                    blocking = false,\r\n                    -- the abs thing is so it does the center to the sides effect\r\n                    -- TODO: Maybe make it flip from center to border like a centrifuge, not priority tho\r\n                    delay = 0.2*AKYRS.get_speed_mult(card),\r\n                    func = function ()\r\n                        if G.play and G.play.cards then\r\n                            local percent = math.abs(1.15 - (i-0.999)/(#G.play.cards-0.998)*0.3)\r\n                            if G.play.cards[i] then\r\n                                G.play.cards[i]:flip()\r\n                            end\r\n                            play_sound('card1', percent);\r\n                        end\r\n                        return true\r\n                    end\r\n                })\r\n                G.E_MANAGER:add_event(\r\n                    Event{\r\n                        trigger = 'after',\r\n                        delay = 0.5*AKYRS.get_speed_mult(card),\r\n                        func = function ()\r\n                            local rankToChangeTo = card2.base.value\r\n                            local ed = poll_edition(\"akyrs_centrifuge_absurd_edition\",1, true, true)\r\n                            local en = SMODS.poll_enhancement({guaranteed = true, key = \"akyrs_centrifuge_absurd\"})\r\n                            if type(en) == \"string\" then en = G.P_CENTERS[en] end\r\n                            local rim = true\r\n                            if i == 1 or i == #G.play.cards then\r\n                                rankToChangeTo = pseudorandom_element(SMODS.Ranks[card2.base.value].next,pseudoseed(\"akyrscentrifuge\"))\r\n                            else\r\n                                en = G.P_CENTERS[\"m_akyrs_scoreless\"]\r\n                                rankToChangeTo = pseudorandom_element(SMODS.Ranks[card2.base.value].prev,pseudoseed(\"akyrscentrifuge\"))\r\n                                rim = false\r\n                            end\r\n                            card2:flip()\r\n                            assert(SMODS.change_base(card2, nil, rankToChangeTo))\r\n                            if AKYRS.bal(\"absurd\") then\r\n                                card2:set_ability(en)\r\n                                if rim then card2:set_edition(ed) end\r\n                                \r\n                            end\r\n                            return true\r\n                        end\r\n                    }\r\n                )\r\n            end\r\n            delay(0.1*AKYRS.get_speed_mult(card)+0.3*#G.play.cards)\r\n        end\r\n        if context.joker_main and AKYRS.bal(\"adequate\") then\r\n            return {\r\n                chips = card.ability.extra.chips * #G.play.cards,\r\n                message = localize(\"k_akyrs_centrifuged\")\r\n            }\r\n        end\r\n    end,\r\n    demicoloncompat = true,",
      "config": {
        "extra": {
          "rank_delta": 1,
          "chips": 4
        }
      },
      "ability": {
        "extra": {
          "rank_delta": 1,
          "chips": 4
        }
      },
      "vars": [
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "neurosama",
      "name": "Neuro Sama",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    key = \"neurosama\",\r\n    pools = { [\"Vtuber\"] = true, },\r\n    pos = {\r\n        x = 1, y = 2\r\n    },\r\n    rarity = 3,\r\n    cost = 6,\r\n    config = {\r\n        name = \"Neuro Sama\",\r\n        extras = {\r\n            xmult = 0,\r\n            xmult_inc = 0.06,\r\n            xmult_absurd = 1,\r\n            xmult_inc_absurd = 1.2,\r\n        }\r\n    },\r\n    loc_vars = function (self,info_queue, card)\r\n        return {\r\n            key = AKYRS.bal_val(self.key, self.key..\"_absurd\"), \r\n            vars = AKYRS.bal_val({\r\n                card.ability.extras.xmult,\r\n                card.ability.extras.xmult_inc\r\n            },\r\n            {\r\n                card.ability.extras.xmult_absurd,\r\n                card.ability.extras.xmult_inc_absurd\r\n            })\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.individual and context.cardarea == G.play and not context.blueprint then\r\n            if context.other_card:is_suit(\"Hearts\") or ((context.other_card:is_suit(\"Spades\") and next(SMODS.find_card(\"j_akyrs_evilneuro\")))) then\r\n                return {\r\n                    message_card = card,\r\n                    func = function ()\r\n                        if Talisman then\r\n                            card.ability.extras.xmult_absurd = to_big(card.ability.extras.xmult_absurd)\r\n                            card.ability.extras.xmult_inc_absurd = to_big(card.ability.extras.xmult_inc_absurd)\r\n                        end\r\n                        if AKYRS.bal(\"absurd\") then\r\n                            SMODS.scale_card(card, { ref_table = card.ability.extras, ref_value = \"xmult_absurd\", scalar_value = \"xmult_inc_absurd\" })\r\n                        else\r\n                            SMODS.scale_card(card, { ref_table = card.ability.extras, ref_value = \"xmult\", scalar_value = \"xmult_inc\" })\r\n                        end\r\n                    end\r\n                }\r\n            end\r\n        end\r\n        if context.joker_main or context.forcetrigger then\r\n            return {\r\n                xmult = AKYRS.bal_val(card.ability.extras.xmult,card.ability.extras.xmult_absurd)\r\n            }\r\n        end\r\n    end,\r\n    blueprint_compat = true,\r\n    demicoloncompat = true,\r\n    hpot_unbreedable = true,",
      "config": {
        "name": "Neuro Sama",
        "extras": {
          "xmult": 0,
          "xmult_inc": 0.06,
          "xmult_absurd": 1,
          "xmult_inc_absurd": 1.2
        }
      },
      "ability": {
        "name": "Neuro Sama",
        "extras": {
          "xmult": 0,
          "xmult_inc": 0.06,
          "xmult_absurd": 1,
          "xmult_inc_absurd": 1.2
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "evilneuro",
      "name": "Evil Neuro",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    key = \"evilneuro\",\r\n    pools = { [\"Vtuber\"] = true, },\r\n    pos = {\r\n        x = 2, y = 2\r\n    },\r\n    rarity = 3,\r\n    cost = 6,\r\n    config = {\r\n        name = \"Evil Neuro\",\r\n        extras = {\r\n            xchips = 1,\r\n            xchips_inc = 0.06,\r\n            xchips_absurd = 1.1,\r\n            xchips_inc_absurd = 1.1,\r\n        }\r\n    },\r\n    loc_vars = function (self,info_queue, card)\r\n        return {\r\n            key = AKYRS.bal_val(self.key, self.key..\"_absurd\"), \r\n            vars = AKYRS.bal_val({\r\n                card.ability.extras.xchips,\r\n                card.ability.extras.xchips_inc\r\n            },\r\n            {\r\n                card.ability.extras.xchips_absurd,\r\n                card.ability.extras.xchips_inc_absurd\r\n            })\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.individual and context.cardarea == G.play and not context.blueprint then\r\n            if context.other_card:is_suit(\"Clubs\") or ((context.other_card:is_suit(\"Diamonds\") and next(SMODS.find_card(\"j_akyrs_neurosama\")))) then\r\n                return {\r\n                    message_card = card,\r\n                    func = function ()\r\n                        if AKYRS.bal(\"adequate\") then\r\n                            \r\n                            SMODS.scale_card(card, { ref_table = card.ability.extras, ref_value = \"xchips\", scalar_value = \"xchips_inc\" })\r\n                        end\r\n                        if AKYRS.bal(\"absurd\") then\r\n                            card.ability.extras.xchips_absurd = to_big(card.ability.extras.xchips_absurd)\r\n                            card.ability.extras.xchips_inc_absurd = to_big(card.ability.extras.xchips_inc_absurd)\r\n                            SMODS.scale_card(card, { ref_table = card.ability.extras, ref_value = \"xchips_absurd\", scalar_value = \"xchips_inc_absurd\",\r\n                                operation = function (ref_t,ref_v,initial,scalar)\r\n                                    ref_t[ref_v] = initial ^ scalar \r\n                                end })\r\n                        end\r\n                    end\r\n                }\r\n            end\r\n        end\r\n        if context.joker_main or context.forcetrigger then\r\n            return {\r\n                xchips = AKYRS.bal_val(card.ability.extras.xchips,card.ability.extras.xchips_absurd)\r\n            }\r\n        end\r\n    end,\r\n    blueprint_compat = true,\r\n    demicoloncompat = true,\r\n    hpot_unbreedable = true,",
      "config": {
        "name": "Evil Neuro",
        "extras": {
          "xchips": 1,
          "xchips_inc": 0.06,
          "xchips_absurd": 1.1,
          "xchips_inc_absurd": 1.1
        }
      },
      "ability": {
        "name": "Evil Neuro",
        "extras": {
          "xchips": 1,
          "xchips_inc": 0.06,
          "xchips_absurd": 1.1,
          "xchips_inc_absurd": 1.1
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "dried_ghast",
      "name": "Dried Ghast",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 3,
        "y": 2
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    key = \"dried_ghast\",\r\n    pools = { [\"Minecraft\"] = true, },\r\n    pos = {\r\n        x = 3, y = 2\r\n    },\r\n    rarity = 3,\r\n    cost = 6,\r\n    config = {\r\n        name = \"Dried Ghast\",\r\n        extras = {\r\n            rounds_left = 2\r\n        }\r\n    },\r\n    loc_vars = function (self,info_queue, card)\r\n        info_queue[#info_queue+1] = G.P_CENTERS[\"j_akyrs_ghastling\"]\r\n        return {\r\n            vars = {\r\n                card.ability.extras.rounds_left,\r\n                2\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.setting_blind and not context.blueprint then\r\n            return {\r\n                message = localize(\"k_akyrs_dried\"),\r\n                func = function ()\r\n                    card.ability.current_round_discards = G.GAME.round_resets.discards\r\n                    G.GAME.current_round.discards_left = 0\r\n                end\r\n            }\r\n        end\r\n        if context.selling_card and context.card == card and not context.blueprint then\r\n            G.GAME.current_round.discards_left = card.ability.current_round_discards \r\n        end\r\n        if (context.end_of_round and context.cardarea == G.jokers or context.forcetrigger) and not context.blueprint then\r\n            if not card.ability.do_not_decrease then\r\n                return {\r\n                    message = localize(\"k_akyrs_moisture\"),\r\n                    func = function ()\r\n                        card.ability.extras.rounds_left = card.ability.extras.rounds_left - 1\r\n                        if card.ability.extras.rounds_left <= 0 then\r\n                            card:start_dissolve({G.C.BLUE}, nil, 0.5)\r\n                            local c = SMODS.add_card({ key = \"j_akyrs_ghastling\"})\r\n                            c.ability.akyrs_from_dried = true\r\n                        end\r\n                    end\r\n                }\r\n            else\r\n                return {\r\n                    func = function ()\r\n                        card.ability.do_not_decrease = false\r\n                    end\r\n                }\r\n            end\r\n\r\n        end\r\n    end,\r\n    demicoloncompat = true,",
      "config": {
        "name": "Dried Ghast",
        "extras": {
          "rounds_left": 2
        }
      },
      "ability": {
        "name": "Dried Ghast",
        "extras": {
          "rounds_left": 2
        }
      },
      "vars": [
        2,
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "ghastling",
      "name": "Ghastling",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 4,
        "y": 2
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    key = \"ghastling\",\r\n    pools = { [\"Minecraft\"] = true, },\r\n    pos = {\r\n        x = 4, y = 2\r\n    },\r\n    rarity = 3,\r\n    cost = 8,\r\n    config = {\r\n        name = \"Ghastling\",\r\n        extras = {\r\n            rounds_left = 10,\r\n            rounds_left_absurd = 20,\r\n            mult = 21.6\r\n        }\r\n    },\r\n    in_pool = function (self, args)\r\n        return false\r\n    end,\r\n    loc_vars = function (self,info_queue, card)\r\n        info_queue[#info_queue+1] = G.P_CENTERS[\"j_akyrs_happy_ghast\"]\r\n        return {\r\n            vars = {\r\n                AKYRS.bal_val(card.ability.extras.rounds_left,card.ability.extras.rounds_left_absurd),\r\n                card.ability.extras.mult,\r\n                3\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if (context.after and context.cardarea == G.jokers or context.forcetrigger) and not context.blueprint then\r\n            if not card.ability.do_not_decrease then\r\n                return {\r\n                    message = localize(\"k_akyrs_growth\"),\r\n                    func = function ()\r\n                        card.ability.extras.rounds_left = card.ability.extras.rounds_left - (#SMODS.find_card(\"j_ice_cream\") + 1)\r\n                        card.ability.extras.rounds_left_absurd = card.ability.extras.rounds_left_absurd - (#SMODS.find_card(\"j_ice_cream\") + 1)\r\n                        if AKYRS.bal_val(card.ability.extras.rounds_left <= 0,card.ability.extras.rounds_left_absurd <= 0) then\r\n                            card:start_dissolve({G.C.RED}, nil, 0.5)\r\n                            if card.ability.akyrs_from_dried then\r\n                                check_for_unlock({ type = \"akyrs_happy_ghast_grown_from_dried\"})\r\n                            end\r\n                            SMODS.add_card({ key = \"j_akyrs_happy_ghast\"})\r\n                        end\r\n                    end\r\n                }\r\n            else\r\n                return {\r\n                    func = function ()\r\n                        card.ability.do_not_decrease = false\r\n                    end\r\n                }\r\n            end\r\n\r\n        end\r\n        if (context.joker_main or context.forcetrigger) then\r\n            return {\r\n                mult = card.ability.extras.mult\r\n            }\r\n        end\r\n    end,\r\n    demicoloncompat = true,\r\n    blueprint_compat = true",
      "config": {
        "name": "Ghastling",
        "extras": {
          "rounds_left": 10,
          "rounds_left_absurd": 20,
          "mult": 21.6
        }
      },
      "ability": {
        "name": "Ghastling",
        "extras": {
          "rounds_left": 10,
          "rounds_left_absurd": 20,
          "mult": 21.6
        }
      },
      "vars": [
        null,
        null,
        21.6,
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "happy_ghast",
      "name": "Happy Ghast",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 5,
        "y": 2
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    key = \"happy_ghast\",\r\n    pools = { [\"Minecraft\"] = true, },\r\n    pos = {\r\n        x = 5, y = 2\r\n    },\r\n    rarity = 3,\r\n    cost = 10,\r\n    config = {\r\n        name = \"Happy Ghast\",\r\n        extras = {\r\n            xmult = 4.32,\r\n            eemult_absurd = 2.16\r\n        }\r\n    },\r\n    in_pool = function (self, args)\r\n        return false\r\n    end,\r\n    loc_vars = function (self,info_queue, card)\r\n        return {\r\n            key = AKYRS.bal_val(self.key, self.key..\"_absurd\"),\r\n            vars = {\r\n                AKYRS.bal_val(card.ability.extras.xmult,card.ability.extras.eemult_absurd)\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if AKYRS.bal_val(context.joker_main,context.individual and context.cardarea == G.play) or context.forcetrigger then\r\n            return AKYRS.bal_val({\r\n                xmult = card.ability.extras.xmult\r\n            },{\r\n                emult = card.ability.extras.eemult_absurd\r\n            })\r\n        end\r\n    end,\r\n    demicoloncompat = true,\r\n    blueprint_compat = true",
      "config": {
        "name": "Happy Ghast",
        "extras": {
          "xmult": 4.32,
          "eemult_absurd": 2.16
        }
      },
      "ability": {
        "name": "Happy Ghast",
        "extras": {
          "xmult": 4.32,
          "eemult_absurd": 2.16
        }
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "charred_roach",
      "name": "Charred Roach",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 6,
        "y": 2
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    pools = { [\"Meme\"] = true, },\r\n    key = \"charred_roach\",\r\n    pos = {\r\n        x = 6, y = 2\r\n    },\r\n    rarity = 2,\r\n    cost = 7,\r\n    config = {\r\n        name = \"Charred Roach\",\r\n        extras = {\r\n        }\r\n    },\r\n    demicoloncompat = true,\r\n    loc_vars = function (self, info_queue, card)\r\n        info_queue[#info_queue+1] = G.P_CENTERS[\"e_akyrs_burnt\"]\r\n        \r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.akyrs_card_remove and context.card_getting_removed.config.center_key ~= \"j_akyrs_charred_roach\" and not (context.card_getting_removed.edition and context.card_getting_removed.edition.key == \"e_akyrs_burnt\")\r\n        then\r\n            return {\r\n                func = function ()\r\n                    local crm = context.card_getting_removed\r\n                    if crm.ability.set == \"Joker\" and crm.config.center_key ~= \"j_akyrs_ash_joker\" then\r\n                        local copy = copy_card(crm,nil,nil,nil, true)\r\n                        copy:set_edition('e_akyrs_burnt')\r\n                        copy.sell_cost = 0\r\n                        G.jokers:emplace(copy)\r\n                    end\r\n                    if (crm.ability.set == \"Enhanced\" or crm.ability.set == \"Default\") and not (crm.config.center_key == \"m_akyrs_ash_card\") then\r\n                        G.playing_card = (G.playing_card and G.playing_card + 1) or 1\r\n                        local copy = copy_card(crm,nil,nil,G.playing_card, true)\r\n                        G.deck.config.card_limit = G.deck.config.card_limit + 1\r\n                        table.insert(G.playing_cards, copy)\r\n                        copy:set_edition('e_akyrs_burnt')\r\n                        if #G.hand.cards > 0 then\r\n                            G.hand:emplace(copy)\r\n                        else\r\n                            G.deck:emplace(copy)\r\n                        end\r\n                        copy:add_to_deck()\r\n                        copy.sell_cost = 0\r\n                        copy:start_materialize(nil)\r\n                        playing_card_joker_effects({copy})\r\n                    end\r\n                end\r\n            }\r\n        end\r\n    end",
      "config": {
        "name": "Charred Roach",
        "extras": {}
      },
      "ability": {
        "name": "Charred Roach",
        "extras": {}
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "ash_joker",
      "name": "Ash Joker",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 7,
        "y": 2
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    key = \"ash_joker\",\r\n    pos = {\r\n        x = 7, y = 2\r\n    },\r\n    rarity = 1,\r\n    cost = 0,\r\n    in_pool = function (self, args)\r\n        return false\r\n    end,\r\n    config = {\r\n        name = \"Ash Joker\",\r\n        extras = {\r\n            chips = 35,\r\n            chips_gain = 15,\r\n            echips = 2,\r\n            odds = 4\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        if AKYRS.bal(\"absurd\") then\r\n            return {\r\n                key = self.key .. \"_absurd\",\r\n                vars = {\r\n                    card.ability.extras.echips,\r\n                }\r\n            }\r\n        end\r\n        local n, d = SMODS.get_probability_vars(card, 1, card.ability.extras.odds, 'akyrs_ash_joker_adequate')\r\n        return {\r\n            vars = {\r\n                card.ability.extras.chips,\r\n                n,\r\n                d,\r\n                card.ability.extras.chips_gain\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.joker_main or context.forcetrigger then\r\n            return AKYRS.bal_val({\r\n                chips = card.ability.extras.chips\r\n            }, {\r\n                echips = card.ability.extras.echips\r\n            })\r\n        end\r\n        if context.end_of_round and context.cardarea == G.jokers then\r\n            local odder = AKYRS.bal(\"absurd\") or \r\n                SMODS.pseudorandom_probability(card,\"akyrs_ash_joker_adequate\", 1, card.ability.extras.odds)\r\n            if odder then\r\n                card.ability.akyrs_ash_disintegrate = odder\r\n            else\r\n                SMODS.scale_card(card, { ref_table = card.ability.extras, ref_value = \"chips\", scalar_value = \"chips_gain\" })\r\n            end\r\n        end\r\n    end,\r\n    demicoloncompat = true,",
      "config": {
        "name": "Ash Joker",
        "extras": {
          "chips": 35,
          "chips_gain": 15,
          "echips": 2,
          "odds": 4
        }
      },
      "ability": {
        "name": "Ash Joker",
        "extras": {
          "chips": 35,
          "chips_gain": 15,
          "echips": 2,
          "odds": 4
        }
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "chicken_jockey",
      "name": "Chicken Jockey",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 9,
        "y": 2
      },
      "raw": "atlas = 'AikoyoriJokers',\r\n    pools = { [\"Meme\"] = true, },\r\n    key = \"chicken_jockey\",\r\n    pos = {\r\n        x = 9, y = 2\r\n    },\r\n    rarity = 3,\r\n    cost = 4,\r\n    config = {\r\n        name = \"Chicken Jockey\",\r\n        extras = {\r\n            xmult = 1,\r\n            xmult_inc = 1,\r\n            emult = 1,\r\n            emult_inc = 1,\r\n            decrease_popcorn = 9,\r\n            popcorn_original_absurd = 5,\r\n            decrease_popcorn_absurd = 1,\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        info_queue[#info_queue+1] = localize{key = \"j_popcorn\", vars = {20,4}}\r\n        if AKYRS.bal(\"absurd\") then\r\n            return {\r\n                key = self.key .. \"_absurd\",\r\n                vars = {\r\n                    card.ability.extras.emult_inc,\r\n                    card.ability.extras.emult,\r\n                    card.ability.extras.decrease_popcorn_absurd,\r\n                    card.ability.extras.popcorn_original_absurd,\r\n                }\r\n            }\r\n        end\r\n        return {\r\n            vars = {\r\n                card.ability.extras.xmult_inc,\r\n                card.ability.extras.xmult,\r\n                card.ability.extras.decrease_popcorn,\r\n            }\r\n        }\r\n    end,\r\n    blueprint_compat = true,\r\n\tdemicoloncompat = true,\r\n    calculate = function (self, card, context)\r\n        if AKYRS.bal(\"absurd\") then\r\n            if context.setting_blind then\r\n                if AKYRS.has_room(G.jokers) then\r\n                    SMODS.add_card{key = \"j_popcorn\"}\r\n                end\r\n            end\r\n        else\r\n            if context.buying_card and context.card.config.center.pools and context.card.config.center.pools[\"Food\"] and not context.blueprint then\r\n                --- @type Card\r\n                local _c = context.card\r\n                AKYRS.simple_event_add(function ()\r\n                    _c:flip()\r\n                    delay(1)\r\n                    AKYRS.simple_event_add(function ()\r\n                        unlock_achievement(\"ach_akyrs_average_daily_scrandle\")\r\n                        _c:set_ability(G.P_CENTERS.j_popcorn)\r\n                        _c:flip()\r\n                        return true\r\n                    end,0)\r\n                    return true\r\n                end,0)\r\n            end\r\n        end\r\n        if context.joker_main then\r\n            return AKYRS.bal_val({\r\n                xmult = card.ability.extras.xmult\r\n            },{\r\n                emult = card.ability.extras.emult\r\n            })\r\n        end\r\n\r\n        if context.akyrs_card_remove  and not context.being_sold\r\n        and (context.card_getting_removed.config and context.card_getting_removed.config.center_key and context.card_getting_removed.config.center_key == \"j_popcorn\") then\r\n            if context.card_getting_removed.ability.mult - context.card_getting_removed.ability.extra <= 0 then\r\n                return {\r\n                    func = AKYRS.bal_val(function ()\r\n                        SMODS.scale_card(card, { ref_table = card.ability.extras, ref_value = \"xmult\", scalar_value = \"xmult_inc\" })\r\n                    end,\r\n                    function ()\r\n                        SMODS.scale_card(card, { ref_table = card.ability.extras, ref_value = \"emult\", scalar_value = \"emult_inc\" })\r\n                    end\r\n                    )\r\n                }\r\n            end\r\n        end\r\n    end",
      "config": {
        "name": "Chicken Jockey",
        "extras": {
          "xmult": 1,
          "xmult_inc": 1,
          "emult": 1,
          "emult_inc": 1,
          "decrease_popcorn": 9,
          "popcorn_original_absurd": 5,
          "decrease_popcorn_absurd": 1
        }
      },
      "ability": {
        "name": "Chicken Jockey",
        "extras": {
          "xmult": 1,
          "xmult_inc": 1,
          "emult": 1,
          "emult_inc": 1,
          "decrease_popcorn": 9,
          "popcorn_original_absurd": 5,
          "decrease_popcorn_absurd": 1
        }
      },
      "vars": [
        1,
        1,
        1,
        5
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "tetoris",
      "name": "Tetoris",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 0,
        "y": 3
      },
      "raw": "key = \"tetoris\",\r\n    pools = { [\"Vocaloids\"] = true, [\"J-POP\"] = true },\r\n    atlas = 'AikoyoriJokers',\r\n    pos = {\r\n        x = 0, y = 3\r\n    },\r\n    rarity = 2,\r\n    cost = 7,\r\n    config = {\r\n        name = \"Tetoris\",\r\n        extras = {\r\n            chips = 10,\r\n            xchips = 2.1,\r\n            immutable = {\r\n                counter = 0\r\n            }\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        if AKYRS.bal(\"absurd\") then\r\n            return {\r\n                key = self.key..\"_absurd\",\r\n                vars = {\r\n                    card.ability.extras.immutable.counter,\r\n                }\r\n            }\r\n        end\r\n        return {\r\n            vars = {\r\n                card.ability.extras.chips,\r\n                card.ability.extras.xchips,\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if AKYRS.bal(\"absurd\") then\r\n            \r\n            if context.akyrs_pre_play then\r\n                return {\r\n                    func = function ()\r\n                        card.ability.extras.immutable.counter = card.ability.extras.immutable.counter + #G.hand.highlighted\r\n                    end\r\n                }\r\n            end\r\n            if context.end_of_round and context.cardarea == G.jokers then\r\n                card.ability.extras.immutable.counter = math.max(card.ability.extras.immutable.counter,0)\r\n                SMODS.calculate_effect({func = function() \r\n                    if card.ability.extras.immutable.counter >= 160 then\r\n                        SMODS.add_card{ key = \"c_soul\", set = \"Spectral\", edition = \"e_negative\"} \r\n                        card.ability.extras.immutable.counter = card.ability.extras.immutable.counter - 160\r\n                    end\r\n                end})\r\n                SMODS.calculate_effect({func = function() \r\n                    if card.ability.extras.immutable.counter >= 4 then\r\n                        SMODS.add_card{ set = \"Spectral\", edition = \"e_negative\", soulable = true} \r\n                        card.ability.extras.immutable.counter = card.ability.extras.immutable.counter - 4\r\n                    end\r\n                end})\r\n            end\r\n        else\r\n            if context.joker_main then\r\n                local c = AKYRS.get_letter_freq_from_cards(G.play.cards)\r\n                local r = AKYRS.get_ranks_freq_from_cards(G.play.cards)\r\n                local s = AKYRS.get_suit_freq_from_cards(G.play.cards)\r\n                if (c[\"l\"] or c[\"s\"] or c[\"o\"] or c[\"z\"] or c[\"j\"] or c[\"i\"] or c[\"t\"] or r[11] or r[10] or s[\"Spades\"]) and G.GAME.akyrs_character_stickers_enabled then\r\n                    return {\r\n                        xchips = card.ability.extras.xchips,\r\n                    }\r\n                end\r\n            end\r\n        end\r\n    end,\r\n    hpot_unbreedable = true,",
      "config": {
        "name": "Tetoris",
        "extras": {
          "chips": 10,
          "xchips": 2.1,
          "immutable": {
            "counter": 0
          }
        }
      },
      "ability": {
        "name": "Tetoris",
        "extras": {
          "chips": 10,
          "xchips": 2.1,
          "immutable": {
            "counter": 0
          }
        }
      },
      "vars": [
        0
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "mukuroju_no_hakamori",
      "name": "躯樹の墓守",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 3,
        "y": 3
      },
      "raw": "pools = { [\"Rhythm Games\"] = true, [\"Maimai\"] = true },\r\n    key = \"mukuroju_no_hakamori\",\r\n    atlas = 'AikoyoriJokers',\r\n    pos = {\r\n        x = 3, y = 3\r\n    },\r\n    rarity = 3,\r\n    cost = 7,\r\n    config = {\r\n        name = \"躯樹の墓守\",\r\n        extras = {\r\n            xmult = 1,\r\n            xmult_absurd = 1,\r\n            xmult_add = 0.5,\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        if AKYRS.bal(\"absurd\") then\r\n            info_queue[#info_queue+1] = {key = 'dd_akyrs_mukuroju_en_absurd', vars = { card.ability.extras.xmult_absurd }, set = \"DescriptionDummy\"}\r\n        else\r\n            info_queue[#info_queue+1] = {key = 'dd_akyrs_mukuroju_en', vars = { card.ability.extras.xmult_add, card.ability.extras.xmult }, set = \"DescriptionDummy\"}\r\n        end\r\n\r\n        info_queue[#info_queue+1] = G.P_CENTERS['c_star']\r\n        if MoreFluff then\r\n            info_queue[#info_queue+1] = G.P_CENTERS['c_mf_rot_star']\r\n        end\r\n        return {\r\n            key = self.key .. AKYRS.bal_val(\"\",\"_absurd\"),\r\n            vars = AKYRS.bal_val({\r\n                card.ability.extras.xmult_add,\r\n                card.ability.extras.xmult\r\n            },{\r\n                card.ability.extras.xmult_absurd\r\n            })\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.using_consumeable and not context.blueprint and (\r\n        AKYRS.is_star(context.consumeable.config.center_key)\r\n        ) then\r\n\r\n            return {\r\n                func = function()\r\n                    if AKYRS.bal(\"absurd\") then\r\n                        SMODS.scale_card(card, { ref_table = card.ability.extras, ref_value = \"xmult_absurd\", scalar_table = {[\"s\"] = 8}, scalar_value = \"s\", operation = \"X\" })\r\n                    else\r\n                        SMODS.scale_card(card, { ref_table = card.ability.extras, ref_value = \"xmult\", scalar_value = \"xmult_add\" })\r\n                    end\r\n                end\r\n            }\r\n        end\r\n        if context.joker_main then\r\n            return {\r\n                xmult = AKYRS.bal_val(card.ability.extras.xmult,card.ability.extras.xmult_absurd)\r\n            }\r\n        end\r\n    end,\r\n    blueprint_compat = true,\r\n    perishable_compat = false,",
      "config": {
        "name": "躯樹の墓守",
        "extras": {
          "xmult": 1,
          "xmult_absurd": 1,
          "xmult_add": 0.5
        }
      },
      "ability": {
        "name": "躯樹の墓守",
        "extras": {
          "xmult": 1,
          "xmult_absurd": 1,
          "xmult_add": 0.5
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "emerald",
      "name": "Emerald",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 4,
        "y": 3
      },
      "raw": "pools = { [\"Minecraft\"] = true },\r\n    key = \"emerald\",\r\n    atlas = 'AikoyoriJokers',\r\n    pos = {\r\n        x = 4, y = 3\r\n    },\r\n    rarity = \"akyrs_emerald\",\r\n    cost = 2,\r\n    config = {\r\n        name = \"Emerald\",\r\n        extras = {\r\n            xcost = 2,\r\n            pluscost = 4,\r\n            ecost = 2,\r\n            amnt = 0,\r\n        }\r\n    },\r\n    add_to_deck = function (self, card, from_debuff)\r\n        G.GAME.akyrs_has_capability_to_trade = true\r\n        AKYRS.simple_event_add(function ()\r\n            local emerald_list = AKYRS.filter_table(G.jokers.cards, function (cd, ind)\r\n                return cd.config.center.key == self.key\r\n            end, true, true)\r\n            print(#emerald_list, G.jokers.config.card_limit, #emerald_list == G.jokers.config.card_limit)\r\n            if #emerald_list == G.jokers.config.card_limit then\r\n                check_for_unlock({ type = \"full_emerald_in_slot\" })\r\n            end\r\n            return true\r\n        end, 0, \"akyrs_desc\")\r\n    end,\r\n    loc_vars = function (self, info_queue, card)\r\n        if AKYRS.bal(\"absurd\") then\r\n            return {\r\n                key = self.key .. \"_absurd\",\r\n                vars = {\r\n                    card.ability.extras.pluscost,\r\n                    card.ability.extras.ecost,\r\n                    card.cost,\r\n                }\r\n            }\r\n        end\r\n        return {\r\n            vars = {\r\n                card.ability.extras.xcost,\r\n                card.cost,\r\n                card.ability.extras.amnt,\r\n            }\r\n        }\r\n    end,\r\n    in_pool = function (self, args)\r\n        return true, {\r\n            allow_duplicates = next(SMODS.find_card(\"j_akyrs_emerald\"))\r\n        }       \r\n    end",
      "config": {
        "name": "Emerald",
        "extras": {
          "xcost": 2,
          "pluscost": 4,
          "ecost": 2,
          "amnt": 0
        }
      },
      "ability": {
        "name": "Emerald",
        "extras": {
          "xcost": 2,
          "pluscost": 4,
          "ecost": 2,
          "amnt": 0
        }
      },
      "vars": [
        4,
        2,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "shimmer_bucket",
      "name": "Shimmer Bucket",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 5,
        "y": 3
      },
      "raw": "pools = { [\"Terraria\"] = true, },\r\n    key = \"shimmer_bucket\",\r\n    atlas = 'AikoyoriJokers',\r\n    pos = {\r\n        x = 5, y = 3\r\n    },\r\n    rarity = 3,\r\n    cost = 15,\r\n    config = {\r\n        name = \"Shimmer Bucket\",\r\n        extras = {\r\n            create_factor = 2,\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras.create_factor,\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.ending_shop and not context.blueprint then\r\n            local index = AKYRS.find_index(G.jokers.cards,card)\r\n            if index and #G.jokers.cards > 1 and G.jokers.cards[index-1] and index > 1 then\r\n                local othercard = G.jokers.cards[index-1]\r\n                if not SMODS.is_eternal(othercard,card) then\r\n                    local rarity = othercard.config.center.rarity\r\n                    othercard:start_dissolve({G.C.AKYRS_PLAYABLE},1.1)\r\n                    othercard:remove_from_deck()\r\n                    for i=1, card.ability.extras.create_factor do\r\n                        SMODS.calculate_effect({\r\n                            func = function ()\r\n                                SMODS.add_card{rarity = rarity, set = \"Joker\", legendary = (rarity == 4)}\r\n                            end\r\n                        }, card)\r\n                    end\r\n                    AKYRS.simple_event_add(function ()\r\n                        card:start_dissolve({G.C.AKYRS_PLAYABLE},1.1)\r\n                        return true\r\n                    end)\r\n                end\r\n            end\r\n        end\r\n    end,\r\n    eternal_compat = false",
      "config": {
        "name": "Shimmer Bucket",
        "extras": {
          "create_factor": 2
        }
      },
      "ability": {
        "name": "Shimmer Bucket",
        "extras": {
          "create_factor": 2
        }
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "space_elevator",
      "name": "Space Elevator",
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 6,
        "y": 3
      },
      "raw": "key = \"space_elevator\",\r\n    pools = { [\"Satisfactory\"] = true, },\r\n    atlas = 'AikoyoriJokers',\r\n    pos = {\r\n        x = 6, y = 3\r\n    },\r\n    rarity = 2,\r\n    cost = 7,\r\n    config = {\r\n        name = \"Space Elevator\",\r\n        extras = {\r\n            phase = 1,\r\n            target_play = 10,\r\n            played = 0,\r\n            target_rank = nil,\r\n            ranks_chosen = {}\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        card.ability.extras.phase = math.floor(card.ability.extras.phase)\r\n        card.ability.extras.target_play = math.floor(card.ability.extras.target_play)\r\n        \r\n        if card.ability.extras.phase > 5 or card.ability.extras.phase < 1 then \r\n            card.ability.extras.phase = 1\r\n        end\r\n        return {\r\n            vars = {\r\n                card.ability.extras.target_play,\r\n                localize(card.ability.extras.target_rank,\"ranks\"),\r\n                card.ability.extras.phase,\r\n                card.ability.extras.played,\r\n            }\r\n        }\r\n    end,\r\n    set_ability = function (self, card, initial, delay_sprites)\r\n        if initial then\r\n            local r = pseudorandom_element(AKYRS.get_p_card_ranks(card.ability.extras.ranks_chosen),pseudoseed(\"akyrs_space_elevator\")) \r\n                or pseudorandom_element(SMODS.Ranks,pseudoseed(\"akyrs_space_elevator\")) \r\n            if r then\r\n                card.ability.extras.target_rank = r.key\r\n                card.ability.extras.ranks_chosen[r.key] = true\r\n            end\r\n            card.ability.extras.played = 0\r\n        end\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.individual and not context.forcetrigger and not context.repetition and not context.repetition_only and not context.blueprint and not context.retrigger_joker and context.cardarea == G.play then\r\n            if not SMODS.has_no_rank(context.other_card) and context.other_card.base.value then\r\n                if context.other_card.base.value == card.ability.extras.target_rank then\r\n                    card.ability.extras.played = card.ability.extras.played + 1\r\n                    --print(card.ability.extras.played)\r\n                    if card.ability.extras.played >= card.ability.extras.target_play then\r\n                        card.ability.extras.phase = card.ability.extras.phase + 1\r\n                        local r = pseudorandom_element(AKYRS.get_p_card_ranks(card.ability.extras.ranks_chosen),pseudoseed(\"akyrs_space_elevator\"))\r\n                        if not r then\r\n                            EMPTY(card.ability.extras.ranks_chosen)\r\n                            r = pseudorandom_element(AKYRS.get_p_card_ranks(card.ability.extras.ranks_chosen),pseudoseed(\"akyrs_space_elevator\"))\r\n                        end\r\n                        if r then\r\n                            card.ability.extras.target_rank = r.key\r\n                            card.ability.extras.ranks_chosen[r.key] = true\r\n                        end\r\n                        if card.ability.extras.phase > 5 then\r\n                            SMODS.add_card{ key = \"c_soul\", set = \"Spectral\", edition = \"e_negative\"}\r\n                            card.ability.extras.phase = 1\r\n                        else\r\n                            SMODS.add_card{ set = \"Spectral\", edition = \"e_negative\" }\r\n                        end\r\n                        card.ability.extras.target_play = pseudorandom(pseudoseed(\"akyrs_space_elevator_num\"),5*card.ability.extras.phase+7,7*card.ability.extras.phase)\r\n                        card.ability.extras.played = 0\r\n                        return {\r\n                            message = localize(\"k_akyrs_sendoff\")\r\n                        }\r\n                    else\r\n                        return {\r\n                            message = localize(\"k_akyrs_received\")\r\n                        }\r\n                    end\r\n                end\r\n            end\r\n        end\r\n    end,\r\n    perishable_compat = false",
      "config": {},
      "ability": {},
      "vars": [
        null,
        null,
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "turret",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 7,
        "y": 3
      },
      "raw": "key = \"turret\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Portal\"] = true, },\r\n    pos = {\r\n        x = 7, y = 3\r\n    },\r\n    rarity = 2,\r\n    cost = 4, \r\n    config = {\r\n        extras = {\r\n            mulx = 2\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        if G.jokers then\r\n            local index = AKYRS.find_index(G.jokers.cards,card)\r\n            if index and #G.jokers.cards > 1 and G.jokers.cards[index+1] and index < #G.jokers.cards then\r\n                local othercard = G.jokers.cards[index+1]\r\n                return {\r\n                    vars = \r\n                    {\r\n                        math.max(othercard.sell_cost * card.ability.extras.mulx,0),\r\n                        card.ability.extras.mulx\r\n                    }\r\n                }\r\n            end\r\n        end\r\n        return {\r\n            vars = {\r\n                \"??\",\r\n                card.ability.extras.mulx\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.selling_card and context.card == card and not context.blueprint then\r\n            \r\n            local index = AKYRS.find_index(G.jokers.cards,card)\r\n            if index and #G.jokers.cards > 1 and G.jokers.cards[index+1] and index < #G.jokers.cards then\r\n                local othercard = G.jokers.cards[index+1]\r\n                return {\r\n                    func = function ()\r\n                        othercard:start_dissolve({G.C.RED},1.6)\r\n                    end,\r\n                    dollars = math.max(othercard.sell_cost * card.ability.extras.mulx,0)\r\n                }\r\n            end\r\n        end\r\n    end,\r\n    eternal_compat = false,",
      "config": {
        "extras": {
          "mulx": 2
        }
      },
      "ability": {
        "extras": {
          "mulx": 2
        }
      },
      "vars": [
        null,
        null,
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "aether_portal",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 8,
        "y": 3
      },
      "raw": "key = \"aether_portal\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Minecraft\"] = true, },\r\n    pos = {\r\n        x = 8, y = 3\r\n    },\r\n    rarity = 2,\r\n    cost = 7, \r\n    config = {\r\n        extras = {\r\n            odds = 4\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        local n,d = SMODS.get_probability_vars(card, 1, card.ability.extras.odds,\"akyrs_aether_chance\")\r\n        return {\r\n            vars = {\r\n                n,\r\n                d\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.setting_blind and not context.blueprint then\r\n            \r\n            local index = AKYRS.find_index(G.jokers.cards,card)\r\n            if index and #G.jokers.cards > 1 and G.jokers.cards[index-1] and index > 1 then\r\n                local other = G.jokers.cards[index-1]\r\n                local edition = pseudorandom_element(G.P_CENTER_POOLS.Edition,pseudoseed(\"akyrs_aether_chance\"))\r\n                repeat\r\n                local edition = pseudorandom_element(G.P_CENTER_POOLS.Edition,pseudoseed(\"akyrs_aether_chance\"))\r\n                until edition and edition.weight and edition.weight > 0 \r\n                if edition then\r\n                    other:set_edition(edition.key)\r\n                end\r\n                if SMODS.pseudorandom_probability(card,\"akyrs_aether_portal\",1,card.ability.extras.odds) then\r\n                    card:start_dissolve({G.C.BLUE},1.6)\r\n                end\r\n            end\r\n        end\r\n    end",
      "config": {
        "extras": {
          "odds": 4
        }
      },
      "ability": {
        "extras": {
          "odds": 4
        }
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "corkscrew",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 9,
        "y": 3
      },
      "raw": "key = \"corkscrew\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Hamsterball\"] = true, },\r\n    pos = {\r\n        x = 9, y = 3\r\n    },\r\n    rarity = 1,\r\n    cost = 3,\r\n    config = {\r\n        extras = { xmult = 2, emult = 1, immutable = {index = 1} }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        if AKYRS.bal(\"absurd\") then\r\n            local current = nil\r\n            if card.area then\r\n                current = AKYRS.find_index(card.area.cards,card)\r\n                card.ability.extras.emult = AKYRS.pos_to_val(card.ability.extras.immutable.index,#card.area.cards)\r\n            end\r\n            return {\r\n                key = self.key .. \"_absurd\",\r\n                vars = {\r\n                    (G.GAME and current) and card.ability.extras.emult or localize(\"ph_akyrs_unknown\")\r\n                }\r\n            }\r\n        end\r\n        return {\r\n            vars = {\r\n                card.ability.extras.xmult\r\n            }\r\n        }\r\n    end,\r\n    add_to_deck = function (self, card, from_debuff)\r\n        if card.area and card.area.cards then\r\n            local current = AKYRS.find_index(card.area.cards,card)\r\n            card.ability.extras.immutable.index = current\r\n            card.ability.extras.emult = AKYRS.pos_to_val(card.ability.extras.immutable.index,#card.area.cards)\r\n        end\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.before then\r\n            if card.area and card.area.cards then\r\n                return {\r\n                    func = function ()\r\n                        local where = pseudorandom(\"akyrs_corkscrew_move_target\",1,#card.area.cards)\r\n                        local current = AKYRS.find_index(card.area.cards,card)\r\n                        card.area.cards[where],card.area.cards[current or 1] = card.area.cards[current],card.area.cards[where]\r\n                        card.ability.extras.immutable.index = current\r\n                        card.area:align_cards()\r\n                        card.ability.extras.emult = AKYRS.pos_to_val(card.ability.extras.immutable.index,#card.area.cards)\r\n                    end\r\n                }\r\n            end\r\n        end\r\n        if context.joker_main then\r\n            if AKYRS.bal(\"adequate\") then\r\n                return {\r\n                    xmult = card.ability.extras.xmult\r\n                }\r\n            else\r\n                return {\r\n                    emult = card.ability.extras.emult\r\n                }\r\n            end\r\n\r\n        end\r\n    end,\r\n    blueprint_compat = true",
      "config": {
        "extras": {
          "xmult": 2,
          "emult": 1,
          "immutable": {
            "index": 1
          }
        }
      },
      "ability": {
        "extras": {
          "xmult": 2,
          "emult": 1,
          "immutable": {
            "index": 1
          }
        }
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "goodbye_sengen",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 0,
        "y": 4
      },
      "raw": "key = \"goodbye_sengen\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Vocaloids\"] = true, [\"J-POP\"] = true },\r\n    pos = {\r\n        x = 0, y = 4\r\n    },\r\n    rarity = 2,\r\n    cost = 7,\r\n    config = {\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        info_queue[#info_queue+1] = G.P_CENTERS[\"c_justice\"]\r\n        return {\r\n            key = self.key..AKYRS.bal_val(\"\",\"_absurd\")\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if AKYRS.bal(\"absurd\") then\r\n            if context.using_consumeable and context.consumeable.config.center_key == \"c_justice\" then\r\n                return {\r\n                    func = function ()\r\n                        SMODS.smart_level_up_hand(nil,\"High Card\",nil,G.GAME.hands[\"High Card\"].level)\r\n                    end\r\n                }\r\n            end\r\n        else\r\n            if context.destroy_card and not context.blueprint then\r\n                if context.destroy_card == context.full_hand[1] and #context.full_hand == 1 and G.GAME.current_round.hands_played == 0 then\r\n                    if AKYRS.has_room(G.consumeables) then\r\n                        return {\r\n                            func = function()\r\n                                AKYRS.simple_event_add(\r\n                                    function ()\r\n                                        SMODS.add_card{ key = \"c_justice\", set = \"Tarot\" } \r\n                                        return true\r\n                                    end, 0\r\n                                )\r\n                            end,\r\n                            message = localize('k_plus_tarot'),\r\n                            colour = G.C.PURPLE,\r\n                            remove = true\r\n                        }\r\n                    end\r\n                    return {\r\n                        remove = true\r\n                    }\r\n                end\r\n            end\r\n        end\r\n\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "liar_dancer",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 1,
        "y": 4
      },
      "raw": "key = \"liar_dancer\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Vocaloids\"] = true, [\"J-POP\"] = true },\r\n    pos = {\r\n        x = 1, y = 4\r\n    },\r\n    rarity = 3,\r\n    cost = 7,\r\n    config = {\r\n        extras = {\r\n            level_down = 1,\r\n            level_up_mult = 1,\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            key = self.key..AKYRS.bal_val(\"\",\"_absurd\"),\r\n            vars = {\r\n                card.ability.extras.level_down,\r\n                card.ability.extras.level_down * card.ability.extras.level_up_mult\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        \r\n        if AKYRS.bal(\"absurd\") then\r\n            if context.before and not context.blueprint then\r\n                return {\r\n                    func = function()\r\n                        local h = {}\r\n                        for mei, _ in pairs(G.GAME.hands) do\r\n                            if not next(context.poker_hands[mei]) then\r\n                                h[mei] = true\r\n                            end\r\n                        end\r\n                        AKYRS.blk_lvl_up(h)\r\n                    end\r\n                }\r\n            end\r\n        else\r\n            if context.before and not context.blueprint then\r\n                local cx = false\r\n                if Talisman then\r\n                    cx = G.GAME.hands[context.scoring_name].level:gt(to_big(1))\r\n                else\r\n                    cx = G.GAME.hands[context.scoring_name].level > 1\r\n                end\r\n                if not context.poker_hands[\"Straight\"] or (context.poker_hands[\"Straight\"] and not next(context.poker_hands[\"Straight\"])) and cx then\r\n                    SMODS.smart_level_up_hand(card,context.scoring_name,nil,-card.ability.extras.level_down)\r\n                    SMODS.smart_level_up_hand(card,\"Straight\",nil,card.ability.extras.level_down * card.ability.extras.level_up_mult)\r\n                    SMODS.smart_level_up_hand(card,\"Straight Flush\",nil,card.ability.extras.level_down * card.ability.extras.level_up_mult)\r\n                end\r\n            end\r\n        end\r\n    end",
      "config": {
        "extras": {
          "level_down": 1,
          "level_up_mult": 1
        }
      },
      "ability": {
        "extras": {
          "level_down": 1,
          "level_up_mult": 1
        }
      },
      "vars": [
        1,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "pissandshittium",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 4,
        "y": 4
      },
      "raw": "key = \"pissandshittium\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Meme\"] = true },\r\n    pos = {\r\n        x = 4, y = 4\r\n    },\r\n    rarity = 1,\r\n    cost = 2,\r\n    config = {\r\n        extras = {\r\n            mult = 6.000,\r\n            eeemult = 0.1\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            key = self.key .. AKYRS.bal_val(\"\",\"_absurd\"),\r\n            vars = {\r\n                AKYRS.bal_val(card.ability.extras.mult,1 + card.ability.extras.eeemult)\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.joker_main then\r\n            return {\r\n                message = localize(\"k_akyrs_pissandshittium\"),\r\n                colour = AKYRS.C.PISSANDSHITTIUM,\r\n                remove_default_message = true,\r\n                mult = AKYRS.bal_val(card.ability.extras.mult,nil),\r\n                emult = AKYRS.bal_val(nil,1 + card.ability.extras.eeemult),\r\n            }\r\n        end\r\n    end,\r\n    blueprint_compat = true",
      "config": {
        "extras": {
          "mult": 6,
          "eeemult": 0.1
        }
      },
      "ability": {
        "extras": {
          "mult": 6,
          "eeemult": 0.1
        }
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "pandora_paradoxxx",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 5,
        "y": 4
      },
      "raw": "key = \"pandora_paradoxxx\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Rhythm Games\"] = true, [\"Maimai\"] = true },\r\n    pos = {\r\n        x = 5, y = 4\r\n    },\r\n    rarity = 3,\r\n    cost = 9,\r\n    config = {\r\n        extras = {\r\n            count = 15,\r\n            current = 0,\r\n            odds_absurd = 3\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        info_queue[#info_queue+1] = {set = \"Tag\", key = \"tag_standard\"}\r\n        -- numerator & denominator :3\r\n        if AKYRS.bal(\"absurd\") then\r\n            local n, d = SMODS.get_probability_vars(card,1,card.ability.extras.odds_absurd,\"akyrs_pandora_paradoxx\")\r\n            return {\r\n                key = self.key..\"_absurd\",\r\n                vars = {\r\n                    n,d\r\n                }\r\n            } \r\n        end\r\n        return {\r\n            vars = {\r\n                card.ability.extras.count,\r\n                card.ability.extras.current\r\n            }\r\n        }\r\n\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.playing_card_added and AKYRS.bal(\"absurd\") then\r\n            return {\r\n                func = function ()\r\n                    for i = 1, #context.cards do\r\n                        if SMODS.pseudorandom_probability(card,\"akyrs_pandora_paradoxxx\",1,card.ability.extras.odds_absurd) then\r\n                            local tag = Tag(\"tag_standard\")\r\n                            add_tag(tag)\r\n                            SMODS.calculate_effect({\r\n                                message = localize(\"k_akyrs_pandora_give_tag\"),\r\n                            }, card)\r\n                        end\r\n                    end\r\n                end\r\n            }\r\n        end\r\n        if context.before and AKYRS.bal(\"adequate\") then\r\n            return {\r\n                func = function ()\r\n                    for _,_c in ipairs(context.scoring_hand) do\r\n                        card.ability.extras.current = card.ability.extras.current + 1\r\n                        SMODS.calculate_effect({\r\n                            juice_card = _c,\r\n                            message = card.ability.extras.current\r\n                        }, card)\r\n                        if card.ability.extras.current >= card.ability.extras.count then \r\n                            SMODS.calculate_effect({\r\n                                message = localize(\"k_akyrs_pandora_give_tag\"),\r\n                                func = function()\r\n                                local tag = Tag(\"tag_standard\")\r\n                                add_tag(tag)\r\n                                    card.ability.extras.current = 0\r\n                                end\r\n                            }, card)\r\n                        end\r\n                    end\r\n                end\r\n            }\r\n        end\r\n    end,\r\n    blueprint_compat = true",
      "config": {
        "extras": {
          "count": 15,
          "current": 0,
          "odds_absurd": 3
        }
      },
      "ability": {
        "extras": {
          "count": 15,
          "current": 0,
          "odds_absurd": 3
        }
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "story_of_undertale",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 6,
        "y": 4
      },
      "raw": "key = \"story_of_undertale\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Meme\"] = true,  [\"Undertale\"] = true, },\r\n    pos = {\r\n        x = 6, y = 4\r\n    },\r\n    rarity = 2,\r\n    cost = 6,\r\n    config = {\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        info_queue[#info_queue+1] = G.P_CENTERS['j_mr_bones']\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.blind_defeated then\r\n            SMODS.calculate_effect({\r\n                card = card,\r\n                message = localize(\"k_akyrs_woah_undertale\"),\r\n            })\r\n            return {\r\n                message = localize(\"k_akyrs_story_of_undertale\"),\r\n                func = function ()\r\n                    local destructable_jokers = {}\r\n                    for i = 1, #G.jokers.cards do\r\n                        if G.jokers.cards[i] ~= card \r\n                        and not SMODS.is_eternal(G.jokers.cards[i]) \r\n                        and not G.jokers.cards[i].getting_sliced \r\n                        and G.jokers.cards[i].config.center_key ~= \"j_mr_bones\" \r\n                        then destructable_jokers[#destructable_jokers+1] = G.jokers.cards[i] end\r\n                    end\r\n                    local joker_to_destroy = destructable_jokers[#destructable_jokers]\r\n    \r\n                    if joker_to_destroy and not (context.blueprint_card or card).getting_sliced then \r\n                        joker_to_destroy.getting_sliced = true\r\n                        G.E_MANAGER:add_event(Event({func = function()\r\n                            (context.blueprint_card or card):juice_up(0.8, 0.8)\r\n                            \r\n                            SMODS.add_card{ key = \"j_mr_bones\", set = \"Joker\", edition = \"e_negative\"}\r\n                            joker_to_destroy:start_dissolve({G.C.RED}, nil, 1.6)\r\n                        return true end }))\r\n                    end\r\n                end\r\n            }\r\n        end\r\n    end,\r\n    blueprint_compat = false",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "no_hints_here",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 7,
        "y": 4
      },
      "raw": "key = \"no_hints_here\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Rhythm Games\"] = true, [\"ADOFAI\"] = true },\r\n    pos = {\r\n        x = 7, y = 4\r\n    },\r\n    rarity = 2,\r\n    cost = 6,\r\n    config = {\r\n        extras = {\r\n            xmult = 3,\r\n            emult = 2.5\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        if AKYRS.bal(\"absurd\") then\r\n            return {\r\n                key = self.key .. \"_absurd\",\r\n                vars = {\r\n                    card.ability.extras.emult,\r\n                }\r\n            }\r\n        end\r\n        return {\r\n            vars = {\r\n                card.ability.extras.xmult,\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.joker_main then\r\n            if AKYRS.bal(\"absurd\") then\r\n                return {\r\n                    emult = card.ability.extras.emult\r\n                }\r\n            else\r\n                return {\r\n                    xmult = card.ability.extras.xmult\r\n                }\r\n            end\r\n        end\r\n    end,\r\n    blueprint_compat = true",
      "config": {
        "extras": {
          "xmult": 3,
          "emult": 2.5
        }
      },
      "ability": {
        "extras": {
          "xmult": 3,
          "emult": 2.5
        }
      },
      "vars": [
        2.5
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "brushing_clothes_pattern",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 8,
        "y": 4
      },
      "raw": "key = \"brushing_clothes_pattern\",\r\n    enhancement_gate = \"m_wild\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Rhythm Games\"] = true, [\"Chunithm\"] = true },\r\n    pos = {\r\n        x = 8, y = 4\r\n    },\r\n    rarity = 2,\r\n    cost = 6,\r\n    config = {\r\n        extras = {\r\n            xchips = 2,\r\n            xchips_absurd = 1,\r\n            xchips_gain_absurd = 2,\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        if AKYRS.bal(\"absurd\") then\r\n            return {\r\n                key = self.key .. \"_absurd\",\r\n                vars = {\r\n                card.ability.extras.xchips_gain_absurd,\r\n                card.ability.extras.xchips_absurd,\r\n                }\r\n            }\r\n        end\r\n        return {\r\n            vars = {\r\n                card.ability.extras.xchips,\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.individual and context.cardarea == G.play and next(context.poker_hands[\"Flush\"]) and not context.blueprint then\r\n            if context.other_card.ability.name == \"Wild Card\" then\r\n                return {\r\n                    message_card = card,\r\n                    func = function ()\r\n                        if AKYRS.bal(\"absurd\") then\r\n                            SMODS.scale_card(card, { ref_table = card.ability.extras, ref_value = \"xchips\", scalar_value = \"xchips_gain\"})\r\n                        end\r\n                    end\r\n                }\r\n            end\r\n        end\r\n        if AKYRS.bal(\"adequate\") and context.press_play then\r\n            local cardsers = G.hand.highlighted\r\n            local text,disp_text,poker_hands,scoring_hand,non_loc_disp_text = G.FUNCS.get_poker_hand_info(cardsers)\r\n            if next(poker_hands[\"Flush\"]) then\r\n                return {\r\n                    func = function()\r\n                        local filtered = AKYRS.filter_table(cardsers, function (cr)\r\n                            return cr.config and cr.config.center_key == \"m_wild\"\r\n                        end, true, true)\r\n                        AKYRS.do_things_to_card(filtered, function (card, index)\r\n                            SMODS.modify_rank(card, 1)\r\n                        end, {stay_flipped_delay = 1,stagger = 0.5,finish_flipped_delay = 0.5, fifo = true, dont_unhighlight = true})\r\n                    end\r\n                }\r\n            end\r\n        end\r\n        if context.joker_main then\r\n            return {\r\n                xchips = AKYRS.bal_val(nil,card.ability.extras.xchips)\r\n            }\r\n        end\r\n    end,\r\n    blueprint_compat = true",
      "config": {
        "extras": {
          "xchips": 2,
          "xchips_absurd": 1,
          "xchips_gain_absurd": 2
        }
      },
      "ability": {
        "extras": {
          "xchips": 2,
          "xchips_absurd": 1,
          "xchips_gain_absurd": 2
        }
      },
      "vars": [
        2,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "you_tried",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 9,
        "y": 4
      },
      "raw": "key = \"you_tried\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Meme\"] = true, },\r\n    pos = {\r\n        x = 9, y = 4\r\n    },\r\n    rarity = 3,\r\n    cost = 12,\r\n    config = {\r\n        extras = {\r\n            ante_set = 3,\r\n            money_set = 4,\r\n            lives_mp = 1,\r\n            lives_mp_set = 4,\r\n            lives_mp_set_money = 31,\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            key = self.key .. AKYRS.bal_val(\"\",\"_absurd\") .. AKYRS.mp_check(\"\",\"_mp\"),\r\n            vars = {\r\n                AKYRS.mp_check(card.ability.extras.ante_set, AKYRS.bal_val(card.ability.extras.lives_mp,card.ability.extras.lives_mp_set)),\r\n                AKYRS.mp_check(card.ability.extras.money_set,card.ability.extras.lives_mp_set_money),\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.final_scoring_step and AKYRS.is_mp() then\r\n            card.ability.extras.last_life = MP.GAME.lives\r\n            card.ability.extras.unset = true\r\n        end\r\n        if context.end_of_round and context.game_over and not context.blueprint and not AKYRS.is_mp() then\r\n            card:start_dissolve({G.C.YELLOW},1.6)\r\n            return {\r\n                saved = localize(\"k_akyrs_you_tried\"),\r\n                func = function ()\r\n                    if AKYRS.bal(\"adequate\") and not AKYRS.is_mp() then\r\n                        for i,k in ipairs(G.jokers.cards) do\r\n                            if not SMODS.is_eternal(k) then\r\n                                k:start_dissolve({G.C.YELLOW},1.6)\r\n                            end\r\n                        end\r\n                    end\r\n                    local old_ante = G.GAME.round_resets.ante\r\n                    if AKYRS.bal(\"adequate\") then\r\n                        ease_ante((-math.floor(G.GAME.round_resets.ante/2)))\r\n                    else\r\n                        ease_ante(-G.GAME.round_resets.ante + card.ability.extras.ante_set)\r\n                    end\r\n                end\r\n            }\r\n        end\r\n    end,",
      "config": {
        "extras": {
          "ante_set": 3,
          "money_set": 4,
          "lives_mp": 1,
          "lives_mp_set": 4,
          "lives_mp_set_money": 31
        }
      },
      "ability": {
        "extras": {
          "ante_set": 3,
          "money_set": 4,
          "lives_mp": 1,
          "lives_mp_set": 4,
          "lives_mp_set_money": 31
        }
      },
      "vars": [
        null,
        null,
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "don_chan",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 0,
        "y": 5
      },
      "raw": "key = \"don_chan\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Rhythm Games\"] = true, [\"Taiko no Tatsujin\"] = true, },\r\n    pos = {\r\n        x = 0, y = 5\r\n    },\r\n    rarity = 1,\r\n    cost = 5,\r\n    config = {\r\n        extras = {\r\n            percent = .1,\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            key = self.key .. AKYRS.bal_val(\"\",\"_absurd\"),\r\n            vars = {\r\n                card.ability.extras.percent * 100,\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if AKYRS.bal_val(context.joker_main,context.individual and context.cardarea == G.play) or context.forcetrigger then\r\n            return {\r\n                mult = hand_chips * card.ability.extras.percent,\r\n                func = function ()\r\n                    AKYRS.simple_event_add(function ()\r\n                        play_sound('akyrs_don',percent or 1, 0.6)\r\n                        return true\r\n                    end)\r\n                end,\r\n            }\r\n        end\r\n    end,\r\n    blueprint_compat = true,\r\n\tdemicoloncompat = true,",
      "config": {
        "extras": {
          "percent": 0.1
        }
      },
      "ability": {
        "extras": {
          "percent": 0.1
        }
      },
      "vars": [
        10
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "katsu_chan",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 1,
        "y": 5
      },
      "raw": "key = \"katsu_chan\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Rhythm Games\"] = true, [\"Taiko no Tatsujin\"] = true, },\r\n    pos = {\r\n        x = 1, y = 5\r\n    },\r\n    rarity = 1,\r\n    cost = 5,\r\n    config = {\r\n        extras = {\r\n            percent = .1,\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            key = self.key .. AKYRS.bal_val(\"\",\"_absurd\"),\r\n            vars = {\r\n                card.ability.extras.percent * 100,\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if AKYRS.bal_val(context.joker_main,context.individual and context.cardarea == G.play) or context.forcetrigger then\r\n            return {\r\n                chips = mult * card.ability.extras.percent,\r\n                func = function ()\r\n                    AKYRS.simple_event_add(function ()\r\n                        play_sound('akyrs_katsu',percent or 1, 0.6)\r\n                        return true\r\n                    end)\r\n                end,\r\n            }\r\n        end\r\n    end,\r\n    blueprint_compat = true,\r\n\tdemicoloncompat = true,",
      "config": {
        "extras": {
          "percent": 0.1
        }
      },
      "ability": {
        "extras": {
          "percent": 0.1
        }
      },
      "vars": [
        10
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "lagtrain",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 2,
        "y": 5
      },
      "raw": "key = \"lagtrain\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Vocaloids\"] = true, [\"J-POP\"] = true },\r\n    pos = {\r\n        x = 2, y = 5\r\n    },\r\n    rarity = 2,\r\n    cost = 8,\r\n    config = {\r\n        extras = {\r\n            chips = 0,\r\n            xchips = 1,\r\n            chips_g = 12,\r\n            xchips_g = 0.1,\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        local _,_2,c = love.window.getMode()\r\n        local x = math.max(c.refreshrate - love.timer.getFPS( ),0) \r\n        if AKYRS.bal(\"absurd\") then\r\n            return {\r\n                key = self.key .. \"_absurd\",\r\n                vars = {\r\n                    card.ability.extras.xchips_g * 240 / c.refreshrate,\r\n                    c.refreshrate,\r\n                    card.ability.extras.xchips,\r\n                }\r\n            }\r\n        end\r\n        return {\r\n            vars = {\r\n                card.ability.extras.chips_g,\r\n                card.ability.extras.chips,\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.before and context.poker_hands[\"Straight\"] and next(context.poker_hands[\"Straight\"]) or context.forcetrigger then\r\n            return {\r\n                func = function ()\r\n                    local _,_2,c = love.window.getMode()\r\n                    local x = math.max((c.refreshrate or 0) - love.timer.getFPS( ),0)\r\n                    SMODS.calculate_effect({\r\n                        message = love.timer.getFPS( )..localize(\"k_akyrs_fps\"),\r\n                        message_card = card,\r\n                    }, card)\r\n                    if AKYRS.bal(\"absurd\") then\r\n                        SMODS.scale_card(card, { ref_table = card.ability.extras, ref_value = \"xchips\", scalar_value = \"xchips_g\",\r\n                            operation = function (rt,rv,int,sc)\r\n                                rt[rv] = int + sc * x * 240 / c.refreshrate\r\n                            end\r\n                        })\r\n                    end\r\n\r\n\r\n                end\r\n            }\r\n        end\r\n        if AKYRS.bal(\"adequate\") then\r\n            if context.individual and context.cardarea == \"unscored\" then\r\n                SMODS.scale_card(context.other_card, { ref_table = context.other_card.ability, ref_value = \"perma_bonus\", scalar_table = card.ability.extras,scalar_value = \"chips_g\", })\r\n            end\r\n        end\r\n        if context.joker_main or context.forcetrigger then\r\n            if AKYRS.bal(\"absurd\") then\r\n                return {\r\n                    xchips = card.ability.extras.xchips\r\n                }\r\n            end\r\n            return {\r\n                chips = card.ability.extras.chips\r\n            }\r\n        end\r\n    end,\r\n    blueprint_compat = true,\r\n\tdemicoloncompat = true,",
      "config": {
        "extras": {
          "chips": 0,
          "xchips": 1,
          "chips_g": 12,
          "xchips_g": 0.1
        }
      },
      "ability": {
        "extras": {
          "chips": 0,
          "xchips": 1,
          "chips_g": 12,
          "xchips_g": 0.1
        }
      },
      "vars": [
        null,
        null,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "bocchi",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 3,
        "y": 5
      },
      "raw": "key = \"bocchi\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Anime\"] = true, [\"Bocchi the Rock\"] = true, [\"Kessoku Band\"] = true, },\r\n    pos = {\r\n        x = 3, y = 5\r\n    },\r\n    rarity = 3,\r\n    cost = 9,\r\n    config = {\r\n        extras = {\r\n            xmult = 1,\r\n            xmult_absurd = 1.1,\r\n            xmult_g = 0.25,\r\n            xmult_g_absurd = 1.3,\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        if AKYRS.bal(\"absurd\") then\r\n            return {\r\n                key = self.key .. \"_absurd\",\r\n                vars = {\r\n                    card.ability.extras.xmult_g_absurd,\r\n                    card.ability.extras.xmult_absurd,\r\n                }\r\n            }\r\n        end\r\n        return {\r\n            vars = {\r\n                card.ability.extras.xmult_g,\r\n                card.ability.extras.xmult,\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.before or context.forcetrigger then\r\n            return {\r\n                func = function ()\r\n                    local x = AKYRS.filter_table(G.jokers.cards,function(t) return AKYRS.is_in_pool(t,\"Kessoku Band\") end, true, true)\r\n                    local sts, stschk = AKYRS.get_suits(G.play.cards)\r\n                    if (AKYRS.bal_val((#G.play.cards) == 1 and G.play.cards[1]:is_suit(\"Spades\"),stschk[\"Spades\"])) or context.forcetrigger then\r\n                        if AKYRS.bal(\"absurd\") then\r\n                            SMODS.scale_card(card, { ref_table = card.ability.extras, ref_value = \"xmult_absurd\", scalar_value = \"xmult_g_absurd\",\r\n                                operation = function (rt,rv,int,sc)\r\n                                    if Talisman then\r\n                                        rt[rv] = to_big(int):pow(sc * #x)\r\n                                    end\r\n                                end\r\n                            })\r\n                        else\r\n                            SMODS.scale_card(card, {ref_table = card.ability.extras, ref_value = \"xmult\", scalar_value = \"xmult_g\", operation = function (rt,rv,int,sc)\r\n                                    rt[rv] = int + sc * #x\r\n                                end})\r\n                        end\r\n                    end\r\n                end\r\n            }\r\n        end\r\n        if context.joker_main or context.forcetrigger then\r\n            if AKYRS.bal(\"absurd\") then\r\n                return {\r\n                    xmult = card.ability.extras.xmult_absurd\r\n                }\r\n            end\r\n            return {\r\n                xmult = card.ability.extras.xmult\r\n            }\r\n        end\r\n    end,\r\n    blueprint_compat = true,\r\n\tdemicoloncompat = true,",
      "config": {
        "extras": {
          "xmult": 1,
          "xmult_absurd": 1.1,
          "xmult_g": 0.25,
          "xmult_g_absurd": 1.3
        }
      },
      "ability": {
        "extras": {
          "xmult": 1,
          "xmult_absurd": 1.1,
          "xmult_g": 0.25,
          "xmult_g_absurd": 1.3
        }
      },
      "vars": [
        1.3,
        1.1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "kita",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 4,
        "y": 5
      },
      "raw": "key = \"kita\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Anime\"] = true, [\"Bocchi the Rock\"] = true, [\"Kessoku Band\"] = true, },\r\n    pos = {\r\n        x = 4, y = 5\r\n    },\r\n    rarity = 2,\r\n    cost = 6,\r\n    config = {\r\n        extras = {\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        info_queue[#info_queue+1] = {set = \"Tarot\", key = \"c_lovers\", vars = {1, localize(\"k_akyrs_wild_card\")}}\r\n        if AKYRS.bal(\"absurd\") then\r\n            return {\r\n                key = self.key .. \"_absurd\",\r\n            }\r\n        end\r\n        return {\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if (context.before or context.forcetrigger) and AKYRS.bal(\"adequate\") then\r\n            return {\r\n                message = localize(\"k_akyrs_kitan\"),\r\n                colour = G.C.RED,\r\n                func = function ()\r\n                    local sts, stschk = AKYRS.get_suits(G.play.cards)\r\n                    if (next(context.poker_hands[\"Flush\"]) and stschk[\"Hearts\"]) or context.forcetrigger then\r\n                        if AKYRS.has_room(G.consumeables) then\r\n                            SMODS.add_card({key = \"c_lovers\", set = \"Tarot\"})\r\n                        end\r\n                    end\r\n                end\r\n            }\r\n        end\r\n        if (context.individual and context.cardarea == G.play or context.forcetrigger) and AKYRS.bal(\"absurd\") then\r\n            return {\r\n                message = localize(\"k_akyrs_kitan\"),\r\n                colour = G.C.RED,\r\n                func = function ()\r\n                    if context.other_card:is_suit(\"Hearts\") then\r\n                        SMODS.add_card({key = \"c_lovers\", set = \"Tarot\", edition = \"e_negative\"})\r\n                    end\r\n                end\r\n            }\r\n        end\r\n    end,\r\n    blueprint_compat = true,\r\n\tdemicoloncompat = true,\r\n    hpot_unbreedable = true,",
      "config": {
        "extras": {}
      },
      "ability": {
        "extras": {}
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "ryou",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 5,
        "y": 5
      },
      "raw": "key = \"ryou\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Anime\"] = true, [\"Bocchi the Rock\"] = true, [\"Kessoku Band\"] = true, },\r\n    pos = {\r\n        x = 5, y = 5\r\n    },\r\n    rarity = 1,\r\n    cost = 2,\r\n    config = {\r\n        extras = {\r\n            debt = 12,\r\n            add_debt = 3,\r\n            debt_absurd = 6,\r\n            factor_debt_absurd = 2,\r\n        }\r\n    },\r\n    add_to_deck = function (self, card, from_debuff)\r\n        card.ability.extras.obtain_bal = AKYRS.bal_val()\r\n        G.GAME.bankrupt_at = G.GAME.bankrupt_at - AKYRS.bal_val_overridable(card.ability.extras.debt,card.ability.extras.debt_absurd,card.ability.extras.obtain_bal)\r\n    end,\r\n    remove_from_deck =function (self, card, from_debuff)\r\n        G.GAME.bankrupt_at = G.GAME.bankrupt_at + AKYRS.bal_val_overridable(card.ability.extras.debt,card.ability.extras.debt_absurd,card.ability.extras.obtain_bal)\r\n    end,\r\n    loc_vars = function (self, info_queue, card)\r\n        if (card.ability.extras.obtain_bal or AKYRS.bal()) == \"absurd\" then\r\n            return {\r\n                key = self.key .. \"_absurd\",\r\n                vars = {\r\n                    card.ability.extras.debt_absurd,\r\n                    card.ability.extras.factor_debt_absurd,\r\n                }\r\n            }\r\n        end\r\n        return {\r\n            vars = {\r\n                card.ability.extras.debt,\r\n                card.ability.extras.add_debt,\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.before and context.poker_hands and #context.poker_hands[\"Pair\"] > 0 then\r\n            return {\r\n                message = localize(\"k_akyrs_ryo_borrowed_money\"),\r\n                func = function ()\r\n                    local pairs_of_clubs = 0\r\n                    for _,e_pair in ipairs(context.poker_hands[\"Pair\"]) do\r\n                        local is_pair_of_clubs = true\r\n                        for _,e_card in ipairs(e_pair) do\r\n                            if not e_card:is_suit(\"Clubs\") then\r\n                                is_pair_of_clubs = false\r\n                            end\r\n                        end\r\n                        if is_pair_of_clubs then\r\n                            pairs_of_clubs = pairs_of_clubs + 1\r\n                        end\r\n                        \r\n                    end\r\n                    \r\n                    if AKYRS.bal_overridable(\"absurd\",card.ability.extras.obtain_bal) then\r\n                        if pairs_of_clubs > 0 then\r\n                            local old_bkrpt_at = card.ability.extras.debt_absurd -- 6,12,24\r\n                            -- new debt should be 12,24,48, etc.\r\n                            -- was told to leave this here\r\n                            -- https://www.reddit.com/r/mildlyinfuriating/comments/zrct25/the_last_time_i_buy_kfc_almost_13_for_this/\r\n                            SMODS.scale_card(card, {ref_table = card.ability.extras, ref_value = \"debt_absurd\", scalar_table = {[\"a\"] = pairs_of_clubs * card.ability.extras.factor_debt_absurd }, scalar_value = \"a\", operation = \"X\" })\r\n                            -- the difference should also account for when, for some reason, the joker value changes like Cryptid's misprintize function\r\n                            -- all those numbers should be positive so i just absurd - old bkrpt ig\r\n                            G.GAME.bankrupt_at = G.GAME.bankrupt_at - (card.ability.extras.debt_absurd - old_bkrpt_at)\r\n                        end\r\n                    else\r\n                        if pairs_of_clubs > 0 then\r\n                            SMODS.scale_card(card, {ref_table = card.ability.extras, ref_value = \"debt\", scalar_value = \"add_debt\"})\r\n                            G.GAME.bankrupt_at = G.GAME.bankrupt_at - card.ability.extras.add_debt\r\n                        end\r\n                    end\r\n                end\r\n            }\r\n        end\r\n    end,\r\n\tdemicoloncompat = true,\r\n    hpot_unbreedable = true,",
      "config": {
        "extras": {
          "debt": 12,
          "add_debt": 3,
          "debt_absurd": 6,
          "factor_debt_absurd": 2
        }
      },
      "ability": {
        "extras": {
          "debt": 12,
          "add_debt": 3,
          "debt_absurd": 6,
          "factor_debt_absurd": 2
        }
      },
      "vars": [
        6,
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "nijika",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 6,
        "y": 5
      },
      "raw": "key = \"nijika\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Anime\"] = true, [\"Bocchi the Rock\"] = true, [\"Kessoku Band\"] = true, },\r\n    pos = {\r\n        x = 6, y = 5\r\n    },\r\n    rarity = 2,\r\n    cost = 8,\r\n    config = {\r\n        extras = {\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        if AKYRS.bal(\"absurd\") then\r\n            return {\r\n                key = self.key .. \"_absurd\",\r\n            }\r\n        end\r\n        return {\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if AKYRS.bal(\"absurd\") then\r\n            if context.individual and context.cardarea == G.play and context.other_card and context.other_card:is_suit(\"Diamonds\") and next(context.poker_hands.Straight) then\r\n                return {\r\n                    message = localize(\"k_akyrs_nijika_planet\"),\r\n                    func = function ()\r\n                        local pl = AKYRS.get_most_played()\r\n                        SMODS.add_card({soulable = true, key = pl, edition = \"e_negative\"})\r\n                    end\r\n                }\r\n            end\r\n        else\r\n            if context.joker_main and next(context.poker_hands.Straight) then\r\n                local diac = 0\r\n                for _,cr in ipairs(G.play.cards) do\r\n                    if cr:is_suit(\"Diamonds\") then\r\n                        diac = diac + 1\r\n                    end\r\n                end\r\n                if diac >= 1 then\r\n                    return {\r\n                        message = localize(\"k_akyrs_nijika_planet\"),\r\n                        func = function ()\r\n                            local pl = AKYRS.get_most_played()\r\n                            SMODS.add_card({key = pl, edition = \"e_negative\"})\r\n                        end\r\n                    }\r\n                end\r\n            end\r\n        end\r\n    end,\r\n\tdemicoloncompat = true,\r\n    hpot_unbreedable = true,",
      "config": {
        "extras": {}
      },
      "ability": {
        "extras": {}
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "blue_portal",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 2,
        "y": 4
      },
      "raw": "key = \"blue_portal\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Portal\"] = true, [\"Video Games\"] = true, },\r\n    pos = {\r\n        x = 2, y = 4\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        info_queue[#info_queue+1] = G.P_CENTERS[\"j_akyrs_orange_portal\"]\r\n        return {\r\n            vars = {card.ability.extras.xc},\r\n            main_end = {\r\n                { n = G.UIT.R, config = { padding = 0.1, colour = G.C.ORANGE, r = 0.1}, nodes = {\r\n                    {\r\n                        n = G.UIT.T, config = {scale = 0.3, text = card.ability.extras.link}\r\n                    }\r\n                }}\r\n            }\r\n        }\r\n    end,\r\n    set_ability = function (self, card, initial, delay_sprites)\r\n        card.ability.extras.link = AKYRS.random_string(10)\r\n    end,\r\n    add_to_deck = function (self, card, from_debuff)\r\n        AKYRS.simple_event_add(\r\n            function()\r\n                local c1 = SMODS.add_card({ key = \"j_akyrs_orange_portal\"})\r\n                c1.ability.extras.link = card.ability.extras.link\r\n                return true\r\n            end\r\n        )\r\n    end,\r\n    remove_from_deck = function (self, card, from_debuff)\r\n        local s = SMODS.find_card(\"j_akyrs_orange_portal\")\r\n        for _,_c in ipairs(s) do\r\n            if _c.ability.extras.link == card.ability.extras.link then\r\n                _c:start_dissolve({G.C.ORANGE})\r\n            end\r\n        end\r\n    end,\r\n    \r\n    rarity = 3,\r\n    cost = 9,\r\n    config = {\r\n        extras = {\r\n            link = \"?????\",\r\n            xc = 2.5\r\n        }\r\n    },\r\n    calculate = function (self, card, context)\r\n        if context.joker_main then\r\n            return {\r\n                xchips = card.ability.extras.xc\r\n            }\r\n        end\r\n    end,\r\n    blueprint_compat = true,\r\n\tdemicoloncompat = true,",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "orange_portal",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 3,
        "y": 4
      },
      "raw": "key = \"orange_portal\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Portal\"] = true, [\"Video Games\"] = true, },\r\n    pos = {\r\n        x = 3, y = 4\r\n    },\r\n    in_pool = function (self, args)\r\n        return false\r\n    end,\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = { card.ability.extras.xm },\r\n            main_end = {\r\n                { n = G.UIT.R, config = { padding = 0.1, colour = G.C.BLUE, r = 0.1}, nodes = {\r\n                    {\r\n                        n = G.UIT.T, config = {scale = 0.3, text = card.ability.extras.link}\r\n                    }\r\n                }}\r\n            }\r\n        }\r\n    end,\r\n    remove_from_deck = function (self, card, from_debuff)\r\n        local s = SMODS.find_card(\"j_akyrs_blue_portal\")\r\n        for _,_c in ipairs(s) do\r\n            if _c.ability.extras.link == card.ability.extras.link then\r\n                _c:start_dissolve({G.C.ORANGE})\r\n            end\r\n        end\r\n    end,\r\n    rarity = \"akyrs_unique\",\r\n    cost = 9,\r\n    config = {\r\n        extras = {\r\n            link = \"?????\",\r\n            xm = 2.5,\r\n        }\r\n    },\r\n    calculate = function (self, card, context)\r\n        if context.joker_main then\r\n            return {\r\n                xmult = card.ability.extras.xm\r\n            }\r\n        end\r\n    end,\r\n    blueprint_compat = true,\r\n\tdemicoloncompat = true,",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "koshitan",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 7,
        "y": 5
      },
      "raw": "key = \"koshitan\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Shikanokonokonokokoshitantan\"] = true,},\r\n    pos = {\r\n        x = 7, y = 5\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = { card.ability.extras.taketh, card.ability.extras.addth },\r\n        }\r\n    end,\r\n    rarity = 2,\r\n    cost = 5,\r\n    config = {\r\n        extras = {\r\n            taketh = 1,\r\n            addth = 5\r\n        }\r\n    },\r\n    calculate = function (self, card, context)\r\n        if context.setting_blind then\r\n            return {\r\n                dollars = -card.ability.extras.taketh,\r\n                message = localize(\"k_akyrs_value_up\"),\r\n                func = function ()\r\n                    AKYRS.simple_event_add(\r\n                        function ()\r\n                            card.ability.extra_value = (card.ability.extra_value or 0) + card.ability.extras.addth\r\n                            card:set_cost()\r\n                            return true\r\n                        end\r\n                    )\r\n                end\r\n            }\r\n        end\r\n    end,\r\n    blueprint_compat = true,\r\n\tdemicoloncompat = true,\r\n    hpot_unbreedable = true,",
      "config": {
        "extras": {
          "taketh": 1,
          "addth": 5
        }
      },
      "ability": {
        "extras": {
          "taketh": 1,
          "addth": 5
        }
      },
      "vars": [
        1,
        5
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "nokotan",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 8,
        "y": 5
      },
      "raw": "key = \"nokotan\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Shikanokonokonokokoshitantan\"] = true,},\r\n    pos = {\r\n        x = 8, y = 5\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        local value = 0\r\n            if card.area and card.area.cards then\r\n            local location = AKYRS.find_index(card.area.cards, card)\r\n            --- @type Card\r\n            local left_card = card.area.cards[location-1]\r\n            --- @type Card\r\n            local right_card = card.area.cards[location+1]\r\n            if left_card then value = value + left_card.sell_cost end\r\n            if right_card then value = value + right_card.sell_cost end\r\n        end\r\n        return {\r\n            vars = { card.ability.extras.scaleth, value * card.ability.extras.scaleth },\r\n        }\r\n    end,\r\n    rarity = 2,\r\n    cost = 6,\r\n    config = {\r\n        extras = {\r\n            scaleth = 2,\r\n        }\r\n    },\r\n    calculate = function (self, card, context)\r\n        if context.joker_main and card.area and card.area.cards then\r\n            local location = AKYRS.find_index(card.area.cards, card)\r\n            --- @type Card\r\n            local left_card = card.area.cards[location-1]\r\n            --- @type Card\r\n            local right_card = card.area.cards[location+1]\r\n            local value = 0\r\n            if left_card then value = value + left_card.sell_cost end\r\n            if right_card then value = value + right_card.sell_cost end\r\n            return {\r\n                mult = card.ability.extras.scaleth * value\r\n            }\r\n        end\r\n    end,\r\n    blueprint_compat = true,\r\n\tdemicoloncompat = true,\r\n    hpot_unbreedable = true,",
      "config": {
        "extras": {
          "scaleth": 2
        }
      },
      "ability": {
        "extras": {
          "scaleth": 2
        }
      },
      "vars": [
        2,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "koshian",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 9,
        "y": 5
      },
      "raw": "key = \"koshian\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Shikanokonokonokokoshitantan\"] = true,},\r\n    pos = {\r\n        x = 9, y = 5\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        local n, d = SMODS.get_probability_vars(card, 2, 2, \"koshian_calc\")\r\n        card.sell_cost = n + d\r\n        return {\r\n            vars = { n, d },\r\n        }\r\n    end,\r\n    rarity = 1,\r\n    cost = 3,\r\n    config = {\r\n        \r\n    },\r\n    add_to_deck = function (self, card, dt)\r\n        local n, d = SMODS.get_probability_vars(card, 2, 2, \"koshian_calc\")\r\n        card.sell_cost = n + d\r\n    end,\r\n    \r\n    calculate = function (self, card, context)\r\n        \r\n    end,\r\n    hpot_unbreedable = true,",
      "config": {},
      "ability": {},
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "bashame",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 0,
        "y": 6
      },
      "raw": "key = \"bashame\",\r\n    enhancement_gate = \"m_akyrs_canopy_card\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Shikanokonokonokokoshitantan\"] = true,},\r\n    pos = {\r\n        x = 0, y = 6\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        info_queue[#info_queue+1] = G.P_CENTERS[\"m_akyrs_canopy_card\"]\r\n        return {\r\n            vars = { card.ability.extra },\r\n        }\r\n    end,\r\n    rarity = 2,\r\n    cost = 5,\r\n    config = {\r\n        extra = 1\r\n    },\r\n    calculate = function (self, card, context)\r\n        if context.individual and context.cardarea == G.play and not context.blueprint then\r\n            if SMODS.get_enhancements(context.other_card)[\"m_akyrs_canopy_card\"] then\r\n                return {\r\n                    message = localize(\"k_akyrs_value_up\"),\r\n                    func = function()\r\n                        card.ability.extra_value = card.ability.extra_value + card.ability.extra\r\n                        card:set_cost()\r\n                    end\r\n                } \r\n            end\r\n        end\r\n    end,\r\n    blueprint_compat = false,\r\n\tdemicoloncompat = true,\r\n    hpot_unbreedable = true,",
      "config": {
        "extra": 1
      },
      "ability": {
        "extra": 1
      },
      "vars": [
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "gift_voucher",
      "name": null,
      "atlas": "guestJokerArts",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"gift_voucher\",\r\n    atlas = 'guestJokerArts',\r\n    pos = { x = 2, y = 0 },\r\n    loc_vars = function (self, info_queue, card)\r\n        info_queue[#info_queue+1] = AKYRS.DescriptionDummies[\"dd_akyrs_credit_gud\"]\r\n        return {\r\n            vars = {\r\n                localize(\"k_\"..string.lower(card.ability.extras.type or \"\"))\r\n            }\r\n        }\r\n    end,\r\n    rarity = 2,\r\n    cost = 7,\r\n    config = {\r\n        extras = {\r\n            type = \"\"\r\n        }\r\n    },\r\n    set_ability = function (self, card, initial, delay_sprites)\r\n        local sts = AKYRS.get_consumable_set()\r\n        card.ability.extras.type = pseudorandom_element(sts, \"akyrs_gift_voucher_initial\")\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.end_of_round and context.cardarea == G.jokers then\r\n            return {\r\n                func = function()\r\n                    local sts = AKYRS.get_consumable_set()\r\n                    card.ability.extras.type = pseudorandom_element(sts, \"akyrs_gift_voucher\")\r\n                end,\r\n                message = localize(\"k_akyrs_gift_change\")\r\n            }\r\n        end\r\n    end,\r\n    blueprint_compat = false,\r\n\tdemicoloncompat = true,",
      "config": {
        "extras": {
          "type": ""
        }
      },
      "ability": {
        "extras": {
          "type": ""
        }
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "sushi",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 5,
        "y": 6
      },
      "raw": "key = \"sushi\",\r\n    atlas = 'AikoyoriJokers',\r\n    pos = { x = 5, y = 6 },\r\n    pools = { Food = true },\r\n    config = {\r\n        extras = {\r\n            chips = 300,\r\n            reduce_chips = -100,\r\n        }\r\n    },\r\n    rarity = 3,\r\n    cost = 7,\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras.chips,\r\n                card.ability.extras.reduce_chips,\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.joker_main then\r\n            return {\r\n                chips = card.ability.extras.chips\r\n            }\r\n        end\r\n        if context.buying_card and context.card and context.card.ability and context.card.ability.set == \"Joker\" and not context.blueprint then\r\n            return {\r\n                func = function ()\r\n                    SMODS.scale_card(card,{\r\n                        ref_table = card.ability.extras,\r\n                        ref_value = \"chips\",\r\n                        scalar_value = \"reduce_chips\",\r\n                        scaling_message = { message = localize(\"k_akyrs_downgrade_ex\") },\r\n                    })\r\n                    if card.ability.extras.chips <= 0 then\r\n                        AKYRS.simple_event_add(function ()\r\n                            card.pinch.x = true\r\n                            SMODS.calculate_effect(\r\n                                { message = localize(\"k_akyrs_ate_up\")},\r\n                                card\r\n                            )\r\n                            card:remove()\r\n                            return true\r\n                        end, 0.5)\r\n                    end\r\n                end,\r\n            }\r\n        end\r\n    end,\r\n    blueprint_compat = true,",
      "config": {
        "extras": {
          "chips": 300,
          "reduce_chips": -100
        }
      },
      "ability": {
        "extras": {
          "chips": 300,
          "reduce_chips": -100
        }
      },
      "vars": [
        300,
        -100
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "biochamber",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 7,
        "y": 6
      },
      "raw": "key = \"biochamber\",\r\n    atlas = 'AikoyoriJokers',\r\n    pos = { x = 7, y = 6 },\r\n    pools = {  },\r\n    config = {\r\n    },\r\n    rarity = 2,\r\n    cost = 7,\r\n    loc_vars = function (self, info_queue, card)\r\n        info_queue[#info_queue+1] = G.P_CENTERS[\"j_akyrs_nutrient\"]\r\n        return {\r\n            vars = {\r\n                \r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.press_play then\r\n            return {\r\n                func = function()\r\n                    AKYRS.simple_event_add(\r\n                        function() \r\n                            if AKYRS.has_room(G.jokers) then\r\n                                SMODS.add_card{ key = \"j_akyrs_nutrient\"}\r\n                            end\r\n                            return true\r\n                        end, 0\r\n                    )\r\n                end\r\n            }\r\n        end\r\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "nutrient",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 8,
        "y": 6
      },
      "raw": "key = \"nutrient\",\r\n    atlas = 'AikoyoriJokers',\r\n    pos = { x = 8, y = 6 },\r\n    pools = { Food = true },\r\n    config = {\r\n        extras = {\r\n            xc = 1.6,\r\n            reduce = -0.2\r\n        }\r\n    },\r\n    rarity = 1,\r\n    cost = 1,\r\n    in_pool = function (self, args)\r\n        return false\r\n    end,\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras.xc,\r\n                -card.ability.extras.reduce\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.end_of_round and context.cardarea == G.jokers then\r\n            return {\r\n                func = function()\r\n                    SMODS.scale_card(card,{\r\n                        ref_table = card.ability.extras,\r\n                        ref_value = \"xc\",\r\n                        scalar_value = \"reduce\",\r\n                        scaling_message = { message = localize(\"k_akyrs_downgrade_ex\") },\r\n                    })\r\n\r\n                    AKYRS.simple_event_add(function ()\r\n                        if card.ability.extras.xc <= 1 then\r\n                            card.pinch.x = true\r\n                            SMODS.calculate_effect(\r\n                                { message = localize(\"k_akyrs_ate_up\")},\r\n                                card\r\n                            )\r\n                            card:remove()\r\n                        end\r\n                        return true\r\n                    end, 0.5)\r\n                end\r\n            }\r\n        end\r\n        if context.joker_main and not context.blueprint then\r\n            return {\r\n                xchips = card.ability.extras.xc\r\n            }\r\n        end\r\n    end,\r\n    blueprint_compat = true,",
      "config": {
        "extras": {
          "xc": 1.6,
          "reduce": -0.2
        }
      },
      "ability": {
        "extras": {
          "xc": 1.6,
          "reduce": -0.2
        }
      },
      "vars": [
        1.6,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "shine_bright_like_a_diamond",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 9,
        "y": 6
      },
      "raw": "key = \"shine_bright_like_a_diamond\",\r\n    pools = { Meme = true },\r\n    atlas = 'AikoyoriJokers',\r\n    pos = { x = 9, y = 6 },\r\n    pools = {  },\r\n    config = {\r\n        extras = {\r\n            xc = 1.6,\r\n            reduce = -0.2\r\n        }\r\n    },\r\n    rarity = 2,\r\n    cost = 4,\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.press_play then\r\n            return {\r\n                func = function()\r\n                    AKYRS.simple_event_add(function() \r\n                        SMODS.add_card({suit = \"Diamonds\", rank = \"Ace\", area = G.play})\r\n                        return true\r\n                    end, 0)\r\n                end\r\n            }\r\n        end\r\n    end,\r\n    blueprint_compat = true,",
      "config": {
        "extras": {
          "xc": 1.6,
          "reduce": -0.2
        }
      },
      "ability": {
        "extras": {
          "xc": 1.6,
          "reduce": -0.2
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "so_close",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 0,
        "y": 7
      },
      "raw": "key = \"so_close\",\r\n    pools = { [\"Video Game\"] = true, [\"Peggle\"] = true },\r\n    atlas = 'AikoyoriJokers',\r\n    pos = { x = 0, y = 7 },\r\n    pools = {  },\r\n    config = {\r\n        extras = {\r\n            score_xbase = 0.03\r\n        }\r\n    },\r\n    rarity = 2,\r\n    cost = 7,\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras.score_xbase * 100\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.individual and context.poker_hands and context.poker_hands[\"Two Pair\"] and context.cardarea == G.hand then\r\n            return {\r\n                akyrs_score = card.ability.extras.score_xbase * (G.GAME.blind.chips or 0)\r\n            }\r\n        end\r\n    end,\r\n    blueprint_compat = true,",
      "config": {
        "extras": {
          "score_xbase": 0.03
        }
      },
      "ability": {
        "extras": {
          "score_xbase": 0.03
        }
      },
      "vars": [
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "snow_pea",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 1,
        "y": 7
      },
      "raw": "key = \"snow_pea\",\r\n    atlas = 'AikoyoriJokers',\r\n    pools = { [\"Video Game\"] = true, [\"Plants vs Zombies\"] = true },\r\n    pos = { x = 1, y = 7 },\r\n    pools = {  },\r\n    config = {\r\n        extras = {\r\n            xscore = 1.75,\r\n        },\r\n    },\r\n    rarity = 3,\r\n    cost = 8,\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras.xscore\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.joker_main then\r\n            return {\r\n                akyrs_xscore = card.ability.extras.xscore\r\n            }\r\n        end\r\n    end,\r\n    blueprint_compat = true,",
      "config": {
        "extras": {
          "xscore": 1.75
        }
      },
      "ability": {
        "extras": {
          "xscore": 1.75
        }
      },
      "vars": [
        1.75
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "konton_boogie",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 2,
        "y": 7
      },
      "raw": "key = \"konton_boogie\",\r\n    atlas = 'AikoyoriJokers',\r\n    pos = { x = 2, y = 7 },\r\n    pools = { [\"Vocaloid\"] = true, },\r\n    pools = {  },\r\n    config = {\r\n        extras = {\r\n            gain = 0.1,\r\n            lose = 0.5,\r\n            xmult = 1,\r\n        },\r\n    },\r\n    rarity = 2,\r\n    cost = 8,\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras.gain,\r\n                card.ability.extras.lose,\r\n                card.ability.extras.xmult,\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.before and #context.full_hand == #context.scoring_hand and not context.blueprint then\r\n            return {\r\n                func = function ()\r\n                    SMODS.scale_card(card, {\r\n                        ref_table = card.ability.extras,\r\n                        ref_value = 'xmult',\r\n                        scalar_value = 'lose',\r\n                        scaling_message = { localize(\"k_akyrs_downgrade_ex\") },\r\n                        operation = function(ref_table, ref_value, initial, scalar_value)\r\n                            ref_table[ref_value] = math.max(ref_table[ref_value] - scalar_value, 1)\r\n                        end,\r\n                    })\r\n                end\r\n            }\r\n        end\r\n        if context.individual and context.cardarea == 'unscored' and not context.blueprint then\r\n            return {\r\n                func = function ()\r\n                    SMODS.scale_card(card, {\r\n                        ref_table = card.ability.extras,\r\n                        ref_value = 'xmult',\r\n                        scalar_value = 'gain',\r\n                    })\r\n                end\r\n            }\r\n        end\r\n        if context.joker_main then\r\n            return {\r\n                xmult = card.ability.extras.xmult\r\n            }\r\n        end\r\n    end,\r\n    blueprint_compat = true,",
      "config": {
        "extras": {
          "gain": 0.1,
          "lose": 0.5,
          "xmult": 1
        }
      },
      "ability": {
        "extras": {
          "gain": 0.1,
          "lose": 0.5,
          "xmult": 1
        }
      },
      "vars": [
        0.1,
        0.5,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "yamada_perfect",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 3,
        "y": 7
      },
      "raw": "key = \"yamada_perfect\",\r\n    atlas = 'AikoyoriJokers',\r\n    pos = { x = 3, y = 7 },\r\n    pools = { [\"Vocaloid\"] = true, },\r\n    pools = {  },\r\n    config = {\r\n        extras = {\r\n            gain = 0.1,\r\n            lose = 0.1,\r\n            xchips = 1,\r\n            suit = \"\",\r\n        },\r\n    },\r\n    set_ability = function (self, card, initial, delay_sprites)\r\n        card.ability.extras.suit = pseudorandom_element(SMODS.Suits,\"akyrs_yamadaperfect_suit\").key\r\n    end,\r\n    rarity = 2,\r\n    cost = 6,\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras.gain,\r\n                card.ability.extras.lose,\r\n                card.ability.extras.xchips,\r\n                localize(card.ability.extras.suit,\"suits_plural\"),\r\n                colours = {\r\n                    G.C.SUITS[card.ability.extras.suit]\r\n                }\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.individual and not context.blueprint and context.cardarea == G.play then\r\n            \r\n            if context.other_card and context.other_card:is_suit(card.ability.extras.suit) then\r\n                SMODS.calculate_effect({\r\n                    func = function ()\r\n                        SMODS.scale_card(card, {\r\n                            ref_table = card.ability.extras,\r\n                            ref_value = 'xchips',\r\n                            scalar_value = 'lose',\r\n                            scaling_message = { localize(\"k_akyrs_downgrade_ex\") },\r\n                            operation = function(ref_table, ref_value, initial, scalar_value)\r\n                                ref_table[ref_value] = math.max(ref_table[ref_value] - scalar_value, 1)\r\n                            end,\r\n                        })\r\n                    end\r\n                }, card)\r\n            end\r\n            if context.poker_hands and next(context.poker_hands[\"Flush\"]) and not context.other_card:is_suit(card.ability.extras.suit) then\r\n                SMODS.calculate_effect({\r\n                    func = function ()\r\n                        SMODS.scale_card(card, {\r\n                            ref_table = card.ability.extras,\r\n                            ref_value = 'xchips',\r\n                            scalar_value = 'gain',\r\n                        })\r\n                    end\r\n                }, card)\r\n            end\r\n        end\r\n        if context.joker_main then\r\n            return {\r\n                xchips = card.ability.extras.xchips\r\n            }\r\n        end\r\n        if context.after and context.cardarea == card.area then\r\n            return {\r\n                message = localize(\"k_reset\"),\r\n                func = function ()\r\n                    card.ability.extras.suit = pseudorandom_element(SMODS.Suits,\"akyrs_yamadaperfect_suit\").key\r\n                end,\r\n            }\r\n        end\r\n    end,\r\n    blueprint_compat = true,",
      "config": {
        "extras": {
          "gain": 0.1,
          "lose": 0.1,
          "xchips": 1,
          "suit": ""
        }
      },
      "ability": {
        "extras": {
          "gain": 0.1,
          "lose": 0.1,
          "xchips": 1,
          "suit": ""
        }
      },
      "vars": [
        0.1,
        0.1,
        1,
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "trend_angelina",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 4,
        "y": 7
      },
      "raw": "key = \"trend_angelina\",\r\n    atlas = 'AikoyoriJokers',\r\n    pos = { x = 4, y = 7 },\r\n    pools = { [\"Vocaloid\"] = true, },\r\n    pools = {  },\r\n    config = {\r\n        extras = {\r\n            gain = 0.4,\r\n            lose = 0.1,\r\n            xscore = 1,\r\n        },\r\n    },\r\n    rarity = 2,\r\n    cost = 6,\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras.gain,\r\n                card.ability.extras.lose,\r\n                card.ability.extras.xscore,\r\n            }\r\n        }\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.before and not context.blueprint then\r\n            if context.poker_hands and next(context.poker_hands[\"Straight\"]) then\r\n                SMODS.calculate_effect({\r\n                    func = function ()\r\n                        SMODS.scale_card(card, {\r\n                            ref_table = card.ability.extras,\r\n                            ref_value = 'xscore',\r\n                            scalar_value = 'gain',\r\n                        })\r\n                    end\r\n                }, card)\r\n            end\r\n            return {\r\n                func = function ()\r\n                    local freq = AKYRS.get_ranks_freq_from_cards(context.scoring_hand)\r\n                    for k, v in pairs(freq) do\r\n                        if v > 1 then\r\n                            SMODS.calculate_effect({\r\n                                func = function ()\r\n                                    for _, cx in ipairs(context.scoring_hand) do\r\n                                        if cx:get_id() == k then\r\n                                            cx:juice_up(0.2, 0.2)\r\n                                        end\r\n                                    end\r\n                                    SMODS.scale_card(card, {\r\n                                        ref_table = card.ability.extras,\r\n                                        ref_value = 'xscore',\r\n                                        scalar_value = 'lose',\r\n                                        scaling_message = { localize(\"k_akyrs_downgrade_ex\") },\r\n                                        operation = function(ref_table, ref_value, initial, scalar_value)\r\n                                            ref_table[ref_value] = math.max(ref_table[ref_value] - scalar_value, 1)\r\n                                        end,\r\n                                    })\r\n                                end\r\n                            }, card)\r\n                        end\r\n                    end\r\n                end\r\n            }\r\n        end\r\n        if context.joker_main then\r\n            return {\r\n                akyrs_xscore = card.ability.extras.xscore\r\n            }\r\n        end\r\n    end,\r\n    blueprint_compat = true,",
      "config": {
        "extras": {
          "gain": 0.4,
          "lose": 0.1,
          "xscore": 1
        }
      },
      "ability": {
        "extras": {
          "gain": 0.4,
          "lose": 0.1,
          "xscore": 1
        }
      },
      "vars": [
        0.4,
        0.1,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "furina",
      "name": null,
      "atlas": "furina",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"furina\",\n    atlas = 'furina',\n    pools = { [\"Genshin Impact\"] = true,},\n    pos = {\n        x = 0, y = 0\n    },\n    soul_pos = {\n        x = 1, y = 0, draw = function (card, scale_mod, rotate_mod)\n            card.children.floating_sprite:draw_shader('dissolve',0, nil, nil, card.children.center,scale_mod, rotate_mod,0,0 - 0.3,nil, 0.6)\n            card.children.floating_sprite:draw_shader('dissolve', nil, nil, nil, card.children.center, scale_mod, rotate_mod,0,0-0.5)\n        end\n    },\n    loc_vars = function (self, info_queue, card)\n        return {\n            vars = { card.ability.extra },\n        }\n    end,\n    rarity = 4,\n    cost = 30,\n    config = {\n        extra = 1\n    },\n    calculate = function (self, card, context)\n        if context.press_play then\n            return {\n                func = function ()\n                    ease_discard(card.ability.extra)\n                end\n            }\n        end\n    end,\n    blueprint_compat = true,\n\tdemicoloncompat = true,\n    hpot_unbreedable = true,",
      "config": {
        "extra": 1
      },
      "ability": {
        "extra": 1
      },
      "vars": [
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "tsunagite",
      "name": null,
      "atlas": "AikoyoriJokers",
      "pos": {
        "x": 9,
        "y": 0
      },
      "raw": "atlas = 'AikoyoriJokers',\n    pos = {\n        x = 9,\n        y = 0\n    },\n    soul_pos = {\n        x = 9,\n        y = 1\n    },\n    pools = { [\"Rhythm Games\"] = true, [\"Maimai\"] = true },\n    key = \"tsunagite\",\n    rarity = 4,\n    cost = 50,\n    loc_vars = function(self, info_queue, card)\n        if AKYRS.bal(\"absurd\") then\n            info_queue[#info_queue+1] = {key = \"akyrs_chip_mult_xchip_xmult\", set = 'Other', vars = \n                { \n                    card.ability.extra.chips_absurd,\n                    card.ability.extra.mult_absurd,\n                    card.ability.extra.Xchips_absurd,\n                    card.ability.extra.Xmult_absurd,\n                }\n            }\n            info_queue[#info_queue+1] = {key = \"akyrs_gain_chip_mult_xchip_xmult\", set = 'Other', vars = \n                { \n                    card.ability.extra.gain_chips_absurd,\n                    card.ability.extra.gain_mult_absurd,\n                    card.ability.extra.gain_Xchips_absurd,\n                    card.ability.extra.gain_Xmult_absurd,\n                }\n            }\n        end\n        if AKYRS.bal(\"adequate\") then\n            local total = 0\n            if G.hand and G.hand.highlighted then\n                for i,k in ipairs(G.hand.highlighted) do\n                    total = total + k:get_chip_bonus()\n                end\n            end\n            info_queue[#info_queue+1] = {key = \"akyrs_tsunagite_scores\", set = 'Other', vars = {\n                total\n            } }\n        end\n        info_queue[#info_queue+1] = {key = \"akyrs_tsunagite_name\", set = 'Other', }\n        return {\n            key = AKYRS.bal_val(self.key, self.key..\"_absurd\"), \n            vars = { \n                15,\n                card.ability.extra.gain_Xmult,\n            }\n        }\n    end,\n    config = {\n        extra = {\n            total = 15,\n            gain_Xmult = 0.15,\n            -- absurd\n            chips_absurd = 150,\n            Xchips_absurd = 15,\n            mult_absurd = 150,\n            Xmult_absurd = 15,\n            base_chips_absurd = 150,\n            base_Xchips_absurd = 1.5,\n            base_mult_absurd = 15,\n            base_Xmult_absurd = 1.5,\n            \n            gain_chips_absurd = 150,\n            gain_Xchips_absurd = 15,\n            gain_mult_absurd = 150,\n            gain_Xmult_absurd = 15,\n        }\n    },\n    calculate = function(self, card, context)\n        if context.individual and context.cardarea == G.play and AKYRS.bal(\"absurd\") then\n            return {\n                chips = card.ability.extra.chips_absurd,\n                xchips = card.ability.extra.Xchips_absurd,\n                mult = card.ability.extra.mult_absurd,\n                xmult = card.ability.extra.Xmult_absurd,\n            }\n        end\t\t\n        if context.using_consumeable or context.forcetrigger and AKYRS.bal(\"absurd\") then\n            if context.consumeable.config.center_key == 'c_wheel_of_fortune' or context.forcetrigger then\n                SMODS.scale_card(card, { no_message = true, ref_table = card.ability.extra, ref_value = \"chips_absurd\", scalar_value = \"gain_chips_absurd\" })\n                SMODS.scale_card(card, { no_message = true, ref_table = card.ability.extra, ref_value = \"Xchips_absurd\", scalar_value = \"gain_Xchips_absurd\" })\n                SMODS.scale_card(card, { no_message = true, ref_table = card.ability.extra, ref_value = \"mult_absurd\", scalar_value = \"gain_mult_absurd\" })\n                SMODS.scale_card(card, { no_message = true, ref_table = card.ability.extra, ref_value = \"Xmult_absurd\", scalar_value = \"gain_Xmult_absurd\" })\n                SMODS.calculate_effect({\n                    message = localize('k_upgrade_ex')\n                }, card)\n            end\n        end\n        if context.akyrs_pre_play and AKYRS.bal(\"adequate\") then\n            return {\n                func = function ()\n                    local total = 0\n                    for i,k in ipairs(context.akyrs_pre_play_cards) do\n                        total = total + k:get_chip_bonus()\n                    end\n                    if math.fmod(total,15) == 0 then\n                        for i,k in ipairs(context.akyrs_pre_play_cards) do\n                            AKYRS.simple_event_add(function()\n                                AKYRS.juice_like_tarot(card)\n                                k:juice_up(0.3, 0.5)\n                                SMODS.scale_card(k, { ref_table = k.ability, ref_value = \"perma_x_mult\", scalar_table = card.ability.extra, scalar_value = \"gain_Xmult\" })\n                                return true\n                            end, 0.5)\n                        end\n                    end\n                end\n            }\n        end\n    end,\n    blueprint_compat = true,\n\tdemicoloncompat = true,",
      "config": {},
      "ability": {},
      "vars": [
        15,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "aikoyori",
      "name": "Aikoyori",
      "atlas": "aikoSelfInsert",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "pools = { [\"Self-Insert\"] = true, },\n    key = \"aikoyori\",\n    atlas = 'aikoSelfInsert',\n    pos = {\n        x = 0, y = 0\n    },\n    soul_pos = {\n        x = 1, y = 0\n    },\n    rarity = 4,\n    cost = 50,\n    config = {\n        name = \"Aikoyori\",\n        extras = {\n            base = {\n                xmult = 1.984,\n                emult = 1.5,\n            }\n        }\n    },\n    hpot_unbreedable = true,\n    set_ability = function (self, card, initial, delay_sprites)\n        ---@type Card\n        card = card\n        local dt = os.time()\n        card.ability.akyrs_aiko_sprite = pseudorandom(\"akyrs_sprite_\"..dt, 0 ,11)\n        AKYRS.simple_event_add(\n            function ()\n                card.children.floating_sprite:set_sprite_pos({ x = 1 + card.ability.akyrs_aiko_sprite, y = 0})\n                return true\n            end, 0\n        )\n    end,\n    loc_vars = function (self, info_queue, card)\n        if AKYRS.bal_val(\"adequate\") then\n            info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_aikoyori_base_ability\", vars = {card.ability.extras.base.xmult}}\n        else\n            info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_aikoyori_base_ability_absurd\", vars = {card.ability.extras.base.emult}}\n        end\n        if AKYRS.is_mod_loaded(\"Cryptid\")  then\n            info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_aikoyori_cryptid_ability\"}\n        end\n        if MoreFluff then\n            info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_aikoyori_more_fluff_ability\"}\n        end\n        if Entropy then\n            info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_aikoyori_entropy_ability\"}\n        end\n        if SDM_0s_Stuff_Mod then\n            info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_aikoyori_sdmstuff_ability\"}\n        end\n        if togabalatro then\n            info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_aikoyori_togasstuff_ability\"}\n        end\n        if PTASaka then\n            info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_aikoyori_pta_ability\"}\n        end\n        if Cryptposting then\n            info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_cryptposting_ability\"}\n        end\n        if AKYRS.is_mod_loaded(\"Prism\") then\n            info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_prism_ability\"}\n        end\n        if garb_enabled then\n            info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_garbshit_ability\"}\n        end\n        if AKYRS.is_mod_loaded(\"finity\") then\n            info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_finity_ability\"}\n        end\n        if Bakery_API then\n            info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_bakery_ability\"}\n        end\n        if AKYRS.is_mod_loaded(\"Astronomica\") then\n            info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_astronomica_ability\"}\n        end\n        if AKYRS.is_mod_loaded(\"vallkarri\") then\n            info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_vallkarri_ability\"}\n        end\n        if AKYRS.is_mod_loaded(\"GrabBag\") then\n            info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_grab_bag_ability\"}\n        end\n        if AKYRS.is_mod_loaded(\"ortalab\") then\n            info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_ortalab_ability\"}\n        end\n        if AKYRS.is_mod_loaded(\"HotPotato\") then\n            info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_hotpot_ability\"}\n        end\n        if AKYRS.is_mod_loaded(\"GSPhanta\") then\n            info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_phanta_ability\"}\n        end\n        if AKYRS.is_mod_loaded(\"kino\") then\n            info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_kino_ability\"}\n        end\n        if AKYRS.is_mod_loaded(\"Maximus\") then\n            info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_maximus_ability\"}\n        end\n        if AKYRS.is_mod_loaded(\"Sagatro\") then\n            info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_sagatro_ability\"}\n        end\n        if AKYRS.is_mod_loaded(\"Qualatro\") then\n            info_queue[#info_queue+1] = {set = \"DescriptionDummy\", key = \"dd_akyrs_qualatro_ability\"}\n        end\n        return {\n        }\n    end,\n    add_to_deck = function (self, card, from_debuff)\n        if Bakery_API then\n            G.GAME.modifiers.Bakery_extra_charms = G.GAME.modifiers.Bakery_extra_charms and G.GAME.modifiers.Bakery_extra_charms + 1 or 1\n        end\n    end,\n    remove_from_deck = function (self, card, from_debuff)\n        if Bakery_API then\n            G.GAME.modifiers.Bakery_extra_charms = G.GAME.modifiers.Bakery_extra_charms and G.GAME.modifiers.Bakery_extra_charms - 1 or 1\n        end\n    end,\n    calculate = function (self, card, context)\n        if context.skip_blind then\n            if Cryptposting then\n                SMODS.calculate_effect({\n                    func = function()\n                        local jkr = pseudorandom_element(cryptposting_joker,pseudoseed(\"aikocryptposting\"))\n                        SMODS.add_card({set = \"Joker\", key = jkr})\n                    end\n                }, card)\n            end\n        end\n        if context.setting_blind then\n            if AKYRS.is_mod_loaded(\"GrabBag\") then\n                SMODS.calculate_effect({\n                    func = function()\n                        SMODS.add_card({set = \"Ephemeral\", area = G.consumeables, edition = \"e_negative\"})\n                    end\n                }, card)\n            end\n        end\n        if context.akyrs_ortalab_zodiac_used then\n            return {\n                func = function ()\n                    AKYRS.simple_event_add(\n                        function()\n                            SMODS.smart_level_up_hand(card, context.zodiac_proto.config.extra.hand_type)\n                            return true\n                        end\n                    )\n                end, 0\n            }\n        end\n        if context.before then\n            if AKYRS.is_mod_loaded(\"Cryptid\") and #G.play.cards == 1 and G.play.cards[1]:get_id() == 14 then\n                SMODS.calculate_effect({ func = function() SMODS.add_card({set = \"Code\", area = G.consumeables, edition = \"e_negative\"}) end}, card)\n            end\n            if Entropy and #context.full_hand >= 4 then\n                local suits_in_hand = {}\n                local ranks_in_hand = {}\n                local all_card_unique = true\n                for i, k in ipairs(context.full_hand) do\n                    if not SMODS.has_no_suit(k) and not SMODS.has_no_rank(k) then\n                        if not suits_in_hand[k.base.suit] and not ranks_in_hand[k:get_id()] then\n                            suits_in_hand[k.base.suit] = true\n                            ranks_in_hand[k:get_id()] = true\n                        else\n                            all_card_unique = false\n                            break\n                        end\n                    end\n                end\n                if all_card_unique then\n                    SMODS.calculate_effect({ func = function() SMODS.add_card({key = \"c_entr_flipside\", area = G.consumeables, edition = \"e_negative\"}) end}, card)\n                end\n            end\n            if AKYRS.is_mod_loaded(\"sdm0sstuff\") then\n                if next(context.poker_hands[\"Full House\"]) then\n                    SMODS.calculate_effect({ func = function() SMODS.add_card({set = \"Bakery\", area = G.consumeables, edition = \"e_negative\"}) end}, card)\n                end\n            end\n            if AKYRS.is_mod_loaded(\"GSPhanta\") then\n                if next(context.poker_hands[\"Four of a Kind\"]) and G.P_CENTER_POOLS.phanta_hanafuda then\n                    SMODS.calculate_effect({ func = function() SMODS.add_card({set = \"Hanafuda\", area = G.consumeables, edition = \"e_negative\"}) end}, card)\n                end\n            end\n            if AKYRS.is_mod_loaded(\"vallkarri\") then\n                if G.GAME.current_round.hands_left == G.GAME.current_round.discards_left then\n                    SMODS.calculate_effect({ func = function() SMODS.add_card({set = \"Aesthetic\", area = G.consumeables, edition = \"e_negative\"}) end}, card)\n                end\n            end\n            if AKYRS.is_mod_loaded(\"Prism\") then\n                if not next(context.poker_hands[\"Flush\"]) then\n                    SMODS.calculate_effect({ func = function() SMODS.add_card({set = \"Myth\", area = G.consumeables, edition = \"e_negative\"}) end}, card)\n                end\n            end\n            if AKYRS.is_mod_loaded(\"kino\") then\n                if math.fmod(G.GAME.current_round.hands_played, 2) == 1 then\n                    SMODS.calculate_effect({ func = function() SMODS.add_card({set = \"confection\", area = G.consumeables, edition = \"e_negative\"}) end}, card)\n                end\n            end\n        end \n        if AKYRS.is_mod_loaded(\"Astronomica\") then\n            if context.after then\n                local cards_below_hand = math.max(G.hand.config.card_limit - #G.play.cards ,1)\n                if cards_below_hand > 1 then\n                    SMODS.calculate_effect({akyrs_xscore = cards_below_hand}, card)\n                end\n            end\n        end\n        if AKYRS.is_mod_loaded(\"HotPotato\") then\n            if context.final_scoring_step then\n                SMODS.calculate_effect ({\n                    func = function ()\n                        ease_spark_points(math.floor(hand_chips) * 10.0)\n                    end\n                }, card)\n            end\n        end\n        if AKYRS.is_mod_loaded(\"finity\") and context.blind_defeated and G.GAME.blind and G.GAME.blind.boss and G.GAME.blind.config.blind.boss.showdown then\n            SMODS.calculate_effect({ func = function() SMODS.add_card({key = \"c_finity_finity\", area = G.consumeables, edition = \"e_negative\"}) end}, card)\n        end\n        if garb_enabled and context.selling_card and context.card.ability.set == \"Joker\" then\n            SMODS.calculate_effect({ func = function() SMODS.add_card({set = \"Stamp\", area = G.consumeables, edition = \"e_negative\"}) end}, card)\n        end\n        if AKYRS.is_mod_loaded(\"Maximus\") and context.selling_card and context.card.ability.set == \"Planet\" then\n            SMODS.calculate_effect({ func = function() SMODS.add_card({set = \"Horoscope\", edition = \"e_negative\"}) end}, card)\n        end\n        if AKYRS.is_mod_loaded(\"Sagatro\") and context.selling_card and context.card.ability.set == \"Tarot\" then\n            SMODS.calculate_effect({ func = function() SMODS.add_card({set = \"Divinatio\", edition = \"e_negative\"}) end}, card)\n        end\n        if context.individual and context.cardarea == G.play then\n            if not context.other_card:is_face() then\n                return AKYRS.bal_val(\n                    {\n                        xmult = card.ability.extras.base.xmult\n                    },\n                    {\n                        emult = card.ability.extras.base.emult\n                    }\n                )\n            end\n        end\n        if context.akyrs_round_eval then\n            local d = Talisman and to_big(context.dollars) or context.dollars\n            local v = Talisman and to_big(10) or 10\n            local c = d < v\n            if togabalatro and c then\n                local tag = Tag(pseudorandom_element(toga_tags,pseudoseed(\"akyrs_aikoyori_toga_tags\")))\n                add_tag(tag)\n            end\n            if PTASaka then\n                if Talisman then\n                    ease_pyrox(to_number(context.dollars))\n                else\n                    ease_pyrox(context.dollars)\n                end\n            end\n        end\n    end,\n    blueprint_compat = true",
      "config": {
        "name": "Aikoyori",
        "extras": {
          "base": {
            "xmult": 1.984,
            "emult": 1.5
          }
        }
      },
      "ability": {
        "name": "Aikoyori",
        "extras": {
          "base": {
            "xmult": 1.984,
            "emult": 1.5
          }
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "planet_bishop_ring",
      "name": "",
      "atlas": "aikoPlanets",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "set = \"Planet\",\r\n    key = \"planet_bishop_ring\",\r\n    atlas = \"aikoPlanets\",\r\n    pos = {x=0, y=0},\r\n    config = {\r\n        extra = 1\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                G.GAME.akyrs_pure_hand_modifier.level,\r\n                G.GAME.akyrs_pure_hand_modifier.multiplier,\r\n                card.ability.extra * 0.5 * G.GAME.akyrs_pure_hand_modifier.level\r\n            }\r\n        }\r\n    end,\r\n    can_use = function (self, card)\r\n        return true\r\n    end,\r\n    in_pool = function (self, args)\r\n        return G.GAME.akyrs_pure_unlocked\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        \r\n        G.GAME.akyrs_pure_unlocked = true\r\n        update_hand_text({sound = 'button', volume = 0.7, pitch = 0.8, delay = 0.3}, {handname=localize('k_akyrs_pure_hands'),chips = '...', mult = '...', level=''})\r\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.2, func = function()\r\n            play_sound('tarot1')\r\n            card:juice_up(0.8, 0.5)\r\n            G.TAROT_INTERRUPT_PULSE = true\r\n            return true end }))\r\n        update_hand_text({delay = 0}, {mult = '+', StatusText = true})\r\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.9, func = function()\r\n            play_sound('tarot1')\r\n            card:juice_up(0.8, 0.5)\r\n            return true end }))\r\n        update_hand_text({delay = 0}, {chips = '+', StatusText = true})\r\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.9, func = function()\r\n            play_sound('tarot1')\r\n            card:juice_up(0.8, 0.5)\r\n            G.TAROT_INTERRUPT_PULSE = nil\r\n            return true end }))\r\n        update_hand_text({sound = 'button', volume = 0.7, pitch = 0.9, delay = 0}, {level='+1'})\r\n        delay(1.3)\r\n        G.GAME.akyrs_pure_hand_modifier.multiplier = G.GAME.akyrs_pure_hand_modifier.multiplier + card.ability.extra * 0.5 * G.GAME.akyrs_pure_hand_modifier.level\r\n        G.GAME.akyrs_pure_hand_modifier.level = G.GAME.akyrs_pure_hand_modifier.level + card.ability.extra\r\n        update_hand_text({sound = 'button', volume = 0.7, pitch = 1.1, delay = 0}, {mult = 0, chips = 0, handname = '', level = ''})\r\n    end",
      "config": {
        "extra": 1
      },
      "ability": {
        "extra": 1
      },
      "vars": [
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "PokerHand",
      "key": "Word Hand",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"Word Hand\",\r\n    visible = false,\r\n    example = {\r\n        { AKYRS.randomCard(), true, nil, akyrs_letter = \"E\", is_null = true},\r\n        { AKYRS.randomCard(), true, nil, akyrs_letter = \"x\", is_null = true},\r\n        { AKYRS.randomCard(), true, nil, akyrs_letter = \"a\", is_null = true},\r\n        { AKYRS.randomCard(), true, nil, akyrs_letter = \"m\", is_null = true},\r\n        { AKYRS.randomCard(), true, nil, akyrs_letter = \"p\", is_null = true},\r\n        { AKYRS.randomCard(), true, nil, akyrs_letter = \"l\", is_null = true},\r\n        { AKYRS.randomCard(), true, nil, akyrs_letter = \"e\", is_null = true},\r\n    },\r\n    evaluate = function(parts, hand_in)\r\n        return {}\r\n    end,\r\n    akyrs_visual_chips = function(self)\r\n        return \"???\"\r\n    end,\r\n    akyrs_visual_mult = function(self)\r\n        return \"???\"\r\n    end,\r\n    chips = 0,\r\n    mult = 0,\r\n    l_chips = 0,\r\n    l_mult = 0,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "PokerHand",
      "key": "expression",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"expression\",\r\n    chips = 0,\r\n    mult = 0,\r\n    l_chips = 0,\r\n    l_mult = 0,\r\n    visible = false,\r\n    example = {\r\n        { \"\", true, nil, akyrs_letter = \"3\", is_null = true},\r\n        { \"\", true, nil, akyrs_letter = \"7\", is_null = true},\r\n        { \"\", true, nil, akyrs_letter = \"*\", is_null = true},\r\n        { \"\", true, nil, akyrs_letter = \"4\", is_null = true},\r\n        { \"\", true, nil, akyrs_letter = \"+\", is_null = true},\r\n        { \"\", true, nil, akyrs_letter = \"2\", is_null = true},\r\n        { \"\", true, nil, akyrs_letter = \"7\", is_null = true},\r\n    },\r\n    evaluate = function(parts, hand_in)\r\n        if ((not G.GAME.akyrs_character_stickers_enabled) or (not G.GAME.akyrs_mathematics_enabled)) then \r\n        return {} end\r\n        local word_hand = {}\r\n        local hand = AKYRS.shallow_indexed_table_copy(hand_in)\r\n        table.sort(hand, AKYRS.hand_sort_function)\r\n        for _, v in pairs(hand) do\r\n            if not v.ability or not v.ability.aikoyori_letters_stickers then return {} end\r\n            local alpha = v.ability.aikoyori_letters_stickers:lower()\r\n            if alpha == \"#\" and v.ability.aikoyori_pretend_letter then\r\n                -- if wild is set fr tbh\r\n                alpha = v.ability.aikoyori_pretend_letter:lower()\r\n            elseif alpha == \"#\" and AKYRS.config.wildcard_behaviour == 3 then -- if it's unset in mode 3 then just make it a random letter i guess\r\n                alpha = '★'\r\n            end\r\n            table.insert(word_hand, alpha)\r\n                \r\n        end\r\n        \r\n        local expression = table.concat(word_hand)\r\n        \r\n        \r\n        local status, value = pcall(AKYRS.MathParser.solve,AKYRS.MathParser,expression)\r\n        if not status or #hand < 1 then return {} end\r\n        G.GAME.aikoyori_evaluation_value = value\r\n        G.GAME.aikoyori_evaluation_replace = false\r\n        G.GAME.akyrs_previous_scoring_key = G.GAME.current_scoring_calculation\r\n        AKYRS.set_scoring_parameter_backup('akyrs_math_display')\r\n        if (G.STATE == G.STATES.HAND_PLAYED) then\r\n            G.GAME.aikoyori_evaluation_value = value\r\n        end\r\n        return {hand}\r\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "PokerHand",
      "key": "modification",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"modification\",\r\n    chips = 0,\r\n    mult = 0,\r\n    l_chips = 0,\r\n    l_mult = 0,\r\n    visible = false,\r\n    example = {\r\n        { \"\", true, nil, akyrs_letter = \"/\", is_null = true},\r\n        { \"\", true, nil, akyrs_letter = \"2\", is_null = true},\r\n        { \"\", true, nil, akyrs_letter = \"5\", is_null = true},\r\n    },\r\n    evaluate = function(parts, hand_in)\r\n        if ((not G.GAME.akyrs_character_stickers_enabled) or (not G.GAME.akyrs_mathematics_enabled)) then \r\n        return {} end\r\n        local word_hand = {}\r\n        local hand = AKYRS.shallow_indexed_table_copy(hand_in)\r\n        table.sort(hand, AKYRS.hand_sort_function)\r\n        for _, v in pairs(hand) do\r\n            if not v.ability or not v.ability.aikoyori_letters_stickers then return {} end\r\n            local alpha = v.ability.aikoyori_letters_stickers:lower()\r\n            if alpha == \"#\" and v.ability.aikoyori_pretend_letter then\r\n                -- if wild is set fr tbh\r\n                alpha = v.ability.aikoyori_pretend_letter:lower()\r\n            elseif alpha == \"#\" and AKYRS.config.wildcard_behaviour == 3 then -- if it's unset in mode 3 then just make it a random letter i guess\r\n                alpha = '★'\r\n            end\r\n            table.insert(word_hand, alpha)\r\n                \r\n        end\r\n        \r\n        local expression = table.concat(word_hand)\r\n        local to_number = to_number or function(l) return l end\r\n        local expression_with_chips = tostring(to_number(G.GAME.chips))..table.concat(word_hand)\r\n        \r\n        \r\n        local status_check, value_fake = pcall(AKYRS.MathParser.solve,AKYRS.MathParser,expression)\r\n        local status, value = pcall(AKYRS.MathParser.solve,AKYRS.MathParser,expression_with_chips)\r\n        if status_check or #hand < 1 then return {} end\r\n        if not status then return {} end\r\n        G.GAME.aikoyori_evaluation_value = value\r\n        G.GAME.aikoyori_evaluation_replace = true\r\n        AKYRS.set_scoring_parameter_backup('akyrs_math_display')\r\n        if (G.STATE == G.STATES.HAND_PLAYED) then\r\n\r\n            G.GAME.aikoyori_evaluation_value = value\r\n           \r\n        end\r\n        return {hand}\r\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "PokerHand",
      "key": "assignment",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"assignment\",\r\n    chips = 0,\r\n    mult = 0,\r\n    l_chips = 0,\r\n    l_mult = 0,\r\n    visible = false,\r\n    example = {\r\n        { \"\", true, nil, akyrs_letter = \"x\", is_null = true},\r\n        { \"\", true, nil, akyrs_letter = \"=\", is_null = true},\r\n        { \"\", true, nil, akyrs_letter = \"7\", is_null = true},\r\n    },\r\n    evaluate = function(parts, hand_in)\r\n        if ((not G.GAME.akyrs_character_stickers_enabled) or (not G.GAME.akyrs_mathematics_enabled)) then \r\n        return {} end\r\n        local word_hand = {}\r\n        local hand = AKYRS.shallow_indexed_table_copy(hand_in)\r\n        table.sort(hand, AKYRS.hand_sort_function)\r\n        for _, v in pairs(hand) do\r\n            if not v.ability or not v.ability.aikoyori_letters_stickers then return {} end\r\n            local alpha = v.ability.aikoyori_letters_stickers:lower()\r\n            if alpha == \"#\" and v.ability.aikoyori_pretend_letter then\r\n                -- if wild is set fr tbh\r\n                alpha = v.ability.aikoyori_pretend_letter:lower()\r\n            elseif alpha == \"#\" and AKYRS.config.wildcard_behaviour == 3 then -- if it's unset in mode 3 then just make it a random letter i guess\r\n                alpha = '★'\r\n            end\r\n            table.insert(word_hand, alpha)\r\n                \r\n        end\r\n        \r\n        local expression = table.concat(word_hand)\r\n        local parts = {}\r\n        for part in expression:gmatch(\"[^=]+\") do\r\n            table.insert(parts, part)\r\n        end\r\n\r\n        if #parts ~= 2 then\r\n            return {}\r\n        end\r\n\r\n        local variable, value_expression = parts[1], parts[2]\r\n        local status, value = pcall(AKYRS.MathParser.solve, AKYRS.MathParser, value_expression)\r\n\r\n        if not status then\r\n            return {}\r\n        end\r\n\r\n        G.GAME.aikoyori_variable_to_set = variable\r\n        G.GAME.aikoyori_value_to_set_to_variable = value\r\n        return {hand}\r\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "PokerHand",
      "key": "tripair",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"tripair\",\r\n    visible = false,\r\n    chips = 120, mult = 12,\r\n    l_chips = 35, l_mult = 3,\r\n\r\n    example = {\r\n        {\"S_A\", true},\r\n        {\"H_A\", true},\r\n        {\"C_T\", true},\r\n        {\"S_T\", true},\r\n        {\"D_8\", true},\r\n        {\"C_8\", true},\r\n    },\r\n    evaluate = function (parts, hand)\r\n        if #parts._2 < 3 then\r\n            return {}\r\n        end\r\n        return parts._all_pairs\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "PokerHand",
      "key": "triplush",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"triplush\",\r\n    visible = false,\r\n    chips = 240, mult = 18,\r\n    l_chips = 65, l_mult = 9,\r\n\r\n    example = {\r\n        {\"C_A\", true},\r\n        {\"C_A\", true},\r\n        {\"C_T\", true},\r\n        {\"C_T\", true},\r\n        {\"C_8\", true},\r\n        {\"S_8\", true},\r\n    },\r\n    evaluate = function (parts, hand)\r\n        if #parts._2 < 3 or #parts._flush < 1 then\r\n            return {}\r\n        end\r\n        return parts._all_pairs\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "PokerHandPart",
      "key": "all_triples",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'all_triples',\r\n    func = function(hand)\r\n        local _3 = get_X_same(3, hand, true)\r\n        if not next(_3) then return {} end\r\n        return {SMODS.merge_lists(_3)}\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "PokerHand",
      "key": "twintriple",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"twintriple\",\r\n    visible = false,\r\n    chips = 140, mult = 10,\r\n    l_chips = 40, l_mult = 5,\r\n\r\n    example = {\r\n        {\"C_7\", true},\r\n        {\"S_7\", true},\r\n        {\"H_7\", true},\r\n        {\"C_3\", true},\r\n        {\"S_3\", true},\r\n        {\"H_3\", true},\r\n    },\r\n    evaluate = function (parts, hand)\r\n        if #parts._3 < 2 then\r\n            return {}\r\n        end\r\n        return parts.akyrs_all_triples\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "PokerHand",
      "key": "twinflupple",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"twinflupple\",\r\n    visible = false,\r\n    chips = 300, mult = 15,\r\n    l_chips = 60, l_mult = 8,\r\n\r\n    example = {\r\n        {\"C_5\", true},\r\n        {\"C_5\", true},\r\n        {\"C_5\", true},\r\n        {\"C_4\", true},\r\n        {\"C_4\", true},\r\n        {\"H_4\", true},\r\n    },\r\n    evaluate = function (parts, hand)\r\n        if #parts._3 < 2 or #parts._flush < 1 then\r\n            return {}\r\n        end\r\n        return parts.akyrs_all_triples\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "PokerHandPart",
      "key": "mflush",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'mflush',\r\n    func = function(hand)\r\n        return AKYRS.get_multi_flush(hand)\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "PokerHandPart",
      "key": "all_flushes",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'all_flushes',\r\n    func = function(hand)\r\n        local _flush = AKYRS.get_multi_flush(hand)\r\n        if not next(_flush) then return {} end\r\n        return {SMODS.merge_lists(_flush)}\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "PokerHandPart",
      "key": "all_straight",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'all_straight',\r\n    func = function(hand)\r\n        local straight = get_straight(hand, SMODS.four_fingers('straight') , SMODS.shortcut(), SMODS.wrap_around_straight())\r\n        if not next(straight) then return {} end\r\n        return {SMODS.merge_lists(straight)}\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "PokerHand",
      "key": "twinflush",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"twinflush\",\r\n    visible = false,\r\n    chips = 700, mult = 10,\r\n    l_chips = 40, l_mult = 15,\r\n\r\n    example = {\r\n        {\"C_A\", true},\r\n        {\"C_K\", true},\r\n        {\"C_K\", true},\r\n        {\"C_T\", true},\r\n        {\"C_9\", true},\r\n        {\"D_8\", true},\r\n        {\"D_5\", true},\r\n        {\"D_5\", true},\r\n        {\"D_4\", true},\r\n        {\"D_2\", true},\r\n    },\r\n    evaluate = function (parts, hand)\r\n        if #parts.akyrs_mflush < 2 then\r\n            return {}\r\n        end\r\n        local cards_counted = {}\r\n        for _, part in ipairs(parts.akyrs_mflush) do\r\n            for _, card in ipairs(part) do\r\n                if not AKYRS.is_in_table(cards_counted, card) then\r\n                    table.insert(cards_counted, card)\r\n                else \r\n                    return {}\r\n                end\r\n            end\r\n        end\r\n        return parts.akyrs_all_flushes\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "PokerHand",
      "key": "flushbung",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"flushbung\",\r\n    visible = false,\r\n    chips = 700, mult = 12,\r\n    l_chips = 35, l_mult = 12,\r\n\r\n    example = {\r\n        {\"C_A\", true},\r\n        {\"C_K\", true},\r\n        {\"C_K\", true},\r\n        {\"C_T\", true},\r\n        {\"C_9\", true},\r\n        {\"C_8\", true},\r\n        {\"C_5\", true},\r\n        {\"C_5\", true},\r\n        {\"C_4\", true},\r\n        {\"C_2\", true},\r\n    },\r\n    evaluate = function (parts, hand)\r\n        if #parts.akyrs_mflush < 1 then\r\n            return {}\r\n        end\r\n        local cards_counted = {}\r\n        for _, part in ipairs(parts.akyrs_mflush) do\r\n            local count = 0\r\n            for _, card in ipairs(part) do\r\n                if not AKYRS.is_in_table(cards_counted, card) then\r\n                    count = count + 1\r\n                    table.insert(cards_counted, card)\r\n                else \r\n                    return {}\r\n                end\r\n                if count >= SMODS.four_fingers('flush') * 2 then\r\n                    return parts.akyrs_mflush\r\n                end\r\n            end\r\n        end\r\n        return {}\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "PokerHand",
      "key": "twinstraight",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"twinstraight\",\r\n    visible = false,\r\n    chips = 900, mult = 8,\r\n    l_chips = 65, l_mult = 17,\r\n\r\n    example = {\r\n        {\"C_A\", true},\r\n        {\"H_K\", true},\r\n        {\"S_Q\", true},\r\n        {\"D_J\", true},\r\n        {\"D_T\", true},\r\n        {\"H_8\", true},\r\n        {\"S_7\", true},\r\n        {\"D_6\", true},\r\n        {\"C_5\", true},\r\n        {\"C_4\", true},\r\n    },\r\n    evaluate = function (parts, hand)\r\n        if #parts._straight < 2 then\r\n            return {}\r\n        end\r\n        local cards_counted = {}\r\n        for _, part in ipairs(parts._straight) do\r\n            for _, card in ipairs(part) do\r\n                if not AKYRS.is_in_table(cards_counted, card) then\r\n                    table.insert(cards_counted, card)\r\n                else \r\n                    return {}\r\n                end\r\n            end\r\n        end\r\n        return parts.akyrs_all_straight\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "PokerHandPart",
      "key": "doublestraight",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'doublestraight',\r\n    func = function(hand) return get_straight(hand, SMODS.four_fingers('straight') * 2, SMODS.shortcut(), SMODS.wrap_around_straight()) end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "PokerHand",
      "key": "direstraight",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"direstraight\",\r\n    visible = false,\r\n    chips = 900, mult = 6,\r\n    l_chips = 50, l_mult = 25,\r\n    example = {\r\n        {\"C_A\", true},\r\n        {\"H_K\", true},\r\n        {\"S_Q\", true},\r\n        {\"D_J\", true},\r\n        {\"D_T\", true},\r\n        {\"C_9\", true},\r\n        {\"H_8\", true},\r\n        {\"S_7\", true},\r\n        {\"D_6\", true},\r\n        {\"C_5\", true},\r\n    },\r\n    evaluate = function (parts, hand)\r\n        if #parts.akyrs_doublestraight < 1 then\r\n            return {}\r\n        end\r\n        return parts.akyrs_all_straight\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "PokerHand",
      "key": "twinstraightflush",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"twinstraightflush\",\r\n    visible = false,\r\n    chips = 1600, mult = 60,\r\n    l_chips = 140, l_mult = 40,\r\n    example = {\r\n        {\"C_A\", true},\r\n        {\"C_K\", true},\r\n        {\"C_Q\", true},\r\n        {\"S_J\", true},\r\n        {\"S_T\", true},\r\n        {\"S_7\", true},\r\n        {\"S_6\", true},\r\n        {\"S_5\", true},\r\n        {\"C_4\", true},\r\n        {\"C_3\", true},\r\n    },\r\n    evaluate = function (parts, hand)\r\n        if #parts._straight < 2 or #parts.akyrs_mflush < 2 then\r\n            return {}\r\n        end\r\n        return SMODS.merge_lists(parts.akyrs_all_straight, parts.akyrs_all_flushes)\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "PokerHand",
      "key": "twinstraightflush",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"twinstraightflush\",\r\n    visible = false,\r\n    chips = 2400, mult = 90,\r\n    l_chips = 210, l_mult = 60,\r\n    example = {\r\n        {\"C_A\", true},\r\n        {\"C_K\", true},\r\n        {\"C_Q\", true},\r\n        {\"S_J\", true},\r\n        {\"S_T\", true},\r\n        {\"S_7\", true},\r\n        {\"S_6\", true},\r\n        {\"S_5\", true},\r\n        {\"C_4\", true},\r\n        {\"C_3\", true},\r\n    },\r\n    evaluate = function (parts, hand)\r\n        if #parts._straight < 2 or #parts.akyrs_mflush < 2 then\r\n            return {}\r\n        end\r\n        return SMODS.merge_lists(parts.akyrs_all_straight, parts.akyrs_all_flushes)\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Rarity",
      "key": "emerald",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"emerald\",\r\n    default_weight = 0.3,\r\n    badge_colour = HEX('73ff33'),\r\n    disable_if_empty = true,\r\n    pools = {\r\n        [\"Joker\"] = true\r\n    },\r\n    get_weight = function(self, weight, object_type)\r\n        local x = SMODS.find_card(\"j_akyrs_emerald\")\r\n        return (G.GAME and next(x)) and 0.45 + 0.05 * #x or 0.02\r\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Rarity",
      "key": "supercommon",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"supercommon\",\r\n    default_weight = 0,\r\n    badge_colour = HEX('8c94a3'),\r\n    disable_if_empty = true,\r\n    pools = {\r\n        [\"Joker\"] = true\r\n    },",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Rarity",
      "key": "unique",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"unique\",\r\n    default_weight = 0,\r\n    badge_colour = HEX('ed9a78'),\r\n    pools = {\r\n        [\"Joker\"] = true\r\n    },",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "ConsumableType",
      "key": "Replicant",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"Replicant\",\n    primary_colour = HEX(\"a30262\"),\n    secondary_colour = HEX(\"ff9a56\"),\n    collection_rows = { 4, 4 },\n    shop_rate = 0,\n    default = \"c_akyrs_replicant_music_streaming\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "UndiscoveredSprite",
      "key": "Replicant",
      "name": null,
      "atlas": "replicant_undisc",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"Replicant\",\n    atlas = \"replicant_undisc\",\n    pos = {x=0, y=0}",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "replicant_forecast",
      "name": null,
      "atlas": "replicant",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"replicant_forecast\",\n    set = \"Replicant\",\n    atlas = \"replicant\",\n    pos = {x=0, y=0},\n    config = {\n        extras = 2,\n    },\n    can_use = function (self, card)\n        return true\n    end,\n    loc_vars = function (self, info_queue, card)\n        return {\n            vars = {\n                card.ability.extras,\n            }\n        }\n    end,\n    use = function (self, card, area, copier)\n        AKYRS.juice_like_tarot(card)\n        for i = 1, card.ability.extras do\n            if not AKYRS.has_room(G.consumeables) then break end\n            local _c = SMODS.add_card{set = \"Replicant\"}\n            _c:juice_up(0.3,0.3)\n        end\n    end",
      "config": {
        "extras": 2
      },
      "ability": {
        "extras": 2
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "replicant_connection",
      "name": null,
      "atlas": "replicant",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"replicant_connection\",\n    set = \"Replicant\",\n    atlas = \"replicant\",\n    pos = {x=1, y=0},\n    config = {\n        max_highlighted = 3,\n        extras = 2,\n    },\n    loc_vars = function (self, info_queue, card)\n        info_queue[#info_queue + 1] = { set = \"Other\", key = \"akyrs_crystalised\" }\n        return {\n            vars = {\n                card.ability.max_highlighted,\n                card.ability.extras,\n            }\n        }\n    end,\n    use = function (self, card, area, copier)\n        AKYRS.juice_like_tarot(card)\n        for _, c in ipairs(G.hand.highlighted) do\n            for i = 1, card.ability.extras do\n                AKYRS.simple_event_add(function ()\n                    local cnew = AKYRS.copy_p_card(c, nil, nil, nil, nil, G.hand)\n                    local s = pseudorandom_element(SMODS.Suits, \"akyrs_replicant_connection_suit\")\n                    local r = pseudorandom_element(SMODS.Ranks, \"akyrs_replicant_connection_rank\")\n                    SMODS.change_base(cnew, s.key, r.key)\n                    SMODS.Stickers.akyrs_crystalised:apply(cnew, true)\n                    SMODS.calculate_context({ playing_card_added = true, cards = { cnew }})\n                    return true\n                end, 0)\n            end\n        end\n    end",
      "config": {
        "max_highlighted": 3,
        "extras": 2
      },
      "ability": {
        "max_highlighted": 3,
        "extras": 2
      },
      "vars": [
        3,
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "replicant_steganography",
      "name": null,
      "atlas": "replicant",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"replicant_steganography\",\n    set = \"Replicant\",\n    atlas = \"replicant\",\n    pos = {x=2, y=0},\n    config = {\n        extras = 2,\n    },\n    loc_vars = function (self, info_queue, card)\n        info_queue[#info_queue+1] = { key = \"akyrs_concealed\", set = \"Other\" }\n        return {\n            vars = {\n                card.ability.extras,\n            }\n        }\n    end,\n    can_use = function (self, card)\n        return true\n    end,\n    use = function (self, card, area, copier)\n        AKYRS.juice_like_tarot(card)\n        if AKYRS.has_room(G.jokers) then\n            \n        end\n        for i = 1, card.ability.extras do\n            AKYRS.simple_event_add(function ()\n                if AKYRS.has_room(G.jokers) then\n                    local cnew = SMODS.add_card{ set = \"Joker\", rarity = 'Rare'}\n                    SMODS.Stickers.akyrs_concealed:apply(cnew, true)\n                end\n                return true\n            end, 0)\n        end\n    end",
      "config": {
        "extras": 2
      },
      "ability": {
        "extras": 2
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "replicant_database",
      "name": null,
      "atlas": "replicant",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"replicant_database\",\n    set = \"Replicant\",\n    atlas = \"replicant\",\n    pos = {x=3, y=0},\n    config = {\n        extras = {\n            add = 1,\n            disca = 1,\n        },\n    },\n    select_card = 'consumeables',\n    loc_vars = function (self, info_queue, card)\n        return {\n            vars = {\n                (math.max(G.GAME.starting_params.play_limit,G.GAME.starting_params.play_limit) + card.ability.extras.add),\n                card.ability.extras.disca,\n            }\n        }\n    end,\n    can_use = function (self, card)\n        return G.GAME.blind.in_blind\n    end,\n    use = function (self, card, area, copier)\n        AKYRS.juice_like_tarot(card)\n        local to_return = (math.max(G.GAME.starting_params.play_limit,G.GAME.starting_params.play_limit) + card.ability.extras.add)\n        local cards = AKYRS.pseudorandom_elements(G.hand.cards,to_return,pseudoseed(\"akyrs_replicant_db_select\"))\n        table.sort(cards, AKYRS.hand_sort_function)\n        for _,c in ipairs(cards) do\n            draw_card(c.area, G.deck, 0, \"down\", nil, c)\n        end\n        AKYRS.simple_event_add(function ()\n            ease_discard(card.ability.extras.disca)\n            G.deck:shuffle(\"akyrs_shuffled_db_replicant\")\n            AKYRS.fill_hand()\n            return true\n        end)\n    end,",
      "config": {
        "extras": {
          "add": 1,
          "disca": 1
        }
      },
      "ability": {
        "extras": {
          "add": 1,
          "disca": 1
        }
      },
      "vars": [
        null,
        null,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "replicant_short_form_content",
      "name": null,
      "atlas": "replicant",
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "key = \"replicant_short_form_content\",\n    set = \"Replicant\",\n    atlas = \"replicant\",\n    pos = {x=4, y=0},\n    config = {\n        extras = -1,\n        extras_mp = 1,\n    },\n    select_card = 'consumeables',\n    loc_vars = function (self, info_queue, card)\n        return {\n            vars = {\n                (AKYRS.is_mp() and card.ability.extras_mp or card.ability.extras),\n            },\n            key = self.key ..(AKYRS.is_mp() and \"_mp\" or \"\")\n        }\n    end,\n    can_use = function (self, card)\n        return G.STATE == G.STATES.BLIND_SELECT\n    end,\n    use = function (self, card, area, copier)\n        AKYRS.juice_like_tarot(card)\n        G.GAME.akyrs_sfc_used = (AKYRS.is_mp() and card.ability.extras_mp or card.ability.extras)\n        local blinds_candidate = AKYRS.filter_table(G.P_BLINDS, function (item)\n            return item.boss and item.boss.showdown and (not item.in_pool or item:in_pool())\n        end, false, true)\n        local blind_to_go = pseudorandom_element(blinds_candidate, \"akyrs_short_form_replicant\")\n        AKYRS.start_blind_arbitrarily(blind_to_go.key)\n    end",
      "config": {
        "extras": -1,
        "extras_mp": 1
      },
      "ability": {
        "extras": -1,
        "extras_mp": 1
      },
      "vars": [
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "replicant_smart_home",
      "name": null,
      "atlas": "replicant",
      "pos": {
        "x": 5,
        "y": 0
      },
      "raw": "key = \"replicant_smart_home\",\n    set = \"Replicant\",\n    atlas = \"replicant\",\n    pos = {x=5, y=0},\n    config = {\n        extras = 3,\n        min_highlighted = 0,\n        max_highlighted = 99999,\n    },\n    loc_vars = function (self, info_queue, card)\n        info_queue[#info_queue+1] = { key = \"akyrs_attention\", set = \"Other\" }\n        if not G.hand then return {\n            vars = {\n                \"???\", \"???\"\n            }\n        } end\n        local h = G.FUNCS.get_poker_hand_info(G.hand.highlighted)\n        return {\n            vars = {\n                card.ability.extras,\n                localize(h, \"poker_hands\") ~= \"ERROR\" and localize(h, \"poker_hands\") or \"???\", \n            }\n        }\n    end,\n    can_use = function (self, card)\n        return #G.hand.highlighted > 0 or AKYRS.is_mod_loaded(\"Cryptid\")\n    end,\n    use = function (self, card, area, copier)\n        AKYRS.simple_event_add(function ()\n            if #G.hand.highlighted > 0 or AKYRS.is_mod_loaded(\"Cryptid\") then\n                table.sort(G.hand.highlighted or {},AKYRS.hand_sort_function_immute)\n                AKYRS.juice_like_tarot(card)\n                local h = G.FUNCS.get_poker_hand_info(G.hand.highlighted)\n                SMODS.smart_level_up_hand(card, h, false, card.ability.extras)\n                AKYRS.do_things_to_card(G.hand.highlighted,\n                    function (cx)\n                        SMODS.Stickers.akyrs_attention:apply(cx, true)\n                    end\n                )\n            end\n            return true \n        end, 0)\n    end",
      "config": {
        "extras": 3,
        "min_highlighted": 0,
        "max_highlighted": 99999
      },
      "ability": {
        "extras": 3,
        "min_highlighted": 0,
        "max_highlighted": 99999
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "replicant_music_streaming",
      "name": null,
      "atlas": "replicant",
      "pos": {
        "x": 6,
        "y": 0
      },
      "raw": "key = \"replicant_music_streaming\",\n    set = \"Replicant\",\n    atlas = \"replicant\",\n    pos = {x=6, y=0},\n    config = {\n        min_highlighted = 0,\n        max_highlighted = 1,\n    },\n    loc_vars = function (self, info_queue, card)\n        info_queue[#info_queue+1] = { key = \"perishable\", set = \"Other\", vars = { G.GAME.perishable_rounds, G.GAME.perishable_rounds } }\n        return {\n            vars = {\n                card.ability.max_highlighted,\n            }\n        }\n    end,\n    can_use = function (self, card)\n        return #G.jokers.highlighted > card.ability.min_highlighted and #G.jokers.highlighted <= card.ability.max_highlighted\n    end,\n    use = function (self, card, area, copier)\n        AKYRS.juice_like_tarot(card)\n        local filtered = AKYRS.filter_table(G.jokers.highlighted, function (ca)\n            return not ca.ability.perishable\n        end, true, true)\n        AKYRS.do_things_to_card(filtered,\n            function (cx)\n                SMODS.Stickers.perishable:apply(cx, true)\n                SMODS.add_card{ set = \"Spectral\", edition = \"e_negative\" }\n            end\n        )\n    end",
      "config": {
        "min_highlighted": 0,
        "max_highlighted": 1
      },
      "ability": {
        "min_highlighted": 0,
        "max_highlighted": 1
      },
      "vars": [
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "replicant_file_sharing",
      "name": null,
      "atlas": "replicant",
      "pos": {
        "x": 7,
        "y": 0
      },
      "raw": "key = \"replicant_file_sharing\",\n    set = \"Replicant\",\n    atlas = \"replicant\",\n    pos = {x=7, y=0},\n    config = {\n    },\n    loc_vars = function (self, info_queue, card)\n        return {\n            vars = {\n                2,\n            }\n        }\n    end,\n    can_use = function (self, card)\n        local cards = AKYRS.filter_table(AKYRS.combine_table(G.jokers.highlighted, G.consumeables.highlighted, G.hand.highlighted),\n        function (ca)\n            return ca ~= card\n        end, true, true)\n        return #cards == 2\n    end,\n    use = function (self, card, area, copier)\n        AKYRS.juice_like_tarot(card)\n        local cards = AKYRS.filter_table(AKYRS.combine_table(G.jokers.highlighted, G.consumeables.highlighted, G.hand.highlighted),\n        function (ca)\n            return ca ~= card\n        end, true, true)\n        local card1 = cards[1]\n        local card2 = cards[2]\n        local card1ogarea = card1.area\n        local card2ogarea = card2.area\n        if card1 and card2 and card1.area and card2.area then\n            if not AKYRS.is_playing_card(card1) then\n                AKYRS.apply_random_p_attrib(card1)\n            end\n            if not AKYRS.is_playing_card(card2) then\n                AKYRS.apply_random_p_attrib(card2)\n            end\n            AKYRS.draw_cards_back_to_hand({card1}, card2ogarea)\n            AKYRS.draw_cards_back_to_hand({card2}, card1ogarea)\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "replicant_ota",
      "name": null,
      "atlas": "replicant",
      "pos": {
        "x": 8,
        "y": 0
      },
      "raw": "key = \"replicant_ota\",\n    set = \"Replicant\",\n    atlas = \"replicant\",\n    pos = {x=8, y=0},\n    config = {\n        extras = {\n            select = 2\n        }\n    },\n    loc_vars = function (self, info_queue, card)\n        info_queue[#info_queue+1] = { key = \"rental\", set = \"Other\", vars = { G.GAME.rental_rate } }\n        return {\n            vars = {\n                card.ability.extras.select,\n            }\n        }\n    end,\n    can_use = function (self, card)\n        local filtered = AKYRS.filter_table(G.jokers.cards, function (ca)\n            return not ca.ability.rental\n        end, true, true)\n        return #filtered >= card.ability.extras.select\n    end,\n    use = function (self, card, area, copier)\n        AKYRS.juice_like_tarot(card)\n        local filtered = AKYRS.filter_table(G.jokers.cards, function (ca)\n            return not ca.ability.rental\n        end, true, true)\n        local selected = AKYRS.pseudorandom_elements(filtered, card.ability.extras.select, \"akyrs_replicant_ota_jkr_select\")\n        AKYRS.do_things_to_card(selected,\n            function (cx)\n                SMODS.Stickers.rental:apply(cx, true)\n                SMODS.add_card{ set = \"Tarot\", edition = \"e_negative\" }\n            end\n        )\n    end",
      "config": {
        "extras": {
          "select": 2
        }
      },
      "ability": {
        "extras": {
          "select": 2
        }
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "replicant_daw",
      "name": null,
      "atlas": "replicant",
      "pos": {
        "x": 9,
        "y": 0
      },
      "raw": "key = \"replicant_daw\",\n    set = \"Replicant\",\n    atlas = \"replicant\",\n    pos = {x=9, y=0},\n    config = {\n    },\n    loc_vars = function (self, info_queue, card)\n        for _,ct in ipairs(G.P_CENTER_POOLS.Enhanced) do\n            if ct.akyrs_note_card then\n                info_queue[#info_queue+1] = ct\n            end\n        end\n    end,\n    can_use = function (self, card)\n        return #G.hand.cards >= 0\n    end,\n    use = function (self, card, area, copier)\n        AKYRS.juice_like_tarot(card)\n        local filtered = AKYRS.map(AKYRS.filter_table(G.P_CENTER_POOLS.Enhanced, function (ct)\n            return ct.akyrs_note_card\n        end, true, true), function (v, k)\n            return { value = v.key, weight = v.akyrs_note_card.weight }\n        end)\n        AKYRS.do_things_to_card(G.hand.cards,\n            function (cx)\n                local selected = AKYRS.weighted_randomiser(filtered, \"akyrs_replicant_daw_select\")\n                cx:set_ability(G.P_CENTERS[selected])\n            end\n        )\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "replicant_instant_messaging",
      "name": null,
      "atlas": "replicant",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"replicant_instant_messaging\",\n    set = \"Replicant\",\n    atlas = \"replicant\",\n    pos = {x=0, y=1},\n    config = {\n    },\n    loc_vars = function (self, info_queue, card)\n    end,\n    can_use = function (self, card)\n        return #G.hand.cards >= 0\n    end,\n    use = function (self, card, area, copier)\n        AKYRS.juice_like_tarot(card)\n        local candidates = AKYRS.filter_table(G.hand.cards, function (ct)\n            return not SMODS.has_no_rank(ct) and not SMODS.has_no_suit(ct) \n        end, true, true)\n        local ranks = AKYRS.map(candidates, function (v, k)\n            return v.config.card\n        end)\n        local shuffled = AKYRS.scramble_list(ranks, \"akyrs_replicant_im\")\n        AKYRS.do_things_to_card(candidates,\n            function (cx, inde)\n                cx:set_base(shuffled[inde])\n            end\n        )\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "replicant_enshittification",
      "name": null,
      "atlas": "replicant",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"replicant_enshittification\",\n    set = \"Replicant\",\n    atlas = \"replicant\",\n    pos = {x=1, y=1},\n    config = {\n    },\n    loc_vars = function (self, info_queue, card)\n        info_queue[#info_queue+1] = { key = \"eternal\", set = \"Other\" }\n        info_queue[#info_queue+1] = { key = \"rental\", set = \"Other\", vars = { G.GAME.rental_rate } }\n\n    end,\n    can_use = function (self, card)\n        return true\n    end,\n    use = function (self, card, area, copier)\n        AKYRS.juice_like_tarot(card)\n        local cd = SMODS.add_card({ edition = \"e_negative\", set = \"Joker\"})\n        SMODS.Stickers.eternal:apply(cd, true)\n        SMODS.Stickers.rental:apply(cd, true)\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "replicant_digital_art",
      "name": null,
      "atlas": "replicant",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"replicant_digital_art\",\n    set = \"Replicant\",\n    atlas = \"replicant\",\n    pos = {x=2, y=1},\n    config = {\n        extras = {\n            gain = 1,\n            give_away = -1,\n        }\n    },\n    loc_vars = function (self, info_queue, card)\n        return {\n            vars = {\n                card.ability.extras.give_away,\n                card.ability.extras.gain,\n            }\n        }\n    end,\n    can_use = function (self, card)\n        return G.GAME.starting_params.discard_limit > 1\n    end,\n    use = function (self, card, area, copier)\n        AKYRS.juice_like_tarot(card)\n        SMODS.change_discard_limit(card.ability.extras.give_away)\n        G.hand:change_size(card.ability.extras.gain)\n        if #G.hand.cards > 0 then\n            AKYRS.fill_hand()\n        end\n    end",
      "config": {
        "extras": {
          "gain": 1,
          "give_away": -1
        }
      },
      "ability": {
        "extras": {
          "gain": 1,
          "give_away": -1
        }
      },
      "vars": [
        -1,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "replicant_common_scam",
      "name": null,
      "atlas": "replicant",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"replicant_common_scam\",\n    set = \"Replicant\",\n    atlas = \"replicant\",\n    pos = {x=3, y=1},\n    config = {\n        extras = {\n            gain = 1,\n            give_away = -1,\n        }\n    },\n    loc_vars = function (self, info_queue, card)\n        return {\n            vars = {\n                card.ability.extras.give_away,\n                card.ability.extras.gain,\n            }\n        }\n    end,\n    can_use = function (self, card)\n        return G.GAME.starting_params.play_limit > 1\n    end,\n    use = function (self, card, area, copier)\n        AKYRS.juice_like_tarot(card)\n        SMODS.change_play_limit(card.ability.extras.give_away)\n        G.E_MANAGER:add_event(Event({func = function()\n            if G.jokers then \n                G.jokers.config.card_limit = G.jokers.config.card_limit + 1\n            end\n        return true end }))\n    end",
      "config": {
        "extras": {
          "gain": 1,
          "give_away": -1
        }
      },
      "ability": {
        "extras": {
          "gain": 1,
          "give_away": -1
        }
      },
      "vars": [
        -1,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "replicant_third_party_cookies",
      "name": null,
      "atlas": "replicant",
      "pos": {
        "x": 4,
        "y": 1
      },
      "raw": "key = \"replicant_third_party_cookies\",\n    set = \"Replicant\",\n    atlas = \"replicant\",\n    pos = {x=4, y=1},\n    config = {\n        extras = {\n        }\n    },\n    loc_vars = function (self, info_queue, card)\n        info_queue[#info_queue+1] = { key = \"akyrs_latticed\", set = \"Other\" }\n    end,\n    can_use = function (self, card)\n        return G.jokers.config.card_limit - #G.jokers.cards > 0\n    end,\n    use = function (self, card, area, copier)\n        AKYRS.juice_like_tarot(card)\n        local to_create = G.jokers.config.card_limit - #G.jokers.cards\n        local food_jokers = AKYRS.map(AKYRS.filter_table(G.P_CENTER_POOLS.Joker, function (val, ind)\n            return val.pools and val.pools.Food\n        end, true, true), function (val, index)\n            return val.key\n        end)\n        local candidates = AKYRS.pseudorandom_elements(food_jokers, to_create, \"akyrs_replicant_3rdparty\")\n        for _, key in ipairs(candidates) do\n            local cdx = SMODS.add_card({key = key, set = \"Joker\"})\n            SMODS.Stickers.akyrs_latticed:apply(cdx, true)\n        end\n    end",
      "config": {
        "extras": {}
      },
      "ability": {
        "extras": {}
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "replicant_silicon_fabrication",
      "name": null,
      "atlas": "replicant",
      "pos": {
        "x": 5,
        "y": 1
      },
      "raw": "key = \"replicant_silicon_fabrication\",\n    set = \"Replicant\",\n    atlas = \"replicant\",\n    pos = {x=5, y=1},\n    config = {\n    },\n    loc_vars = function (self, info_queue, card)\n        info_queue[#info_queue+1] = G.P_CENTERS.m_akyrs_wafer_card\n    end,\n    can_use = function (self, card)\n        local eligible_cards = AKYRS.filter_table(G.hand.cards, function (cfx, ind)\n            return cfx.config.center.key ~= \"m_akyrs_wafer_card\"\n        end, true, true)\n        return #G.hand.cards > 0 and #eligible_cards > 0\n    end,\n    use = function (self, card, area, copier)\n        AKYRS.juice_like_tarot(card)\n        local eligible_cards = AKYRS.filter_table(G.hand.cards, function (cfx, ind)\n            return cfx.config.center.key ~= \"m_akyrs_wafer_card\"\n        end, true, true)\n        local candidates = AKYRS.pseudorandom_elements(eligible_cards, 1, \"akyrs_replicant_3rdparty_wafer\")\n        for _, v in ipairs(candidates) do\n            AKYRS.remove_value_from_table(eligible_cards,v)\n        end\n        local candidates_edition = AKYRS.pseudorandom_elements(eligible_cards, 1, \"akyrs_replicant_3rdparty_edition\")\n        AKYRS.do_things_to_card(candidates, function (cardx, index)\n            cardx:set_ability(G.P_CENTERS.m_akyrs_wafer_card)\n        end)\n        AKYRS.do_things_to_card(candidates_edition, function (cardx, index)\n            cardx:set_edition('e_akyrs_dyed')\n        end)\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Seal",
      "key": "carmine",
      "name": null,
      "atlas": "aikoyoriStickers",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"carmine\",\n    atlas = 'aikoyoriStickers',\n    pos = {x = 1, y = 0},\n    badge_colour = HEX('4a3b3b'),\n    sound = { sound = 'generic1', per = 1.2, vol = 0.4 },\n\n    calculate = function(self, card, context)\n\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Seal",
      "key": "neon",
      "name": null,
      "atlas": "aikoyoriStickers",
      "pos": {
        "x": 5,
        "y": 1
      },
      "raw": "key = \"neon\",\n    atlas = 'aikoyoriStickers',\n    pos = {x = 5, y = 1},\n    badge_colour = HEX('5bbee0'),\n    sound = { sound = 'generic1', per = 1.2, vol = 0.4 },\n    loc_vars =function (self, info_queue, card)\n        info_queue[#info_queue+1] = AKYRS.DescriptionDummies['dd_akyrs_neon_seal_ex']\n    end,\n\n    calculate = function(self, card, context)\n        if context.main_scoring then\n            local h = AKYRS.filter_table(G.hand.cards, function (item)\n                return item.seal == \"akyrs_neon\"\n            end, true, true)\n            local p = AKYRS.filter_table(G.play.cards, function (item)\n                return item.seal == \"akyrs_neon\"\n            end, true, true)\n            local index = AKYRS.find_index(p, card)\n            if index and index <= math.min(#h,#p) then\n                return {\n                    func = function ()\n                        if AKYRS.has_room(G.consumeables) then\n                            SMODS.calculate_effect({\n                                message = localize(\"k_akyrs_plus_umbral\"),\n                            }, card)\n                            AKYRS.simple_event_add(function ()\n                                SMODS.add_card{ set = \"Umbral\" }\n                                h[index]:juice_up(0.5,0.5)\n                                return true\n                            end, 0)\n                        end\n                    end,\n                }\n            end\n        end\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Seal",
      "key": "twin",
      "name": null,
      "atlas": "aikoyoriStickers",
      "pos": {
        "x": 6,
        "y": 1
      },
      "raw": "key = \"twin\",\n    atlas = 'aikoyoriStickers',\n    pos = {x = 6, y = 1},\n    badge_colour = HEX('ff84a8'),\n    sound = { sound = 'generic1', per = 1.2, vol = 0.4 },\n\n    calculate = function(self, card, context)\n        if context.main_scoring and G.jokers and G.jokers.cards and context.area == G.play then\n            local copyable = AKYRS.filter_table(G.jokers.cards, function (item)\n                return item.config.center and item.config.center.blueprint_compat\n            end, true, true)\n            local joker = pseudorandom_element(copyable, \"akyrs_twin_seal_select_jonkler\")\n            if joker then\n                AKYRS.simple_event_add(function ()\n                    joker:juice_up(0.5,0.5)\n                    return true\n                end, 0)\n                local text,disp_text,poker_hands,scoring_hand,non_loc_disp_text = G.FUNCS.get_poker_hand_info(G.play.cards)\n                local ctx = {cardarea = G.jokers, full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands, joker_main = true}\n                local x = SMODS.blueprint_effect(card, joker, ctx)\n                return x\n            end\n        end\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Seal",
      "key": "fault",
      "name": null,
      "atlas": "aikoyoriStickers",
      "pos": {
        "x": 7,
        "y": 1
      },
      "raw": "key = \"fault\",\n    atlas = 'aikoyoriStickers',\n    pos = {x = 7, y = 1},\n    badge_colour = HEX('b7f058'),\n    sound = { sound = 'generic1', per = 1.2, vol = 0.4 },\n    loc_vars = function (self, info_queue, card)\n        local t = ((G.hand or {}).highlighted or {})\n        if G.STATE == G.STATES.HAND_PLAYED then\n            t = G.play.cards\n        end\n        local s = AKYRS.filter_table(t, function (item)\n            return item.seal == \"akyrs_fault\"\n        end, true, true)\n        local n, d = SMODS.get_probability_vars(card, 1, #s * #s, \"akyrs_fault_seal\")\n        return {\n            vars = {\n                #s == #t and #t > 0 and n or 0,\n                math.max(d, 0),\n                #s\n            }\n        }\n    end,\n    calculate = function(self, card, context)\n        if context.repetition then\n            local p = AKYRS.filter_table(G.play.cards, function (item)\n                return item.seal == \"akyrs_fault\"\n            end, true, true)\n            if #p == #G.play.cards and #p > 0 then\n                local roll = SMODS.pseudorandom_probability(card, \"akyrs_fault_seal\", 1, #p * #p) \n                if roll then\n                    return {\n                        message = localize('k_again_ex'),\n                        repetitions = #p,\n                    }\n                end\n            end\n\n        end\n    end,",
      "config": {},
      "ability": {},
      "vars": [
        0,
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Seal",
      "key": "deformed",
      "name": null,
      "atlas": "aikoyoriStickers",
      "pos": {
        "x": 8,
        "y": 1
      },
      "raw": "key = \"deformed\",\n    atlas = 'aikoyoriStickers',\n    pos = {x = 8, y = 1},\n    badge_colour = HEX('c76d71'),\n    sound = { sound = 'generic1', per = 1.2, vol = 0.4 },\n    loc_vars = function (self, info_queue, card)\n        info_queue[#info_queue+1] = { set = \"Other\", key = \"akyrs_self_destructs\"}\n    end,\n    calculate = function(self, card, context)\n        if context.press_play and card.area == G.hand and AKYRS.find_index(G.hand.highlighted, card) then\n            return {\n                func = function()\n                    AKYRS.simple_event_add(function() \n                        local c = AKYRS.copy_p_card(card, nil, nil, nil, nil, G.play)\n                        SMODS.Stickers.akyrs_self_destructs:apply(c, true)\n                        return true\n                    end, 0)\n                end\n            }\n        end\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Stake",
      "key": "outer",
      "name": null,
      "atlas": "aikoStakes",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"outer\",\r\n    atlas = \"aikoStakes\", pos = {x = 1, y = 1},\r\n    sticker_atlas = \"aikoStakeStickers\", sticker_pos = {x = 1, y = 1},\r\n    applied_stakes = {  },\r\n    modifiers = function ()\r\n        G.GAME.starting_params.hands = G.GAME.starting_params.hands + 1\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Stake",
      "key": "inner",
      "name": null,
      "atlas": "aikoStakes",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"inner\",\r\n    atlas = \"aikoStakes\", pos = {x = 2, y = 1},\r\n    sticker_atlas = \"aikoStakeStickers\", sticker_pos = {x = 2, y = 1},\r\n    applied_stakes = {  },\r\n    modifiers = function ()\r\n        G.GAME.starting_params.hand_size = G.GAME.starting_params.hand_size + 1\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Stake",
      "key": "copper",
      "name": null,
      "atlas": "aikoStakes",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"copper\",\r\n    atlas = \"aikoStakes\", pos = {x = 0, y = 0},\r\n    sticker_atlas = \"aikoStakeStickers\", sticker_pos = {x = 0, y = 0},\r\n    applied_stakes = { \"white\" },\r\n    prefix_config = { applied_stakes = { mod = false } },\r\n    colour = HEX(\"b74912\"),    \r\n    modifiers = function ()\r\n        G.GAME.modifiers.akyrs_spawn_oxidising = true\r\n    end",
      "config": {
        "applied_stakes": {
          "mod": false
        }
      },
      "ability": {
        "applied_stakes": {
          "mod": false
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Stake",
      "key": "lime",
      "name": null,
      "atlas": "aikoStakes",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"lime\",\r\n    atlas = \"aikoStakes\", pos = {x = 3, y = 1},\r\n    sticker_atlas = \"aikoStakeStickers\", sticker_pos = {x = 3, y = 1},\r\n    applied_stakes = { \"akyrs_copper\" },\r\n    prefix_config = { applied_stakes = { mod = false } },\r\n    colour = HEX(\"a8ff50\"),\r\n    modifiers = function ()\r\n        G.GAME.starting_params.ante_scaling = 1.5\r\n    end",
      "config": {
        "applied_stakes": {
          "mod": false
        }
      },
      "ability": {
        "applied_stakes": {
          "mod": false
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Stake",
      "key": "lemon",
      "name": null,
      "atlas": "aikoStakes",
      "pos": {
        "x": 4,
        "y": 1
      },
      "raw": "key = \"lemon\",\r\n    atlas = \"aikoStakes\", pos = {x = 4, y = 1},\r\n    sticker_atlas = \"aikoStakeStickers\", sticker_pos = {x = 4, y = 1},\r\n    applied_stakes = { \"akyrs_copper\" },\r\n    prefix_config = { applied_stakes = { mod = false } },\r\n    colour = HEX(\"f4e756\"),\r\n    modifiers = function ()\r\n        G.GAME.modifiers.scaling = 2\r\n    end",
      "config": {
        "applied_stakes": {
          "mod": false
        }
      },
      "ability": {
        "applied_stakes": {
          "mod": false
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Stake",
      "key": "turquoise",
      "name": null,
      "atlas": "aikoStakes",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "key = \"turquoise\",\r\n    atlas = \"aikoStakes\", pos = {x = 2, y = 2},\r\n    sticker_atlas = \"aikoStakeStickers\", sticker_pos = {x = 2, y = 2},\r\n    applied_stakes = { \"akyrs_lime\",\"akyrs_lemon\" },\r\n    prefix_config = { applied_stakes = { mod = false } },\r\n    colour = HEX(\"00ffff\"),    \r\n    modifiers = function ()\r\n        G.GAME.starting_params.dollars = G.GAME.starting_params.dollars + 1\r\n    end",
      "config": {
        "applied_stakes": {
          "mod": false
        }
      },
      "ability": {
        "applied_stakes": {
          "mod": false
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Stake",
      "key": "amethyst",
      "name": null,
      "atlas": "aikoStakes",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"amethyst\",\r\n    atlas = \"aikoStakes\", pos = {x = 1, y = 0},\r\n    sticker_atlas = \"aikoStakeStickers\", sticker_pos = {x = 1, y = 0},\r\n    applied_stakes = { \"akyrs_turquoise\" },\r\n    prefix_config = { applied_stakes = { mod = false } },\r\n    colour = HEX(\"f4e756\"),\r\n    calculate = function (self, context)\r\n        if context.blind_defeated then\r\n            local cards_with_no_crystals = AKYRS.filter_table(G.playing_cards, function (_card)\r\n                return not _card.ability.akyrs_crystalised\r\n            end)\r\n            local c2a = pseudorandom_element(cards_with_no_crystals, \"akyrs_amethyst_stake\")\r\n            if c2a then\r\n                SMODS.Stickers.akyrs_crystalised:apply(c2a, true)\r\n            end\r\n        end\r\n    end,\r\n    modifiers = function ()\r\n        G.GAME.starting_params.hands = G.GAME.starting_params.hands + 1\r\n    end",
      "config": {
        "applied_stakes": {
          "mod": false
        }
      },
      "ability": {
        "applied_stakes": {
          "mod": false
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Stake",
      "key": "wooden",
      "name": null,
      "atlas": "aikoStakes",
      "pos": {
        "x": 0,
        "y": 3
      },
      "raw": "key = \"wooden\",\r\n    atlas = \"aikoStakes\", pos = {x = 0, y = 3},\r\n    sticker_atlas = \"aikoStakeStickers\", sticker_pos = {x = 0, y = 3},\r\n    applied_stakes = { \"akyrs_amethyst\" },\r\n    prefix_config = { applied_stakes = { mod = false } },\r\n    colour = HEX(\"ad8455\"),\r\n    calculate = function (self, context)\r\n        if context.setting_blind then\r\n            AKYRS.simple_event_add(\r\n                function ()\r\n                    local _card = SMODS.add_card{ set = \"Base\", area = G.deck }\r\n                    SMODS.calculate_context({ playing_card_added = true, cards = { _card } })\r\n                    return true\r\n                end\r\n            )\r\n        end\r\n    end,\r\n    modifiers = function ()\r\n    end",
      "config": {
        "applied_stakes": {
          "mod": false
        }
      },
      "ability": {
        "applied_stakes": {
          "mod": false
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Stake",
      "key": "bismuth",
      "name": null,
      "atlas": "aikoStakes",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"bismuth\",\r\n    atlas = \"aikoStakes\", pos = {x = 3, y = 0},\r\n    sticker_atlas = \"aikoStakeStickers\", sticker_pos = {x = 3, y = 0},\r\n    applied_stakes = { \"akyrs_wooden\" },\r\n    prefix_config = { applied_stakes = { mod = false } },\r\n    colour = HEX(\"72db94\"),\r\n    calculate = function (self, context)\r\n    end,\r\n    modifiers = function ()\r\n        G.GAME.modifiers.akyrs_spawn_latticed = true\r\n    end,",
      "config": {
        "applied_stakes": {
          "mod": false
        }
      },
      "ability": {
        "applied_stakes": {
          "mod": false
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Stake",
      "key": "high_contrast",
      "name": null,
      "atlas": "aikoStakes",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"high_contrast\",\r\n    atlas = \"aikoStakes\", pos = {x = 0, y = 1},\r\n    sticker_atlas = \"aikoStakeStickers\", sticker_pos = {x = 0, y = 1},\r\n    applied_stakes = { \"akyrs_bismuth\" },\r\n    prefix_config = { applied_stakes = { mod = false } },\r\n    colour = HEX(\"f4ff12\"),\r\n    calculate = function (self, context)\r\n    end,\r\n    modifiers = function ()\r\n        G.GAME.modifiers.scaling = 3\r\n    end,",
      "config": {
        "applied_stakes": {
          "mod": false
        }
      },
      "ability": {
        "applied_stakes": {
          "mod": false
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Stake",
      "key": "hydrogel",
      "name": null,
      "atlas": "aikoStakes",
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "key = \"hydrogel\",\r\n    atlas = \"aikoStakes\", pos = {x = 4, y = 0},\r\n    sticker_atlas = \"aikoStakeStickers\", sticker_pos = {x = 4, y = 0},\r\n    applied_stakes = { \"akyrs_high_contrast\" },\r\n    prefix_config = { applied_stakes = { mod = false } },\r\n    colour = HEX(\"f4ff12\"),\r\n    calculate = function (self, context)\r\n        if context.blind_defeated then\r\n            local cards_with_no_crystals = AKYRS.filter_table(G.playing_cards, function (_card)\r\n                return not _card.ability.akyrs_crystalised\r\n            end)\r\n            local c2a = pseudorandom_element(cards_with_no_crystals, \"akyrs_amethyst_stake\")\r\n            if c2a then\r\n                SMODS.Stickers.akyrs_sus:apply(c2a, true)\r\n            end\r\n        end\r\n    end,\r\n    modifiers = function ()\r\n        G.GAME.modifiers.scaling = 3\r\n    end,",
      "config": {
        "applied_stakes": {
          "mod": false
        }
      },
      "ability": {
        "applied_stakes": {
          "mod": false
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Stake",
      "key": "spotify",
      "name": null,
      "atlas": "aikoStakes",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "key = \"spotify\",\r\n    atlas = \"aikoStakes\", pos = {x = 1, y = 2},\r\n    sticker_atlas = \"aikoStakeStickers\", sticker_pos = {x = 1, y = 2},\r\n    applied_stakes = { \"akyrs_hydrogel\" },\r\n    prefix_config = { applied_stakes = { mod = false } },\r\n    colour = HEX(\"60f78e\"),\r\n    calculate = function (self, context)\r\n        if context.blind_defeated then\r\n            local cards_with_no_rental = AKYRS.filter_table(G.jokers.cards, function (_card)\r\n                return not _card.ability.rental\r\n            end)\r\n            local c2a = pseudorandom_element(cards_with_no_rental, \"akyrs_amethyst_stake\")\r\n            if c2a then\r\n                SMODS.Stickers.rental:apply(c2a, true)\r\n            end\r\n        end\r\n    end,\r\n    modifiers = function ()\r\n        G.GAME.modifiers.scaling = 3\r\n    end,",
      "config": {
        "applied_stakes": {
          "mod": false
        }
      },
      "ability": {
        "applied_stakes": {
          "mod": false
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Stake",
      "key": "aluminium",
      "name": null,
      "atlas": "aikoStakes",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"aluminium\",\r\n    atlas = \"aikoStakes\", pos = {x = 2, y = 0},\r\n    sticker_atlas = \"aikoStakeStickers\", sticker_pos = {x = 2, y = 0},\r\n    applied_stakes = { \"akyrs_hydrogel\" },\r\n    prefix_config = { applied_stakes = { mod = false } },\r\n    colour = HEX(\"c4cbd9\"),\r\n    modifiers = function ()\r\n        G.GAME.win_ante = G.GAME.win_ante + 1\r\n    end,",
      "config": {
        "applied_stakes": {
          "mod": false
        }
      },
      "ability": {
        "applied_stakes": {
          "mod": false
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Stake",
      "key": "steam",
      "name": null,
      "atlas": "aikoStakes",
      "pos": {
        "x": 3,
        "y": 2
      },
      "raw": "key = \"steam\",\r\n    atlas = \"aikoStakes\", pos = {x = 3, y = 2},\r\n    sticker_atlas = \"aikoStakeStickers\", sticker_pos = {x = 3, y = 2},\r\n    applied_stakes = { \"akyrs_aluminium\" },\r\n    prefix_config = { applied_stakes = { mod = false } },\r\n    colour = HEX(\"60f78e\"),\r\n    modifiers = function ()\r\n        G.GAME.modifiers.akyrs_spawn_steam_sale = true\r\n    end,",
      "config": {
        "applied_stakes": {
          "mod": false
        }
      },
      "ability": {
        "applied_stakes": {
          "mod": false
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Stake",
      "key": "netherite",
      "name": null,
      "atlas": "aikoStakes",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = \"netherite\",\r\n    atlas = \"aikoStakes\", pos = {x = 0, y = 2},\r\n    sticker_atlas = \"aikoStakeStickers\", sticker_pos = {x = 0, y = 2},\r\n    applied_stakes = { \"akyrs_steam\", \"gold\" },\r\n    prefix_config = { applied_stakes = { mod = false } },\r\n    colour = HEX(\"3b3939\"),\r\n    modifiers = function ()\r\n        G.GAME.starting_params.discards = G.GAME.starting_params.discards + 1\r\n        G.GAME.starting_params.dollars = G.GAME.starting_params.dollars + 2\r\n    end,",
      "config": {
        "applied_stakes": {
          "mod": false
        }
      },
      "ability": {
        "applied_stakes": {
          "mod": false
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Stake",
      "key": "doom",
      "name": null,
      "atlas": "aikoStakes",
      "pos": {
        "x": 4,
        "y": 2
      },
      "raw": "key = \"doom\",\r\n    atlas = \"aikoStakes\", pos = {x = 4, y = 2},\r\n    sticker_atlas = \"aikoStakeStickers\", sticker_pos = {x = 4, y = 2},\r\n    applied_stakes = { \"akyrs_netherite\" },\r\n    prefix_config = { applied_stakes = { mod = false } },\r\n    colour = HEX(\"3b3939\"),\r\n    modifiers = function ()\r\n        G.GAME.modifiers.akyrs_spawn_self_destruct = true\r\n    end,",
      "config": {
        "applied_stakes": {
          "mod": false
        }
      },
      "ability": {
        "applied_stakes": {
          "mod": false
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sticker",
      "key": "self_destructs",
      "name": null,
      "atlas": "aikoyoriStickers",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"self_destructs\",\r\n    default_compat = true,\r\n    atlas = \"aikoyoriStickers\",\r\n    pos = {x = 0, y = 0},\r\n    rate = 0,\r\n    badge_colour = G.C.RED,\r\n    sets =  all_sets,\r\n    calculate = function(self, card, context)\r\n    end,\r\n    should_apply = function (self, card, center, area, bypass_reroll)\r\n        if self.sets[card.ability.set] then\r\n            if G.GAME.modifiers.akyrs_spawn_self_destruct and pseudorandom((area == G.pack_cards and 'akyrs_packs_self_destruct' or 'akyrs_self_destruct')..G.GAME.round_resets.ante) > 0.9 then\r\n                return true\r\n            end\r\n        end\r\n        return false\r\n    end,\r\n    apply = function(self, card, val)\r\n        card.ability[self.key] = val\r\n        card:set_cost()\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sticker",
      "key": "sigma",
      "name": null,
      "atlas": "aikoyoriStickers",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"sigma\",\r\n    default_compat = true,\r\n    atlas = \"aikoyoriStickers\",\r\n    pos = {x = 3, y = 0},\r\n    rate = 0,\r\n    badge_colour = HEX(\"ee36ff\"),\r\n    sets =  all_sets,\r\n    calculate = function(self, card, context)\r\n    end,\r\n    apply = function(self, card, val)\r\n        card.ability[self.key] = val\r\n        card.ability.akyrs_stay_sigma = true\r\n        card:set_cost()\r\n    end,\r\n    \r\n    draw = function (self, card, layer)\r\n        G.shared_stickers[self.key].role.draw_major = card\r\n        G.shared_stickers[self.key]:draw_shader('dissolve', nil, nil, nil, card.children.center)\r\n        G.shared_stickers[self.key]:draw_shader('akyrs_texelated', nil, card.ARGS.send_to_shader, nil, card.children.center)\r\n        G.shared_stickers[self.key]:draw_shader('voucher', nil, card.ARGS.send_to_shader, nil, card.children.center)\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sticker",
      "key": "oxidising",
      "name": null,
      "atlas": "aikoyoriStickers",
      "pos": {
        "x": 5,
        "y": 0
      },
      "raw": "key = \"oxidising\",\r\n    default_compat = true,\r\n    atlas = \"aikoyoriStickers\",\r\n    pos = {x = 5, y = 0},\r\n    rate = 0,\r\n    badge_colour = HEX(\"b74912\"),\r\n    sets =  all_sets,\r\n    should_apply = function (self, card, center, area, bypass_reroll)\r\n        if self.sets[card.ability.set] then\r\n            if G.GAME.modifiers.akyrs_spawn_oxidising and pseudorandom((area == G.pack_cards and 'akyrs_packs_oxi_' or 'akyrs_oxi_')..G.GAME.round_resets.ante) > 0.7 then\r\n                return true\r\n            end\r\n        end\r\n        return false\r\n    end,\r\n    loc_vars = function (self, info_queue, card)\r\n        info_queue[#info_queue+1] = AKYRS.DescriptionDummies[\"dd_akyrs_copper_scrape_tip\"]\r\n        return {\r\n            key = AKYRS.compare(card.ability[self.key],\">=\", 4) and self.key..\"_full\" or self.key,\r\n            vars = {\r\n                (card.ability[self.key] - 1) * 25,\r\n                localize(\"k_akyrs_copper_oxidation_stage_\"..card.ability[self.key]+1),\r\n                card.ability.akyrs_oxidising_round,\r\n                card.ability.akyrs_oxidising_round ~= 1 and localize(\"k_akyrs_round_plural\") or localize(\"k_akyrs_round_singular\"),\r\n                25\r\n            }\r\n        }\r\n    end,\r\n    apply = function(self, card, val)\r\n        if val == true then val = 1 else val = 0 end\r\n        card.ability[self.key] = val\r\n        card.ability.akyrs_oxidising_round = 2\r\n        card.cost = math.floor(card.cost / 2)\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.akyrs_copper_end_of_round then\r\n            return {\r\n                akyrs_ignore_copper_calculation = true,\r\n                func = function ()\r\n                    card.ability.akyrs_oxidising_round = card.ability.akyrs_oxidising_round - 1\r\n                    if AKYRS.compare(card.ability.akyrs_oxidising_round,\"<=\", 0) and AKYRS.compare(card.ability[self.key],\"<\", 4) then\r\n                        SMODS.calculate_effect({\r\n                            func = function ()\r\n                                card.ability[self.key] = card.ability[self.key] + 1\r\n                                card.ability.akyrs_oxidising_round = 2\r\n                            end\r\n                        }, card)\r\n                    end\r\n                end,\r\n                message = localize(\"k_akyrs_oxidise_ex\"),\r\n                colour = HEX(\"337a57\")\r\n            }\r\n        end\r\n        if context.using_consumeable then\r\n            return {\r\n                akyrs_ignore_copper_calculation = true,\r\n                func = function ()\r\n                    local psrd = pseudorandom(pseudoseed(\"akyrs_oxidising_scrape_\"..card.config.center_key))\r\n                    local cond = AKYRS.compare(card.ability[self.key],\">\", 1) or AKYRS.compare(card.ability.akyrs_oxidising_round,\"<\", 2)\r\n                    if cond and psrd >= 0.9 then\r\n                        SMODS.calculate_effect(\r\n                            {\r\n                                akyrs_ignore_copper_calculation = true,\r\n                                func = function ()\r\n                                    AKYRS.simple_event_add(\r\n                                        function ()\r\n                                            card.ability[self.key] = (card.ability[self.key] or 4) - 1\r\n                                            card.ability.akyrs_oxidising_round = 2\r\n                                            return true\r\n                                        end, 0\r\n                                    )\r\n                                end,\r\n                                message = localize(\"k_akyrs_scrape_ex\"),\r\n                                colour = HEX(\"994433\")\r\n                            }, card\r\n                        )\r\n                    elseif cond then\r\n                        SMODS.calculate_effect(\r\n                            {\r\n                                akyrs_ignore_copper_calculation = true,\r\n                                message = localize(\"k_nope_ex\"),\r\n                                colour = G.C.PURPLE\r\n                            }, card\r\n                        )\r\n                    end\r\n                end,\r\n            }\r\n        end\r\n    end,\r\n    draw = function (self, card, layer)\r\n        local val = card.ability.akyrs_oxidising and math.min(4,math.max(1,card.ability.akyrs_oxidising)) or 1\r\n        \r\n        AKYRS.copper_stickers[val] = AKYRS.copper_stickers[val] or Sprite(0, 0, G.CARD_W, G.CARD_H, G.ASSET_ATLAS[\"akyrs_aikoyoriStickers\"], { x = 4 + val, y = 0})\r\n        AKYRS.copper_stickers[val].role.draw_major = card\r\n        AKYRS.copper_stickers[val]:draw_shader('dissolve', nil, nil, nil, card.children.center)\r\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null,
        null,
        null,
        null,
        25
      ],
      "infoQueue": []
    },
    {
      "type": "Sticker",
      "key": "attention",
      "name": null,
      "atlas": "aikoyoriStickers",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"attention\",\r\n    default_compat = true,\r\n    atlas = \"aikoyoriStickers\",\r\n    pos = {x = 0, y = 1},\r\n    rate = 0,\r\n    badge_colour = HEX(\"FF6D6D\"),\r\n    sets =  { [\"Default\"] = true, [\"Enhanced\"] = true, [\"Base\"] = true },\r\n    apply = function(self, card, val)\r\n        card.ability[self.key] = val\r\n    end,\r\n    calculate = function (self, card, context)\r\n        if context.debuff_hand and card.area == G.hand then\r\n            local contains_attention = false\r\n            for _,_c in ipairs(context.full_hand) do\r\n                if _c.ability.akyrs_attention then\r\n                    contains_attention = true\r\n                end\r\n            end\r\n            if not contains_attention then\r\n                return {\r\n                    debuff = true,\r\n                    debuff_text = localize(\"k_akyrs_must_pay_attention\"),\r\n                    func = function ()\r\n                        AKYRS.simple_event_add(\r\n                            function()\r\n                                card:juice_up(0.2,0.2)\r\n                            return true\r\n                        end, 0)\r\n                    end\r\n                }\r\n            end\r\n        end\r\n        if context.destroy_card and context.cardarea == G.play then\r\n            if card == context.destroy_card then\r\n                return {\r\n                    remove = true\r\n                }\r\n            end\r\n        end\r\n    end,\r\n    draw = function (self, card, layer)\r\n        G.shared_stickers[self.key].role.draw_major = card\r\n        G.shared_stickers[self.key]:draw_shader('dissolve', nil, nil, nil, card.children.center)\r\n        G.shared_stickers[self.key]:draw_shader('voucher', nil, card.ARGS.send_to_shader, nil, card.children.center)\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sticker",
      "key": "concealed",
      "name": null,
      "atlas": "aikoyoriStickers",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"concealed\",\r\n    default_compat = true,\r\n    atlas = \"aikoyoriStickers\",\r\n    pos = {x = 1, y = 1},\r\n    rate = 0,\r\n    badge_colour = HEX(\"6394ff\"),\r\n    sets =  all_sets,\r\n    should_apply = function (self, card, center, area, bypass_reroll)\r\n        if self.sets[card.ability.set] then\r\n            if G.GAME.modifiers.akyrs_spawn_concealed and pseudorandom((area == G.pack_cards and 'akyrs_packs_concealed_' or 'akyrs_concealed_')..G.GAME.round_resets.ante) > 0.7 then\r\n                return true\r\n            end\r\n        end\r\n        return false\r\n    end,\r\n    apply = function (self, card, val)\r\n        card.ability[self.key] = val\r\n        card:set_ability(card.config.center)\r\n        card:set_sprites(card.config.center, card.config.base)\r\n        card.cost = 5\r\n        card.sell_cost = 3\r\n    end,\r\n    calculate = function(self, card, context)\r\n    end,    \r\n    draw = function (self, card, layer)\r\n        G.shared_stickers[self.key].role.draw_major = card\r\n        G.shared_stickers[self.key]:draw_shader('dissolve', nil, nil, nil, card.children.center)\r\n        G.shared_stickers[self.key]:draw_shader('voucher', nil, card.ARGS.send_to_shader, nil, card.children.center)\r\n    end",
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sticker",
      "key": "crystalised",
      "name": null,
      "atlas": "aikoyoriStickers",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"crystalised\",\r\n    default_compat = true,\r\n    atlas = \"aikoyoriStickers\",\r\n    pos = {x = 2, y = 1},\r\n    rate = 0,\r\n    badge_colour = HEX(\"d285ff\"),\r\n    sets =  { [\"Default\"] = true, [\"Enhanced\"] = true, [\"Base\"] = true },\r\n    calculate = function(self, card, context)\r\n        if context.debuff_hand and AKYRS.find_index(context.full_hand, card) then\r\n            return {\r\n                debuff = true,\r\n                debuff_text = localize(\"k_akyrs_crystalised_warning\"),\r\n                function ()\r\n                    AKYRS.simple_event_add(\r\n                        function()\r\n                            card:juice_up(0.2,0.2)\r\n                        return true\r\n                    end, 0)\r\n                end\r\n            }\r\n        end\r\n        if context.after and (context.cardarea == G.play or context.cardarea == 'unscored') then\r\n            return {\r\n                func = function()\r\n                    AKYRS.simple_event_add(\r\n                        function ()\r\n                            self:apply(card, false)\r\n                            AKYRS.juice_like_tarot(card)\r\n                            return true\r\n                        end\r\n                    )\r\n                end\r\n            }\r\n        end\r\n    end,    \r\n    draw = function (self, card, layer)\r\n        G.shared_stickers[self.key].role.draw_major = card\r\n        G.shared_stickers[self.key]:draw_shader('dissolve', nil, nil, nil, card.children.center)\r\n        G.shared_stickers[self.key]:draw_shader('voucher', nil, card.ARGS.send_to_shader, nil, card.children.center)\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sticker",
      "key": "latticed",
      "name": null,
      "atlas": "aikoyoriStickers",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"latticed\",\r\n    default_compat = true,\r\n    atlas = \"aikoyoriStickers\",\r\n    pos = {x = 3, y = 1},\r\n    rate = 0,\r\n    badge_colour = HEX(\"54bcc0\"),\r\n    sets =  { [\"Joker\"] = true },\r\n    should_apply = function (self, card, center, area, bypass_reroll)\r\n        if self.sets[card.ability.set] then\r\n            if G.GAME.modifiers.akyrs_spawn_latticed and center.eternal_compat and pseudorandom((area == G.pack_cards and 'akyrs_packs_latticed_' or 'akyrs_latticed_')..G.GAME.round_resets.ante) > 0.7 then\r\n                return true\r\n            end\r\n        end\r\n        return false\r\n    end,\r\n    draw = function (self, card, layer)\r\n        G.shared_stickers[self.key].role.draw_major = card\r\n        G.shared_stickers[self.key]:draw_shader('dissolve', nil, nil, nil, card.children.center)\r\n        G.shared_stickers[self.key]:draw_shader('voucher', nil, card.ARGS.send_to_shader, nil, card.children.center)\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sticker",
      "key": "sus",
      "name": null,
      "atlas": "aikoyoriStickers",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"sus\",\r\n    default_compat = true,\r\n    atlas = \"aikoyoriStickers\",\r\n    pos = {x = 2, y = 0},\r\n    rate = 0,\r\n    badge_colour = HEX(\"72c8dd\"),\r\n    sets =  { [\"Default\"] = true, [\"Enhanced\"] = true, [\"Base\"] = true },\r\n    calculate = function (self, card, context)\r\n    end,\r\n    draw = function (self, card, layer)\r\n        G.shared_stickers[self.key].role.draw_major = card\r\n        G.shared_stickers[self.key]:draw_shader('dissolve', nil, nil, nil, card.children.center)\r\n        G.shared_stickers[self.key]:draw_shader('voucher', nil, card.ARGS.send_to_shader, nil, card.children.center)\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sticker",
      "key": "sale",
      "name": null,
      "atlas": "aikoyoriStickers",
      "pos": {
        "x": 4,
        "y": 1
      },
      "raw": "key = \"sale\",\r\n    default_compat = true,\r\n    atlas = \"aikoyoriStickers\",\r\n    pos = {x = 4, y = 1},\r\n    rate = 0,\r\n    sets =  all_sets,\r\n    should_apply = function (self, card, center, area, bypass_reroll)\r\n        if self.sets[card.ability.set] then\r\n            if G.GAME.modifiers.akyrs_spawn_steam_sale and pseudorandom((area == G.pack_cards and 'akyrs_packs_sale_' or 'akyrs_sale_')..G.GAME.round_resets.ante) > 0.4 then\r\n                return true\r\n            end\r\n        end\r\n        return false\r\n    end,\r\n    badge_colour = HEX(\"749265\"),\r\n    sets =  all_sets,\r\n    config = {\r\n        extras = {\r\n            reduce = 0.5\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                self.config.extras.reduce\r\n            }\r\n        }\r\n    end,\r\n    apply = function (self, card, val)\r\n        card.ability[self.key] = val\r\n        card.cost = 1\r\n        card.sell_cost = 1\r\n    end,\r\n    calculate = function(self, card, context)\r\n        if context.end_of_round and not context.repetition and not context.individual then\r\n            if card.ability.akyrs_sale then\r\n                return {\r\n                    dollars = -self.config.extras.reduce\r\n                }\r\n            end\r\n        end\r\n    end,\r\n    calculate = function (self, card, context)\r\n    end,",
      "config": {
        "extras": {
          "reduce": 0.5
        }
      },
      "ability": {
        "extras": {
          "reduce": 0.5
        }
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Tag",
      "key": "spell_itself_tag",
      "name": null,
      "atlas": "akyrs_aikoyoriTags",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"spell_itself_tag\",\r\n    in_pool = function(self, args)\r\n        return G.GAME.akyrs_character_stickers_enabled and G.GAME.akyrs_wording_enabled\r\n    end,\r\n    loc_vars = function (self, info_queue, tag)\r\n        info_queue[#info_queue+1] = G.P_CENTERS[\"p_akyrs_mega_letter_pack_1\"]\r\n    end,\r\n    atlas = \"akyrs_aikoyoriTags\", pos = { x = 0, y = 0},\r\n    apply = function (self, tag, context)\r\n        if context.type == 'new_blind_choice' then\r\n            local lock = tag.ID\r\n            G.CONTROLLER.locks[lock] = true\r\n            tag:yep(\"+\",G.C.BLUE,function ()\r\n                local key = 'p_akyrs_mega_letter_pack_'..(math.random(1,2))\r\n                local card = Card(G.play.T.x + G.play.T.w/2 - G.CARD_W*1.27/2,\r\n                G.play.T.y + G.play.T.h/2-G.CARD_H*1.27/2, G.CARD_W*1.27, G.CARD_H*1.27, G.P_CARDS.empty, G.P_CENTERS[key], {bypass_discovery_center = true, bypass_discovery_ui = true})\r\n                card.cost = 0\r\n                card.from_tag = true\r\n                G.FUNCS.use_card({config = {ref_table = card}})\r\n                card:start_materialize()\r\n                G.CONTROLLER.locks[lock] = nil\r\n                return true\r\n            end)\r\n            tag.triggered = true\r\n            return true\r\n        end \r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Tag",
      "key": "umbral_tag",
      "name": null,
      "atlas": "akyrs_aikoyoriTags",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"umbral_tag\",\r\n    loc_vars = function (self, info_queue, tag)\r\n        info_queue[#info_queue+1] = G.P_CENTERS[\"p_akyrs_mega_umbral_pack_1\"]\r\n    end,\r\n    atlas = \"akyrs_aikoyoriTags\", pos = { x = 1, y = 0},\r\n    apply = function (self, tag, context)\r\n        if context.type == 'new_blind_choice' then\r\n            local lock = tag.ID\r\n            G.CONTROLLER.locks[lock] = true\r\n            tag:yep(\"+\",G.C.AKYRS_UMBRAL_P,function ()\r\n                local key = 'p_akyrs_mega_umbral_pack_'..(math.random(1,2))\r\n                local card = Card(G.play.T.x + G.play.T.w/2 - G.CARD_W*1.27/2,\r\n                G.play.T.y + G.play.T.h/2-G.CARD_H*1.27/2, G.CARD_W*1.27, G.CARD_H*1.27, G.P_CARDS.empty, G.P_CENTERS[key], {bypass_discovery_center = true, bypass_discovery_ui = true})\r\n                card.cost = 0\r\n                card.from_tag = true\r\n                G.FUNCS.use_card({config = {ref_table = card}})\r\n                card:start_materialize()\r\n                G.CONTROLLER.locks[lock] = nil\r\n                return true\r\n            end)\r\n            tag.triggered = true\r\n            return true\r\n        end \r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "ConsumableType",
      "key": "Umbral",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"Umbral\",\r\n    primary_colour = HEX(\"ffd45b\"),\r\n    secondary_colour = HEX(\"925ac3\"),\r\n    collection_rows = { 5, 5 },\r\n    shop_rate = 3,\r\n    default = \"c_akyrs_umbral_break_up\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "UndiscoveredSprite",
      "key": "Umbral",
      "name": null,
      "atlas": "umbra_undisc",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"Umbral\",\r\n    atlas = \"umbra_undisc\",\r\n    pos = {x=0, y=0}",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_graduate",
      "name": null,
      "atlas": "umbra",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_graduate\",\r\n    atlas = \"umbra\",\r\n    pos = {x=0,y=0},\r\n    loc_vars = function (self, info_queue, card)\r\n        local disallow = not not (G.GAME.akyrs_last_umbral == self.key or not G.GAME.akyrs_last_umbral)\r\n        local text = G.GAME.akyrs_last_umbral and localize{type = \"name_text\",key = G.GAME.akyrs_last_umbral, set = \"Umbral\"} or localize(\"ph_akyrs_unknown\")\r\n        if G.GAME.akyrs_last_umbral and not disallow then\r\n            info_queue[#info_queue+1] = G.P_CENTERS[G.GAME.akyrs_last_umbral]\r\n        end\r\n        return {\r\n            main_end = {\r\n                { n = G.UIT.R, config = { padding = 0.1, colour = disallow and G.C.RED or G.C.GREEN, r = 0.1}, nodes = {\r\n                    {\r\n                        n = G.UIT.T, config = {scale = 0.3, text = text}\r\n                    }\r\n                }}\r\n            }\r\n        }\r\n    end,\r\n    can_use = function (self, card)\r\n        return not (G.GAME.akyrs_last_umbral == self.key or not G.GAME.akyrs_last_umbral)\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.simple_event_add(function ()\r\n            AKYRS.juice_like_tarot(card)\r\n            local disallow = not not (G.GAME.akyrs_last_umbral == self.key or not G.GAME.akyrs_last_umbral)\r\n            if not disallow then\r\n                SMODS.add_card{key = G.GAME.akyrs_last_umbral}\r\n            end\r\n            return 0\r\n        end, 0)\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_realist",
      "name": null,
      "atlas": "umbra",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_realist\",\r\n    atlas = \"umbra\",\r\n    pos = {x=1,y=0},\r\n    config = {\r\n        max_highlighted = 1,\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        info_queue[#info_queue+1] = G.P_CENTERS[\"m_akyrs_insolate_card\"]\r\n        return {\r\n            vars = {\r\n                card.ability.max_highlighted\r\n            }\r\n        }\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.simple_event_add(function ()\r\n            AKYRS.juice_like_tarot(card)\r\n            AKYRS.do_things_to_card(G.hand.highlighted,function (_card)\r\n                _card:set_ability(G.P_CENTERS[\"m_akyrs_insolate_card\"])\r\n            end, {stay_flipped_delay = 1,stagger = 0.1, fifo = true})\r\n            return true\r\n        end, 0)\r\n    end",
      "config": {
        "max_highlighted": 1
      },
      "ability": {
        "max_highlighted": 1
      },
      "vars": [
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_tribal",
      "name": null,
      "atlas": "umbra",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_tribal\",\r\n    atlas = \"umbra\",\r\n    pos = {x=2,y=0},\r\n    config = {\r\n        min_highlighted = 0,\r\n        max_highlighted = 99999,\r\n    },\r\n    can_use = function (self, card)\r\n        return (G.hand.highlighted and #G.hand.highlighted > 0) or AKYRS.is_mod_loaded(\"Cryptid\")\r\n    end,\r\n    loc_vars = function (self, info_queue, card)\r\n        if not G.hand then return {\r\n            vars = {\r\n                \"???\", \"???\"\r\n            }\r\n        } end\r\n        local h = G.FUNCS.get_poker_hand_info(G.hand.highlighted)\r\n        local pl = AKYRS.get_planet_for_hand(h)\r\n        if pl then\r\n            info_queue[#info_queue+1] = G.P_CENTERS[pl]\r\n        end\r\n        return {\r\n            vars = {\r\n                localize(h, \"poker_hands\") ~= \"ERROR\" and localize(h, \"poker_hands\") or \"???\", \r\n                pl and localize({type = \"name_text\", set = \"Planet\", key = pl}) or \"???\",\r\n            }\r\n        }\r\n        \r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.simple_event_add(function ()\r\n            table.sort(G.hand.highlighted,AKYRS.hand_sort_function_immute)\r\n            AKYRS.juice_like_tarot(card)\r\n            local h = G.FUNCS.get_poker_hand_info(G.hand.highlighted)\r\n            local pl = AKYRS.get_planet_for_hand(h)\r\n            if pl then\r\n                SMODS.add_card{key = pl}\r\n            end\r\n            return true \r\n        end, 0)\r\n    end",
      "config": {
        "min_highlighted": 0,
        "max_highlighted": 99999
      },
      "ability": {
        "min_highlighted": 0,
        "max_highlighted": 99999
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_gambit",
      "name": null,
      "atlas": "umbra",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_gambit\",\r\n    atlas = \"umbra\",\r\n    pos = {x=3,y=0},\r\n    config = {\r\n        extras = 3,\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras\r\n            }\r\n        }\r\n    end,\r\n    can_use = function (self, card)\r\n        return #G.hand.cards > 0\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        local cards = AKYRS.pseudorandom_elements(G.hand.cards,card.ability.extras,pseudoseed(\"akyrs_umbral_gambit_c\"))\r\n        local rank = pseudorandom_element({\"King\",\"Queen\",\"Ace\"},pseudoseed(\"akyrs_umbral_gambit_r\"))\r\n        AKYRS.do_things_to_card(cards,function (_card)\r\n            _card = SMODS.change_base(_card,nil,rank)\r\n        end, {stay_flipped_delay = 1,stagger = 0.5,finish_flipped_delay = 0.5, fifo = true})\r\n    end",
      "config": {
        "extras": 3
      },
      "ability": {
        "extras": 3
      },
      "vars": [
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_kingpin",
      "name": null,
      "atlas": "umbra",
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_kingpin\",\r\n    atlas = \"umbra\",\r\n    pos = {x=4,y=0},\r\n    can_use = function (self, card)\r\n        return G.STATE == G.STATES.SELECTING_HAND or #G.hand.cards > 0\r\n    end,\r\n    config = {\r\n        extra = 2,\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extra\r\n            }\r\n        }\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        AKYRS.simple_event_add(\r\n            function ()\r\n                for i = 1, card.ability.extra do\r\n                    local c = SMODS.add_card{ area = G.hand, set = \"Base\", seal = SMODS.poll_seal({guaranteed = true,}), rank = \"King\" }\r\n                    c.pinned = true\r\n                    c:juice_up(0.3,0.3)\r\n                end\r\n                return true\r\n            end\r\n        )\r\n    end",
      "config": {
        "extra": 2
      },
      "ability": {
        "extra": 2
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_tea_time",
      "name": null,
      "atlas": "umbra",
      "pos": {
        "x": 5,
        "y": 0
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_tea_time\",\r\n    atlas = \"umbra\",\r\n    pos = {x=5,y=0},\r\n    config = {\r\n        min_highlighted = 1,\r\n        max_highlighted = 1\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        for _,k in ipairs(AKYRS.tea_cards) do\r\n            info_queue[#info_queue+1] = G.P_CENTERS[k] \r\n        end\r\n        return {\r\n            vars = {\r\n                card.ability.max_highlighted\r\n            }\r\n        }\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        AKYRS.do_things_to_card(G.hand.highlighted,function (_card)\r\n            local ench = pseudorandom_element(AKYRS.tea_cards,pseudoseed(\"akyrs_umbral_tea_time\"))\r\n            _card:set_ability(G.P_CENTERS[ench])\r\n        end, {stay_flipped_delay = 1,stagger = 0.5,finish_flipped_delay = 0.5, fifo = true})\r\n    end",
      "config": {
        "min_highlighted": 1,
        "max_highlighted": 1
      },
      "ability": {
        "min_highlighted": 1,
        "max_highlighted": 1
      },
      "vars": [
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_break_up",
      "name": null,
      "atlas": "umbra",
      "pos": {
        "x": 6,
        "y": 0
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_break_up\",\r\n    atlas = \"umbra\",\r\n    config = {\r\n        min_highlighted = 1,\r\n        max_highlighted = 1\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        info_queue[#info_queue+1] = AKYRS.DescriptionDummies[\"dd_akyrs_break_up_tip\"]\r\n\r\n        return {\r\n            vars = {\r\n                card.ability.max_highlighted\r\n            }\r\n        }\r\n    end,\r\n    can_use = function (self, card)\r\n        local has_no_rank, has_no_suit \r\n        for _, c in ipairs(G.hand.highlighted) do\r\n            if SMODS.has_no_suit(c) then\r\n                has_no_suit = true\r\n            end\r\n            if SMODS.has_no_rank(c) then\r\n                has_no_rank = true\r\n            end\r\n        end\r\n        return (#G.hand.highlighted <= card.ability.max_highlighted and #G.hand.highlighted >= card.ability.min_highlighted) and not (has_no_rank and has_no_suit)\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        for _, c in ipairs(G.hand.highlighted) do\r\n            if not SMODS.has_no_suit(c) then\r\n                local c2 = AKYRS.copy_p_card(c, nil, nil, G.playing_card)\r\n                c2.ability.akyrs_special_card_type = \"rank\"\r\n                c2:set_sprites(c2.config.center,c2.config.card)\r\n                SMODS.calculate_context({ playing_card_added = true, cards = { c2 } })\r\n            end\r\n            if not SMODS.has_no_rank(c) then\r\n                local c2 = AKYRS.copy_p_card(c, nil, nil, G.playing_card)\r\n                c2.ability.akyrs_special_card_type = \"suit\"\r\n                c2:set_sprites(c2.config.center,c2.config.card)\r\n                SMODS.calculate_context({ playing_card_added = true, cards = { c2 } })\r\n            end\r\n            -- requested by autumm\r\n            c.no_graveyard = true\r\n            -- no destroy context because it technically is not gone\r\n            c:start_dissolve({ G.C.AKYRS_UMBRAL_P, G.C.AKYRS_UMBRAL_Y, }, 1 )\r\n        end\r\n        \r\n    end,\r\n    pos = {x=6,y=0},",
      "config": {
        "min_highlighted": 1,
        "max_highlighted": 1
      },
      "ability": {
        "min_highlighted": 1,
        "max_highlighted": 1
      },
      "vars": [
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_public_transport",
      "name": null,
      "atlas": "umbra",
      "pos": {
        "x": 7,
        "y": 0
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_public_transport\",\r\n    atlas = \"umbra\",\r\n    pos = {x=7,y=0},\r\n    config = {\r\n        max_highlighted = 1,\r\n        akyrs_create = 2,\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.akyrs_create,\r\n                card.ability.max_highlighted\r\n            }\r\n        }\r\n    end,\r\n    use = function (z, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        local ud = pseudorandom_element({1,-1},pseudoseed(\"akyrs_umbral_pubtp_updown\"))\r\n        for _,_c in ipairs(G.hand.highlighted) do\r\n            for i = 1, card.ability.akyrs_create do\r\n                local c2 = AKYRS.copy_p_card(_c, nil, nil, G.playing_card)\r\n                if SMODS.has_no_rank(c2) then\r\n                    unlock_achievement(\"ach_akyrs_literally_cryptid\")\r\n                end\r\n                if not c2.is_null then\r\n                    c2 = SMODS.modify_rank(c2, ud*i)\r\n                end\r\n                SMODS.calculate_context({ playing_card_added = true, cards = { c2 } })\r\n                if c2 then c2:juice_up(0.3,0.3) end\r\n            end\r\n            AKYRS.deselect_from_area(_c)\r\n            \r\n        end\r\n    end",
      "config": {
        "max_highlighted": 1,
        "akyrs_create": 2
      },
      "ability": {
        "max_highlighted": 1,
        "akyrs_create": 2
      },
      "vars": [
        2,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_corruption",
      "name": null,
      "atlas": "umbra",
      "pos": {
        "x": 8,
        "y": 0
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_corruption\",\r\n    atlas = \"umbra\",\r\n    pos = {x=8,y=0},\r\n    can_use = function (self, card)\r\n        return #G.hand.cards > 0 \r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        local ud = pseudorandom_element({\"dupe\",\"destroy\"},pseudoseed(\"akyrs_umbral_corrupt_pick\"))\r\n        local cds = AKYRS.pseudorandom_elements(G.hand.cards,math.ceil(#G.hand.cards/2),pseudoseed(\"akyrs_umbral_corrupt_cards\"))\r\n        for _,_card in ipairs(cds) do\r\n            if ud == \"dupe\" then\r\n                local c2 = AKYRS.copy_p_card(_card)\r\n                SMODS.calculate_context({ playing_card_added = true, cards = { c2 } })\r\n            else\r\n                SMODS.calculate_context({ remove_playing_cards = true, removed = _card})\r\n                _card:start_dissolve({G.C.AKYRS_UMBRAL_P,G.C.AKYRS_UMBRAL_P},1)\r\n            end\r\n        end\r\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_fomo",
      "name": null,
      "atlas": "umbra",
      "pos": {
        "x": 9,
        "y": 0
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_fomo\",\r\n    atlas = \"umbra\",\r\n    pos = {x=9,y=0},\r\n    config = {\r\n        extras = {\r\n            create = 1,\r\n            take = 12\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras.create,\r\n                card.ability.extras.take\r\n            }\r\n        }\r\n    end,\r\n    can_use = function (self, card)\r\n        -- wtf? talisman\r\n        for _,v in ipairs(G.GAME.current_round.voucher) do\r\n            if G.GAME.akyrs_list_of_generated_but_not_redeemed_vouchers[v] then\r\n                return false\r\n            end\r\n        end\r\n        return #G.GAME.akyrs_list_of_generated_but_not_redeemed_vouchers > 0 and AKYRS.can_afford(card.ability.extras.take)\r\n    end,\r\n    in_pool = function (self, args)\r\n        return #G.GAME.akyrs_list_of_generated_but_not_redeemed_vouchers > 0\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        ease_dollars(-card.ability.extras.take)\r\n        for i = 1, card.ability.extras.create do\r\n            local to_redeem = pseudorandom_element(G.GAME.akyrs_list_of_generated_but_not_redeemed_vouchers,pseudoseed(\"akyrs_umbral_fomo_voucher\"))\r\n            local _c = SMODS.create_card{ set = \"Voucher\", key = to_redeem }\r\n            _c.cost = 0\r\n            G.play:emplace(_c)\r\n            _c:redeem()\r\n            if G.shop_vouchers and G.shop_vouchers.cards then\r\n                for _,_cds in ipairs(G.shop_vouchers.cards) do\r\n                    if _cds.config.center_key == to_redeem then\r\n                        _cds:remove()\r\n                    end\r\n                end\r\n            end\r\n            AKYRS.simple_event_add(\r\n                function ()\r\n                    _c:start_dissolve(nil,2)\r\n                    return true\r\n                end, 1\r\n            )\r\n        end\r\n    end",
      "config": {
        "extras": {
          "create": 1,
          "take": 12
        }
      },
      "ability": {
        "extras": {
          "create": 1,
          "take": 12
        }
      },
      "vars": [
        1,
        12
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_misfortune",
      "name": null,
      "atlas": "umbra",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_misfortune\",\r\n    atlas = \"umbra\",\r\n    pos = {x=0,y=1},\r\n    config = {\r\n        max_highlighted = 2\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        info_queue[#info_queue+1] = G.P_CENTERS[\"m_akyrs_hatena\"]\r\n        info_queue[#info_queue+1] = G.P_CENTERS[\"m_akyrs_item_box\"]\r\n        return {\r\n            vars = {\r\n                card.ability.max_highlighted\r\n            }\r\n        }\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        AKYRS.do_things_to_card(G.hand.highlighted,\r\n            function (_c)\r\n                if _c.config.center_key == \"m_akyrs_hatena\" then\r\n                    _c:set_ability(G.P_CENTERS[\"m_akyrs_item_box\"])\r\n                else\r\n                    _c:set_ability(G.P_CENTERS[\"m_akyrs_hatena\"])\r\n                end\r\n                AKYRS.deselect_from_area(_c)\r\n            end\r\n        )\r\n    end",
      "config": {
        "max_highlighted": 2
      },
      "ability": {
        "max_highlighted": 2
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_book_smart",
      "name": null,
      "atlas": "umbra",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_book_smart\",\r\n    atlas = \"umbra\",\r\n    pos = {x=1,y=1},\r\n    config = {\r\n        extras = 2,\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras\r\n            }\r\n        }\r\n    end,\r\n    can_use = function (self, card)\r\n        return true\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        for i = 1, card.ability.extras do\r\n            if not AKYRS.has_room(G.consumeables) then break end\r\n            local _c = SMODS.add_card{set = \"Umbral\"}\r\n            _c:juice_up(0.3,0.3)\r\n        end\r\n    end",
      "config": {
        "extras": 2
      },
      "ability": {
        "extras": 2
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_prisoner",
      "name": null,
      "atlas": "umbra",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_prisoner\",\r\n    atlas = \"umbra\",\r\n    pos = {x=2,y=1},\r\n    config = {\r\n        max_highlighted = 2\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        info_queue[#info_queue+1] = G.P_CENTERS[\"m_akyrs_brick_card\"]\r\n        return {\r\n            vars = {\r\n                card.ability.max_highlighted\r\n            }\r\n        }\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        AKYRS.do_things_to_card(G.hand.highlighted,\r\n            function (_c)\r\n                _c:set_ability(G.P_CENTERS[\"m_akyrs_brick_card\"])\r\n                AKYRS.deselect_from_area(_c)\r\n            end\r\n        )\r\n    end",
      "config": {
        "max_highlighted": 2
      },
      "ability": {
        "max_highlighted": 2
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_overgrowth",
      "name": null,
      "atlas": "umbra",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_overgrowth\",\r\n    atlas = \"umbra\",\r\n    pos = {x=3,y=1},\r\n    config = {\r\n        max_highlighted = 4\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        info_queue[#info_queue+1] = G.P_CENTERS[\"m_akyrs_canopy_card\"]\r\n        return {\r\n            vars = {\r\n                card.ability.max_highlighted\r\n            }\r\n        }\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        AKYRS.do_things_to_card(G.hand.highlighted,\r\n            function (_c)\r\n                _c:set_ability(G.P_CENTERS[\"m_akyrs_canopy_card\"])\r\n                AKYRS.deselect_from_area(_c)\r\n            end\r\n        )\r\n    end",
      "config": {
        "max_highlighted": 4
      },
      "ability": {
        "max_highlighted": 4
      },
      "vars": [
        4
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_intrusive_thoughts",
      "name": null,
      "atlas": "umbra",
      "pos": {
        "x": 4,
        "y": 1
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_intrusive_thoughts\",\r\n    atlas = \"umbra\",\r\n    pos = {x=4,y=1},\r\n    config = {\r\n        extras = {\r\n            xmoney = 3,\r\n            setdollarmult = 2,\r\n            emoney = 2,\r\n            odds = 0.5,\r\n        }\r\n    },\r\n    \r\n    calculate = function (self, card, context)\r\n        if context.selling_card and context.card == card then\r\n            local die_question_mark = SMODS.pseudorandom_probability(card,\"akyrs_umbral_intrusive\",1 ,2, \"akyrs_umbral_intrusive\", true)\r\n            return {\r\n                message = localize(\"k_akyrs_umbral_intrusive_\"..(die_question_mark and \"would_die\" or \"would_win\")),\r\n                colour = (die_question_mark and G.C.GREEN or G.C.RED),\r\n                func = function ()\r\n                    AKYRS.force_save()\r\n                end\r\n            }\r\n        end\r\n    end,\r\n    loc_vars = function (self, info_queue, card)\r\n        G.GAME.akyrs_umbral_intrusive_usage_set = G.GAME.akyrs_umbral_intrusive_usage_set or -4\r\n        return {\r\n            key = self.key .. (AKYRS.bal(\"absurd\") and \"_absurd\" or \"\"),\r\n            vars = {\r\n                AKYRS.bal(\"absurd\") and card.ability.extras.emoney or card.ability.extras.xmoney,\r\n                card.ability.extras.odds * 100,\r\n                SMODS.signed_dollars(G.GAME.akyrs_umbral_intrusive_usage_set)\r\n            }\r\n        }\r\n    end,\r\n    can_use = function (self, card)\r\n        return true\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        local die_question_mark = SMODS.pseudorandom_probability(card,\"akyrs_umbral_intrusive\",card.ability.extras.odds ,1, \"akyrs_umbral_intrusive\", true)\r\n        local d_dollar = 0\r\n        if die_question_mark then\r\n            if AKYRS.bal(\"absurd\") then\r\n                if G.STAGE == G.STAGES.RUN then \r\n                    G.GAME.akyrs_defeated_by_center = self.key\r\n                    G.TAROT_INTERRUPT = nil\r\n                    G.STATE = G.STATES.GAME_OVER; G.STATE_COMPLETE = false \r\n                end\r\n            else\r\n                AKYRS.simple_event_add(\r\n                    function ()\r\n                        d_dollar = -G.GAME.dollars + G.GAME.akyrs_umbral_intrusive_usage_set\r\n                        ease_dollars(d_dollar)\r\n                        G.GAME.akyrs_umbral_intrusive_usage_set = -4\r\n                        return true\r\n                    end, 0\r\n                )\r\n            end\r\n        else\r\n            if AKYRS.bal(\"absurd\") then\r\n                AKYRS.simple_event_add(\r\n                    function ()\r\n                        if Talisman and type(to_big(G.GAME.dollars)) == \"table\" then\r\n                            d_dollar = to_big(G.GAME.dollars):pow(card.ability.extras.emoney) - to_big(G.GAME.dollars)\r\n                        else\r\n                            d_dollar = G.GAME.dollars ^ card.ability.extras.emoney - G.GAME.dollars\r\n                        end\r\n                        ease_dollars(d_dollar)\r\n                        return true\r\n                    end, 0\r\n                )\r\n            else\r\n                AKYRS.simple_event_add(\r\n                    function ()\r\n                        d_dollar = G.GAME.dollars * ( card.ability.extras.xmoney - 1 )\r\n                        G.GAME.akyrs_umbral_intrusive_usage_set = (G.GAME.akyrs_umbral_intrusive_usage_set or -4) * card.ability.extras.setdollarmult\r\n                        ease_dollars(d_dollar)\r\n                        return true\r\n                    end, 0\r\n                )\r\n            end\r\n        end\r\n        AKYRS.force_save()\r\n    end",
      "config": {
        "extras": {
          "xmoney": 3,
          "setdollarmult": 2,
          "emoney": 2,
          "odds": 0.5
        }
      },
      "ability": {
        "extras": {
          "xmoney": 3,
          "setdollarmult": 2,
          "emoney": 2,
          "odds": 0.5
        }
      },
      "vars": [
        2,
        50,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_weeping_angel",
      "name": null,
      "atlas": "umbra",
      "pos": {
        "x": 5,
        "y": 1
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_weeping_angel\",\r\n    atlas = \"umbra\",\r\n    pos = {x=5,y=1},\r\n    config = {\r\n        extras = 2\r\n    },\r\n    can_use = function (self, card)\r\n        return #G.hand.cards > 0\r\n    end,\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras\r\n            }\r\n        }\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        for _,_c in ipairs(G.hand.cards) do\r\n            AKYRS.simple_event_add(\r\n                function ()\r\n                    play_sound('card1')\r\n                    _c:juice_up(0.3, 0.3)\r\n                    _c:flip()\r\n                    return true\r\n                end, 0.25\r\n            )\r\n        end\r\n        AKYRS.simple_event_add(\r\n            function ()\r\n                local money_obtain = 0\r\n                for _,_c in ipairs(G.hand.cards) do\r\n                    if _c.facing == \"back\" then\r\n                        money_obtain = money_obtain + card.ability.extras\r\n                    end\r\n                end\r\n                if money_obtain ~= 0 then\r\n                    ease_dollars(money_obtain)\r\n                end\r\n                return true\r\n            end, 0.25\r\n        )\r\n    end",
      "config": {
        "extras": 2
      },
      "ability": {
        "extras": 2
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_bunker",
      "name": null,
      "atlas": "umbra",
      "pos": {
        "x": 6,
        "y": 1
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_bunker\",\r\n    atlas = \"umbra\",\r\n    pos = {x=6,y=1},\r\n    config = {\r\n        max_highlighted = 1\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.max_highlighted\r\n            }\r\n        }\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        AKYRS.do_things_to_card(\r\n            G.hand.highlighted,\r\n            function (_card)\r\n                local ench = SMODS.poll_enhancement({guaranteed = true, key = \"akyrs_umbral_bunker_ench\"})\r\n                local edition = poll_edition(\"akyrs_umbral_bunker_edition\", nil, nil, true)\r\n                local seal = SMODS.poll_seal({guaranteed = true, key = \"akyrs_umbral_bunker_seal\"})\r\n                _card:set_ability(G.P_CENTERS[ench])\r\n                _card:set_seal(seal)\r\n                _card:set_edition(edition)\r\n                _card.ability.akyrs_forced_selection = true\r\n            end\r\n        )\r\n    end",
      "config": {
        "max_highlighted": 1
      },
      "ability": {
        "max_highlighted": 1
      },
      "vars": [
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_rock",
      "name": null,
      "atlas": "umbra",
      "pos": {
        "x": 7,
        "y": 1
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_rock\",\r\n    atlas = \"umbra\",\r\n    pos = {x=7,y=1},\r\n    config = {\r\n        extras = 10\r\n    },\r\n    can_use = function (self, card)\r\n        return #G.hand.cards > 0\r\n    end,\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras\r\n            }\r\n        }\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        for _,_c in ipairs(G.hand.cards) do\r\n            AKYRS.simple_event_add(\r\n                function ()\r\n                    _c.ability.perma_bonus = _c.ability.perma_bonus + card.ability.extras\r\n                    _c:juice_up(0.3, 0.3)\r\n                    play_sound(\"tarot1\")\r\n                    return true\r\n                end\r\n            )\r\n        end\r\n    end",
      "config": {
        "extras": 10
      },
      "ability": {
        "extras": 10
      },
      "vars": [
        10
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_crust",
      "name": null,
      "atlas": "umbra",
      "pos": {
        "x": 8,
        "y": 1
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_crust\",\r\n    atlas = \"umbra\",\r\n    pos = {x=8,y=1},\r\n    config = {\r\n        extras = 0.1\r\n    },\r\n    can_use = function (self, card)\r\n        return #G.hand.cards > 0\r\n    end,\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras\r\n            }\r\n        }\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        for _,_c in ipairs(G.hand.cards) do\r\n            if _c:is_suit(\"Clubs\") then\r\n                AKYRS.simple_event_add(\r\n                    function ()\r\n                        _c.ability.perma_x_mult = _c.ability.perma_x_mult + card.ability.extras\r\n                        _c:juice_up(0.3, 0.3)\r\n                        play_sound(\"tarot1\")\r\n                        return true\r\n                    end\r\n                )\r\n            end\r\n        end\r\n    end",
      "config": {
        "extras": 0.1
      },
      "ability": {
        "extras": 0.1
      },
      "vars": [
        0.1
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_mantle",
      "name": null,
      "atlas": "umbra",
      "pos": {
        "x": 9,
        "y": 1
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_mantle\",\r\n    atlas = \"umbra\",\r\n    pos = {x=9,y=1},\r\n    config = {\r\n        extras = 0.1\r\n    },\r\n    can_use = function (self, card)\r\n        return #G.hand.cards > 0\r\n    end,\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras\r\n            }\r\n        }\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        for _,_c in ipairs(G.hand.cards) do\r\n            if _c:is_suit(\"Spades\") then\r\n                AKYRS.simple_event_add(\r\n                    function ()\r\n                        _c.ability.perma_x_chips = _c.ability.perma_x_chips + card.ability.extras\r\n                        _c:juice_up(0.3, 0.3)\r\n                        play_sound(\"tarot1\")\r\n                        return true\r\n                    end\r\n                )\r\n            end\r\n        end\r\n    end",
      "config": {
        "extras": 0.1
      },
      "ability": {
        "extras": 0.1
      },
      "vars": [
        0.1
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_core",
      "name": null,
      "atlas": "umbra",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_core\",\r\n    atlas = \"umbra\",\r\n    pos = {x=0,y=2},\r\n    config = {\r\n        extras = 1\r\n    },\r\n    can_use = function (self, card)\r\n        return #G.hand.cards > 0\r\n    end,\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras\r\n            }\r\n        }\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        for _,_c in ipairs(G.hand.cards) do\r\n            if _c:is_suit(\"Hearts\") then\r\n                AKYRS.simple_event_add(\r\n                    function ()\r\n                        _c.ability.perma_p_dollars = _c.ability.perma_p_dollars + card.ability.extras\r\n                        _c:juice_up(0.3, 0.3)\r\n                        play_sound(\"tarot1\")\r\n                        return true\r\n                    end\r\n                )\r\n            end\r\n        end\r\n    end",
      "config": {
        "extras": 1
      },
      "ability": {
        "extras": 1
      },
      "vars": [
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_atmosphere",
      "name": null,
      "atlas": "umbra",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_atmosphere\",\r\n    atlas = \"umbra\",\r\n    pos = {x=1,y=2},\r\n    config = {\r\n    },\r\n    can_use = function (self, card)\r\n        return #G.hand.cards > 0\r\n    end,\r\n    loc_vars = function (self, info_queue, card)\r\n        G.GAME.akyrs_umbral_atmosphere_score_inc = G.GAME.akyrs_umbral_atmosphere_score_inc or 100\r\n        G.GAME.akyrs_umbral_atmosphere_uses = G.GAME.akyrs_umbral_atmosphere_uses or 0\r\n        return {\r\n            vars = {\r\n                G.GAME.akyrs_umbral_atmosphere_score_inc,\r\n                G.GAME.akyrs_umbral_atmosphere_score_inc + 100 * (G.GAME.akyrs_umbral_atmosphere_uses + 1)^2\r\n            }\r\n        }\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        G.GAME.akyrs_umbral_atmosphere_score_inc = G.GAME.akyrs_umbral_atmosphere_score_inc or 100\r\n        G.GAME.akyrs_umbral_atmosphere_uses = (G.GAME.akyrs_umbral_atmosphere_uses or 0) + 1\r\n        for _,_c in ipairs(G.hand.cards) do\r\n            if _c:is_suit(\"Diamonds\") then\r\n                AKYRS.simple_event_add(\r\n                    function ()\r\n                        _c.ability.akyrs_perma_score = _c.ability.akyrs_perma_score + G.GAME.akyrs_umbral_atmosphere_score_inc\r\n                        _c:juice_up(0.3, 0.3)\r\n                        play_sound(\"tarot1\")\r\n                        return true\r\n                    end\r\n                )\r\n            end\r\n        end\r\n        AKYRS.simple_event_add(\r\n            function ()\r\n                G.GAME.akyrs_umbral_atmosphere_score_inc =  G.GAME.akyrs_umbral_atmosphere_score_inc + 100 * (G.GAME.akyrs_umbral_atmosphere_uses)^2\r\n                return true\r\n            end, 0\r\n        )\r\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_nyctophobia",
      "name": null,
      "atlas": "umbra",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_nyctophobia\",\r\n    atlas = \"umbra\",\r\n    pos = {x=2,y=2},\r\n    can_use = function (self, card)\r\n        return true\r\n    end,\r\n    config = {\r\n        extra = 1\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extra\r\n            }\r\n        }\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        for i = 1, card.ability.extra do\r\n            local c = SMODS.add_card{ edition = \"e_negative\", set = \"Tarot\"}\r\n            c:juice_up(0.3, 0.3)\r\n        end\r\n    end",
      "config": {
        "extra": 1
      },
      "ability": {
        "extra": 1
      },
      "vars": [
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_puzzle",
      "name": null,
      "atlas": "umbra",
      "pos": {
        "x": 3,
        "y": 2
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_puzzle\",\r\n    atlas = \"umbra\",\r\n    pos = {x=3,y=2},\r\n    config = {\r\n        min_highlighted = 2,\r\n        max_highlighted = 2,\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        if G.GAME.akyrs_character_stickers_enabled and AKYRS.config.show_joker_preview then\r\n            info_queue[#info_queue+1] = AKYRS.DescriptionDummies[\"dd_akyrs_letter_puzzle_umbral_expl\"]\r\n        end\r\n        return {\r\n            vars = {\r\n                card.ability.min_highlighted\r\n            }\r\n        }\r\n    end,\r\n    can_use = function (self, card)\r\n        return #G.hand.highlighted >= math.max(2,card.ability.min_highlighted) and #G.hand.highlighted <= card.ability.max_highlighted\r\n    end, \r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        table.sort(G.hand.highlighted,AKYRS.hand_sort_function_immute)\r\n        AKYRS.do_things_to_card(\r\n            G.hand.highlighted,\r\n            function (_card, index)\r\n                if index == 1 then\r\n                    if G.hand.highlighted[2] then\r\n                        ---@type Card\r\n                        local c2 = G.hand.highlighted[2]\r\n                        if c2.edition then\r\n                            _card:set_edition(c2.edition.key)\r\n                        end\r\n                        if c2.seal then\r\n                            _card:set_seal(c2.seal)\r\n                        end\r\n                        if not SMODS.has_no_suit(c2) and c2.base and c2.base.suit then\r\n                            _card = SMODS.change_base(_card, c2.base.suit )\r\n                            if _card and _card.ability.akyrs_special_card_type == \"rank\" then\r\n                                _card.ability.akyrs_special_card_type = nil\r\n                                _card:set_sprites(_card.config.center,_card.config.card)\r\n                            end\r\n                        end\r\n                        if _card then\r\n                            if _card:get_letter_with_pretend() and c2:get_letter_with_pretend() then\r\n                                _card:set_letters(_card:get_letter_with_pretend()..c2:get_letter_with_pretend())\r\n                            end\r\n                        end\r\n                    end\r\n                else\r\n                    SMODS.calculate_context({ remove_playing_cards = true, removed = _card})\r\n                    _card:start_dissolve({G.C.AKYRS_UMBRAL_P, G.C.AKYRS_UMBRAL_Y})\r\n                end\r\n            end\r\n        )\r\n    end",
      "config": {
        "min_highlighted": 2,
        "max_highlighted": 2
      },
      "ability": {
        "min_highlighted": 2,
        "max_highlighted": 2
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_electrify",
      "name": null,
      "atlas": "umbra",
      "pos": {
        "x": 4,
        "y": 2
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_electrify\",\r\n    atlas = \"umbra\",\r\n    pos = {x=4,y=2},\r\n    config = {\r\n        max_highlighted = 1,\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        \r\n        info_queue[#info_queue+1] = G.P_CENTERS[\"m_akyrs_zap_card\"]\r\n        return {\r\n            vars = {\r\n                card.ability.max_highlighted\r\n            }\r\n        }\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        AKYRS.do_things_to_card(\r\n            G.hand.highlighted,\r\n            function (_card)\r\n                _card:set_ability(G.P_CENTERS[\"m_akyrs_zap_card\"])\r\n            end\r\n        )\r\n    end",
      "config": {
        "max_highlighted": 1
      },
      "ability": {
        "max_highlighted": 1
      },
      "vars": [
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_bounce",
      "name": null,
      "atlas": "umbra",
      "pos": {
        "x": 7,
        "y": 2
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_bounce\",\r\n    atlas = \"umbra\",\r\n    pos = {x=7,y=2},\r\n    config = {\r\n        max_highlighted = 1,\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        \r\n        info_queue[#info_queue+1] = G.P_CENTERS[\"m_akyrs_net_card\"]\r\n        return {\r\n            vars = {\r\n                card.ability.max_highlighted\r\n            }\r\n        }\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        AKYRS.do_things_to_card(\r\n            G.hand.highlighted,\r\n            function (_card)\r\n                _card:set_ability(G.P_CENTERS[\"m_akyrs_net_card\"])\r\n            end\r\n        )\r\n    end",
      "config": {
        "max_highlighted": 1
      },
      "ability": {
        "max_highlighted": 1
      },
      "vars": [
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_hydrate",
      "name": null,
      "atlas": "umbra",
      "pos": {
        "x": 8,
        "y": 2
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_hydrate\",\r\n    atlas = \"umbra\",\r\n    pos = {x=8,y=2},\r\n    config = {\r\n        max_highlighted = 2,\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        \r\n        info_queue[#info_queue+1] = G.P_CENTERS[\"m_akyrs_droplet_card\"]\r\n        return {\r\n            vars = {\r\n                card.ability.max_highlighted\r\n            }\r\n        }\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        AKYRS.do_things_to_card(\r\n            G.hand.highlighted,\r\n            function (_card)\r\n                _card:set_ability(G.P_CENTERS[\"m_akyrs_droplet_card\"])\r\n            end\r\n        )\r\n    end",
      "config": {
        "max_highlighted": 2
      },
      "ability": {
        "max_highlighted": 2
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_d1",
      "name": null,
      "atlas": "umbra",
      "pos": {
        "x": 5,
        "y": 2
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_d1\",\r\n    atlas = \"umbra\",\r\n    pos = {x=5,y=2},\r\n    config = {\r\n        extras = {\r\n            d = 1,\r\n            n = 1\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras.n,\r\n                card.ability.extras.d,\r\n            }\r\n        }\r\n    end,\r\n    can_use = function (self, card)\r\n        return true\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        G.GAME.akyrs_prob_mod = G.GAME.akyrs_prob_mod or {}\r\n        table.insert(G.GAME.akyrs_prob_mod, {n_add = card.ability.extras.n, d_add = card.ability.extras.d, id = \"d1\"})\r\n    end",
      "config": {
        "extras": {
          "d": 1,
          "n": 1
        }
      },
      "ability": {
        "extras": {
          "d": 1,
          "n": 1
        }
      },
      "vars": [
        1,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_exit_plan",
      "name": null,
      "atlas": "umbra",
      "pos": {
        "x": 0,
        "y": 3
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_exit_plan\",\r\n    atlas = \"umbra\",\r\n    pos = {x=0,y=3},\r\n    config = {\r\n        extras = {\r\n            n = 1,\r\n            d = 2,\r\n            mp_percent_of_req = 0.30,\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        local n, d = SMODS.get_probability_vars(card ,card.ability.extras.n, card.ability.extras.d, \"akyrs_umbral_exit_plan\" )\r\n        return {\r\n            vars = {\r\n                n, d, card.ability.extras.mp_percent_of_req * 100, get_blind_amount(G.GAME.round_resets.ante) * card.ability.extras.mp_percent_of_req\r\n            },\r\n            key = self.key .. AKYRS.mp_check(\"\",\"_mp\")\r\n        }\r\n    end,\r\n    select_card = 'consumeables',\r\n    can_use = function (self, card)\r\n        if G.GAME.blind and G.GAME.blind.in_blind then\r\n            return true\r\n        end\r\n        return false\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        if G.GAME.blind and G.GAME.blind.in_blind then\r\n            local should = SMODS.pseudorandom_probability(card, \"akyrs_umbral_exit_plan\" ,card.ability.extras.n, card.ability.extras.d )\r\n            if should then \r\n                if AKYRS.is_mp() then\r\n                    AKYRS.mod_score({ add = get_blind_amount(G.GAME.round_resets.ante) * card.ability.extras.mp_percent_of_req})\r\n                    if true then\r\n                        AKYRS.simple_event_add(function ()\r\n                            if not AKYRS.is_mp() or not MP.is_pvp_boss() then\r\n                                AKYRS.force_check_win()\r\n                            else\r\n                                MP.ACTIONS.play_hand(G.GAME.chips, G.GAME.current_round.hands_left)\r\n                            end\r\n                            return true\r\n                        end,0)\r\n                    end\r\n                else\r\n                    G.GAME.blind:disable()\r\n                end\r\n            else\r\n                -- nope\r\n                AKYRS.simple_event_add(function()\r\n                    attention_text({\r\n                        text = localize('k_nope_ex'),\r\n                        scale = 1.3,\r\n                        hold = 1.4,\r\n                        major = card,\r\n                        backdrop_colour = G.C.AKYRS_UMBRAL_P,\r\n                        align = 'cm',\r\n                        offset = { x = 0, y = 0 },\r\n                        silent = true\r\n                    })\r\n                    G.E_MANAGER:add_event(Event({\r\n                        trigger = 'after',\r\n                        delay = 0.06 * G.SETTINGS.GAMESPEED,\r\n                        blockable = false,\r\n                        blocking = false,\r\n                        func = function()\r\n                            play_sound('tarot2', 0.76, 0.4); return true\r\n                        end\r\n                    }))\r\n                    play_sound('tarot2', 1, 0.4)\r\n                    card:juice_up(0.3, 0.5)\r\n                    return true\r\n                end)\r\n            end\r\n        else\r\n            if card.area and card.area ~= G.consumeables then\r\n                if AKYRS.has_room(G.consumeables, card) then\r\n                    G.consumeables:emplace(card)\r\n                    card:add_to_deck()\r\n                else\r\n                    alert_no_space(card, G.consumeables)\r\n                end\r\n            end\r\n        end\r\n\r\n    end",
      "config": {
        "extras": {
          "n": 1,
          "d": 2,
          "mp_percent_of_req": 0.3
        }
      },
      "ability": {
        "extras": {
          "n": 1,
          "d": 2,
          "mp_percent_of_req": 0.3
        }
      },
      "vars": [
        null,
        null,
        30,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "umbral_free_will",
      "name": null,
      "atlas": "umbra",
      "pos": {
        "x": 6,
        "y": 2
      },
      "raw": "set = \"Umbral\",\r\n    key = \"umbral_free_will\",\r\n    atlas = \"umbra\",\r\n    pos = {x=6,y=2},\r\n    soul_pos = {x=9,y=2, draw=function (card, scale_mod, rotate_mod)\r\n        if card.children.floating_sprite then\r\n            rotate_mod = -G.TIMERS.REAL * 0.731\r\n            local sc = -0.25\r\n            local xm = 0.2 * math.cos(G.TIMERS.REAL)\r\n            local ym = 0.2 * math.sin(G.TIMERS.REAL)\r\n            card.children.floating_sprite:draw_shader('dissolve', 0, nil,nil,card.children.center,sc, rotate_mod,xm,ym+0.2,nil, 0.6)\r\n            card.children.floating_sprite:draw_shader('dissolve', nil, nil,nil,card.children.center,sc, rotate_mod,xm,ym,nil, 0.6)\r\n        end\r\n    end},\r\n    hidden = true,\r\n    soul_rate = 0.05,\r\n    can_repeat_soul = true,\r\n    soul_set = 'Replicant',\r\n    config = {\r\n        extras = {\r\n            mod = 1\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras.mod\r\n            }\r\n        }\r\n    end,\r\n    can_use = function (self, card)\r\n        return true\r\n    end,\r\n    use = function (self, card, area, copier)\r\n        AKYRS.juice_like_tarot(card)\r\n        SMODS.change_play_limit(card.ability.extras.mod)\r\n        SMODS.change_discard_limit(card.ability.extras.mod)\r\n    end",
      "config": {
        "extras": {
          "mod": 1
        }
      },
      "ability": {
        "extras": {
          "mod": 1
        }
      },
      "vars": [
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Voucher",
      "key": "alphabet_soup",
      "name": null,
      "atlas": "aikoyoriVouchers",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"alphabet_soup\",\r\n    atlas = 'aikoyoriVouchers', pos = { x = 2, y = 0 } ,\r\n    cost = 8,\r\n    config = {\r\n        extras = {\r\n            addentum = 2\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras.addentum\r\n            }\r\n        }\r\n    end,\r\n    redeem = function (self, card) \r\n        G.GAME.akyrs_character_stickers_enabled = true\r\n        G.GAME.akyrs_wording_enabled = true\r\n        SMODS.change_play_limit(card.ability.extras.addentum)\r\n        SMODS.change_discard_limit(card.ability.extras.addentum)\r\n        for _,c in ipairs(G.playing_cards) do\r\n            c:set_sprites(c.config.center,c.config.card)\r\n        end\r\n    end,\r\n    unredeem = function (self, card) \r\n        G.GAME.akyrs_character_stickers_enabled = false\r\n        SMODS.change_play_limit(-card.ability.extras.addentum)\r\n        SMODS.change_discard_limit(-card.ability.extras.addentum)\r\n        G.GAME.akyrs_wording_enabled = false\r\n        for _,c in ipairs(G.playing_cards) do\r\n            c:set_sprites(c.config.center,c.config.card)\r\n        end\r\n    end,\r\n    in_pool = function (self, args)\r\n        return not G.GAME.akyrs_mathematics_enabled\r\n    end",
      "config": {
        "extras": {
          "addentum": 2
        }
      },
      "ability": {
        "extras": {
          "addentum": 2
        }
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Voucher",
      "key": "crossing_field",
      "name": null,
      "atlas": "aikoyoriVouchers",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"crossing_field\",\r\n    atlas = 'aikoyoriVouchers', pos = { x = 3, y = 0 } ,\r\n    cost = 12,\r\n    config = {\r\n        extras = {\r\n            addentum = 3\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras.addentum\r\n            }\r\n        }\r\n    end,\r\n    requires = { \"v_akyrs_alphabet_soup\" },\r\n    redeem = function (self, card) \r\n        G.GAME.akyrs_letters_mult_enabled = true\r\n        SMODS.change_play_limit(card.ability.extras.addentum)\r\n        SMODS.change_discard_limit(card.ability.extras.addentum)\r\n    end,\r\n    unredeem = function (self, card) \r\n        G.GAME.akyrs_letters_mult_enabled = false\r\n        SMODS.change_play_limit(-card.ability.extras.addentum)\r\n        SMODS.change_discard_limit(-card.ability.extras.addentum)\r\n    end,\r\n    in_pool = function (self, args)\r\n        return not G.GAME.akyrs_mathematics_enabled\r\n    end",
      "config": {
        "extras": {
          "addentum": 3
        }
      },
      "ability": {
        "extras": {
          "addentum": 3
        }
      },
      "vars": [
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Voucher",
      "key": "banquet",
      "name": null,
      "atlas": "aikoyoriVouchers",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"banquet\",\r\n    atlas = 'aikoyoriVouchers', pos = { x = 0, y = 0 } ,\r\n    cost = 15,\r\n    config = {\r\n        extras = {\r\n            addentum = 1\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras.addentum\r\n            }\r\n        }\r\n    end,\r\n    redeem = function (self, card) \r\n        SMODS.change_play_limit(card.ability.extras.addentum)\r\n        SMODS.change_discard_limit(card.ability.extras.addentum)\r\n        G.hand:change_size(card.ability.extras.addentum)\r\n    end,\r\n    unredeem = function (self, card) \r\n        SMODS.change_play_limit(-card.ability.extras.addentum)\r\n        SMODS.change_discard_limit(-card.ability.extras.addentum)\r\n        G.hand:change_size(-card.ability.extras.addentum)\r\n    end,",
      "config": {
        "extras": {
          "addentum": 1
        }
      },
      "ability": {
        "extras": {
          "addentum": 1
        }
      },
      "vars": [
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Voucher",
      "key": "worlds_end",
      "name": null,
      "atlas": "aikoyoriVouchers",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"worlds_end\",\r\n    atlas = 'aikoyoriVouchers', pos = { x = 1, y = 0 } ,\r\n    cost = 15,\r\n    config = {\r\n        extras = {\r\n            addentum = 2\r\n        }\r\n    },\r\n    loc_vars = function (self, info_queue, card)\r\n        return {\r\n            vars = {\r\n                card.ability.extras.addentum\r\n            }\r\n        }\r\n    end,\r\n    requires = { \"v_akyrs_banquet\" },\r\n    redeem = function (self, card) \r\n        SMODS.change_play_limit(card.ability.extras.addentum)\r\n        SMODS.change_discard_limit(card.ability.extras.addentum)\r\n        G.hand:change_size(card.ability.extras.addentum)\r\n    end,\r\n    unredeem = function (self, card) \r\n        SMODS.change_play_limit(-card.ability.extras.addentum)\r\n        SMODS.change_discard_limit(-card.ability.extras.addentum)\r\n        G.hand:change_size(-card.ability.extras.addentum)\r\n    end,",
      "config": {
        "extras": {
          "addentum": 2
        }
      },
      "ability": {
        "extras": {
          "addentum": 2
        }
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Ranks",
      "key": "credit_larantula",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"credit_larantula\",\n    generate_ui = function(self, info_queue, card, desc_nodes, specific_vars, full_UI_table)\n        SMODS.Center.generate_ui(self, info_queue, card, desc_nodes, specific_vars, full_UI_table)\n\n        AKYRS.embedded_ui_sprite(\"akyrs_larantula_l_credits\",{x = 0, y = 0}, desc_nodes, {\n            w = 800,\n            h = 800,\n            rounded = 0.5\n        })\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "DynaTextEffect",
      "key": "obfuscate",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"obfuscate\",\n        func = function (dynatext, index, letter)\n            letter.letter = love.graphics.newText(dynatext.font.FONT, string.char(math.fmod((string.byte(letter.char) + math.fmod(math.floor(G.TIMERS.REAL * 142.1 + index), 192)), 94)+ 33))\n        end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "DynaTextEffect",
      "key": "rainbow_wiggle",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"rainbow_wiggle\",\n        func = function (dynatext, index, letter)\n            letter.colour = AKYRS.hsl2rgb(math.fmod((G.TIMERS.REAL + index) * 50, 360), 1, 0.75)\n            letter.offset.y = math.cos(G.TIMERS.REAL * 2.95 + index) * 9\n            letter.scale = (((math.sin((G.TIMERS.REAL + index)*2.9443) + 1)/2) + 6 )/6\n        end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "DynaTextEffect",
      "key": "snaking",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"snaking\",\n        func = function (dynatext, index, letter)\n            letter.offset.x = math.sin((G.TIMERS.REAL + index) * 7.95) * 7\n            letter.offset.y = math.cos((G.TIMERS.REAL + index) * 7.95) * 7\n        end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "DynaTextEffect",
      "key": "shrivel",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"shrivel\",\n        func = function (dynatext, index, letter)\n            letter.offset.x = math.sin((G.TIMERS.REAL * 14511.15 + index * 534.415) * 7.95) * 5\n            letter.offset.y = math.cos((G.TIMERS.REAL * 534.15 + index * 14511.415) * 7.95) * 5\n        end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "DynaTextEffect",
      "key": "exponent",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"exponent\",\n        func = function (dynatext, index, letter)\n            letter.offset.y = 20\n            letter.offset.x = 20\n        end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "DrawStep",
      "key": "extras",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"extras\",\r\n    order = 50,\r\n    func = function (card, layer)\r\n        AKYRS.aikoyori_draw_extras(card,layer)\r\n    end,\r\n    conditions = { vortex = false, facing = 'front' },",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "DrawStep",
      "key": "pinned_sticker",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"pinned_sticker\",\r\n    order = 95,\r\n    func = function(self)\r\n        if self.pinned then\r\n            if not AKYRS.pinned_sticker then\r\n                AKYRS.pinned_sticker = Sprite(0, 0, G.CARD_W, G.CARD_H, G.ASSET_ATLAS[\"akyrs_aikoyoriStickers\"], {x = 4,y = 0}) \r\n            end\r\n            AKYRS.pinned_sticker.role.draw_major = self\r\n            AKYRS.pinned_sticker:draw_shader('dissolve', nil, nil, nil, self.children.center,nil,nil,nil,-0.3)\r\n            AKYRS.pinned_sticker:draw_shader('voucher', nil, nil, nil, self.children.center,nil,nil,nil,-0.3)\r\n        end\r\n    end,\r\n    conditions = { vortex = false, facing = 'front' },",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "DrawStep",
      "key": "misc_btns",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'misc_btns',\r\n    order = -30,\r\n    func = function(self)\r\n        --Draw any tags/buttons\r\n        if self.children.akyrs_wildcard then self.children.akyrs_wildcard:draw() end\r\n        if self.children.akyrs_redeem_voucher then self.children.akyrs_redeem_voucher:draw() end\r\n        if self.children.akyrs_collection_ui then self.children.akyrs_collection_ui:draw() end\r\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Font",
      "key": "NotoEmoji",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"NotoEmoji\",\r\n    path = \"NotoEmoji-Bold.ttf\",\r\n    render_scale = 140,\r\n    TEXT_HEIGHT_SCALE = 0.65, \r\n    TEXT_OFFSET = {x=0,y=0}, \r\n    FONTSCALE = 0.12,\r\n    squish = 1, \r\n    DESCSCALE = 1",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Font",
      "key": "MochiyPopOne",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"MochiyPopOne\",\r\n    path = \"MochiyPopOne-Regular.ttf\",\r\n    render_scale = 128,\r\n    TEXT_HEIGHT_SCALE = 0.9,\r\n    TEXT_OFFSET = {x=10,y=-10},\r\n    FONTSCALE = 0.11,\r\n    squish = 1,\r\n    DESCSCALE = 1",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Scoring_Calculation",
      "key": "puzzle_display",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"puzzle_display\",\n    func = function (self, chips, mult, flames)\n        local to_big = to_big or function(x) return x end\n        return to_big(0)\n    end,\n    order = 999,\n    replace_ui = function(self)\n        return {\n            n = G.UIT.R,\n            config = { id = 'hand_operator_container' },\n            nodes = {\n\n            }\n        }\n    end,",
      "config": {
        "id": "hand_operator_container"
      },
      "ability": {
        "id": "hand_operator_container"
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Scoring_Calculation",
      "key": "math_display",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"math_display\",\n    order = 999,\n    func = function (self, chips, mult, flames)\n        local to_big = to_big or function(x) return x end\n        if flames then\n            if to_big(G.GAME.aikoyori_evaluation_value) == to_big(G.GAME.blind.chips) then\n                return to_big(G.GAME.aikoyori_evaluation_value) * 100\n            end\n            return 0\n        else\n            return to_big(G.GAME.aikoyori_evaluation_value) - to_big(G.GAME.chips)\n        end\n    end,\n    replace_ui = function(self)\n        return {\n            n = G.UIT.R,\n            config = { align = \"cm\", padding = 0.1, id = 'hand_operator_container' },\n            nodes = {\n                {\n                    n = G.UIT.O,\n                    config = {\n                        object = DynaText({ string = {{ ref_table = G.GAME, ref_value = \"aikoyori_evaluation_value\" }}, scale = 0.6, colours = {G.C.WHITE}, akyrs_number_format = 1e15 })\n                    }\n                }\n            }\n        }\n    end,\n    update_ui = function (self, container, chip_display, mult_display, operator)\n        container.UIBox:update()\n    end",
      "config": {
        "align": "cm",
        "padding": 0.1,
        "id": "hand_operator_container"
      },
      "ability": {
        "align": "cm",
        "padding": 0.1,
        "id": "hand_operator_container"
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "letter_booster_pack_music",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"letter_booster_pack_music\",\r\n    path = \"letterPack.ogg\",\r\n    sync = {\r\n        ['music1'] = true,\r\n        ['music2'] = true,\r\n        ['music3'] = true,\r\n        ['music4'] = true,\r\n        ['music5'] = true,\r\n        ['akyrs_umbral_booster_pack_music'] = true,\r\n    },\r\n    select_music_track = function(self) \r\n        return G.booster_pack and not G.booster_pack.REMOVED and SMODS.OPENED_BOOSTER and SMODS.OPENED_BOOSTER.config.center.kind == 'letter_pack' and 100 or nil\r\n    end",
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "umbral_booster_pack_music",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"umbral_booster_pack_music\",\r\n    path = \"umbralpack.ogg\",\r\n    sync = {\r\n        ['music1'] = true,\r\n        ['music2'] = true,\r\n        ['music3'] = true,\r\n        ['music4'] = true,\r\n        ['music5'] = true,\r\n        ['akyrs_letter_booster_pack_music'] = true,\r\n    },\r\n    select_music_track = function(self) \r\n        return G.booster_pack and not G.booster_pack.REMOVED and SMODS.OPENED_BOOSTER and SMODS.OPENED_BOOSTER.config.center.kind == 'umbral_pack' and 100 or nil\r\n    end",
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "noire_sfx",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"noire_sfx\",\r\n    path = \"noire.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "texelated_sfx",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"texelated_sfx\",\r\n    path = \"texelated.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "sliced_sfx",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"sliced_sfx\",\r\n    path = \"sliced.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "burnt_sfx",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"burnt_sfx\",\r\n    path = \"burnt.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "enchant1",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"enchant1\",\r\n    path = \"enchant/enchant1.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "enchant2",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"enchant2\",\r\n    path = \"enchant/enchant2.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "enchant3",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"enchant3\",\r\n    path = \"enchant/enchant3.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "loud_incorrect_buzzer",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"loud_incorrect_buzzer\",\r\n    path = \"loudbuzzer.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "piano",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"piano\",\r\n    path = \"piano.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "don",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"don\",\r\n    path = \"don.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "katsu",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"katsu\",\r\n    path = \"katsu.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "xscore",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"xscore\",\r\n    path = \"xscore.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "dyed",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"dyed\",\r\n    path = \"dyed.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "layer_aikoyori",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"layer_aikoyori\",\r\n    path = \"layer_aikoyori.ogg\",\r\n    pitch = 1,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    }
  ],
  "version": "0.2.0-alpha-260122a"
}