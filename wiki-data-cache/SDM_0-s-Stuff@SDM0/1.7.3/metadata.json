{
  "locMap": {
    "sdm0sstuff": {
      "name": "SDM_0's Stuff",
      "text": [
        "{C:attention,s:1.3}Content{s:1.3} mod that adds new {C:attention,s:1.3}jokers{s:1.3}, {C:tarot,s:1.3}consumables{s:1.3},",
        "{C:blue,s:1.3}vouchers{s:1.3}, {C:red,s:1.3}decks{s:1.3}, {C:money,s:1.3}challenges{s:1.3} and {C:bakery,s:1.3}bakery goods{s:1.3}.",
        " ",
        "{E:2,C:gold,s:1.3}Special thanks{s:1.3} to RattlingSnow, queen of stupid, FlameThrowerFIM,",
        "Jamie, N', Larswijn, Darthalex2014, PainKiller and Mysthaps for their help"
      ],
      "type": "Mod"
    },
    "j_sdm_burger": {
      "name": "Burger",
      "text": [
        "{C:chips}+#3#{} Chips, {C:mult}+#2#{} Mult",
        "and {X:mult,C:white}X#1#{} Mult for",
        "the next {C:attention}#4#{} rounds"
      ],
      "type": "Joker"
    },
    "j_sdm_bounciest_ball": {
      "name": "Bounciest Ball",
      "text": [
        "This Joker gains {C:chips}+#2#{} Chips when",
        "scoring most played {C:attention}poker hand{}",
        "{C:inactive}(Currently {C:attention}#3#{C:inactive}, {C:chips}+#1#{C:inactive} Chips)"
      ],
      "type": "Joker"
    },
    "j_sdm_lucky_joker": {
      "name": "Lucky Joker",
      "text": [
        "Retrigger",
        "each played {C:attention}7{}",
        "{C:attention}#1#{} additional times"
      ],
      "type": "Joker"
    },
    "j_sdm_iconic_icon": {
      "name": "Iconic Icon",
      "text": [
        "{C:mult}+#2#{} Mult per {C:attention}Ace{}",
        "in your {C:attention}full deck{},",
        "{C:mult}+#3#{} Mult if {C:attention}modified{}",
        "{C:inactive}(Currently {C:mult}+#1#{C:inactive} Mult)"
      ],
      "type": "Joker"
    },
    "j_sdm_mult_n_chips": {
      "name": "Mult'N'Chips",
      "text": [
        "Scored {C:attention}Bonus{} cards",
        "give {C:mult}+#1#{} Mult and",
        "scored {C:attention}Mult{} cards",
        "give {C:chips}+#2#{} Chips"
      ],
      "type": "Joker"
    },
    "j_sdm_moon_base": {
      "name": "Moon Base",
      "text": [
        "When {C:attention}Blind{} is selected,",
        "create a random",
        "{C:attention}Space{} Joker",
        "{s:0.8,C:inactive}(Cannot create Moon Base)",
        "{C:inactive}(Must have room)"
      ],
      "type": "Joker"
    },
    "j_sdm_shareholder_joker": {
      "name": "Shareholder Joker",
      "text": [
        "Earn between {C:money}$#1#{} and {C:money}$#2#{}",
        "at end of round"
      ],
      "type": "Joker"
    },
    "j_sdm_magic_hands": {
      "name": "Magic Hands",
      "text": [
        "{C:attention}Three of a Kind{} or",
        "{C:attention}higher{} can be made",
        "with {C:attention}1{} less card"
      ],
      "type": "Joker"
    },
    "j_sdm_tip_jar": {
      "name": "Tip Jar",
      "text": [
        "Earn your money's",
        "{C:attention}highest digit",
        "at end of round",
        "{C:inactive}(ex: {C:money}$24{C:inactive} -> {C:money}$4{C:inactive})"
      ],
      "type": "Joker"
    },
    "j_sdm_wandering_star": {
      "name": "Wandering Star",
      "text": [
        "Level up a random",
        "{C:attention}poker hand{} on {C:green}reroll{}"
      ],
      "type": "Joker"
    },
    "j_sdm_ouija_board": {
      "name": "Ouija Board",
      "text": [
        "After {C:attention}#2#{} rounds,",
        "sell this card to",
        "create a {C:spectral}Soul{} card",
        "{C:inactive}(Must have room)",
        "{C:inactive}(Currently {C:attention}#1#{C:inactive}/#2#)"
      ],
      "type": "Joker"
    },
    "j_sdm_la_revolution": {
      "name": "La Révolution",
      "text": [
        "Upgrade {C:attention}winning hand{}",
        "played without {C:attention}face{} cards"
      ],
      "type": "Joker"
    },
    "j_sdm_clown_bank": {
      "name": "Clown Bank",
      "text": [
        "When {C:attention}Blind{} is selected, spend {C:money}$#3#{}",
        "into this Joker {C:attention}sell value{},",
        "{X:mult,C:white}X#2#{} Mult per {C:money}$#4#{} of {C:attention}extra sell value{}",
        "{C:inactive}(Currently {X:mult,C:white}X#1#{C:inactive} Mult)"
      ],
      "type": "Joker"
    },
    "j_sdm_furnace": {
      "name": "Furnace",
      "text": [
        "When round begins,",
        "add a random {C:attention}Gold{} or",
        "{C:attention}Steel{} playing card"
      ],
      "type": "Joker"
    },
    "j_sdm_warehouse": {
      "name": "Warehouse",
      "text": [
        "{C:attention}+#1#{} hand size,",
        "other cards",
        "can't be sold"
      ],
      "type": "Joker"
    },
    "j_sdm_zombie_joker": {
      "name": "Zombie Joker",
      "text": [
        "{C:green}#1# in #2#{} chance to create",
        "a {C:tarot}Death{} card when",
        "{C:attention}selling{} a Joker card",
        "{C:inactive}(Must have room)"
      ],
      "type": "Joker"
    },
    "j_sdm_mystery_joker": {
      "name": "Mystery Joker",
      "text": [
        "Create a {C:red}Rare {C:attention}Tag{} when",
        "{C:attention}Boss Blind{} is defeated"
      ],
      "type": "Joker"
    },
    "j_sdm_infinite_staircase": {
      "name": "Infinite Staircase",
      "text": [
        "{X:mult,C:white}X#1#{} Mult if scored hand",
        "contains a {C:attention}numerical{}",
        "{C:attention}Straight{} without an {C:attention}Ace{}"
      ],
      "type": "Joker"
    },
    "j_sdm_ninja_joker": {
      "name": "Ninja Joker",
      "text": [
        "This Joker adds {C:dark_edition}Negative{} on",
        "each {C:attention}adjacent Joker{} when",
        "a {C:attention}playing card{} is destroyed",
        "then {S:1.1,C:red,E:2}self destructs{}"
      ],
      "type": "Joker"
    },
    "j_sdm_reach_the_stars": {
      "name": "Reach the Stars",
      "text": [
        "Scoring a hand of {C:attention}#1#{} and",
        "{C:attention}#2#{} cards creates a",
        "random {C:planet}Planet{} card",
        "{s:0.8}Changes each trigger",
        "{C:inactive}(Must have room)",
        "{C:inactive}(Currently {C:attention}#3#{C:inactive}#4# & {C:attention}#5#{C:inactive}#6#)"
      ],
      "type": "Joker"
    },
    "j_sdm_crooked_joker": {
      "name": "Crooked Joker",
      "text": [
        "{C:attention}Doubles{} or {C:red}destroys{}",
        "each added {C:attention}Joker{}",
        "{C:inactive}(Must have room)"
      ],
      "type": "Joker"
    },
    "j_sdm_crooked_joker_cryptid": {
      "name": "Crooked Joker",
      "text": [
        "{C:attention}Doubles{} or {C:red}destroys{}",
        "each added {C:attention}Joker{}",
        "{C:inactive}(Must have room)",
        "{C:inactive}(Cannot be rigged)"
      ],
      "type": "Joker"
    },
    "j_sdm_property_damage": {
      "name": "Property Damage",
      "text": [
        "This Joker gains {X:mult,C:white}X#2#{} Mult",
        "when discarded hand",
        "contains a {C:attention}Full House{}",
        "{C:inactive}(Currently {X:mult,C:white}X#1#{} {C:inactive}Mult)"
      ],
      "type": "Joker"
    },
    "j_sdm_rock_n_roll": {
      "name": "Rock'N'Roll",
      "text": [
        "Retrigger all played",
        "{C:attention}Enhanced{} cards"
      ],
      "type": "Joker"
    },
    "j_sdm_contract": {
      "name": "Contract",
      "text": [
        "Earn {C:money}$#1#{} at",
        "end of round,",
        "{C:red}#2#X{} Blind goal"
      ],
      "type": "Joker"
    },
    "j_sdm_cupidon": {
      "name": "Cupidon",
      "text": [
        "{C:blue}+#1#{} hand,",
        "{C:attention}+#2#{} hand size,",
        "{C:red}-#3#{} discards"
      ],
      "type": "Joker"
    },
    "j_sdm_pizza": {
      "name": "Pizza",
      "text": [
        "When {C:attention}Blind{} is selected,",
        "gain {C:blue}+#1#{} hands",
        "{C:blue}-#2#{} per round played"
      ],
      "type": "Joker"
    },
    "j_sdm_treasure_chest": {
      "name": "Treasure Chest",
      "text": [
        "Sell this card",
        "to gain {C:money}$#1#"
      ],
      "type": "Joker"
    },
    "j_sdm_bullet_train": {
      "name": "Bullet Train",
      "text": [
        "{C:chips}+#1#{} Chips on your",
        "{C:attention}first hand{} if no discards",
        "were used this round"
      ],
      "type": "Joker"
    },
    "j_sdm_chaos_theory": {
      "name": "Chaos Theory",
      "text": [
        "Adds {C:attention}double{} the value of all",
        "{C:attention}on-screen numbers{} to Chips",
        "{C:inactive}(Currently {C:chips}+#2#{C:inactive} Chips)"
      ],
      "type": "Joker"
    },
    "j_sdm_jambo": {
      "name": "Jambo",
      "text": [
        "Adds {C:attention}double{}",
        "the rank of a",
        "random {C:attention}discarded{}",
        "card to Mult"
      ],
      "type": "Joker"
    },
    "j_sdm_water_slide": {
      "name": "Water Slide",
      "text": [
        "All played {C:attention}9{}, {C:attention}7{} and {C:attention}6{}",
        "become {C:attention}Bonus{} cards",
        "when scored"
      ],
      "type": "Joker"
    },
    "j_sdm_joker_voucher": {
      "name": "Joker Voucher",
      "text": [
        "{X:mult,C:white}X#1#{} Mult per redeemed",
        "{C:attention}Voucher{} this run",
        "{C:inactive}(Currently {X:mult,C:white}X#2#{C:inactive} Mult)"
      ],
      "type": "Joker"
    },
    "j_sdm_free_pass": {
      "name": "Free Pass",
      "text": [
        "First {C:blue}hand{} or {C:red}discard{}",
        "of round is {C:attention}free{}"
      ],
      "type": "Joker"
    },
    "j_sdm_legionary_joker": {
      "name": "Legionary Joker",
      "text": [
        "Each {C:spades}#1#{} or {C:diamonds}#2#{}",
        "card held in hand",
        "gives {C:mult}+#3#{} Mult"
      ],
      "type": "Joker"
    },
    "j_sdm_jack_a_dit": {
      "name": "Jack a Dit",
      "text": [
        "{C:red}+#1#{} Mult if {C:attention}poker hand{}",
        "is a {C:attention}#2#{} or {C:attention}#3#{}",
        "and has a {C:attention}Jack{}",
        "{s:0.8}poker hands change",
        "{s:0.8}at end of round"
      ],
      "type": "Joker"
    },
    "j_sdm_chain_reaction": {
      "name": "Chain Reaction",
      "text": [
        "This Joker gains {C:mult}+X{} Mult",
        "when scoring an {C:attention}X of a Kind{}",
        "{C:inactive}(Currently {C:mult}+#1#{C:inactive} Mult)"
      ],
      "type": "Joker"
    },
    "j_sdm_consolation_prize": {
      "name": "Consolation Prize",
      "text": [
        "At end of round, create",
        "a random {C:attention}Tag{} if you",
        "played your {C:attention}final hand{}"
      ],
      "type": "Joker"
    },
    "j_sdm_horoscopy": {
      "name": "Horoscopy",
      "text": [
        "{C:green}#1# in #2#{} chance to create a",
        "random {C:tarot}Tarot{} card when",
        "a {C:planet}Planet{} card is used",
        "{C:inactive}(Must have room){}"
      ],
      "type": "Joker"
    },
    "j_sdm_roulette": {
      "name": "Roulette",
      "text": [
        "When round begins,",
        "{C:green}#1# in #2#{} chance to add",
        "a {C:dark_edition}Foil{}, {C:dark_edition}Holographic{} or",
        "{C:dark_edition}Polychrome{} edition to",
        "a random {C:attention}Joker{} or {C:attention}card{}"
      ],
      "type": "Joker"
    },
    "j_sdm_carcinization": {
      "name": "Carcinization",
      "text": [
        "When {C:attention}Blind{} is selected,",
        "turn Joker to the left",
        "into {C:attention}Carcinization{},",
        "{C:mult}+#1#{} Mult per {C:attention}Carcinization{}",
        "{C:inactive}(Currently {C:mult}+#2#{C:inactive} Mult)"
      ],
      "type": "Joker"
    },
    "j_sdm_wormhole": {
      "name": "Wormhole",
      "text": [
        "Level ups are {C:attention}doubled{}"
      ],
      "type": "Joker"
    },
    "j_sdm_child": {
      "name": "Child",
      "text": [
        "{X:attention,C:white}X#1#{} Blind",
        "requirement"
      ],
      "type": "Joker"
    },
    "j_sdm_yo_yo": {
      "name": "Yo-Yo",
      "text": [
        "Swaps between {X:mult,C:white}X#1#",
        "and {X:mult,C:white}X#2#{} Mult each",
        "{C:attention}played hand",
        "{C:inactive}(Currently {X:mult,C:white}X#3#{C:inactive} Mult)"
      ],
      "type": "Joker"
    },
    "j_sdm_ditto_joker": {
      "name": "Ditto Joker",
      "text": [
        "When {C:attention}Blind{} is selected,",
        "turns into a random",
        "owned {C:attention}Joker{}, resets",
        "on each selected {C:attention}Blind{}",
        "{C:inactive}(Except Ditto Joker)"
      ],
      "type": "Joker"
    },
    "j_sdm_pastry_chef": {
      "name": "Pastry Chef",
      "text": [
        "Create a {C:bakery}Bakery{} good",
        "when one is {C:attention}consumed{}",
        "{C:inactive}(Must have room)"
      ],
      "type": "Joker"
    },
    "j_sdm_archibald": {
      "name": "Archibald",
      "text": [
        "Once per {C:attention}Ante{}, creates",
        "a {C:dark_edition}Negative{} copy of a",
        "random {C:attention}Joker{} at the",
        "end of the {C:attention}shop",
        "{C:inactive}(Cannot copy Archibald)",
        "{C:inactive}(Currently {C:attention}#1#{C:inactive}#2#{C:inactive})"
      ],
      "type": "Joker"
    },
    "j_sdm_0": {
      "name": "SDM_0",
      "text": [
        "{C:dark_edition}+#1#{} Joker Slot",
        "when a {C:attention}2{}",
        "is destroyed"
      ],
      "type": "Joker"
    },
    "j_sdm_skelton": {
      "name": "Skelton",
      "text": [
        "If scored hand is a single",
        "{C:attention}Jack{}, this Joker destroys",
        "each {C:attention}unscored card{} and",
        "gains {C:money}$#2#{} per destroyed card",
        "{C:inactive}(Currently {C:money}$#1#{C:inactive})"
      ],
      "type": "Joker"
    },
    "j_sdm_trance_the_devil": {
      "name": "Trance The Devil",
      "text": [
        "This Joker {C:attention}destroys{} each",
        "{C:attention}vanilla{} consumable for",
        "{X:mult,C:white}X#1#{} Mult at the",
        "end of round",
        "{C:inactive}(Currently {X:mult,C:white}X#2#{C:inactive} Mult)"
      ],
      "type": "Joker"
    },
    "j_sdm_mishmash": {
      "name": "Mishmash",
      "text": [
        "Scored {C:attention}Bonus{} cards give {C:mult}+#1#{} Mult,",
        "scored {C:attention}Mult{} cards give {C:chips}+#2#{} Chips,",
        "held {C:attention}Gold{} cards give {X:mult,C:white}X#3#{} Mult and",
        "held {C:attention}Steel{} cards give {C:money}$#4#{} at end of round"
      ],
      "type": "Joker"
    },
    "j_sdm_ceo_joker": {
      "name": "CEO Joker",
      "text": [
        "Earn between {C:money}$#1#{} and {C:money}$#2#{}",
        "at end of round,"
      ],
      "type": "Joker"
    },
    "j_sdm_maglev_train": {
      "name": "Maglev Train",
      "text": [
        "{C:mult}+#1#{} Mult on your",
        "{C:attention}first hand{} if no discards",
        "were used this round"
      ],
      "type": "Joker"
    },
    "j_sdm_joker_voucher_voucher": {
      "name": "Joker Voucher Voucher",
      "text": [
        "This card is destroyed to redeem",
        "a {C:attention}Joker Voucher Voucher{}"
      ],
      "type": "Joker"
    },
    "b_sdm_0_s": {
      "name": "SDM_0's Deck",
      "text": [
        "{C:attention}SDM_0's Stuff{}",
        "Joker cards",
        "appear {C:attention}5{} times",
        "more often"
      ],
      "type": "Back"
    },
    "b_sdm_bazaar": {
      "name": "Bazaar Deck",
      "text": [
        "After defeating each",
        "{C:attention}Boss Blind{}, create a",
        "{C:attention}SDM_0's Stuff{} consumable",
        "{C:inactive}(Must have room)"
      ],
      "type": "Back"
    },
    "b_sdm_sandbox": {
      "name": "Sandbox Deck",
      "text": [
        "{C:attention}+#1#{} Joker Slots",
        "{C:red}+#2#{} Ante to win"
      ],
      "type": "Back"
    },
    "b_sdm_lucky_7": {
      "name": "Lucky 7 Deck",
      "text": [
        "Starting {C:attention}7s{} are {C:attention,T:m_lucky}Lucky{} Cards",
        "{s:0.8}Doubles all {C:attention,s:0.8}listed {C:green,E:1,S:1.1,s:0.8}probabilities",
        "{C:red}X#1#{} base Blind size"
      ],
      "type": "Back"
    },
    "b_sdm_dna": {
      "name": "DNA Deck",
      "text": [
        "Rightmost playing card",
        "from {C:attention}winning poker hand{}",
        "is {C:blue}dupli{C:red}cated{}"
      ],
      "type": "Back"
    },
    "b_sdm_hieroglyph": {
      "name": "Hieroglyph Deck",
      "text": [
        "{C:spectral}Spectral{} cards may",
        "appear in the shop,",
        "start with an {C:spectral,T:c_ankh}Ankh{} card"
      ],
      "type": "Back"
    },
    "b_sdm_xxl": {
      "name": "XXL Deck",
      "text": [
        "Start with {C:attention}double{}",
        "the deck size"
      ],
      "type": "Back"
    },
    "b_sdm_hoarder": {
      "name": "Hoarder Deck",
      "text": [
        "At end of each Round:",
        "{C:money}$#1#{} per remaining {C:red}Discard",
        "Extra {C:blue}Hands{} no longer earn money",
        "Earn no {C:attention}Interest{} at end of round"
      ],
      "type": "Back"
    },
    "b_sdm_modders": {
      "name": "Modder's Deck",
      "text": [
        "{C:attention}Vanilla{} Joker cards",
        "can't appear in shop"
      ],
      "type": "Back"
    },
    "b_sdm_reverb": {
      "name": "Reverb Deck",
      "text": [
        "Retrigger each Joker",
        "{C:attention}#2#{} time",
        "{C:red}#1#{} Joker Slots"
      ],
      "type": "Back"
    },
    "b_sdm_roguelike": {
      "name": "Roguelike Deck",
      "text": [
        "Start run with the",
        "{C:attention,T:v_overstock_norm}#1#{} voucher",
        "{C:attention}+#2#{} Booster Pack slot",
        "{C:green}Rerolling{} is disabled"
      ],
      "type": "Back"
    },
    "b_sdm_bakers": {
      "name": "Baker's Deck",
      "text": [
        "Start run with the",
        "{C:bakery,T:v_sdm_bakery_stall}#1#{} voucher",
        "{C:attention}+#2#{} consumable slot"
      ],
      "type": "Back"
    },
    "b_sdm_deck_of_dreams": {
      "name": "Deck of Dreams",
      "text": [
        "Combines each {C:green}positive{}",
        "{C:attention}SDM_0's Stuff{} deck effect"
      ],
      "type": "Back"
    },
    "b_sdm_deck_of_nightmares": {
      "name": "Deck of Nightmares",
      "text": [
        "Combines each {C:red}negative{}",
        "{C:attention}SDM_0's Stuff{} deck effect"
      ],
      "type": "Back"
    },
    "b_sdm_deck_of_stuff": {
      "name": "Deck of Stuff",
      "text": [
        "Combines each",
        "{C:attention}SDM_0's Stuff{}",
        "deck effect"
      ],
      "type": "Back"
    },
    "c_sdm_sphinx": {
      "name": "The Sphinx",
      "text": [
        "{C:green}#1# in #2#{} chance to add",
        "{C:dark_edition}Foil{}, {C:dark_edition}Holographic{}, or",
        "{C:dark_edition}Polychrome{} effect to",
        "{C:attention}#3#{} selected card in hand"
      ],
      "type": "Tarot"
    },
    "c_sdm_mother": {
      "name": "The Mother",
      "text": [
        "Permanently upgrades",
        "up to {C:attention}#1#{} selected",
        "cards with {C:chips}+#2#{} Chips"
      ],
      "type": "Tarot"
    },
    "c_sdm_baker": {
      "name": "The Baker",
      "text": [
        "Creates {C:attention}#1#{} random",
        "{C:bakery}Bakery{} good",
        "{C:inactive}(Must have room)"
      ],
      "type": "Tarot"
    },
    "c_sdm_eggxoplanet": {
      "name": "Egg-xoplanet",
      "text": [
        "{S:0.8}({S:0.8,V:1}lvl.#1#{S:0.8}){} Level up",
        "{C:attention}#2#",
        "{C:mult}+#3#{} Mult and",
        "{C:chips}+#4#{} chips"
      ],
      "type": "Planet"
    },
    "c_sdm_sacrifice": {
      "name": "Sacrifice",
      "text": [
        "{C:attention}+#1#{} Joker Slot,",
        "{C:red}-#2#{} hand,",
        "{C:red}-#3#{} discard"
      ],
      "type": "Spectral"
    },
    "c_sdm_morph": {
      "name": "Morph",
      "text": [
        "Lose {C:attention}#1#{} item, gain {C:attention}#2#{}",
        "of another item",
        "from the list"
      ],
      "type": "Spectral"
    },
    "c_sdm_bind": {
      "name": "Bind",
      "text": [
        "Apply or remove {C:purple}Eternal{}",
        "on a selected Joker",
        "{C:inactive}(Must be compatible){}"
      ],
      "type": "Spectral"
    },
    "c_sdm_doppelganger": {
      "name": "Doppelgänger",
      "text": [
        "Replaces a random {C:attention}Joker{}",
        "by the leftmost or",
        "rightmost {C:attention}Joker{}"
      ],
      "type": "Spectral"
    },
    "c_sdm_wedding_cake": {
      "name": "Wedding Cake",
      "text": [
        "{C:dark_edition}+#1#{} Joker Slot,",
        "{C:attention}+#1#{} consumable slot,",
        "lasts forever"
      ],
      "type": "Spectral"
    },
    "c_sdm_chocolate_truffles": {
      "name": "Chocolate Truffles",
      "text": [
        "Earn {C:money}$#1#{},",
        "lasts {C:attention}#2#{} round(s)"
      ],
      "type": "Bakery"
    },
    "c_sdm_sourdough": {
      "name": "Sourdough",
      "text": [
        "{X:chips,C:white}X#1#{} Chips,",
        "lasts {C:attention}#2#{} hand(s)"
      ],
      "type": "Bakery"
    },
    "c_sdm_baguette": {
      "name": "Baguette",
      "text": [
        "{X:mult,C:white}X#1#{} Mult,",
        "lasts {C:attention}#2#{} hand(s)"
      ],
      "type": "Bakery"
    },
    "c_sdm_banana_bread": {
      "name": "Banana Bread",
      "text": [
        "{X:mult,C:white}X#1#{} Mult,",
        "{C:green}#2# in #3#{} chance this card",
        "is destroyed each hand"
      ],
      "type": "Bakery"
    },
    "c_sdm_breadsticks": {
      "name": "Breadsticks",
      "text": [
        "{C:blue}+#1#{} hands,",
        "lasts {C:attention}#2#{} round(s)"
      ],
      "type": "Bakery"
    },
    "c_sdm_croissant": {
      "name": "Croissant",
      "text": [
        "{C:red}+#1#{} discards,",
        "lasts {C:attention}#2#{} round(s)"
      ],
      "type": "Bakery"
    },
    "c_sdm_bread_loaf": {
      "name": "Bread Loaf",
      "text": [
        "{C:attention}+#1#{} handsize,",
        "lasts {C:attention}#2#{} round(s)"
      ],
      "type": "Bakery"
    },
    "c_sdm_sprinkle_donut": {
      "name": "Sprinkle Donut",
      "text": [
        "When round begins, add",
        "{C:dark_edition}Polychrome{} to a random",
        "{C:attention}playing card{} in hand,",
        "lasts {C:attention}#2#{} trigger(s)"
      ],
      "type": "Bakery"
    },
    "c_sdm_fortune_cookie": {
      "name": "Fortune Cookie",
      "text": [
        "Create {C:attention}#1#{} {C:green}free{} {C:tarot}Arcana Pack{}",
        "at the start of shop,",
        "lasts {C:attention}#2#{} trigger(s)",
        "{C:inactive}(Doesn't require room)"
      ],
      "type": "Bakery"
    },
    "c_sdm_moon_cakes": {
      "name": "Moon Cakes",
      "text": [
        "Create {C:attention}#1#{} {C:green}free{} {C:planet}Celestial Pack{}",
        "at the start of shop,",
        "lasts {C:attention}#2#{} trigger(s)",
        "{C:inactive}(Doesn't require room)"
      ],
      "type": "Bakery"
    },
    "c_sdm_bread_monster": {
      "name": "Bread Monster",
      "text": [
        "Create {C:attention}#1#{} {C:green}free{} {C:spectral}Spectral Pack{}",
        "at the start of shop,",
        "lasts {C:attention}#2#{} trigger(s)",
        "{C:inactive}(Doesn't require room)"
      ],
      "type": "Bakery"
    },
    "c_sdm_bread_bites": {
      "name": "Bread Bites",
      "text": [
        "Create {C:attention}#1#{} {C:green}free{} {C:cry_code}Code Pack{}",
        "at the start of shop,",
        "lasts {C:attention}#2#{} trigger(s)",
        "{C:inactive}(Doesn't require room)"
      ],
      "type": "Bakery"
    },
    "c_sdm_sponge_cake": {
      "name": "Sponge Cake",
      "text": [
        "Create {C:attention}#1#{} {C:dark_edition}Negative {C:attention}Splash{}",
        "when {C:attention}Blind{} is selected,",
        "lasts {C:attention}#2#{} trigger(s)"
      ],
      "type": "Bakery"
    },
    "c_sdm_macarons": {
      "name": "Macarons",
      "text": [
        "Create {C:attention}#1#{} {C:green}free{} {C:colourcard}Colour Pack{}",
        "at the start of shop,",
        "lasts {C:attention}#2#{} trigger(s)",
        "{C:inactive}(Doesn't require room)"
      ],
      "type": "Bakery"
    },
    "c_sdm_king_cake": {
      "name": "King Cake",
      "text": [
        "Create {C:attention}#1#{} {C:green}free{} {C:paperback_minor_arcana}Minor Arcana Pack{}",
        "at the start of shop,",
        "lasts {C:attention}#2#{} trigger(s)",
        "{C:inactive}(Doesn't require room)"
      ],
      "type": "Bakery"
    },
    "c_sdm_ambrosia_bread": {
      "name": "Ambrosia Bread",
      "text": [
        "Create {C:attention}#1#{} {C:green}free{} {C:myth_light}Legend Pack{}",
        "at the start of shop,",
        "lasts {C:attention}#2#{} trigger(s)",
        "{C:inactive}(Doesn't require room)"
      ],
      "type": "Bakery"
    },
    "c_sdm_peremech": {
      "name": "Peremech",
      "text": [
        "Create {C:attention}#1#{} {C:green}free{} {C:attention}TOGA Booster{}",
        "{C:attention}Pack{} at the start of shop,",
        "lasts {C:attention}#2#{} trigger(s)",
        "{C:inactive}(Doesn't require room)"
      ],
      "type": "Bakery"
    },
    "c_sdm_funnel_cake": {
      "name": "Funnel Cake",
      "text": [
        "Create {C:attention}#1#{} {C:green}free{} {C:silly}Silly Pack{}",
        "at the start of shop,",
        "lasts {C:attention}#2#{} trigger(s)",
        "{C:inactive}(Doesn't require room)"
      ],
      "type": "Bakery"
    },
    "c_sdm_chiacchiere": {
      "name": "Chiacchiere",
      "text": [
        "Create {C:attention}#1#{} {C:green}free{} {C:stamp}Postal Pack{}",
        "at the start of shop,",
        "lasts {C:attention}#2#{} trigger(s)",
        "{C:inactive}(Doesn't require room)"
      ],
      "type": "Bakery"
    },
    "v_sdm_shadow": {
      "name": "Shadow",
      "text": [
        "Create a {C:dark_edition}Negative{C:attention} Tag{}"
      ],
      "type": "Voucher"
    },
    "v_sdm_eclipse": {
      "name": "Eclipse",
      "text": [
        "Create a {C:dark_edition}Negative{C:attention} Tag{}",
        "when {C:attention}Boss Blind{} is defeated"
      ],
      "type": "Voucher"
    },
    "v_sdm_oblivion": {
      "name": "Oblivion",
      "text": [
        "Create a {C:dark_edition}Negative{C:attention} Tag{}",
        "when {C:attention}Blind{} is defeated"
      ],
      "type": "Voucher"
    },
    "v_sdm_drought": {
      "name": "Drought",
      "text": [
        "{C:attention}Standard Packs{} no",
        "longer appear in shop"
      ],
      "type": "Voucher"
    },
    "v_sdm_famine": {
      "name": "Famine",
      "text": [
        "{C:attention}Buffon Packs{} no",
        "longer appear in shop"
      ],
      "type": "Voucher"
    },
    "v_sdm_desolation": {
      "name": "Desolation",
      "text": [
        "Non-{C:attention}Mega Packs{} no",
        "longer appear in shop"
      ],
      "type": "Voucher"
    },
    "v_sdm_bakery_stall": {
      "name": "Bakery Stall",
      "text": [
        "{C:bakery}Bakery{} goods may",
        "appear in the shop"
      ],
      "type": "Voucher"
    },
    "v_sdm_bakery_shop": {
      "name": "Bakery Shop",
      "text": [
        "{C:bakery}Bakery{} goods last",
        "twice as long"
      ],
      "type": "Voucher"
    },
    "v_sdm_bakery_factory": {
      "name": "Bakery Factory",
      "text": [
        "Double the effects",
        "of {C:bakery}Bakery{} goods"
      ],
      "type": "Voucher"
    },
    "v_sdm_joker_voucher": {
      "name": "Joker Voucher",
      "text": [
        "{X:mult,C:white}X#1#{} Mult per redeemed",
        "{C:attention}Voucher{} this run",
        "{C:inactive}(Currently {X:mult,C:white}X#2#{C:inactive} Mult)"
      ],
      "type": "Voucher"
    },
    "tag_sdm_flour": {
      "name": "Flour Tag",
      "text": [
        "Gives a free",
        "{C:bakery}Jumbo Bakery Pack"
      ],
      "type": "Tag"
    },
    "p_sdm_bakery_normal_1": {
      "name": "Bakery Pack",
      "text": [
        "Choose {C:attention}#1#{} of up to",
        "{C:attention}#2#{C:bakery} Bakery{} goods to",
        "be taken immediately"
      ],
      "type": "Other"
    },
    "p_sdm_bakery_normal_2": {
      "name": "Bakery Pack",
      "text": [
        "Choose {C:attention}#1#{} of up to",
        "{C:attention}#2#{C:bakery} Bakery{} goods to",
        "be taken immediately"
      ],
      "type": "Other"
    },
    "p_sdm_bakery_jumbo_1": {
      "name": "Jumbo Bakery Pack",
      "text": [
        "Choose {C:attention}#1#{} of up to",
        "{C:attention}#2#{C:bakery} Bakery{} goods to",
        "be taken immediately"
      ],
      "type": "Other"
    },
    "p_sdm_bakery_mega_1": {
      "name": "Mega Bakery Pack",
      "text": [
        "Choose {C:attention}#1#{} of up to",
        "{C:attention}#2#{C:bakery} Bakery{} goods to",
        "be taken immediately"
      ],
      "type": "Other"
    },
    "undiscovered_bakery": {
      "name": "Unknown Bakery Goods",
      "text": [
        "Find this card in an unseeded",
        "run to find out what it does"
      ],
      "type": "Other"
    },
    "space_jokers": {
      "name": "Space Jokers",
      "text": [
        "Astronomer, Constellation,",
        "Rocket, Satellite,",
        "Space Joker, Supernova etc."
      ],
      "type": "Other"
    },
    "modified_card": {
      "name": "Modified",
      "text": [
        "Enhancement, seal,",
        "edition"
      ],
      "type": "Other"
    },
    "chaos_exceptions": {
      "name": "Exceptions",
      "text": [
        "Round score, goal score,",
        "hand level, and descriptions"
      ],
      "type": "Other"
    },
    "perishable_no_debuff": {
      "name": "Perishable",
      "text": [
        "Debuffed after",
        "{C:attention}#1#{} rounds"
      ],
      "type": "Other"
    },
    "morph_list": {
      "name": "Morph List",
      "text": [
        "Hand, discard, handsize,",
        "joker slot, consumable slot"
      ],
      "type": "Other"
    },
    "undefined_standard_pack": {
      "name": "Standard Pack",
      "text": [
        "Choose {C:attention}X{} of up to",
        "{C:attention}Y{C:attention} Playing{} cards to",
        "add to your deck"
      ],
      "type": "Other"
    },
    "undefined_buffoon_pack": {
      "name": "Buffoon Pack",
      "text": [
        "Choose {C:attention}X{} of up to",
        "{C:attention}Y{C:joker} Joker{} cards"
      ],
      "type": "Other"
    },
    "undefined_mega_pack": {
      "name": "Mega Booster Pack",
      "text": [
        "Choose {C:attention}2{} of up to",
        "{C:attention}5{C:attention} X{} cards to",
        "be used immediately"
      ],
      "type": "Other"
    },
    "vanilla_consumable": {
      "name": "Vanilla Consumable",
      "text": [
        "{C:tarot}Tarot{}, {C:planet}Planet",
        "and {C:spectral}Spectral{} cards"
      ],
      "type": "Other"
    },
    "je_j_sdm_mult_n_chips": {
      "name": "Evolution",
      "text": [
        "Score {C:attention}#2# Mult",
        "and {C:attention}Bonus{} cards",
        "{C:inactive}({C:attention}#1#{C:inactive}/#2#)"
      ],
      "type": "Other"
    },
    "je_j_sdm_shareholder_joker": {
      "name": "Evolution",
      "text": [
        "Sell {C:attention}#2# {C:blue}Common",
        "{C:attention}Joker{} cards",
        "{C:inactive}({C:attention}#1#{C:inactive}/#2#)"
      ],
      "type": "Other"
    },
    "je_j_sdm_bullet_train": {
      "name": "Evolution",
      "text": [
        "Win {C:attention}#2# rounds",
        "with {C:attention}1{} hand",
        "{C:inactive}({C:attention}#1#{C:inactive}/#2#)"
      ],
      "type": "Other"
    },
    "je_j_sdm_joker_voucher": {
      "name": "Evolution",
      "text": [
        "Purchase {C:attention}#2#{} vouchers",
        "this run",
        "{C:inactive}({C:attention}#1#{C:inactive}/#2#)"
      ],
      "type": "Other"
    },
    "sleeve_sdm_0_s": {
      "name": "SDM_0's Sleeve",
      "text": [
        "{C:attention}SDM_0's Stuff{}",
        "Joker cards",
        "appear {C:attention}5{} times",
        "more often"
      ],
      "type": "Sleeve"
    },
    "sleeve_sdm_bazaar": {
      "name": "Bazaar Sleeve",
      "text": [
        "After defeating each",
        "{C:attention}Boss Blind{}, create a",
        "{C:attention}SDM_0's Stuff{} consumable",
        "{C:inactive}(Must have room)"
      ],
      "type": "Sleeve"
    },
    "sleeve_sdm_sandbox": {
      "name": "Sandbox Sleeve",
      "text": [
        "{C:attention}+#1#{} Joker Slots",
        "{C:red}+#2#{} Ante to win"
      ],
      "type": "Sleeve"
    },
    "sleeve_sdm_lucky_7": {
      "name": "Lucky 7 Sleeve",
      "text": [
        "Starting {C:attention}7s{} are {C:attention,T:m_lucky}Lucky{} Cards",
        "{s:0.8}Doubles all {C:attention,s:0.8}listed {C:green,E:1,S:1.1,s:0.8}probabilities",
        "{C:red}X#1#{} base Blind size"
      ],
      "type": "Sleeve"
    },
    "sleeve_sdm_lucky_7_alt_1": {
      "name": "Lucky 7 Sleeve",
      "text": [
        "Start run with a",
        "{C:purple}Eternal{} {C:attention,T:j_sdm_lucky_joker}Lucky Joker"
      ],
      "type": "Sleeve"
    },
    "sleeve_sdm_lucky_7_alt_2": {
      "name": "Lucky 7 Sleeve",
      "text": [
        "Start run with a",
        "{C:purple}Eternal{} {C:attention,T:j_oops}Oops! All 6s"
      ],
      "type": "Sleeve"
    },
    "sleeve_sdm_dna": {
      "name": "DNA Sleeve",
      "text": [
        "Rightmost playing card",
        "from {C:attention}winning poker hand{}",
        "is {C:blue}dupli{C:red}cated{}"
      ],
      "type": "Sleeve"
    },
    "sleeve_sdm_hieroglyph": {
      "name": "Hieroglyph Sleeve",
      "text": [
        "{C:spectral}Spectral{} cards may",
        "appear in the shop,",
        "start with an {C:spectral,T:c_ankh}Ankh{} card"
      ],
      "type": "Sleeve"
    },
    "sleeve_sdm_hieroglyph_ghost": {
      "name": "Hieroglyph Sleeve",
      "text": [
        "{C:spectral}Spectral{} cards appearance rate",
        "in the shop doubles",
        "Start with an {C:spectral,T:c_ankh}Ankh{} card"
      ],
      "type": "Sleeve"
    },
    "sleeve_sdm_hieroglyph_alt": {
      "name": "Hieroglyph Sleeve",
      "text": [
        "{C:spectral}Spectral{} cards appearance rate",
        "in the shop doubles,",
        "{C:spectral}Spectral Packs{} have {C:attention}#1#{}",
        "extra options to choose from"
      ],
      "type": "Sleeve"
    },
    "sleeve_sdm_xxl": {
      "name": "XXL Sleeve",
      "text": [
        "Start with {C:attention}double{}",
        "the deck size"
      ],
      "type": "Sleeve"
    },
    "sleeve_sdm_hoarder": {
      "name": "Hoarder Sleeve",
      "text": [
        "At end of each Round:",
        "{C:money}$#1#{} per remaining {C:red}Discard",
        "{s:0.8}Extra {s:0.8,C:blue}Hands{s:0.8} no longer earn money",
        "{s:0.8}Earn no {s:0.8,C:attention}Interest{s:0.8} at end of round"
      ],
      "type": "Sleeve"
    },
    "sleeve_sdm_hoarder_alt": {
      "name": "Hoarder Sleeve",
      "text": [
        "At end of each Round:",
        "{C:money}$#1#{} per remaining {C:red}Discard",
        "{s:0.8}Earn no {s:0.8,C:attention}Interest{s:0.8} at end of round"
      ],
      "type": "Sleeve"
    },
    "sleeve_sdm_modders": {
      "name": "Modder's Sleeve",
      "text": [
        "{C:attention}Vanilla{} Joker cards",
        "can't appear in shop"
      ],
      "type": "Sleeve"
    },
    "sleeve_sdm_modders_alt": {
      "name": "Modder's Sleeve",
      "text": [
        "{C:attention}Vanilla{} cards",
        "and Vouchers",
        "can't appear in shop"
      ],
      "type": "Sleeve"
    },
    "sleeve_sdm_reverb": {
      "name": "Reverb Sleeve",
      "text": [
        "Retrigger each Joker",
        "{C:attention}#2#{} time",
        "{C:red}#1#{} Joker Slots"
      ],
      "type": "Sleeve"
    },
    "sleeve_sdm_reverb_alt": {
      "name": "Reverb Sleeve",
      "text": [
        "Retrigger each Joker",
        "{C:attention}#1#{} more time"
      ],
      "type": "Sleeve"
    },
    "sleeve_sdm_roguelike": {
      "name": "Roguelike Sleeve",
      "text": [
        "Start run with the",
        "{C:attention,T:v_overstock_norm}#1#{} voucher",
        "{C:attention}+#2#{} Booster Pack slot",
        "{C:green}Rerolling{} is disabled"
      ],
      "type": "Sleeve"
    },
    "sleeve_sdm_roguelike_alt": {
      "name": "Roguelike Sleeve",
      "text": [
        "Start run with the",
        "{C:attention,T:v_overstock_plus}#1#{} voucher",
        "{C:attention}+#2#{} Voucher slot"
      ],
      "type": "Sleeve"
    },
    "sleeve_sdm_bakers": {
      "name": "Baker's Sleeve",
      "text": [
        "Start run with the",
        "{C:bakery,T:v_sdm_bakery_stall}#1#{} voucher",
        "{C:attention}+#2#{} consumable slots"
      ],
      "type": "Sleeve"
    },
    "sleeve_sdm_bakers_alt": {
      "name": "Baker's Sleeve",
      "text": [
        "Start run with the",
        "{C:bakery,T:v_sdm_bakery_shop}#1#{} voucher"
      ],
      "type": "Sleeve"
    },
    "pnr_sdm_lucky_joker": {
      "name": "Luck",
      "text": [
        "Retrigger",
        "first scored {C:attention}7{}",
        "{C:attention}#1#{} additional time(s)"
      ],
      "type": "Partner"
    },
    "pnr_sdm_shareholder_joker": {
      "name": "Stonks",
      "text": [
        "Earn between {C:money}$#1#{} and {C:money}$#2#{}",
        "at end of round"
      ],
      "type": "Partner"
    },
    "pnr_sdm_ouija_board": {
      "name": "Spirit",
      "text": [
        "Create {C:attention}#2# {C:red}Rare {C:attention}Tag(s){}",
        "after {C:attention}#1#{} rounds",
        "{C:inactive}(Currently {C:attention}#3#{C:inactive}/#1#)"
      ],
      "type": "Partner"
    },
    "pnr_sdm_mystery_joker": {
      "name": "Gacha",
      "text": [
        "Create {C:attention}#1# {C:green}Uncommon {C:attention}Tag(s){}",
        "when {C:attention}Boss Blind{} is defeated"
      ],
      "type": "Partner"
    },
    "pnr_sdm_crooked_joker": {
      "name": "Twist",
      "text": [
        "Gain or lose {C:attention}#1#{} card slot(s)",
        "at the start of shop"
      ],
      "type": "Partner"
    },
    "pnr_sdm_jambo": {
      "name": "Joke",
      "text": [
        "{C:mult}+#1#{} Mult from lowest",
        "discarded {C:attention}rank{}",
        "{C:inactive}(Currently {C:mult}+#2#{C:inactive} Mult)"
      ],
      "type": "Partner"
    },
    "pnr_sdm_free_pass": {
      "name": "Ticket",
      "text": [
        "First {C:blue}hand{} #1# {C:red}discard{}",
        "of round is {C:attention}free{}",
        "on {C:attention}Boss Blind{}"
      ],
      "type": "Partner"
    },
    "pnr_sdm_ditto_joker": {
      "name": "Goop",
      "text": [
        "Transforms into a",
        "random {C:attention}partner{}",
        "every {C:attention}2{} Antes"
      ],
      "type": "Partner"
    },
    "k_sdm_active": {
      "name": "\"Active\"",
      "text": [],
      "type": "dictionary"
    },
    "k_sdm_inactive": {
      "name": "\"Inactive\"",
      "text": [],
      "type": "dictionary"
    },
    "k_halved_ex": {
      "name": "\"Halved!\"",
      "text": [],
      "type": "dictionary"
    },
    "k_shared_ex": {
      "name": "\"Shared!\"",
      "text": [],
      "type": "dictionary"
    },
    "k_plus_code": {
      "name": "\"+1 Code\"",
      "text": [],
      "type": "dictionary"
    },
    "k_plus_tag": {
      "name": "\"+1 Tag\"",
      "text": [],
      "type": "dictionary"
    },
    "k_plus_pack": {
      "name": "\"+1 Pack\"",
      "text": [],
      "type": "dictionary"
    },
    "k_crab_ex": {
      "name": "\"Crab!\"",
      "text": [],
      "type": "dictionary"
    },
    "k_bonus": {
      "name": "\"Bonus\"",
      "text": [],
      "type": "dictionary"
    },
    "k_ditto_ex": {
      "name": "\"Ditto!\"",
      "text": [],
      "type": "dictionary"
    },
    "k_bakery": {
      "name": "\"Bakery\"",
      "text": [],
      "type": "dictionary"
    },
    "b_bakery_cards": {
      "name": "\"Bakery Goods\"",
      "text": [],
      "type": "dictionary"
    },
    "k_bakery_pack": {
      "name": "\"Bakery Pack\"",
      "text": [],
      "type": "dictionary"
    },
    "k_plus_bakery": {
      "name": "\"+1 Bakery\"",
      "text": [],
      "type": "dictionary"
    },
    "k_plus_egg": {
      "name": "\"+1 Egg\"",
      "text": [],
      "type": "dictionary"
    },
    "a_hand": {
      "name": "\"+#1# Hand\"",
      "text": [],
      "type": "v_dictionary"
    },
    "a_hands": {
      "name": "\"+#1# Hands\"",
      "text": [],
      "type": "v_dictionary"
    },
    "a_hand_minus": {
      "name": "\"-#1# Hand\"",
      "text": [],
      "type": "v_dictionary"
    },
    "a_discard": {
      "name": "\"+#1# Discard\"",
      "text": [],
      "type": "v_dictionary"
    },
    "a_discard_minus": {
      "name": "\"-#1# Discard\"",
      "text": [],
      "type": "v_dictionary"
    },
    "a_joker_slot": {
      "name": "\"+#1# Joker Slot\"",
      "text": [],
      "type": "v_dictionary"
    },
    "a_joker_slot_minus": {
      "name": "\"-#1# Joker Slot\"",
      "text": [],
      "type": "v_dictionary"
    },
    "a_consumable_slot": {
      "name": "\"+#1# Cons. Slot\"",
      "text": [],
      "type": "v_dictionary"
    },
    "a_consumable_slot_minus": {
      "name": "\"-#1# Cons. Slot\"",
      "text": [],
      "type": "v_dictionary"
    },
    "a_shop_slot": {
      "name": "\"+#1# Shop Slot\"",
      "text": [],
      "type": "v_dictionary"
    },
    "a_shop_slot_minus": {
      "name": "\"-#1# Shop Slot\"\n        ",
      "text": [],
      "type": "v_dictionary"
    },
    "ach_sdm_good_riddance": {
      "name": "\"Good Riddance\"",
      "text": [],
      "type": "achievement_names"
    }
  },
  "atlases": {
    "sdm_bakery_boosters": {
      "path": "bakery/sdm_bakery_boosters.png",
      "px": 71,
      "py": 95,
      "resolvedGitHubPath": "assets/1x/bakery/sdm_bakery_boosters.png"
    },
    "sdm_bakery_consumables": {
      "path": "bakery/sdm_bakery_consumables.png",
      "px": 70,
      "py": 95,
      "resolvedGitHubPath": "assets/1x/bakery/sdm_bakery_consumables.png"
    },
    "sdm_bakery_tags": {
      "path": "bakery/sdm_bakery_tags.png",
      "px": 34,
      "py": 34,
      "resolvedGitHubPath": "assets/1x/bakery/sdm_bakery_tags.png"
    },
    "sdm_bakery_vouchers": {
      "path": "bakery/sdm_bakery_vouchers.png",
      "px": 71,
      "py": 95,
      "resolvedGitHubPath": "assets/1x/bakery/sdm_bakery_vouchers.png"
    },
    "sdm_consumables": {
      "path": "sdm_consumables.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/SDM_0-s-Stuff@SDM0/1.7.3/sdm_consumables.png",
      "resolvedGitHubPath": "assets/1x/sdm_consumables.png"
    },
    "sdm_enhancers": {
      "path": "sdm_enhancers.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/SDM_0-s-Stuff@SDM0/1.7.3/sdm_enhancers.png",
      "resolvedGitHubPath": "assets/1x/sdm_enhancers.png"
    },
    "sdm_jokers": {
      "path": "sdm_jokers.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/SDM_0-s-Stuff@SDM0/1.7.3/sdm_jokers.png",
      "resolvedGitHubPath": "assets/1x/sdm_jokers.png"
    },
    "sdm_ditto_mark": {
      "path": "sdm_ditto_mark.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/SDM_0-s-Stuff@SDM0/1.7.3/sdm_ditto_mark.png",
      "resolvedGitHubPath": "assets/1x/sdm_ditto_mark.png"
    },
    "sdm_vouchers": {
      "path": "sdm_vouchers.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/SDM_0-s-Stuff@SDM0/1.7.3/sdm_vouchers.png",
      "resolvedGitHubPath": "assets/1x/sdm_vouchers.png"
    },
    "sdm_sleeves": {
      "path": "sdm_sleeves.png",
      "px": 73,
      "py": 95,
      "localPath": "/wiki-data/SDM_0-s-Stuff@SDM0/1.7.3/sdm_sleeves.png",
      "resolvedGitHubPath": "assets/1x/sdm_sleeves.png"
    },
    "sdm_partners": {
      "path": "sdm_partners.png",
      "px": 46,
      "py": 58,
      "localPath": "/wiki-data/SDM_0-s-Stuff@SDM0/1.7.3/sdm_partners.png",
      "resolvedGitHubPath": "assets/1x/sdm_partners.png"
    },
    "modicon": {
      "path": "sdm_modicon.png",
      "px": 34,
      "py": 34,
      "localPath": "/wiki-data/SDM_0-s-Stuff@SDM0/1.7.3/sdm_modicon.png",
      "resolvedGitHubPath": "assets/1x/sdm_modicon.png"
    }
  },
  "cards": [
    {
      "type": "Bakery",
      "key": "good_riddance",
      "atlas": null,
      "pos": null,
      "raw": "object_type = \"Achievement\",\n    key = \"good_riddance\",\n    order = 10000,\n    bypass_all_unlocked = true,\n    --reset_on_startup = true,\n    unlock_condition = function(self, args)\n        if args.type == \"good_riddance\" then\n            return true\n        end\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "ConsumableType",
      "key": "Bakery",
      "atlas": null,
      "pos": null,
      "raw": "key = 'Bakery',\n    collection_rows = { 5, 6 },\n    primary_colour = HEX('e69138'),\n    secondary_colour = HEX('ff7f00'),\n    default = \"c_sdm_chocolate_truffles\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "sdm_bakery_boosters",
      "atlas": null,
      "pos": null,
      "raw": "key = \"sdm_bakery_boosters\",\n    path = \"bakery/sdm_bakery_boosters.png\",\n    px = 71,\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "sdm_bakery_doorbell",
      "atlas": null,
      "pos": null,
      "raw": "key = \"sdm_bakery_doorbell\",\n    path = \"doorbell.ogg\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "bakery_normal_1",
      "atlas": "sdm_bakery_boosters",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = 'bakery_normal_1',\n    name = 'Bakery Pack',\n    pos = {x = 0, y = 0},\n    cost = 4,\n    config = {extra = 3, choose = 1},\n    group_key = 'k_bakery_pack',\n    create_card = function(self, card, i)\n        return {set = \"Bakery\", area = G.pack_cards, skip_materialize = true, soulable = true, key_append = \"bkr\"}\n    end,\n    weight = 0.3,\n    kind = 'Bakery',\n    atlas = \"sdm_bakery_boosters\"",
      "config": {
        "extra": 3,
        "choose": 1
      },
      "ability": {
        "extra": 3,
        "choose": 1
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "bakery_normal_2",
      "atlas": "sdm_bakery_boosters",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = 'bakery_normal_2',\n    name = 'Bakery Pack',\n    pos = {x = 1, y = 0},\n    cost = 4,\n    config = {extra = 3, choose = 1},\n    group_key = 'k_bakery_pack',\n    create_card = function(self, card, i)\n        return {set = \"Bakery\", area = G.pack_cards, skip_materialize = true, soulable = true, key_append = \"bkr\"}\n    end,\n    weight = 0.3,\n    kind = 'Bakery',\n    atlas = \"sdm_bakery_boosters\"",
      "config": {
        "extra": 3,
        "choose": 1
      },
      "ability": {
        "extra": 3,
        "choose": 1
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "bakery_jumbo_1",
      "atlas": "sdm_bakery_boosters",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = 'bakery_jumbo_1',\n    name = 'Jumbo Bakery Pack',\n    pos = {x = 2, y = 0},\n    cost = 4,\n    config = {extra = 5, choose = 1},\n    group_key = 'k_bakery_pack',\n    create_card = function(self, card, i)\n        return {set = \"Bakery\", area = G.pack_cards, skip_materialize = true, soulable = true, key_append = \"bkr\"}\n    end,\n    weight = 0.3,\n    kind = 'Bakery',\n    atlas = \"sdm_bakery_boosters\"",
      "config": {
        "extra": 5,
        "choose": 1
      },
      "ability": {
        "extra": 5,
        "choose": 1
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "bakery_mega_1",
      "atlas": "sdm_bakery_boosters",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = 'bakery_mega_1',\n    name = 'Mega Bakery Pack',\n    pos = {x = 3, y = 0},\n    cost = 8,\n    config = {extra = 5, choose = 2},\n    group_key = 'k_bakery_pack',\n    create_card = function(self, card, i)\n        return {set = \"Bakery\", area = G.pack_cards, skip_materialize = true, soulable = true, key_append = \"bkr\"}\n    end,\n    weight = 0.07,\n    kind = 'Bakery',\n    atlas = \"sdm_bakery_boosters\"",
      "config": {
        "extra": 5,
        "choose": 2
      },
      "ability": {
        "extra": 5,
        "choose": 2
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "sdm_bakery_consumables",
      "atlas": null,
      "pos": null,
      "raw": "key = \"sdm_bakery_consumables\",\n    path = \"bakery/sdm_bakery_consumables.png\",\n    px = 70,\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "UndiscoveredSprite",
      "key": "Bakery",
      "atlas": "Tarot",
      "pos": {
        "x": 5,
        "y": 2
      },
      "raw": "key = 'Bakery',\n    atlas = 'Tarot',\n    prefix_config = {atlas = false},\n    pos = {x = 5, y = 2}",
      "config": {
        "atlas": false
      },
      "ability": {
        "atlas": false
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "baker",
      "atlas": "sdm_consumables",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = 'baker',\n    name = 'The Baker',\n    set = 'Tarot',\n    pos = {x = 2, y = 1},\n    cost = 3,\n    config = {extra = 1},\n    loc_vars = function(self, info_queue, card)\n        return {vars = {self.config.extra}}\n    end,\n    can_use = function(self, card, area, copier)\n        return #G.consumeables.cards < G.consumeables.config.card_limit or (card.area and card.area == G.consumeables)\n    end,\n    use = function(self, card)\n        local used_tarot = card or self\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n            if G.consumeables.config.card_limit > #G.consumeables.cards then\n                play_sound('timpani')\n                local _card = create_card('Bakery', G.consumeables, nil, nil, nil, nil, nil, bkr)\n                _card:add_to_deck()\n                G.consumeables:emplace(_card)\n                used_tarot:juice_up(0.3, 0.5)\n            end\n        return true end }))\n    end,\n    atlas = \"sdm_consumables\"",
      "config": {
        "extra": 1
      },
      "ability": {
        "extra": 1
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Bakery",
      "key": "sourdough",
      "atlas": null,
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = 'sourdough',\n    name = 'Sourdough',\n    pos = {x = 0, y = 0},\n    soul_pos = {x = 0, y = 1},\n    config = {extra = {amount = 2, remaining = 4}},\n    calculate = function(self, card, context)\n        if context.joker_main then\n            return {\n                xchips = card.ability.extra.amount,\n                func = function()\n                    if not context or SDM_0s_Stuff_Funcs.no_bp_retrigger(context) then\n                        SDM_0s_Stuff_Funcs.decrease_remaining_food(card)\n                    end\n                end\n            }\n        end\n    end,",
      "config": {
        "extra": {
          "amount": 2,
          "remaining": 4
        }
      },
      "ability": {
        "extra": {
          "amount": 2,
          "remaining": 4
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Bakery",
      "key": "baguette",
      "atlas": null,
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = 'baguette',\n    name = 'Baguette',\n    pos = {x = 1, y = 0},\n    soul_pos = {x = 1, y = 1},\n    config = {extra = {amount = 2, remaining = 4}},\n    calculate = function(self, card, context)\n        if context.joker_main then\n            return {\n                xmult = card.ability.extra.amount,\n                func = function()\n                    if not context or SDM_0s_Stuff_Funcs.no_bp_retrigger(context) then\n                        SDM_0s_Stuff_Funcs.decrease_remaining_food(card)\n                    end\n                end\n            }\n        end\n    end,",
      "config": {
        "extra": {
          "amount": 2,
          "remaining": 4
        }
      },
      "ability": {
        "extra": {
          "amount": 2,
          "remaining": 4
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Bakery",
      "key": "chocolate_truffles",
      "atlas": null,
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = 'chocolate_truffles',\n    name = 'Chocolate Truffles',\n    pos = {x = 2, y = 0},\n    soul_pos = {x = 2, y = 1},\n    config = {extra = {amount = 6, remaining = 3}},\n    calc_dollar_bonus = function(self, card)\n        local dollars = card.ability.extra.amount\n        SDM_0s_Stuff_Funcs.decrease_remaining_food(card)\n        return dollars\n    end,",
      "config": {
        "extra": {
          "amount": 6,
          "remaining": 3
        }
      },
      "ability": {
        "extra": {
          "amount": 6,
          "remaining": 3
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Bakery",
      "key": "banana_bread",
      "atlas": null,
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = 'banana_bread',\n    name = 'Banana Bread',\n    pos = {x = 3, y = 0},\n    soul_pos = {x = 3, y = 1},\n    config = {extra = {amount = 3, remaining = 4}},\n    loc_vars = function(self, info_queue, card)\n        local mod_num, mod_den = SMODS.get_probability_vars(card, 1, card.ability.extra.remaining)\n        return {vars = {card.ability.extra.amount, mod_num, mod_den}}\n    end,\n    calculate = function(self, card, context)\n        if context.joker_main then\n            return {\n                xmult = card.ability.extra.amount,\n                func = function()\n                    if SDM_0s_Stuff_Funcs.proba_check(card, card.ability.extra.remaining, 'bananabread') then\n                        G.E_MANAGER:add_event(Event({\n                            func = function()\n                                play_sound('tarot1')\n                                card.T.r = -0.2\n                                card:juice_up(0.3, 0.4)\n                                card.states.drag.is = true\n                                card.children.center.pinch.x = true\n                                G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.3, blockable = false,\n                                    func = function()\n                                        G.jokers:remove_card(card)\n                                        card:remove()\n                                        card = nil\n                                    return true; end}))\n                                return true\n                            end\n                        }))\n                        card_eval_status_text(card, 'extra', nil, nil, nil, {\n                            message = localize('k_extinct_ex'),\n                            colour = G.C.FILTER\n                        })\n                        SMODS.calculate_context({sdm_bakery_consumed = true})\n                    else\n                        card_eval_status_text(card, 'extra', nil, nil, nil, {\n                            message = localize('k_safe_ex'),\n                            colour = G.C.FILTER\n                        })\n                    end\n                end\n            }\n        end\n    end,",
      "config": {
        "extra": {
          "amount": 3,
          "remaining": 4
        }
      },
      "ability": {
        "extra": {
          "amount": 3,
          "remaining": 4
        }
      },
      "vars": [
        3,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Bakery",
      "key": "breadsticks",
      "atlas": null,
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "key = 'breadsticks',\n    name = 'Breadsticks',\n    pos = {x = 4, y = 0},\n    soul_pos = {x = 4, y = 1},\n    config = {extra = {amount = 2, remaining = 2}},\n    add_to_deck = function(self, card, from_debuff)\n        SMODS.Bakery.add_to_deck(self, card, from_debuff)\n        if not from_debuff then\n            G.GAME.round_resets.hands = G.GAME.round_resets.hands + card.ability.extra.amount\n            ease_hands_played(card.ability.extra.amount)\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        if not from_debuff then\n            G.GAME.round_resets.hands = G.GAME.round_resets.hands - card.ability.extra.amount\n        end\n    end,\n    calculate = function(self, card, context)\n        if context.end_of_round and context.main_eval and SDM_0s_Stuff_Funcs.no_bp_retrigger(context) then\n            SDM_0s_Stuff_Funcs.decrease_remaining_food(card)\n        end\n    end,",
      "config": {
        "extra": {
          "amount": 2,
          "remaining": 2
        }
      },
      "ability": {
        "extra": {
          "amount": 2,
          "remaining": 2
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Bakery",
      "key": "croissant",
      "atlas": null,
      "pos": {
        "x": 5,
        "y": 0
      },
      "raw": "key = 'croissant',\n    name = 'Croissant',\n    pos = {x = 5, y = 0},\n    soul_pos = {x = 5, y = 1},\n    config = {extra = {amount = 2, remaining = 2}},\n    add_to_deck = function(self, card, from_debuff)\n        SMODS.Bakery.add_to_deck(self, card, from_debuff)\n        if not from_debuff then\n            G.GAME.round_resets.discards = G.GAME.round_resets.discards + card.ability.extra.amount\n            ease_discard(card.ability.extra.amount)\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        if not from_debuff then\n            G.GAME.round_resets.discards = G.GAME.round_resets.discards - card.ability.extra.amount\n        end\n    end,\n    calculate = function(self, card, context)\n        if context.end_of_round and context.main_eval and SDM_0s_Stuff_Funcs.no_bp_retrigger(context) then\n            SDM_0s_Stuff_Funcs.decrease_remaining_food(card)\n        end\n    end,",
      "config": {
        "extra": {
          "amount": 2,
          "remaining": 2
        }
      },
      "ability": {
        "extra": {
          "amount": 2,
          "remaining": 2
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Bakery",
      "key": "bread_loaf",
      "atlas": null,
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = 'bread_loaf',\n    name = 'Bread Loaf',\n    pos = {x = 0, y = 2},\n    soul_pos = {x = 0, y = 3},\n    config = {extra = {amount = 2, remaining = 2}},\n    add_to_deck = function(self, card, from_debuff)\n        SMODS.Bakery.add_to_deck(self, card, from_debuff)\n        if G.hand then\n            G.hand:change_size(card.ability.extra.amount)\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        if G.hand then\n            G.hand:change_size(-card.ability.extra.amount)\n        end\n    end,\n    calculate = function(self, card, context)\n        if context.end_of_round and context.main_eval and SDM_0s_Stuff_Funcs.no_bp_retrigger(context) then\n            SDM_0s_Stuff_Funcs.decrease_remaining_food(card)\n        end\n    end,",
      "config": {
        "extra": {
          "amount": 2,
          "remaining": 2
        }
      },
      "ability": {
        "extra": {
          "amount": 2,
          "remaining": 2
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Bakery",
      "key": "sprinkle_donut",
      "atlas": null,
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "key = 'sprinkle_donut',\n    name = 'Sprinkle Donut',\n    pos = {x = 1, y = 2},\n    soul_pos = {x = 1, y = 3},\n    config = {extra = {amount = 1, remaining = 2}},\n    calculate = function(self, card, context)\n        if context.first_hand_drawn then\n            local no_edition_cards = {}\n            for _, v in ipairs(G.hand.cards) do\n                if not v.edition then no_edition_cards[#no_edition_cards+1] = v end\n            end\n            if no_edition_cards[1] then\n                G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n                    local _card = pseudorandom_element(no_edition_cards, pseudoseed('dnt'))\n                    _card:set_edition('e_polychrome', true)\n                    card:juice_up(0.3, 0.5)\n                return true end }))\n                SDM_0s_Stuff_Funcs.decrease_remaining_food(card)\n            end\n        end\n    end,",
      "config": {
        "extra": {
          "amount": 1,
          "remaining": 2
        }
      },
      "ability": {
        "extra": {
          "amount": 1,
          "remaining": 2
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Bakery",
      "key": "fortune_cookie",
      "atlas": null,
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "key = 'fortune_cookie',\n    name = 'Fortune Cookie',\n    pos = {x = 2, y = 2},\n    soul_pos = {x = 2, y = 3},\n    config = {extra = {amount = 1, remaining = 3}},\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue+1] = G.P_CENTERS.p_arcana_normal_1\n        return SMODS.Bakery.loc_vars(self, info_queue, card)\n    end,\n    calculate = function(self, card, context)\n        if context.starting_shop then\n            for i = 1, card.ability.extra.amount do\n                G.E_MANAGER:add_event(Event{\n                    func = function()\n                    local _booster = SMODS.add_booster_to_shop('p_arcana_normal_'..(math.random(1,4)))\n                    _booster.cost = 0\n                    return true\n                end})\n                card_eval_status_text(card, 'extra', nil, nil, nil, {\n                    message = localize('k_plus_pack'),\n                    colour = G.C.SECONDARY_SET.Tarot,\n                })\n            end\n            SDM_0s_Stuff_Funcs.decrease_remaining_food(card)\n        end\n    end,",
      "config": {
        "extra": {
          "amount": 1,
          "remaining": 3
        }
      },
      "ability": {
        "extra": {
          "amount": 1,
          "remaining": 3
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Bakery",
      "key": "moon_cakes",
      "atlas": null,
      "pos": {
        "x": 3,
        "y": 2
      },
      "raw": "key = 'moon_cakes',\n    name = 'Moon Cakes',\n    pos = {x = 3, y = 2},\n    soul_pos = {x = 3, y = 3},\n    config = {extra = {amount = 1, remaining = 3}},\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue+1] = G.P_CENTERS.p_celestial_normal_1\n        return SMODS.Bakery.loc_vars(self, info_queue, card)\n    end,\n    calculate = function(self, card, context)\n        if context.starting_shop then\n            for i = 1, card.ability.extra.amount do\n                G.E_MANAGER:add_event(Event{\n                    func = function()\n                    local _booster = SMODS.add_booster_to_shop('p_celestial_normal_'..(math.random(1,4)))\n                    _booster.cost = 0\n                    return true\n                end})\n                card_eval_status_text(card, 'extra', nil, nil, nil, {\n                    message = localize('k_plus_pack'),\n                    colour = G.C.SECONDARY_SET.Tarot,\n                })\n            end\n            SDM_0s_Stuff_Funcs.decrease_remaining_food(card)\n        end\n    end,",
      "config": {
        "extra": {
          "amount": 1,
          "remaining": 3
        }
      },
      "ability": {
        "extra": {
          "amount": 1,
          "remaining": 3
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Bakery",
      "key": "bread_monster",
      "atlas": null,
      "pos": {
        "x": 4,
        "y": 2
      },
      "raw": "key = 'bread_monster',\n    name = 'Bread Monster',\n    pos = {x = 4, y = 2},\n    soul_pos = {x = 4, y = 3},\n    config = {extra = {amount = 1, remaining = 2}},\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue+1] = G.P_CENTERS.p_spectral_normal_1\n        return SMODS.Bakery.loc_vars(self, info_queue, card)\n    end,\n    calculate = function(self, card, context)\n        if context.starting_shop then\n            for i = 1, card.ability.extra.amount do\n                G.E_MANAGER:add_event(Event{\n                    func = function()\n                    local _booster = SMODS.add_booster_to_shop('p_spectral_normal_'..(math.random(1,2)))\n                    _booster.cost = 0\n                    return true\n                end})\n                card_eval_status_text(card, 'extra', nil, nil, nil, {\n                    message = localize('k_plus_pack'),\n                    colour = G.C.SECONDARY_SET.Spectral,\n                })\n            end\n            SDM_0s_Stuff_Funcs.decrease_remaining_food(card)\n        end\n    end,",
      "config": {
        "extra": {
          "amount": 1,
          "remaining": 2
        }
      },
      "ability": {
        "extra": {
          "amount": 1,
          "remaining": 2
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Bakery",
      "key": "wedding_cake",
      "atlas": null,
      "pos": {
        "x": 5,
        "y": 2
      },
      "raw": "key = 'wedding_cake',\n    name = 'Wedding Cake',\n    set = 'Spectral',\n    soul_set = 'Bakery',\n    pos = {x = 5, y = 2},\n    soul_pos = {x = 5, y = 3},\n    config = {extra = {amount = 1, remaining = -1}},\n    hidden = true,\n    add_to_deck = function(self, card, from_debuff)\n        SMODS.Bakery.add_to_deck(self, card, from_debuff)\n        if not from_debuff then\n            G.jokers.config.card_limit = G.jokers.config.card_limit + card.ability.extra.amount\n            G.consumeables.config.card_limit = G.consumeables.config.card_limit + card.ability.extra.amount\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        if not from_debuff then\n            G.jokers.config.card_limit = G.jokers.config.card_limit - card.ability.extra.amount\n            G.consumeables.config.card_limit = G.consumeables.config.card_limit - card.ability.extra.amount\n        end\n    end,",
      "config": {
        "extra": {
          "amount": 1,
          "remaining": -1
        }
      },
      "ability": {
        "extra": {
          "amount": 1,
          "remaining": -1
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Bakery",
      "key": "sponge_cake",
      "atlas": null,
      "pos": {
        "x": 1,
        "y": 4
      },
      "raw": "key = 'sponge_cake',\n            name = 'Sponge Cake',\n            pos = {x = 1, y = 4},\n            soul_pos = {x = 1, y = 5},\n            config = {extra = {amount = 1, remaining = 2}},\n            loc_vars = function(self, info_queue, card)\n                info_queue[#info_queue+1] = G.P_CENTERS.e_negative\n                info_queue[#info_queue+1] = G.P_CENTERS.j_splash\n                return SMODS.Bakery.loc_vars(self, info_queue, card)\n            end,\n            calculate = function(self, card, context)\n                if context.setting_blind and SDM_0s_Stuff_Funcs.no_bp_retrigger(context) then\n                    for i = 1, card.ability.extra.amount do\n                        G.E_MANAGER:add_event(Event({\n                            trigger = 'before',\n                            delay = 0.0,\n                            func = (function()\n                                SMODS.add_card({key = 'j_splash', edition = 'e_negative', key_append = 'sck'})\n                                return true\n                            end)\n                        }))\n                        card_eval_status_text(card, 'extra', nil, nil, nil, {\n                            message = localize('k_plus_joker'),\n                            colour = G.C.BLUE,\n                        })\n                    end\n                    SDM_0s_Stuff_Funcs.decrease_remaining_food(card)\n                end\n            end,",
      "config": {
        "extra": {
          "amount": 1,
          "remaining": 2
        }
      },
      "ability": {
        "extra": {
          "amount": 1,
          "remaining": 2
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Bakery",
      "key": "macarons",
      "atlas": null,
      "pos": {
        "x": 2,
        "y": 4
      },
      "raw": "key = 'macarons',\n            name = 'Macarons',\n            pos = {x = 2, y = 4},\n            soul_pos = {x = 2, y = 5},\n            config = {extra = {amount = 1, remaining = 2}},\n            loc_vars = function(self, info_queue, card)\n                info_queue[#info_queue+1] = G.P_CENTERS.p_mf_colour_normal_1\n                return SMODS.Bakery.loc_vars(self, info_queue, card)\n            end,\n            calculate = function(self, card, context)\n                if context.starting_shop then\n                    for i = 1, card.ability.extra.amount do\n                        G.E_MANAGER:add_event(Event{\n                            func = function()\n                            local _booster = SMODS.add_booster_to_shop('p_mf_colour_normal_'..(math.random(1,2)))\n                            _booster.cost = 0\n                            return true\n                        end})\n                        card_eval_status_text(card, 'extra', nil, nil, nil, {\n                            message = localize('k_plus_pack'),\n                            colour = G.C.PURPLE,\n                        })\n                    end\n                    SDM_0s_Stuff_Funcs.decrease_remaining_food(card)\n                end\n            end,\n            no_collection = not (mf_config and mf_config[\"Colour Cards\"]),\n            in_pool = function()\n                return mf_config and mf_config[\"Colour Cards\"]\n            end,",
      "config": {
        "extra": {
          "amount": 1,
          "remaining": 2
        }
      },
      "ability": {
        "extra": {
          "amount": 1,
          "remaining": 2
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Bakery",
      "key": "king_cake",
      "atlas": null,
      "pos": {
        "x": 3,
        "y": 4
      },
      "raw": "key = 'king_cake',\n            name = 'King Cake',\n            pos = {x = 3, y = 4},\n            soul_pos = {x = 3, y = 5},\n            config = {extra = {amount = 1, remaining = 2}},\n            loc_vars = function(self, info_queue, card)\n                info_queue[#info_queue+1] = G.P_CENTERS.p_paperback_minor_arcana_normal_1\n                return SMODS.Bakery.loc_vars(self, info_queue, card)\n            end,\n            calculate = function(self, card, context)\n                if context.starting_shop then\n                    for i = 1, card.ability.extra.amount do\n                        G.E_MANAGER:add_event(Event{\n                            func = function()\n                            local _booster = SMODS.add_booster_to_shop('p_paperback_minor_arcana_normal_'..(math.random(1,2)))\n                            _booster.cost = 0\n                            return true\n                        end})\n                        card_eval_status_text(card, 'extra', nil, nil, nil, {\n                            message = localize('k_plus_pack'),\n                            colour = G.C.PAPERBACK_MINOR_ARCANA,\n                        })\n                    end\n                    SDM_0s_Stuff_Funcs.decrease_remaining_food(card)\n                end\n            end,\n            no_collection = not (PB_UTIL and PB_UTIL.config and PB_UTIL.config.minor_arcana_enabled),\n            in_pool = function()\n                return PB_UTIL and PB_UTIL.config and PB_UTIL.config.minor_arcana_enabled\n            end,",
      "config": {
        "extra": {
          "amount": 1,
          "remaining": 2
        }
      },
      "ability": {
        "extra": {
          "amount": 1,
          "remaining": 2
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Bakery",
      "key": "ambrosia_bread",
      "atlas": null,
      "pos": {
        "x": 4,
        "y": 4
      },
      "raw": "key = 'ambrosia_bread',\n            name = 'Ambrosia Bread',\n            pos = {x = 4, y = 4},\n            soul_pos = {x = 4, y = 5},\n            config = {extra = {amount = 1, remaining = 2}},\n            loc_vars = function(self, info_queue, card)\n                info_queue[#info_queue+1] = G.P_CENTERS.p_prism_small_myth_1\n                return SMODS.Bakery.loc_vars(self, info_queue, card)\n            end,\n            calculate = function(self, card, context)\n                if context.starting_shop then\n                    for i = 1, card.ability.extra.amount do\n                        G.E_MANAGER:add_event(Event{\n                            func = function()\n                            local _booster = SMODS.add_booster_to_shop('p_prism_small_myth_'..(math.random(1,2)))\n                            _booster.cost = 0\n                            return true\n                        end})\n                        card_eval_status_text(card, 'extra', nil, nil, nil, {\n                            message = localize('k_plus_pack'),\n                            colour = G.PRISM.C.myth_1,\n                        })\n                    end\n                    SDM_0s_Stuff_Funcs.decrease_remaining_food(card)\n                end\n            end,\n            no_collection = not (G.PRISM and G.PRISM.config.myth_enabled),\n            in_pool = function()\n                return G.PRISM and G.PRISM.config.myth_enabled\n            end,",
      "config": {
        "extra": {
          "amount": 1,
          "remaining": 2
        }
      },
      "ability": {
        "extra": {
          "amount": 1,
          "remaining": 2
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Bakery",
      "key": "peremech",
      "atlas": null,
      "pos": {
        "x": 5,
        "y": 4
      },
      "raw": "key = 'peremech',\n            name = 'Peremech',\n            pos = {x = 5, y = 4},\n            soul_pos = {x = 5, y = 5},\n            config = {extra = {amount = 1, remaining = 2}},\n            loc_vars = function(self, info_queue, card)\n                info_queue[#info_queue+1] = G.P_CENTERS.p_toga_togazipboosterpack\n                info_queue[#info_queue+1] = G.P_CENTERS.p_toga_togaziparchivepack\n                info_queue[#info_queue+1] = G.P_CENTERS.p_toga_togararpack\n                info_queue[#info_queue+1] = G.P_CENTERS.p_toga_togacardcabpack\n                info_queue[#info_queue+1] = G.P_CENTERS.p_toga_togaxcopydnapack\n                return SMODS.Bakery.loc_vars(self, info_queue, card)\n            end,\n            calculate = function(self, card, context)\n                if context.starting_shop then\n                    for i = 1, card.ability.extra.amount do\n                        G.E_MANAGER:add_event(Event{\n                            func = function()\n                            local _pack = get_pack(nil, 'TOGABoostPack')\n                            local _booster = SMODS.add_booster_to_shop(_pack.key)\n                            _booster.cost = 0\n                            return true\n                        end})\n                        card_eval_status_text(card, 'extra', nil, nil, nil, {\n                            message = localize('k_plus_pack'),\n                            colour = G.C.RED,\n                        })\n                    end\n                    SDM_0s_Stuff_Funcs.decrease_remaining_food(card)\n                end\n            end,",
      "config": {
        "extra": {
          "amount": 1,
          "remaining": 2
        }
      },
      "ability": {
        "extra": {
          "amount": 1,
          "remaining": 2
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Bakery",
      "key": "funnel_cake",
      "atlas": null,
      "pos": {
        "x": 0,
        "y": 6
      },
      "raw": "key = 'funnel_cake',\n            name = 'Funnel Cake',\n            pos = {x = 0, y = 6},\n            soul_pos = {x = 0, y = 7},\n            config = {extra = {amount = 1, remaining = 2}},\n            loc_vars = function(self, info_queue, card)\n                info_queue[#info_queue+1] = G.P_CENTERS.p_fmod_silly_small_2\n                return SMODS.Bakery.loc_vars(self, info_queue, card)\n            end,\n            calculate = function(self, card, context)\n                if context.starting_shop then\n                    for i = 1, card.ability.extra.amount do\n                        G.E_MANAGER:add_event(Event{\n                            func = function()\n                            -- First pack doesnt have a '_1'\n                            local _pack = (math.random(1,4) == 1 and '') or ('_' ..(math.random(2,4)))\n                            local _booster = SMODS.add_booster_to_shop('p_fmod_silly_small'.. _pack)\n                            _booster.cost = 0\n                            return true\n                        end})\n                        card_eval_status_text(card, 'extra', nil, nil, nil, {\n                            message = localize('k_plus_pack'),\n                            colour = HEX(\"ff98e2\"),\n                        })\n                    end\n                    SDM_0s_Stuff_Funcs.decrease_remaining_food(card)\n                end\n            end,\n            no_collection = not (SMODS.Mods['LuckyRabbit'] and SMODS.Mods['LuckyRabbit'].config and SMODS.Mods['LuckyRabbit'].config.silly_enabled),\n            in_pool = function()\n                return SMODS.Mods['LuckyRabbit'] and SMODS.Mods['LuckyRabbit'].config and SMODS.Mods['LuckyRabbit'].config.silly_enabled\n            end,",
      "config": {
        "extra": {
          "amount": 1,
          "remaining": 2
        }
      },
      "ability": {
        "extra": {
          "amount": 1,
          "remaining": 2
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Bakery",
      "key": "chiacchiere",
      "atlas": null,
      "pos": {
        "x": 1,
        "y": 6
      },
      "raw": "key = 'chiacchiere',\n            name = 'Chiacchiere',\n            pos = {x = 1, y = 6},\n            soul_pos = {x = 1, y = 7},\n            config = {extra = {amount = 1, remaining = 2}},\n            loc_vars = function(self, info_queue, card)\n                info_queue[#info_queue+1] = G.P_CENTERS.p_garb_stamp_booster\n                return SMODS.Bakery.loc_vars(self, info_queue, card)\n            end,\n            calculate = function(self, card, context)\n                if context.starting_shop then\n                    for i = 1, card.ability.extra.amount do\n                        G.E_MANAGER:add_event(Event{\n                            func = function()\n                            -- First pack doesnt have a '_1'\n                            local _pack = (math.random(1,2) == 1 and '') or '_2'\n                            local _booster = SMODS.add_booster_to_shop('p_garb_stamp_booster'.. _pack)\n                            _booster.cost = 0\n                            return true\n                        end})\n                        card_eval_status_text(card, 'extra', nil, nil, nil, {\n                            message = localize('k_plus_pack'),\n                            colour = G.C.FILTER,\n                        })\n                    end\n                    SDM_0s_Stuff_Funcs.decrease_remaining_food(card)\n                end\n            end,",
      "config": {
        "extra": {
          "amount": 1,
          "remaining": 2
        }
      },
      "ability": {
        "extra": {
          "amount": 1,
          "remaining": 2
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "sdm_bakery_tags",
      "atlas": null,
      "pos": null,
      "raw": "key = \"sdm_bakery_tags\",\n    path = \"bakery/sdm_bakery_tags.png\",\n    px = 34,\n    py = 34,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Tag",
      "key": "flour",
      "atlas": "sdm_bakery_tags",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = 'flour',\n    name = 'Flour Tag',\n    pos = {x = 0, y = 0},\n    min_ante = 2,\n    apply = function(self, tag, context)\n        if context.type == 'new_blind_choice' then\n            local lock = tag.ID\n            G.CONTROLLER.locks[lock] = true\n            tag:yep('+', G.C.PURPLE,function()\n                local card = Card(G.play.T.x + G.play.T.w/2 - G.CARD_W*1.27/2,\n                G.play.T.y + G.play.T.h/2-G.CARD_H*1.27/2, G.CARD_W*1.27, G.CARD_H*1.27, G.P_CARDS.empty, G.P_CENTERS['p_sdm_bakery_jumbo_1'], {bypass_discovery_center = true, bypass_discovery_ui = true})\n                card.cost = 0\n                card.from_tag = true\n                G.FUNCS.use_card({config = {ref_table = card}})\n                card:start_materialize()\n                G.CONTROLLER.locks[lock] = nil\n                return true\n            end)\n            tag.triggered = true\n            return true\n        end\n    end,\n    atlas = \"sdm_bakery_tags\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "sdm_bakery_vouchers",
      "atlas": null,
      "pos": null,
      "raw": "key = \"sdm_bakery_vouchers\",\n    path = \"bakery/sdm_bakery_vouchers.png\",\n    px = 71,\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Voucher",
      "key": "bakery_stall",
      "atlas": "sdm_bakery_vouchers",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = 'bakery_stall',\n    name = 'Bakery Stall',\n    pos = {x = 0, y = 0},\n    config = {extra = 2},\n    redeem = function(self, card)\n        G.E_MANAGER:add_event(Event({func = function()\n            G.GAME.bakery_rate = card.ability.extra\n        return true end}))\n    end,\n    atlas = \"sdm_bakery_vouchers\"",
      "config": {
        "extra": 2
      },
      "ability": {
        "extra": 2
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Voucher",
      "key": "bakery_shop",
      "atlas": "sdm_bakery_vouchers",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = 'bakery_shop',\n    name = 'Bakery Shop',\n    pos = {x = 0, y = 1},\n    redeem = function(self, card)\n        for k, v in ipairs(G.consumeables.cards) do\n            if v.config.center.set == \"Bakery\" then\n                v.ability.extra.remaining = v.ability.extra.remaining * 2\n            end\n        end\n        -- Future Bakery goods boost handled in SMODS.Bakery\n    end,\n    requires = {\"v_sdm_bakery_stall\"},\n    atlas = \"sdm_bakery_vouchers\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Challenge",
      "key": "scientific_downfall",
      "atlas": null,
      "pos": null,
      "raw": "loc_txt = \"Scientific Downfall\",\n    key = 'scientific_downfall',\n    rules = {\n        custom = {\n            {id = 'no_shop_planets'},\n        },\n        modifiers = {\n            {id = 'discards', value = 4},\n            {id = 'hands', value = 2},\n        },\n    },\n    jokers = {\n        {id = 'j_sdm_la_revolution', eternal = true},\n    },\n    restrictions = {\n        banned_cards = {\n            {id = 'c_high_priestess'},\n            {id = 'c_black_hole'},\n            {id = 'c_trance'},\n            {id = 'p_celestial_normal_1', ids = {\n                'p_celestial_normal_1','p_celestial_normal_2','p_celestial_normal_3','p_celestial_normal_4','p_celestial_jumbo_1','p_celestial_jumbo_2','p_celestial_mega_1','p_celestial_mega_2',\n            }},\n            {id = 'j_8_ball'},\n            {id = 'j_space'},\n            {id = 'j_constellation'},\n            {id = 'j_certificate'},\n            {id = 'j_satellite'},\n            {id = 'j_astronomer'},\n            {id = 'j_burnt'},\n            {id = 'j_sdm_reach_the_stars'},\n            {id = 'j_sdm_wormhole'},\n            {id = 'v_telescope'},\n            {id = 'v_observatory'},\n            {id = 'v_planet_merchant'},\n            {id = 'v_planet_tycoon'},\n        },\n        banned_tags = {\n            {id = 'tag_meteor'},\n            {id = 'tag_orbital'},\n        },\n        banned_other = {},\n    }",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Challenge",
      "key": "a_plumber_s_hassle",
      "atlas": null,
      "pos": null,
      "raw": "loc_txt = \"A Plumber's Hassle\",\n    key = 'a_plumber_s_hassle',\n    rules = {\n        custom = {},\n        modifiers = {\n            {id = 'joker_slots', value = 4},\n            {id = 'hands', value = 3},\n        },\n    },\n    jokers = {\n        {id = 'j_sdm_infinite_staircase', eternal = true},\n        {id = 'j_runner', eternal = true},\n    },\n    restrictions = {\n        banned_cards = {\n            {id = 'v_grabber'},\n            {id = 'v_nacho_tong'},\n            {id = 'j_burglar'},\n            {id = 'j_sdm_pizza'},\n        },\n        banned_tags = {},\n        banned_other = {}\n    }",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Challenge",
      "key": "spare_change",
      "atlas": null,
      "pos": null,
      "raw": "loc_txt = \"Spare Change\",\n    key = 'spare_change',\n    rules = {\n        custom = {\n            {id = 'no_extra_hand_money'},\n            {id = 'no_interest'}\n        },\n        modifiers = {},\n    },\n    jokers = {\n        {id = 'j_sdm_clown_bank', eternal = true},\n        {id = 'j_sdm_tip_jar', eternal = true},\n    },\n    restrictions = {\n        banned_cards = {\n            {id = 'v_seed_money'},\n            {id = 'v_money_tree'},\n            {id = 'j_to_the_moon'},\n            {id = 'j_rocket'},\n            {id = 'j_golden'},\n            {id = 'j_satellite'},\n            {id = 'j_sdm_shareholder_joker'},\n            {id = 'j_sdm_tip_jar'},\n            {id = 'j_sdm_treasure_chest'},\n        },\n        banned_tags = {},\n        banned_other = {}\n    }",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Challenge",
      "key": "twisted_binding",
      "atlas": null,
      "pos": null,
      "raw": "loc_txt = \"Twisted Binding\",\n    key = 'twisted_binding',\n    jokers = {\n        {id = 'j_sdm_crooked_joker', eternal = true},\n    },",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Challenge",
      "key": "Archifoolery",
      "atlas": null,
      "pos": null,
      "raw": "loc_txt = \"Archifoolery\",\n    key = 'Archifoolery',\n    rules = {\n        custom = {},\n        modifiers = {\n            {id = 'joker_slots', value = 1},\n        },\n    },\n    jokers = {\n        {id = 'j_sdm_archibald', edition = 'negative', eternal = true},\n    },\n    restrictions = {\n        banned_cards = {\n            {id = 'j_sdm_0'},\n            {id = 'v_blank'},\n            {id = 'v_antimatter'},\n        },\n        banned_tags = {},\n        banned_other = {}\n    }",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "sdm_consumables",
      "atlas": null,
      "pos": null,
      "raw": "key = \"sdm_consumables\",\n    path = \"sdm_consumables.png\",\n    px = 71,\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "sphinx",
      "atlas": "sdm_consumables",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = 'sphinx',\n    name = 'The Sphinx',\n    set = 'Tarot',\n    pos = {x = 0, y = 0},\n    cost = 3,\n    config = {extra = {max_highlighted = 1, odds = 2}},\n    loc_vars = function(self, info_queue, card)\n        local mod_num, mod_den = SMODS.get_probability_vars(card, 1, self.config.extra.odds)\n        return {vars = {mod_num, mod_den, self.config.extra.max_highlighted}}\n    end,\n    can_use = function(self, card, area, copier)\n        if G.STATE == G.STATES.SELECTING_HAND or G.STATE == G.STATES.SMODS_BOOSTER_OPENED then\n            return G.hand and G.hand.highlighted and #G.hand.highlighted <= card.ability.extra.max_highlighted and #G.hand.highlighted >= 1\n        end\n        return false\n    end,\n    use = function(self, card)\n        local used_tarot = card or self\n        if SDM_0s_Stuff_Funcs.proba_check(card, card.ability.extra.odds, 'sphinx') then\n            G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n                for i = 1, #G.hand.highlighted do\n                    local edition = poll_edition('wheel_of_fortune', nil, true, true)\n                    G.hand.highlighted[i]:set_edition(edition, true)\n                end\n                used_tarot:juice_up(0.3, 0.5)\n                return true\n            end}))\n        else\n            G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n                attention_text({\n                    text = localize('k_nope_ex'),\n                    scale = 1.3,\n                    hold = 1.4,\n                    major = used_tarot,\n                    backdrop_colour = G.C.SECONDARY_SET.Tarot,\n                    align = (G.STATE == G.STATES.SMODS_BOOSTER_OPENED) and 'tm' or 'cm',\n                    offset = {x = 0, y = (G.STATE == G.STATES.SMODS_BOOSTER_OPENED) and -0.2 or 0},\n                    silent = true\n                    })\n                    G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.06*G.SETTINGS.GAMESPEED, blockable = false, blocking = false, func = function()\n                        play_sound('tarot2', 0.76, 0.4);return true end}))\n                    play_sound('tarot2', 1, 0.4)\n                    used_tarot:juice_up(0.3, 0.5)\n            return true end}))\n        end\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.2,func = function() if G.hand then G.hand:unhighlight_all() end; return true end }))\n    end,\n    atlas = \"sdm_consumables\"",
      "config": {
        "extra": {
          "max_highlighted": 1,
          "odds": 2
        }
      },
      "ability": {
        "extra": {
          "max_highlighted": 1,
          "odds": 2
        }
      },
      "vars": [
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "mother",
      "atlas": "sdm_consumables",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = 'mother',\n    name = 'The Mother',\n    set = 'Tarot',\n    pos = {x = 3, y = 0},\n    cost = 3,\n    config = {extra = {max_highlighted = 2, chip_mod = 15}},\n    loc_vars = function(self, info_queue, card)\n        return {vars = {self.config.extra.max_highlighted, self.config.extra.chip_mod}}\n    end,\n    can_use = function(self, card, area, copier)\n        if G.STATE == G.STATES.SELECTING_HAND or G.STATE == G.STATES.SMODS_BOOSTER_OPENED then\n            if G.hand and G.hand.highlighted then\n                return card.ability.extra.max_highlighted >= #G.hand.highlighted and #G.hand.highlighted >= 1\n            end\n        end\n        return false\n    end,\n    use = function(self, card)\n        local used_tarot = card or self\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n            play_sound('tarot1')\n            used_tarot:juice_up(0.3, 0.5)\n            return true end\n        }))\n        for i=1, #G.hand.highlighted do\n            local percent = 1.15 - (i-0.999)/(#G.hand.highlighted-0.998)*0.3\n            G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.15,func = function() play_sound('card1', percent);G.hand.highlighted[i]:juice_up(0.3, 0.3);return true end }))\n        end\n        delay(0.05)\n        for i=1, #G.hand.highlighted do\n            card_eval_status_text(G.hand.highlighted[i], 'extra', nil, nil, nil, {message = localize{type = 'variable', key = 'a_chips', vars = {self.config.extra.chip_mod}}, colour = G.C.CHIPS})\n            G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.15,func = function()\n                local _card = G.hand.highlighted[i]\n                _card.ability.perma_bonus = _card.ability.perma_bonus or 0\n                _card.ability.perma_bonus = _card.ability.perma_bonus + card.ability.extra.chip_mod\n                return true end }))\n            G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.15,func = function() G.hand.highlighted[i]:juice_up(0.3, 0.3);return true end }))\n        end\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.2,func = function() G.hand:unhighlight_all(); return true end }))\n        delay(0.5)\n    end,\n    atlas = \"sdm_consumables\"",
      "config": {
        "extra": {
          "max_highlighted": 2,
          "chip_mod": 15
        }
      },
      "ability": {
        "extra": {
          "max_highlighted": 2,
          "chip_mod": 15
        }
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "sacrifice",
      "atlas": "sdm_consumables",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = 'sacrifice',\n    name = 'Sacrifice',\n    set = 'Spectral',\n    pos = {x = 1, y = 0},\n    cost = 4,\n    config = {extra = {jkr_slot = 1, hand = 1, discard = 1}},\n    loc_vars = function(self, info_queue, card)\n        return {vars = {self.config.extra.jkr_slot, self.config.extra.hand, self.config.extra.discard}}\n    end,\n    can_use = function(self, card, area, copier)\n        return G.GAME.round_resets.discards >= card.ability.extra.discard and G.GAME.round_resets.hands > card.ability.extra.hand\n    end,\n    use = function(self, card)\n        local used_tarot = card or self\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n            play_sound('tarot1')\n            used_tarot:juice_up(0.3, 0.5)\n            G.jokers.config.card_limit = G.jokers.config.card_limit + card.ability.extra.jkr_slot\n            G.GAME.round_resets.hands = G.GAME.round_resets.hands - card.ability.extra.hand\n            ease_hands_played(-1)\n            G.GAME.round_resets.discards = G.GAME.round_resets.discards - card.ability.extra.discard\n            ease_discard(-1)\n        return true end }))\n    end,\n    atlas = \"sdm_consumables\"",
      "config": {
        "extra": {
          "jkr_slot": 1,
          "hand": 1,
          "discard": 1
        }
      },
      "ability": {
        "extra": {
          "jkr_slot": 1,
          "hand": 1,
          "discard": 1
        }
      },
      "vars": [
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "morph",
      "atlas": "sdm_consumables",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = 'morph',\n    set = 'Spectral',\n    pos = {x = 2, y = 0},\n    cost = 4,\n    config = {extra = {add = 2, remove = 1}},\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue+1] = {key = \"morph_list\", set = \"Other\"}\n        return {vars = {self.config.extra.remove, self.config.extra.add}}\n    end,\n    can_use = function(self, card, area, copier)\n        return G.GAME.round_resets.hands > card.ability.extra.remove or G.GAME.round_resets.discards > 0 or to_big(G.GAME.dollars) > to_big(0)\n        or G.hand.config.card_limit > card.ability.extra.remove or G.jokers.config.card_limit > 0 or G.consumeables.config.card_limit > 0\n    end,\n    use = function(self, card)\n        local resource = {\"hand\", \"discard\", \"handsize\", \"joker_slot\", \"consumable_slot\"}\n        local taken = {}\n        if G.GAME.round_resets.hands > card.ability.extra.remove then\n            table.insert(taken, \"hand\")\n        end\n        if G.GAME.round_resets.discards > 0 then\n            table.insert(taken, \"discard\")\n        end\n        if G.hand.config.card_limit > card.ability.extra.remove then\n            table.insert(taken, \"handsize\")\n        end\n        if G.jokers.config.card_limit > 0 then\n            table.insert(taken, \"joker_slot\")\n        end\n        if G.consumeables.config.card_limit > 0 then\n            table.insert(taken, \"consumable_slot\")\n        end\n        local removed_ind = pseudorandom(\"tmtt_removed\", 1, #taken)\n        local removed = taken[removed_ind]\n        table.remove(resource, (SDM_0s_Stuff_Funcs.index_elem(resource, removed) or \"hand\"))\n        local added = resource[pseudorandom(\"tmtt_added\", 1, #resource)]\n        local morph_funcs = {\n            hand = function(extra, sign)\n                G.GAME.round_resets.hands = G.GAME.round_resets.hands + (sign * extra)\n                ease_hands_played(sign * extra)\n            end,\n            discard = function(extra, sign)\n                G.GAME.round_resets.discards = G.GAME.round_resets.discards + (sign * extra)\n                ease_discard(sign * extra)\n            end,\n            handsize = function(extra, sign)\n                G.hand:change_size(sign * extra)\n            end,\n            joker_slot = function(extra, sign)\n                G.jokers.config.card_limit = G.jokers.config.card_limit + (sign * extra)\n            end,\n            consumable_slot = function(extra, sign)\n                G.consumeables.config.card_limit = G.consumeables.config.card_limit + (sign * extra)\n            end\n        }\n        local used_tarot = card or self\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.3, func = function()\n            play_sound('tarot1')\n            used_tarot:juice_up(0.3, 0.5)\n            removed_result = {\n                hand = localize{type = 'variable', key = 'a_hand_minus', vars = {card.ability.extra.remove}},\n                discard = localize{type = 'variable', key = 'a_discard_minus', vars = {card.ability.extra.remove}},\n                handsize = localize{type = 'variable', key = 'a_handsize_minus', vars = {card.ability.extra.remove}},\n                joker_slot = localize{type = 'variable', key = 'a_joker_slot_minus', vars = {card.ability.extra.remove}},\n                consumable_slot = localize{type = 'variable', key = 'a_consumable_slot_minus', vars = {card.ability.extra.remove}},\n            }\n            morph_funcs[removed](card.ability.extra.remove, -1)\n            attention_text({\n                text = removed_result[removed],\n                scale = 1,\n                hold = 1,\n                major = used_tarot,\n                backdrop_colour = G.C.RED,\n                align = (G.STATE == G.STATES.SMODS_BOOSTER_OPENED) and 'tm' or 'cm',\n                offset = {x = 0, y = (G.STATE == G.STATES.SMODS_BOOSTER_OPENED) and -0.2 or 0},\n                silent = true\n            })\n        return true end }))\n        delay(0.8)\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.3, func = function()\n            play_sound('tarot1')\n            used_tarot:juice_up(0.3, 0.5)\n            added_result = {\n                hand = localize{type = 'variable', key = 'a_hand', vars = {card.ability.extra.add}},\n                discard = localize{type = 'variable', key = 'a_discard', vars = {card.ability.extra.add}},\n                handsize = localize{type = 'variable', key = 'a_handsize', vars = {card.ability.extra.add}},\n                joker_slot = localize{type = 'variable', key = 'a_joker_slot', vars = {card.ability.extra.add}},\n                consumable_slot = localize{type = 'variable', key = 'a_consumable_slot', vars = {card.ability.extra.add}},\n            }\n            morph_funcs[added](card.ability.extra.add, 1)\n            attention_text({\n                text = added_result[added],\n                scale = 1,\n                hold = 1,\n                major = used_tarot,\n                backdrop_colour = G.C.BLUE,\n                align = (G.STATE == G.STATES.SMODS_BOOSTER_OPENED) and 'tm' or 'cm',\n                offset = {x = 0, y = (G.STATE == G.STATES.SMODS_BOOSTER_OPENED) and -0.2 or 0},\n                silent = true\n            })\n        return true end }))\n        delay(0.6)\n    end,\n    atlas = \"sdm_consumables\"",
      "config": {
        "extra": {
          "add": 2,
          "remove": 1
        }
      },
      "ability": {
        "extra": {
          "add": 2,
          "remove": 1
        }
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "bind",
      "atlas": "sdm_consumables",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = 'bind',\n    name = 'Bind',\n    set = 'Spectral',\n    pos = {x = 0, y = 1},\n    cost = 4,\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue+1] = {key = 'eternal', set = 'Other'}\n    end,\n    can_use = function(self, card, area, copier)\n        if #G.jokers.highlighted >= 1 then\n            local joker = G.jokers.highlighted[1]\n            return joker.ability.eternal or (joker.config.center.eternal_compat and not joker.ability.perishable)\n        end\n        return false\n    end,\n    use = function(self, card)\n        local used_tarot = card or self\n        local joker = G.jokers.highlighted[1]\n        G.E_MANAGER:add_event(Event({func = function()\n            play_sound('tarot1')\n            used_tarot:juice_up(0.3, 0.5)\n            return true end\n        }))\n        if not joker.ability.eternal then\n            G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.1,func = function()\n                joker:set_eternal(true)\n                joker:juice_up(0.3, 0.3)\n                return true end\n            }))\n        else\n            G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.1,func = function()\n                joker.ability.eternal = false\n                joker:juice_up(0.3, 0.3)\n                return true end\n            }))\n        end\n        delay(0.5)\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.2,func = function() G.jokers:unhighlight_all(); return true end }))\n    end,\n    atlas = \"sdm_consumables\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "doppelganger",
      "atlas": "sdm_consumables",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = 'doppelganger',\n    name = 'Doppelgänger',\n    set = 'Spectral',\n    pos = {x = 1, y = 1},\n    cost = 4,\n    can_use = function(self, card, area, copier)\n        if G.jokers and G.jokers.cards then\n            if #G.jokers.cards <= 1 then return false end\n            local eternal_count = 0\n            for _, v in ipairs(G.jokers.cards) do\n                if SMODS.is_eternal(v) then eternal_count = eternal_count + 1 end\n            end\n            return eternal_count < #G.jokers.cards\n        else\n            return false\n        end\n    end,\n    use = function(self, card)\n        local selected_joker = G.jokers.cards[pseudorandom_element({1, #G.jokers.cards}, pseudoseed('dpgg'))]\n        local replacable_jokers = {}\n        for _, v in ipairs(G.jokers.cards) do\n            if not (SMODS.is_eternal(v) or v == selected_joker) then replacable_jokers[#replacable_jokers + 1] = v end\n        end\n        local chosen_joker = pseudorandom_element(replacable_jokers, pseudoseed('dpgg'))\n        G.E_MANAGER:add_event(Event({trigger = 'before', delay = 0.75, func = function()\n            chosen_joker:start_dissolve()\n        return true end }))\n        G.E_MANAGER:add_event(Event({trigger = 'before', delay = 0.4, func = function()\n            if #G.jokers.cards <= G.jokers.config.card_limit then\n                local _card = copy_card(selected_joker)\n                _card:start_materialize()\n                _card:add_to_deck()\n                G.jokers:emplace(_card)\n            end\n        return true end }))\n    end,\n    atlas = \"sdm_consumables\"",
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "sdm_enhancers",
      "atlas": null,
      "pos": null,
      "raw": "key = \"sdm_enhancers\",\n    path = \"sdm_enhancers.png\",\n    px = 71,\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "sdm_0_s",
      "atlas": "sdm_enhancers",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"sdm_0_s\",\n        pos = {x = 0, y = 0},\n        -- Deck effect in \"lovely.toml\"\n        atlas = \"sdm_enhancers\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "bazaar",
      "atlas": "sdm_enhancers",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"bazaar\",\n        pos = {x = 1, y = 0},\n        calculate = function(self, back, context)\n            if context.context == 'eval' and G.GAME.last_blind and G.GAME.last_blind.boss then\n                if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then\n                    G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            play_sound('timpani')\n                            SMODS.add_card({set = \"SDM_0s_consus\", area = G.consumeables, key_append = 'bzr'})\n                            G.GAME.consumeable_buffer = 0\n                            return true\n                        end\n                    }))\n                end\n            end\n        end,\n        atlas = \"sdm_enhancers\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "sandbox",
      "atlas": "sdm_enhancers",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"sandbox\",\n    pos = {x = 2, y = 0},\n    config = {joker_slot = 2, extra_ante = 2},\n    loc_vars = function(self)\n        return {vars = {self.config.joker_slot, self.config.extra_ante}}\n    end,\n    apply = function(self)\n        G.GAME.win_ante = G.GAME.win_ante + self.config.extra_ante\n    end,\n    atlas = \"sdm_enhancers\"",
      "config": {
        "joker_slot": 2,
        "extra_ante": 2
      },
      "ability": {
        "joker_slot": 2,
        "extra_ante": 2
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "lucky_7",
      "atlas": "sdm_enhancers",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"lucky_7\",\n    pos = {x = 3, y = 0},\n    config = {ante_scaling = 1.5},\n    loc_vars = function(self)\n        return {vars = {self.config.ante_scaling}}\n    end,\n    apply = function(self)\n        G.E_MANAGER:add_event(Event({\n            func = function()\n                for i = #G.playing_cards, 1, -1 do\n                    if G.playing_cards[i].base.id == 7 then\n                        G.playing_cards[i]:set_ability(G.P_CENTERS.m_lucky)\n                    end\n                end\n                for k, v in pairs(G.GAME.probabilities) do\n                    G.GAME.probabilities[k] = v*2\n                end\n                return true\n            end\n        }))\n    end,\n    atlas = \"sdm_enhancers\"",
      "config": {
        "ante_scaling": 1.5
      },
      "ability": {
        "ante_scaling": 1.5
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "dna",
      "atlas": "sdm_enhancers",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"dna\",\n    pos = {x = 1, y = 1},\n    calculate = function(self, back, context)\n        if context.context == \"final_scoring_step\" then\n            if G.GAME.chips + context.chips * context.mult > G.GAME.blind.chips and (G.play and G.play.cards) then\n                G.E_MANAGER:add_event(Event({func = function()\n                    G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                    local card_to_copy = G.play.cards[#G.play.cards]\n                    if card_to_copy then\n                        local _card = copy_card(card_to_copy, nil, nil, G.playing_card)\n                        _card:add_to_deck()\n                        G.deck.config.card_limit = G.deck.config.card_limit + 1\n                        table.insert(G.playing_cards, _card)\n                        G.hand:emplace(_card)\n                        _card.states.visible = nil\n                        _card:start_materialize()\n                        playing_card_joker_effects({true})\n                    end\n                    return true\n                end}))\n            end\n        end\n    end,\n    atlas = \"sdm_enhancers\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "hieroglyph",
      "atlas": "sdm_enhancers",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"hieroglyph\",\n    pos = {x = 2, y = 1},\n    config = {spectral_rate = 2, consumables = {'c_ankh'}},\n    atlas = \"sdm_enhancers\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "xxl",
      "atlas": "sdm_enhancers",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"xxl\",\n    pos = {x = 3, y = 1},\n    apply = function()\n        G.E_MANAGER:add_event(Event({\n            func = function()\n                local cards_to_copy = {}\n                for k, v in ipairs(G.deck.cards) do\n                    cards_to_copy[#cards_to_copy+1] = v\n                end\n                for k, v in ipairs(cards_to_copy) do\n                    G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                    local _card = copy_card(v)\n                    _card:add_to_deck()\n                    G.deck.config.card_limit = G.deck.config.card_limit + 1\n                    table.insert(G.playing_cards, _card)\n                    G.deck:emplace(_card)\n                end\n                G.GAME.starting_deck_size = #G.playing_cards\n            return true\n        end}))\n    end,\n    atlas = \"sdm_enhancers\"",
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "hoarder",
      "atlas": "sdm_enhancers",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = \"hoarder\",\n    pos = {x = 0, y = 2},\n    config = {extra_discard_bonus = 3, no_interest = true},\n    loc_vars = function(self)\n        return {vars = {self.config.extra_discard_bonus}}\n    end,\n    apply = function()\n        G.GAME.modifiers.no_extra_hand_money = true\n    end,\n    atlas = \"sdm_enhancers\"",
      "config": {
        "extra_discard_bonus": 3,
        "no_interest": true
      },
      "ability": {
        "extra_discard_bonus": 3,
        "no_interest": true
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "modders",
      "atlas": "sdm_enhancers",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "key = \"modders\",\n    pos = {x = 1, y = 2},\n    apply = function()\n        -- Vanilla pool changes applied in \"lovely.toml\"\n        if Cryptid and ((G.GAME.selected_sleeve and G.GAME.selected_sleeve == \"sleeve_cry_equilibrium_sleeve\")\n        or (G.GAME.viewed_sleeve and G.GAME.viewed_sleeve == \"sleeve_cry_equilibrium_sleeve\"))\n        or ((G.GAME.selected_sleeve and G.GAME.selected_sleeve == \"sleeve_cry_antimatter_sleeve\")\n        or (G.GAME.viewed_sleeve and G.GAME.viewed_sleeve == \"sleeve_cry_antimatter_sleeve\")) then\n            for _, v in pairs(G.P_CENTER_POOLS[\"Joker\"]) do\n                if not v.original_key or (v.class_prefix..'_'..v.original_key == v.key) and (not Tsunami or (Tsunami and v.key ~= \"j_splash\")) then\n                    v.no_doe = true\n                end\n            end\n        end\n    end,\n    atlas = \"sdm_enhancers\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "reverb",
      "atlas": "sdm_enhancers",
      "pos": {
        "x": 3,
        "y": 2
      },
      "raw": "key = \"reverb\",\n    pos = {x = 3, y = 2},\n    config = {joker_slot = -2, retrigger = 1},\n    loc_vars = function(self)\n        return {vars = {self.config.joker_slot, self.config.retrigger}}\n    end,\n    calculate = function(self, back, context)\n        if context.retrigger_joker_check and not context.retrigger_joker then\n            if SDM_0s_Stuff_Config.retrigger_on_deck then\n                return {\n                    repetitions = self.config.retrigger,\n                    message = localize('k_again_ex'),\n                }\n            else\n                return {\n                    repetitions = self.config.retrigger,\n                    remove_default_message = true,\n                    func = function()\n                        card_eval_status_text(context.other_card, 'extra', nil, nil, nil, {\n                            message = localize('k_again_ex'),\n                        })\n                    end\n                }\n            end\n        end\n    end,\n    atlas = \"sdm_enhancers\"",
      "config": {
        "joker_slot": -2,
        "retrigger": 1
      },
      "ability": {
        "joker_slot": -2,
        "retrigger": 1
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "roguelike",
      "atlas": "sdm_enhancers",
      "pos": {
        "x": 0,
        "y": 3
      },
      "raw": "key = \"roguelike\",\n    pos = {x = 0, y = 3},\n    config = {booster_slot = 1, vouchers = {\"v_overstock_norm\"}},\n    loc_vars = function(self)\n        return {vars = {localize{type = 'name_text', key = 'v_overstock_norm', set = 'Voucher'}, self.config.booster_slot}}\n    end,\n    apply = function(self)\n        G.GAME.modifiers.sdm_no_reroll = true   -- No reroll effect in utils.lua overrides\n        SMODS.change_booster_limit(self.config.booster_slot)\n    end,\n    atlas = \"sdm_enhancers\"",
      "config": {},
      "ability": {},
      "vars": [
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "bakers",
      "atlas": "sdm_enhancers",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "key = \"bakers\",\n        pos = {x = 2, y = 2},\n        config = {voucher = 'v_sdm_bakery_stall', consumable_slot = 1},\n        loc_vars = function(self)\n            return {vars = {localize{type = 'name_text', key = 'v_sdm_bakery_stall', set = 'Voucher'}, self.config.consumable_slot}}\n        end,\n        atlas = \"sdm_enhancers\"",
      "config": {
        "voucher": "v_sdm_bakery_stall",
        "consumable_slot": 1
      },
      "ability": {
        "voucher": "v_sdm_bakery_stall",
        "consumable_slot": 1
      },
      "vars": [
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "deck_of_dreams",
      "atlas": "sdm_enhancers",
      "pos": {
        "x": 1,
        "y": 3
      },
      "raw": "key = \"deck_of_dreams\",\n    pos = {x = 1, y = 3},\n    config = {spectral_rate = 2, consumables = {'c_ankh'}, extra_discard_bonus = 3, vouchers = {(SDM_0s_Stuff_Config.sdm_bakery and \"v_sdm_bakery_stall\") or nil, \"v_overstock_norm\"}, joker_slot = 2, consumable_slot = 1, retrigger = 1, booster_slot = 1},\n    apply = function(self)\n        SMODS.change_booster_limit(self.config.booster_slot)\n        G.E_MANAGER:add_event(Event({\n            func = function()\n                for i = #G.playing_cards, 1, -1 do\n                    if G.playing_cards[i].base.id == 7 then\n                        G.playing_cards[i]:set_ability(G.P_CENTERS.m_lucky)\n                    end\n                end\n                for k, v in pairs(G.GAME.probabilities) do\n                    G.GAME.probabilities[k] = v*2\n                end\n                return true\n            end\n        }))\n    end,\n    calculate = function(self, back, context)\n        if context.context == 'eval' and G.GAME.last_blind and G.GAME.last_blind.boss and SDM_0s_Stuff_Config.sdm_consus then\n            if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then\n                G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        play_sound('timpani')\n                        SMODS.add_card({set = \"SDM_0s_consus\", area = G.consumeables, key_append = 'dod'})\n                        G.GAME.consumeable_buffer = 0\n                        return true\n                    end\n                }))\n            end\n        end\n        if context.retrigger_joker_check and not context.retrigger_joker then\n            if SDM_0s_Stuff_Config.retrigger_on_deck then\n                return {\n                    repetitions = self.config.retrigger,\n                    message = localize('k_again_ex'),\n                }\n            else\n                return {\n                    repetitions = self.config.retrigger,\n                    remove_default_message = true,\n                    func = function()\n                        card_eval_status_text(context.other_card, 'extra', nil, nil, nil, {\n                            message = localize('k_again_ex'),\n                        })\n                    end\n                }\n            end\n        end\n    end,\n    atlas = \"sdm_enhancers\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "deck_of_nightmares",
      "atlas": "sdm_enhancers",
      "pos": {
        "x": 2,
        "y": 3
      },
      "raw": "key = \"deck_of_nightmares\",\n    pos = {x = 2, y = 3},\n    config = {no_interest = true, joker_slot = -2},\n    apply = function(self)\n        -- SDM_0's Deck and Modder's Deck effect in \"lovely.toml\"\n        if Cryptid and ((G.GAME.selected_sleeve and G.GAME.selected_sleeve == \"sleeve_cry_equilibrium_sleeve\")\n        or (G.GAME.viewed_sleeve and G.GAME.viewed_sleeve == \"sleeve_cry_equilibrium_sleeve\"))\n        or ((G.GAME.selected_sleeve and G.GAME.selected_sleeve == \"sleeve_cry_antimatter_sleeve\")\n        or (G.GAME.viewed_sleeve and G.GAME.viewed_sleeve == \"sleeve_cry_antimatter_sleeve\")) then\n            for _, v in pairs(G.P_CENTER_POOLS[\"Joker\"]) do\n                if not v.original_key or (v.class_prefix..'_'..v.original_key == v.key) then\n                    v.no_doe = true\n                end\n            end\n        end\n        G.GAME.win_ante = 10\n        G.GAME.modifiers.no_extra_hand_money = true\n        G.GAME.modifiers.sdm_no_reroll = true   -- No reroll effect in utils.lua overrides\n        G.E_MANAGER:add_event(Event({\n            func = function()\n                local cards_to_copy = {}\n                for k, v in ipairs(G.deck.cards) do\n                    cards_to_copy[#cards_to_copy+1] = v\n                end\n                for k, v in ipairs(cards_to_copy) do\n                    G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                    local _card = copy_card(v)\n                    _card:add_to_deck()\n                    G.deck.config.card_limit = G.deck.config.card_limit + 1\n                    table.insert(G.playing_cards, _card)\n                    G.deck:emplace(_card)\n                end\n                G.GAME.starting_deck_size = #G.playing_cards\n            return true\n        end}))\n    end,\n    calculate = function(self, back, context)\n        if context.context == \"final_scoring_step\" then\n            if G.GAME.chips + context.chips * context.mult > G.GAME.blind.chips and (G.play and G.play.cards) then\n                G.E_MANAGER:add_event(Event({func = function()\n                    G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                    local card_to_copy = G.play.cards[#G.play.cards]\n                    if card_to_copy then\n                        local _card = copy_card(card_to_copy, nil, nil, G.playing_card)\n                        _card:add_to_deck()\n                        G.deck.config.card_limit = G.deck.config.card_limit + 1\n                        table.insert(G.playing_cards, _card)\n                        G.hand:emplace(_card)\n                        _card.states.visible = nil\n                        _card:start_materialize()\n                        playing_card_joker_effects({true})\n                    end\n                    return true\n                end}))\n            end\n        end\n    end,\n    atlas = \"sdm_enhancers\"",
      "config": {
        "no_interest": true,
        "joker_slot": -2
      },
      "ability": {
        "no_interest": true,
        "joker_slot": -2
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "deck_of_stuff",
      "atlas": "sdm_enhancers",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"deck_of_stuff\",\n    pos = {x = 0, y = 1},\n    config = {spectral_rate = 2, consumables = {'c_ankh'}, extra_discard_bonus = 3, no_interest = true, vouchers = {(SDM_0s_Stuff_Config.sdm_bakery and \"v_sdm_bakery_stall\") or nil, \"v_overstock_norm\"}, consumable_slot = 1, retrigger = 1, booster_slot = 1},\n    apply = function(self)\n        -- SDM_0's Deck and Modder's Deck effect in \"lovely.toml\"\n        if Cryptid and ((G.GAME.selected_sleeve and G.GAME.selected_sleeve == \"sleeve_cry_equilibrium_sleeve\")\n        or (G.GAME.viewed_sleeve and G.GAME.viewed_sleeve == \"sleeve_cry_equilibrium_sleeve\"))\n        or ((G.GAME.selected_sleeve and G.GAME.selected_sleeve == \"sleeve_cry_antimatter_sleeve\")\n        or (G.GAME.viewed_sleeve and G.GAME.viewed_sleeve == \"sleeve_cry_antimatter_sleeve\")) then\n            for _, v in pairs(G.P_CENTER_POOLS[\"Joker\"]) do\n                if not v.original_key or (v.class_prefix..'_'..v.original_key == v.key) then\n                    v.no_doe = true\n                end\n            end\n        end\n        G.GAME.win_ante = 10\n        G.GAME.modifiers.no_extra_hand_money = true\n        G.GAME.modifiers.sdm_no_reroll = true   -- No reroll effect in utils.lua overrides\n        SMODS.change_booster_limit(self.config.booster_slot)\n        G.E_MANAGER:add_event(Event({\n            func = function()\n                for i = #G.playing_cards, 1, -1 do\n                    if G.playing_cards[i].base.id == 7 then\n                        G.playing_cards[i]:set_ability(G.P_CENTERS.m_lucky)\n                    end\n                end\n                for k, v in pairs(G.GAME.probabilities) do\n                    G.GAME.probabilities[k] = v*2\n                end\n                return true\n            end\n        }))\n        G.E_MANAGER:add_event(Event({\n            func = function()\n                local cards_to_copy = {}\n                for k, v in ipairs(G.deck.cards) do\n                    cards_to_copy[#cards_to_copy+1] = v\n                end\n                for k, v in ipairs(cards_to_copy) do\n                    G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                    local _card = copy_card(v)\n                    _card:add_to_deck()\n                    G.deck.config.card_limit = G.deck.config.card_limit + 1\n                    table.insert(G.playing_cards, _card)\n                    G.deck:emplace(_card)\n                end\n                G.GAME.starting_deck_size = #G.playing_cards\n            return true\n        end}))\n    end,\n    calculate = function(self, back, context)\n        if context.context == 'eval' and G.GAME.last_blind and G.GAME.last_blind.boss and SDM_0s_Stuff_Config.sdm_consus then\n            if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then\n                G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        play_sound('timpani')\n                        SMODS.add_card({set = \"SDM_0s_consus\", area = G.consumeables, key_append = 'dos'})\n                        G.GAME.consumeable_buffer = 0\n                        return true\n                    end\n                }))\n            end\n        elseif context.context == \"final_scoring_step\" then\n            if G.GAME.chips + context.chips * context.mult > G.GAME.blind.chips and (G.play and G.play.cards) then\n                G.E_MANAGER:add_event(Event({func = function()\n                    G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n                    local card_to_copy = G.play.cards[#G.play.cards]\n                    if card_to_copy then\n                        local _card = copy_card(card_to_copy, nil, nil, G.playing_card)\n                        _card:add_to_deck()\n                        G.deck.config.card_limit = G.deck.config.card_limit + 1\n                        table.insert(G.playing_cards, _card)\n                        G.hand:emplace(_card)\n                        _card.states.visible = nil\n                        _card:start_materialize()\n                        playing_card_joker_effects({true})\n                    end\n                    return true\n                end}))\n            end\n        end\n        if context.retrigger_joker_check and not context.retrigger_joker then\n            if SDM_0s_Stuff_Config.retrigger_on_deck then\n                return {\n                    repetitions = self.config.retrigger,\n                    message = localize('k_again_ex'),\n                }\n            else\n                return {\n                    repetitions = self.config.retrigger,\n                    remove_default_message = true,\n                    func = function()\n                        card_eval_status_text(context.other_card, 'extra', nil, nil, nil, {\n                            message = localize('k_again_ex'),\n                        })\n                    end\n                }\n            end\n        end\n    end,\n    atlas = \"sdm_enhancers\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "sdm_jokers",
      "atlas": null,
      "pos": null,
      "raw": "key = \"sdm_jokers\",\n    path = \"sdm_jokers.png\",\n    px = 71,\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "burger",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"burger\",\n    name = \"Burger\",\n    rarity = 2,\n    blueprint_compat = true,\n    eternal_compat = false,\n    pos = {x = 1, y = 0},\n    cost = 6,\n    config = {extra = {Xmult = 1.25, mult = 15, chips = 30, remaining = 4}},\n    loc_vars = function(self, info_queue, card)\n        return {vars = {card.ability.extra.Xmult, card.ability.extra.mult, card.ability.extra.chips, card.ability.extra.remaining}}\n    end,\n    calculate = function(self, card, context)\n        if context.end_of_round and context.main_eval and SDM_0s_Stuff_Funcs.no_bp_retrigger(context) then\n            SDM_0s_Stuff_Funcs.decrease_remaining_food(card)\n        elseif context.joker_main then\n            return {\n                chips = card.ability.extra.chips,\n                extra = {\n                    mult = card.ability.extra.mult,\n                    extra = {\n                        Xmult = card.ability.extra.Xmult\n                    }\n                }\n            }\n        end\n    end,\n    atlas = \"sdm_jokers\"",
      "config": {
        "extra": {
          "Xmult": 1.25,
          "mult": 15,
          "chips": 30,
          "remaining": 4
        }
      },
      "ability": {
        "extra": {
          "Xmult": 1.25,
          "mult": 15,
          "chips": 30,
          "remaining": 4
        }
      },
      "vars": [
        1.25,
        15,
        30,
        4
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "bounciest_ball",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"bounciest_ball\",\n    name = \"Bounciest Ball\",\n    rarity = 1,\n    blueprint_compat = true,\n    perishable_compat = false,\n    pos = {x = 2, y = 0},\n    cost = 5,\n    config = {extra = {chips = 0, chip_mod = 10}},\n    loc_vars = function(self, info_queue, card)\n        return {vars = {card.ability.extra.chips, card.ability.extra.chip_mod, localize(SDM_0s_Stuff_Funcs.get_most_played_better_hand() or \"High Card\", \"poker_hands\")}}\n    end,\n    calculate = function(self, card, context)\n        if context.cardarea == G.jokers and context.before and SDM_0s_Stuff_Funcs.no_bp_retrigger(context) then\n            if context.scoring_name == SDM_0s_Stuff_Funcs.get_most_played_better_hand() then\n                card.ability.extra.chips = card.ability.extra.chips + card.ability.extra.chip_mod\n                return {\n                    message = localize('k_upgrade_ex'),\n                    colour = G.C.CHIPS,\n                }\n            end\n        elseif context.joker_main and card.ability.extra.chips ~= 0 then\n            return {\n                chips = card.ability.extra.chips\n            }\n        end\n    end,\n    atlas = \"sdm_jokers\"",
      "config": {
        "extra": {
          "chips": 0,
          "chip_mod": 10
        }
      },
      "ability": {
        "extra": {
          "chips": 0,
          "chip_mod": 10
        }
      },
      "vars": [
        0,
        10,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "lucky_joker",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"lucky_joker\",\n    name = \"Lucky Joker\",\n    rarity = 2,\n    blueprint_compat = true,\n    pos = {x = 3, y = 0},\n    cost = 5,\n    config = {extra = {repetition = 2}},\n    loc_vars = function(self, info_queue, card)\n        return {vars = {card and card.ability.extra.repetition or 2}} -- Made this way to avoid Lucky 7 Deck crashing on Lucky Joker hover\n    end,\n    calculate = function(self, card, context)\n        if context.repetition and not context.individual and context.cardarea == G.play then\n            if context.other_card:get_id() == 7 then\n                return {\n                    repetitions = card.ability.extra.repetition,\n                }\n            end\n        end\n    end,\n    atlas = \"sdm_jokers\"",
      "config": {
        "extra": {
          "repetition": 2
        }
      },
      "ability": {
        "extra": {
          "repetition": 2
        }
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "iconic_icon",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "key = \"iconic_icon\",\n    name = \"Iconic Icon\",\n    rarity = 1,\n    blueprint_compat = true,\n    pos = {x = 4, y = 0},\n    cost = 5,\n    config = {extra = {mult_mod = 2}},\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue+1] = {key = \"modified_card\", set = \"Other\"}\n        local mlt = 0\n        if G.playing_cards then\n            for _, v in pairs(G.playing_cards) do\n                if v:get_id() == 14 then\n                    mlt = mlt + card.ability.extra.mult_mod * (((v.edition or v.seal or v.ability.effect ~= \"Base\") and 2) or 1)\n                end\n            end\n        end\n        return {vars = {mlt, card.ability.extra.mult_mod, card.ability.extra.mult_mod * 2}}\n    end,\n    calculate = function(self, card, context)\n        if context.joker_main then\n            local mlt = 0\n            if G.playing_cards then\n                for _, v in pairs(G.playing_cards) do\n                    if v:get_id() == 14 then\n                        mlt =  mlt + card.ability.extra.mult_mod * (((v.edition or v.seal or v.ability.effect ~= \"Base\") and 2) or 1)\n                    end\n                end\n            end\n            if mlt ~= 0 then\n                return {\n                    mult = mlt,\n                }\n            end\n        end\n    end,\n    atlas = \"sdm_jokers\"",
      "config": {
        "extra": {
          "mult_mod": 2
        }
      },
      "ability": {
        "extra": {
          "mult_mod": 2
        }
      },
      "vars": [
        null,
        2,
        4
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "mult_n_chips",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 5,
        "y": 0
      },
      "raw": "key = \"mult_n_chips\",\n    name = \"Mult'N'Chips\",\n    rarity = 1,\n    blueprint_compat = true,\n    pos = {x = 5, y = 0},\n    cost = 5,\n    config = {extra = {mult = 4, chips = 30}},\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue+1] = G.P_CENTERS.m_bonus\n        info_queue[#info_queue+1] = G.P_CENTERS.m_mult\n        return {vars = {card.ability.extra.mult, card.ability.extra.chips}}\n    end,\n    calculate = function(self, card, context)\n        if not context.end_of_round and context.individual and context.cardarea == G.play then\n            if context.other_card.ability.effect == \"Bonus Card\" then\n                return {\n                    mult = card.ability.extra.mult,\n                }\n            elseif context.other_card.ability.effect == \"Mult Card\" then\n                return {\n                    chips = card.ability.extra.chips,\n                }\n            end\n        end\n    end,\n    in_pool = function()\n        if G.playing_cards then\n            for _, v in pairs(G.playing_cards) do\n                if v.config.center == G.P_CENTERS.m_bonus or v.config.center == G.P_CENTERS.m_mult then\n                    return true\n                end\n            end\n        end\n        return false\n    end,\n    atlas = \"sdm_jokers\"",
      "config": {
        "extra": {
          "mult": 4,
          "chips": 30
        }
      },
      "ability": {
        "extra": {
          "mult": 4,
          "chips": 30
        }
      },
      "vars": [
        4,
        30
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "moon_base",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 6,
        "y": 0
      },
      "raw": "key = \"moon_base\",\n    name = \"Moon Base\",\n    rarity = 2,\n    blueprint_compat = true,\n    pos = {x = 6, y = 0},\n    cost = 8,\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue+1] = {key = \"space_jokers\", set = \"Other\"}\n    end,\n    calculate = function(self, card, context)\n        if context.setting_blind and not card.getting_sliced and #G.jokers.cards + G.GAME.joker_buffer < G.jokers.config.card_limit then\n            G.GAME.joker_buffer = G.GAME.joker_buffer + 1\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    SMODS.add_card({set = \"Space\", key_append = \"mnb\"})\n                    G.GAME.joker_buffer = 0\n                    return true\n                end}))\n            card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = localize('k_plus_joker'), colour = G.C.BLUE})\n        end\n    end,\n    atlas = \"sdm_jokers\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "shareholder_joker",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 7,
        "y": 0
      },
      "raw": "key = \"shareholder_joker\",\n    name = \"Shareholder Joker\",\n    rarity = 1,\n    pos = {x = 7, y = 0},\n    cost = 5,\n    config = {extra = {min = 1, max = 8}},\n    loc_vars = function(self, info_queue, card)\n        return {vars = {card.ability.extra.min, card.ability.extra.max}}\n    end,\n    calc_dollar_bonus = function(self, card)\n        local rand_dollar = pseudorandom(pseudoseed('shareholder'), card.ability.extra.min, card.ability.extra.max)\n        return rand_dollar\n    end,\n    atlas = \"sdm_jokers\"",
      "config": {
        "extra": {
          "min": 1,
          "max": 8
        }
      },
      "ability": {
        "extra": {
          "min": 1,
          "max": 8
        }
      },
      "vars": [
        1,
        8
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "magic_hands",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 8,
        "y": 0
      },
      "raw": "key = \"magic_hands\",\n    name = \"Magic Hands\",\n    rarity = 2,\n    pos = {x = 8, y = 0},\n    cost = 7,\n    -- Effect coded in lovely.toml --\n    atlas = \"sdm_jokers\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "tip_jar",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 9,
        "y": 0
      },
      "raw": "key = \"tip_jar\",\n    name = \"Tip Jar\",\n    rarity = 2,\n    pos = {x = 9, y = 0},\n    cost = 8,\n    calc_dollar_bonus = function(self, card)\n        local highest = 0\n        for digit in tostring(math.abs(G.GAME.dollars)):gmatch(\"%d\") do\n            highest = math.max(highest, tonumber(digit))\n        end\n        if highest > 0 then\n            return highest\n        end\n    end,\n    atlas = \"sdm_jokers\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "wandering_star",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"wandering_star\",\n    name = \"Wandering Star\",\n    rarity = 1,\n    pos = {x = 0, y = 1},\n    cost = 6,\n    calculate = function(self, card, context)\n        if context.reroll_shop and SDM_0s_Stuff_Funcs.no_bp_retrigger(context) then\n            local visible_hands = {}\n            for _, v in ipairs(G.handlist) do\n                if SMODS.is_poker_hand_visible(v) then\n                    table.insert(visible_hands, v)\n                end\n            end\n            if visible_hands[1] then\n                local selected_hand = pseudorandom_element(visible_hands, pseudoseed('wandering'))\n                SMODS.smart_level_up_hand(card, selected_hand)\n            end\n        end\n    end,\n    atlas = \"sdm_jokers\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "ouija_board",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"ouija_board\",\n    name = \"Ouija Board\",\n    rarity = 3,\n    eternal_compat = false,\n    perishable_compat = false,\n    pos = {x = 1, y = 1},\n    cost = 10,\n    config = {extra = {rounds = 0, remaining = 6}},\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue+1] = G.P_CENTERS.c_soul\n        return {vars = {card.ability.extra.rounds, card.ability.extra.remaining}}\n    end,\n    calculate = function(self, card, context)\n        if context.end_of_round and context.main_eval and SDM_0s_Stuff_Funcs.no_bp_retrigger(context) then\n            if card.ability.extra.rounds < card.ability.extra.remaining then\n                card.ability.extra.rounds = math.min(card.ability.extra.rounds + 1, card.ability.extra.remaining)\n                if card.ability.extra.rounds <= card.ability.extra.remaining then\n                    card_eval_status_text(card, 'extra', nil, nil, nil, {message = card.ability.extra.rounds .. \"/\" .. card.ability.extra.remaining})\n                end\n                if card.ability.extra.rounds >= card.ability.extra.remaining then\n                    local eval = function(card) return not card.REMOVED end\n                    juice_card_until(card, eval, true)\n                end\n            end\n        end\n        if context.selling_self and card.ability.extra.rounds >= card.ability.extra.remaining and SDM_0s_Stuff_Funcs.no_bp_retrigger(context) then\n            if not card.getting_sliced and #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then\n                G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1\n                G.E_MANAGER:add_event(Event({\n                    func = (function()\n                        G.E_MANAGER:add_event(Event({\n                            func = function()\n                                SMODS.add_card({key = 'c_soul', key_append = 'ojb'})\n                                G.GAME.consumeable_buffer = 0\n                                return true\n                            end}))\n                        card_eval_status_text(card, 'extra', nil, nil, nil, {message = localize('k_plus_spectral'), colour = G.C.SECONDARY_SET.Spectral})\n                    return true\n                end)}))\n            end\n        end\n    end,\n    atlas = \"sdm_jokers\"",
      "config": {
        "extra": {
          "rounds": 0,
          "remaining": 6
        }
      },
      "ability": {
        "extra": {
          "rounds": 0,
          "remaining": 6
        }
      },
      "vars": [
        0,
        6
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "la_revolution",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"la_revolution\",\n    name = \"La Révolution\",\n    rarity = 3,\n    blueprint_compat = true,\n    pos = {x = 2, y = 1},\n    cost = 8,\n    config = {extra = {no_faces = true}},\n    calculate = function(self, card, context)\n        if context.cardarea == G.jokers and context.after and SDM_0s_Stuff_Funcs.no_bp_retrigger(context) then\n            card.ability.extra.no_faces = true\n            for i = 1, #context.full_hand do\n                if context.full_hand[i]:is_face() then\n                    card.ability.extra.no_faces = false\n                    break\n                end\n            end\n        end\n        if context.end_of_round and context.main_eval and card.ability.extra.no_faces then\n            return {\n                level_up = true\n            }\n        end\n    end,\n    atlas = \"sdm_jokers\"",
      "config": {
        "extra": {
          "no_faces": true
        }
      },
      "ability": {
        "extra": {
          "no_faces": true
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "clown_bank",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"clown_bank\",\n    name = \"Clown Bank\",\n    rarity = 2,\n    perishable_compat = false,\n    blueprint_compat = true,\n    pos = {x = 3, y = 1},\n    cost = 6,\n    config = {extra = {Xmult_mod = 0.1, dollars = 2, dollars_mod = 2}},\n    loc_vars = function(self, info_queue, card)\n        local xmlt = 1 + math.floor(card.ability.extra_value/card.ability.extra.dollars_mod) * card.ability.extra.Xmult_mod\n        return {vars = {xmlt, card.ability.extra.Xmult_mod, card.ability.extra.dollars, card.ability.extra.dollars_mod}}\n    end,\n    calculate = function(self, card, context)\n        if context.setting_blind and not card.getting_sliced and SDM_0s_Stuff_Funcs.no_bp_retrigger(context) then\n            if to_big(G.GAME.dollars) - card.ability.extra.dollars >= to_big(G.GAME.bankrupt_at) then\n                card_eval_status_text(card, 'extra', nil, nil, nil, {\n                    message = \"-\"  .. localize('$') .. card.ability.extra.dollars,\n                    colour = G.C.RED\n                })\n                ease_dollars(-card.ability.extra.dollars)\n                card.ability.extra_value = card.ability.extra_value + card.ability.extra.dollars\n                card:set_cost()\n                G.E_MANAGER:add_event(Event({\n                    func = function() card_eval_status_text(card, 'extra', nil, nil, nil, {message = localize('k_val_up'), colour = G.C.MONEY}); return true\n                end}))\n                return\n            end\n        elseif context.joker_main then\n            local xmlt = 1 + math.floor(card.ability.extra_value/card.ability.extra.dollars_mod) * card.ability.extra.Xmult_mod\n            if xmlt ~= 1 then\n                return {\n                    Xmult = xmlt\n                }\n            end\n        end\n    end,\n    atlas = \"sdm_jokers\"",
      "config": {
        "extra": {
          "Xmult_mod": 0.1,
          "dollars": 2,
          "dollars_mod": 2
        }
      },
      "ability": {
        "extra": {
          "Xmult_mod": 0.1,
          "dollars": 2,
          "dollars_mod": 2
        }
      },
      "vars": [
        null,
        0.1,
        2,
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "furnace",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 4,
        "y": 1
      },
      "raw": "key = \"furnace\",\n    name = \"Furnace\",\n    rarity = 2,\n    blueprint_compat = true,\n    pos = {x = 4, y = 1},\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue+1] = G.P_CENTERS.m_gold\n        info_queue[#info_queue+1] = G.P_CENTERS.m_steel\n    end,\n    calculate = function(self, card, context)\n        if context.first_hand_drawn then\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    local _card = create_playing_card({\n                        front = pseudorandom_element(G.P_CARDS, pseudoseed('furn_fr')),\n                        center = G.P_CENTERS.c_base}, G.hand, nil, nil, {G.C.SECONDARY_SET.Enhanced})\n                    local enhance_type = pseudorandom(pseudoseed('furned'))\n                    if enhance_type > 0.5 then _card:set_ability(G.P_CENTERS.m_gold)\n                    else _card:set_ability(G.P_CENTERS.m_steel)\n                    end\n                    G.GAME.blind:debuff_card(_card)\n                    G.hand:sort()\n                    if context.blueprint_card then context.blueprint_card:juice_up() else card:juice_up() end\n                    return true\n                end}))\n            playing_card_joker_effects({true})\n        end\n    end,\n    atlas = \"sdm_jokers\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "warehouse",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 5,
        "y": 1
      },
      "raw": "key = \"warehouse\",\n    name = \"Warehouse\",\n    rarity = 2,\n    pos = {x = 5, y = 1},\n    cost = 6,\n    config = {extra = {h_size = 3}},\n    loc_vars = function(self, info_queue, card)\n        return {vars = {card.ability.extra.h_size}}\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        G.hand:change_size(card.ability.extra.h_size)\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        G.hand:change_size(-card.ability.extra.h_size)\n    end,\n    -- \"Others cards can't be sold\" effect in \"lovely.toml\"\n    atlas = \"sdm_jokers\"",
      "config": {
        "extra": {
          "h_size": 3
        }
      },
      "ability": {
        "extra": {
          "h_size": 3
        }
      },
      "vars": [
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "zombie_joker",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 6,
        "y": 1
      },
      "raw": "key = \"zombie_joker\",\n    name = \"Zombie Joker\",\n    rarity = 1,\n    pos = {x = 6, y = 1},\n    cost = 5,\n    config = {extra = 3},\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue+1] = G.P_CENTERS.c_death\n        local mod_num, mod_den = SMODS.get_probability_vars(card, 1, card.ability.extra)\n        return {vars = {mod_num, mod_den}}\n    end,\n    calculate = function(self, card, context)\n        if context.selling_card and SDM_0s_Stuff_Funcs.no_bp_retrigger(context) then\n            if context.card.ability.set == 'Joker' and SDM_0s_Stuff_Funcs.proba_check(card, card.ability.extra, 'zmbjkr') then\n                if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit or\n                context.card.ability.set ~= 'Joker' and #G.consumeables.cards + G.GAME.consumeable_buffer <= G.consumeables.config.card_limit then\n                    G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1\n                    G.E_MANAGER:add_event(Event({\n                        trigger = 'before',\n                        delay = 0.0,\n                        func = (function()\n                                SMODS.add_card({key = 'c_death', key_append = 'zmb'})\n                                G.GAME.consumeable_buffer = 0\n                            return true\n                        end)}))\n                    card_eval_status_text(card, 'extra', nil, nil, nil, {message = localize('k_plus_tarot'), colour = G.C.SECONDARY_SET.Tarot})\n                end\n            end\n        end\n    end,\n    atlas = \"sdm_jokers\"",
      "config": {
        "extra": 3
      },
      "ability": {
        "extra": 3
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "mystery_joker",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 7,
        "y": 1
      },
      "raw": "key = \"mystery_joker\",\n    name = \"Mystery Joker\",\n    rarity = 1,\n    blueprint_compat = true,\n    pos = {x = 7, y = 1},\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue+1] = G.P_TAGS.tag_rare\n    end,\n    calculate = function(self, card, context)\n        if context.end_of_round and context.main_eval and context.beat_boss then\n            G.E_MANAGER:add_event(Event({\n                func = (function()\n                    add_tag(Tag('tag_rare'))\n                    card:juice_up(0.3, 0.4)\n                    play_sound('generic1', 0.9 + math.random()*0.1, 0.8)\n                    play_sound('holo1', 1.2 + math.random()*0.1, 0.4)\n                    return true\n                end)\n            }))\n        end\n    end,\n    atlas = \"sdm_jokers\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "infinite_staircase",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 8,
        "y": 1
      },
      "raw": "key = \"infinite_staircase\",\n    name = \"Infinite Staircase\",\n    rarity = 2,\n    blueprint_compat = true,\n    pos = {x = 8, y = 1},\n    cost = 6,\n    config = {extra = {Xmult = 3}},\n    loc_vars = function(self, info_queue, card)\n        return {vars = {card.ability.extra.Xmult}}\n    end,\n    calculate = function(self, card, context)\n        if context.joker_main then\n            local no_faces_and_ace = true\n            for i = 1, #context.scoring_hand do\n                if context.scoring_hand[i]:is_face() or context.scoring_hand[i]:get_id() == 14 then\n                    no_faces_and_ace = false\n                end\n            end\n            if no_faces_and_ace and next(context.poker_hands[\"Straight\"]) then\n                return {\n                    message = localize{type='variable',key='a_xmult',vars={card.ability.extra.Xmult}},\n                    Xmult_mod = card.ability.extra.Xmult\n                }\n            end\n        end\n    end,\n    atlas = \"sdm_jokers\"",
      "config": {
        "extra": {
          "Xmult": 3
        }
      },
      "ability": {
        "extra": {
          "Xmult": 3
        }
      },
      "vars": [
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "ninja_joker",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 9,
        "y": 1
      },
      "raw": "key = \"ninja_joker\",\n    name = \"Ninja Joker\",\n    rarity = 3,\n    eternal_compat = false,\n    pos = {x = 9, y = 1},\n    cost = 7,\n    loc_vars = function(self, info_queue, card)\n        if not card.edition or (card.edition and not card.edition.negative) then\n            info_queue[#info_queue+1] = G.P_CENTERS.e_negative\n        end\n    end,\n    calculate = function(self, card, context)\n        if (context.cards_destroyed and (context.glass_shattered and #context.glass_shattered > 0))\n        or (context.remove_playing_cards and (context.removed and #context.removed > 0)) and SDM_0s_Stuff_Funcs.no_bp_retrigger(context) then\n            local my_pos = nil\n            for i = 1, #G.jokers.cards do\n                if G.jokers.cards[i] == card then my_pos = i; break end\n            end\n            local jokers = {}\n            if my_pos then\n                if G.jokers.cards[my_pos-1] then jokers[#jokers+1] = G.jokers.cards[my_pos-1] end\n                if G.jokers.cards[my_pos+1] then jokers[#jokers+1] = G.jokers.cards[my_pos+1] end\n            end\n            if jokers[1] then\n                G.E_MANAGER:add_event(Event({\n                    func = (function()\n                        for i = 1, #jokers do\n                            jokers[i]:set_edition(\"e_negative\")\n                        end\n                        card:juice_up(0.3, 0.4)\n                        card:start_dissolve({G.C.DARK_EDITION}, nil, 1.6)\n                        return true\n                    end)\n                }))\n            end\n        end\n    end,\n    atlas = \"sdm_jokers\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "reach_the_stars",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = \"reach_the_stars\",\n    name = \"Reach the Stars\",\n    rarity = 1,\n    blueprint_compat = true,\n    pos = {x = 0, y = 2},\n    cost = 5,\n    config = {extra = {num_card1 = 1, num_card2 = 5, c1_scored = false, c2_scored = false}},\n    loc_vars = function(self, info_queue, card)\n        return {vars = {card.ability.extra.num_card1, card.ability.extra.num_card2,\n        (card.ability.extra.c1_scored and card.ability.extra.num_card1) or \"\",\n        (not card.ability.extra.c1_scored and card.ability.extra.num_card1) or \"\",\n        (card.ability.extra.c2_scored and card.ability.extra.num_card2) or \"\",\n        (not card.ability.extra.c2_scored and card.ability.extra.num_card2) or \"\",\n    }}\n    end,\n    set_ability = function(self, card, initial, delay_sprites)\n        local num_card1, num_card2 = SDM_0s_Stuff_Funcs.rts_init()\n        card.ability.extra.num_card1 = num_card1\n        card.ability.extra.num_card2 = num_card2\n    end,\n    calculate = function(self, card, context)\n        if context.cardarea == G.jokers and context.final_scoring_step and not (context.before or context.after) and context.scoring_hand then\n            if SDM_0s_Stuff_Funcs.no_bp_retrigger(context) then\n                if #context.scoring_hand == card.ability.extra.num_card1 and not card.ability.extra.c1_scored then\n                    card.ability.extra.c1_scored = true\n                    card_eval_status_text(card, 'extra', nil, nil, nil, {\n                        message = ((card.ability.extra.c2_scored and \"2/\") or \"1/\") .. 2,\n                        colour = G.C.FILTER,\n                    })\n                elseif #context.scoring_hand == card.ability.extra.num_card2 and not card.ability.extra.c2_scored then\n                    card.ability.extra.c2_scored = true\n                    card_eval_status_text(card, 'extra', nil, nil, nil, {\n                        message = ((card.ability.extra.c1_scored and \"2/\") or \"1/\") ..  2,\n                        colour = G.C.FILTER,\n                    })\n                end\n            end\n            if card.ability.extra.c1_scored and card.ability.extra.c2_scored then\n                card.ability.extra.c1_scored = false\n                card.ability.extra.c2_scored = false\n                if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then\n                    G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1\n                    G.E_MANAGER:add_event(Event({\n                        trigger = 'before',\n                        delay = 0.0,\n                        func = (function()\n                            SMODS.add_card({set = 'Planet', key_append = 'rts'})\n                            G.GAME.consumeable_buffer = 0\n                            return true\n                        end)}\n                    ))\n                    card_eval_status_text(card, 'extra', nil, nil, nil, {\n                        message = localize('k_plus_planet'),\n                        colour = G.C.SECONDARY_SET.Planet,\n                    })\n                    if SDM_0s_Stuff_Funcs.no_bp_retrigger(context) then\n                        local num_card1, num_card2 = SDM_0s_Stuff_Funcs.rts_init()\n                        card.ability.extra.num_card1 = num_card1\n                        card.ability.extra.num_card2 = num_card2\n                        return {\n                            message = localize('k_reset')\n                        }\n                    end\n                else\n                    card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = localize('k_no_room_ex')})\n                end\n            end\n        end\n    end,\n    immutable = true, -- Cryptid compat to prevent impossible hand values\n    atlas = \"sdm_jokers\"",
      "config": {
        "extra": {
          "num_card1": 1,
          "num_card2": 5,
          "c1_scored": false,
          "c2_scored": false
        }
      },
      "ability": {
        "extra": {
          "num_card1": 1,
          "num_card2": 5,
          "c1_scored": false,
          "c2_scored": false
        }
      },
      "vars": [
        1,
        5,
        null,
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "crooked_joker",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "key = \"crooked_joker\",\n    name = \"Crooked Joker\",\n    rarity = 1,\n    pos = {x = 1, y = 2},\n    cost = 1,\n    loc_vars = function(self, info_queue, card)\n        if Cryptid then\n            return {key = self.key .. \"_cryptid\", vars = {}}\n        end\n    end,\n    calculate = function(self, card, context)\n        if context.card_added and SDM_0s_Stuff_Funcs.no_bp_retrigger(context) then\n            if context.card ~= card and context.card.ability.set == 'Joker' and not (context.card.ability and context.card.ability.not_crooked) then\n                local do_dupe = pseudorandom(pseudoseed('crkj'), 0, 1)\n                if do_dupe == 1 then\n                    if #G.jokers.cards + G.GAME.joker_buffer < G.jokers.config.card_limit - 1 then\n                        G.GAME.joker_buffer = G.GAME.joker_buffer + 1\n                        card_eval_status_text(card, 'extra', nil, nil, nil, {\n                            message = localize('k_plus_joker'),\n                            colour = G.C.BLUE,\n                        })\n                        G.E_MANAGER:add_event(Event({\n                            func = function()\n                                context.card.ability.not_crooked = true\n                                local new_card = copy_card(context.card, nil, nil, nil, nil)\n                                new_card:add_to_deck()\n                                G.jokers:emplace(new_card)\n                                new_card:start_materialize()\n                                G.GAME.joker_buffer = 0\n                                return true\n                            end\n                        }))\n                    end\n                elseif not (SMODS.is_eternal(context.card) or context.card.getting_sliced) then\n                    card_eval_status_text(card, 'extra', nil, nil, nil, {\n                        message = localize('k_nope_ex'),\n                        colour = G.C.RED,\n                    })\n                    G.E_MANAGER:add_event(Event({func = function()\n                        context.card.getting_sliced = true\n                        context.card:start_dissolve({G.C.RED}, nil, 1.6)\n                    return true end }))\n                end\n            end\n        end\n    end,\n    atlas = \"sdm_jokers\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "property_damage",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "key = \"property_damage\",\n    name = \"Property Damage\",\n    rarity = 3,\n    perishable_compat = false,\n    blueprint_compat = true,\n    pos = {x = 2, y = 2},\n    cost = 8,\n    config = {extra = {Xmult = 1, Xmult_mod = 0.25}},\n    loc_vars = function(self, info_queue, card)\n        return {vars = {card.ability.extra.Xmult, card.ability.extra.Xmult_mod}}\n    end,\n    calculate = function(self, card, context)\n        if context.pre_discard and SDM_0s_Stuff_Funcs.no_bp_retrigger(context) then\n            local eval = evaluate_poker_hand(G.hand.highlighted)\n            if eval[\"Full House\"] and eval[\"Full House\"][1] then\n                card.ability.extra.Xmult = card.ability.extra.Xmult + card.ability.extra.Xmult_mod\n                G.E_MANAGER:add_event(Event({func = function()\n                    card_eval_status_text(card, 'extra', nil, nil, nil, {message = localize{type='variable',key='a_xmult',vars={card.ability.extra.Xmult}}});\n                    return true end}))\n                return\n            end\n        elseif context.joker_main and card.ability.extra.Xmult ~= 1 then\n            return {\n                Xmult = card.ability.extra.Xmult\n            }\n        end\n    end,\n    atlas = \"sdm_jokers\"",
      "config": {
        "extra": {
          "Xmult": 1,
          "Xmult_mod": 0.25
        }
      },
      "ability": {
        "extra": {
          "Xmult": 1,
          "Xmult_mod": 0.25
        }
      },
      "vars": [
        1,
        0.25
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "rock_n_roll",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 3,
        "y": 2
      },
      "raw": "key = \"rock_n_roll\",\n    name = \"Rock'N'Roll\",\n    rarity = 2,\n    blueprint_compat = true,\n    pos = {x = 3, y = 2},\n    cost = 6,\n    config = {extra = 1},\n    calculate = function(self, card, context)\n        if context.repetition and not context.individual and context.cardarea == G.play then\n            if context.other_card.ability.effect ~= \"Base\" then\n                return {\n                    repetitions = card.ability.extra,\n                }\n            end\n        end\n    end,\n    in_pool = function()\n        if G.playing_cards then\n            for _, v in pairs(G.playing_cards) do\n                if v.ability.effect ~= \"Base\" then\n                    return true\n                end\n            end\n        end\n        return false\n    end,\n    atlas = \"sdm_jokers\"",
      "config": {
        "extra": 1
      },
      "ability": {
        "extra": 1
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "contract",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 4,
        "y": 2
      },
      "raw": "key = \"contract\",\n    name = \"Contract\",\n    rarity = 2,\n    pos = {x = 4, y = 2},\n    cost = 6,\n    config = {extra = {money = 8, blind_req = 2}},\n    loc_vars = function(self, info_queue, card)\n        return {vars = {card.ability.extra.money, card.ability.extra.blind_req}}\n    end,\n    calculate = function(self, card, context)\n        if context.setting_blind and not card.getting_sliced and SDM_0s_Stuff_Funcs.no_bp_retrigger(context) then\n            G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.1,func = function()\n                G.GAME.blind.chips = math.floor(G.GAME.blind.chips * card.ability.extra.blind_req)\n                G.GAME.blind.chip_text = number_format(G.GAME.blind.chips)\n\n                local chips_UI = G.hand_text_area.blind_chips\n                G.FUNCS.blind_chip_UI_scale(G.hand_text_area.blind_chips)\n                G.HUD_blind:recalculate()\n                chips_UI:juice_up()\n\n                if not silent then play_sound('chips2') end\n            return true end }))\n        end\n    end,\n    calc_dollar_bonus = function(self, card)\n        return card.ability.extra.money\n    end,\n    atlas = \"sdm_jokers\"",
      "config": {
        "extra": {
          "money": 8,
          "blind_req": 2
        }
      },
      "ability": {
        "extra": {
          "money": 8,
          "blind_req": 2
        }
      },
      "vars": [
        8,
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "cupidon",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 5,
        "y": 2
      },
      "raw": "key = \"cupidon\",\n    name = \"Cupidon\",\n    rarity = 2,\n    pos = {x = 5, y = 2},\n    cost = 6,\n    config = {extra = {hand = 1, handsize = 1, discard = 2}},\n    loc_vars = function(self, info_queue, card)\n        return {vars = {card.ability.extra.hand, card.ability.extra.handsize, card.ability.extra.discard}}\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not from_debuff then\n            G.hand:change_size(card.ability.extra.handsize)\n            G.GAME.round_resets.hands = G.GAME.round_resets.hands + card.ability.extra.hand\n            ease_hands_played(card.ability.extra.hand)\n            G.GAME.round_resets.discards = G.GAME.round_resets.discards - card.ability.extra.discard\n            ease_discard(-card.ability.extra.discard)\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        if not from_debuff then\n            G.hand:change_size(-card.ability.extra.handsize)\n            G.GAME.round_resets.hands = G.GAME.round_resets.hands - card.ability.extra.hand\n            G.GAME.round_resets.discards = G.GAME.round_resets.discards + card.ability.extra.discard\n        end\n    end,\n    atlas = \"sdm_jokers\"",
      "config": {
        "extra": {
          "hand": 1,
          "handsize": 1,
          "discard": 2
        }
      },
      "ability": {
        "extra": {
          "hand": 1,
          "handsize": 1,
          "discard": 2
        }
      },
      "vars": [
        1,
        1,
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "pizza",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 6,
        "y": 2
      },
      "raw": "key = \"pizza\",\n    name = \"Pizza\",\n    rarity = 1,\n    blueprint_compat = true,\n    eternal_compat = false,\n    pos = {x = 6, y = 2},\n    cost = 5,\n    config = {extra = {hands = 4, hand_mod = 1}},\n    loc_vars = function(self, info_queue, card)\n        return {vars = {card.ability.extra.hands, card.ability.extra.hand_mod}}\n    end,\n    calculate = function(self, card, context)\n        if context.end_of_round and context.main_eval and SDM_0s_Stuff_Funcs.no_bp_retrigger(context) then\n            card.ability.extra.hands = card.ability.extra.hands - card.ability.extra.hand_mod\n            if card.ability.extra.hands > 0 then\n                card_eval_status_text(card, 'extra', nil, nil, nil, {\n                    message = card.ability.extra.hands .. '',\n                    colour = G.C.CHIPS\n                })\n            else\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        play_sound('tarot1')\n                        card.T.r = -0.2\n                        card:juice_up(0.3, 0.4)\n                        card.states.drag.is = true\n                        card.children.center.pinch.x = true\n                        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.3, blockable = false,\n                            func = function()\n                                G.jokers:remove_card(card)\n                                card:remove()\n                                card = nil\n                            return true; end}))\n                        return true\n                    end\n                }))\n                return {\n                    message = localize('k_shared_ex'),\n                    colour = G.C.FILTER\n                }\n            end\n        end\n        if context.setting_blind and not (context.blueprint_card or card).getting_sliced then\n            G.E_MANAGER:add_event(Event({func = function()\n                ease_hands_played(card.ability.extra.hands)\n                if card.ability.extra.hands > 1 then\n                    card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = localize{type = 'variable', key = 'a_hands', vars = {card.ability.extra.hands}}})\n                else\n                    card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = localize{type = 'variable', key = 'a_hand', vars = {card.ability.extra.hands}}})\n                end\n            return true end }))\n        end\n    end,\n    atlas = \"sdm_jokers\"",
      "config": {
        "extra": {
          "hands": 4,
          "hand_mod": 1
        }
      },
      "ability": {
        "extra": {
          "hands": 4,
          "hand_mod": 1
        }
      },
      "vars": [
        4,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "treasure_chest",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 7,
        "y": 2
      },
      "raw": "key = \"treasure_chest\",\n    name = \"Treasure Chest\",\n    rarity = 1,\n    eternal_compat = false,\n    pos = {x = 7, y = 2},\n    cost = 0,\n    config = {extra = 10},\n    loc_vars = function(self, info_queue, card)\n        return {vars = {card.ability.extra}}\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not from_debuff then card.sell_cost = 0 end\n    end,\n    calculate = function(self, card, context)\n        if context.selling_self then\n            return {\n                dollars = card.ability.extra\n            }\n        end\n    end,\n    in_pool = function()\n        if not G.jokers or (G.jokers and (not G.jokers.cards or not G.jokers.config)) then return false end\n        return #G.jokers.cards < G.jokers.config.card_limit\n    end,\n    pixel_size = {w = 71, h = 71},\n    atlas = \"sdm_jokers\"",
      "config": {
        "extra": 10
      },
      "ability": {
        "extra": 10
      },
      "vars": [
        10
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "bullet_train",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 8,
        "y": 2
      },
      "raw": "key = \"bullet_train\",\n    name = \"Bullet Train\",\n    rarity = 1,\n    blueprint_compat = true,\n    pos = {x = 8, y = 2},\n    cost = 6,\n    config = {extra = 150},\n    loc_vars = function(self, info_queue, card)\n        return {vars = {card.ability.extra}}\n    end,\n    calculate = function(self, card, context)\n        if context.joker_main and G.GAME.current_round.hands_played == 0 and G.GAME.current_round.discards_used == 0 then\n            return {\n                chips = card.ability.extra\n            }\n        end\n    end,\n    atlas = \"sdm_jokers\"",
      "config": {
        "extra": 150
      },
      "ability": {
        "extra": 150
      },
      "vars": [
        150
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "chaos_theory",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 9,
        "y": 2
      },
      "raw": "key = \"chaos_theory\",\n    name = \"Chaos Theory\",\n    rarity = 3,\n    blueprint_compat = true,\n    pos = {x = 9, y = 2},\n    cost = 8,\n    config = {extra = {chips = 0, chip_mod = 2}},\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue+1] = {key = \"chaos_exceptions\", set = \"Other\"}\n        local chs = SDM_0s_Stuff_Funcs.sum_incremental(card.ability.extra.chip_mod)\n        return {vars = {card.ability.extra.chip_mod, chs}}\n    end,\n    calculate = function(self, card, context)\n        local chs = SDM_0s_Stuff_Funcs.sum_incremental(card.ability.extra.chip_mod)\n        if context.joker_main and chs ~= 0 then\n            return {\n                chips = chs\n            }\n        end\n    end,\n    atlas = \"sdm_jokers\"",
      "config": {
        "extra": {
          "chips": 0,
          "chip_mod": 2
        }
      },
      "ability": {
        "extra": {
          "chips": 0,
          "chip_mod": 2
        }
      },
      "vars": [
        2,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "jambo",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 0,
        "y": 5
      },
      "raw": "key = \"jambo\",\n    name = \"Jambo\",\n    rarity = 1,\n    blueprint_compat = true,\n    pos = {x = 0, y = 5},\n    cost = 6,\n    calculate = function(self, card, context)\n        if context.joker_main and (G.discard and #G.discard.cards > 0) then\n            local _card = pseudorandom_element(G.discard.cards, pseudoseed('jambo'))\n            if _card.debuff then\n                return {\n                    message = localize('k_debuffed'),\n                }\n            end\n            local mlt = _card.base.nominal * 2\n            if mlt ~= 0 then\n                return {\n                    mult = mlt\n                }\n            end\n        end\n    end,\n    atlas = \"sdm_jokers\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "water_slide",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 1,
        "y": 5
      },
      "raw": "key = \"water_slide\",\n    name = \"Water Slide\",\n    rarity = 2,\n    pos = {x = 1, y = 5},\n    cost = 7,\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue+1] = G.P_CENTERS.m_bonus\n    end,\n    calculate = function(self, card, context)\n        if context.cardarea == G.jokers and context.before and context.scoring_hand and SDM_0s_Stuff_Funcs.no_bp_retrigger(context) then\n            local triggered = false\n            for i = 1, #context.scoring_hand do\n                if (context.scoring_hand[i]:get_id() == 9 or\n                context.scoring_hand[i]:get_id() == 7 or\n                context.scoring_hand[i]:get_id() == 6)\n                and not context.scoring_hand[i].debuff then\n                    triggered = true\n                    context.scoring_hand[i]:set_ability(G.P_CENTERS.m_bonus, nil, true)\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            context.scoring_hand[i]:juice_up()\n                            return true\n                        end\n                    }))\n                end\n            end\n            if triggered then\n                card_eval_status_text(card, 'extra', nil, nil, nil, {\n                    message = localize('k_bonus'),\n                    colour = G.C.BLUE,\n                })\n            end\n        end\n    end,\n    atlas = \"sdm_jokers\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "joker_voucher",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 2,
        "y": 5
      },
      "raw": "key = \"joker_voucher\",\n    name = \"Joker Voucher\",\n    rarity = 3,\n    blueprint_compat = true,\n    pos = {x = 2, y = 5},\n    cost = 8,\n    config = {extra = {Xmult_mod = 0.25}},\n    loc_vars = function(self, info_queue, card)\n        return {vars = {card.ability.extra.Xmult_mod, 1 + ((G.vouchers and #G.vouchers.cards) or 0) * card.ability.extra.Xmult_mod}}\n    end,\n    calculate = function(self, card, context)\n        if context.buying_card and context.card.ability.set == \"Voucher\" then\n            G.E_MANAGER:add_event(Event({\n                func = function() card_eval_status_text(card, 'extra', nil, nil, nil, {message = localize{type='variable',key='a_xmult',vars={1 + (#G.vouchers.cards or 0) * card.ability.extra.Xmult_mod}}}); return true\n                end}))\n            return\n        end\n        if context.joker_main then\n            local xmlt = 1 + (#G.vouchers.cards or 0) * card.ability.extra.Xmult_mod\n            if xmlt ~= 1 then\n                return {\n                    Xmult = xmlt\n                }\n            end\n        end\n    end,\n    atlas = \"sdm_jokers\"",
      "config": {
        "extra": {
          "Xmult_mod": 0.25
        }
      },
      "ability": {
        "extra": {
          "Xmult_mod": 0.25
        }
      },
      "vars": [
        0.25,
        0.25
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "free_pass",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 3,
        "y": 5
      },
      "raw": "key = \"free_pass\",\n    name = \"Free Pass\",\n    rarity = 1,\n    pos = {x = 3, y = 5},\n    cost = 5,\n    calculate = function(self, card, context)\n        if context.first_hand_drawn and SDM_0s_Stuff_Funcs.no_bp_retrigger(context) then\n            local eval = function() return G.GAME.current_round.hands_played == 0 and G.GAME.current_round.discards_used == 0 end\n            juice_card_until(card, eval, true)\n        end\n        if context.cardarea == G.jokers and context.before and (G.GAME.current_round.discards_used == 0 and G.GAME.current_round.hands_played == 0) then\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    ease_hands_played(1)\n                    card_eval_status_text(card, 'extra', nil, nil, nil, {message = localize{type = 'variable', key = 'a_hand', vars = {1}}, colour = G.C.BLUE})\n                    return true\n                end}))\n            return\n        elseif context.pre_discard and (G.GAME.current_round.discards_used == 0 and G.GAME.current_round.hands_played == 0) then\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    ease_discard(1)\n                    card_eval_status_text(card, 'extra', nil, nil, nil, {message = localize{type = 'variable', key = 'a_discard', vars = {1}}, colour = G.C.RED})\n                    return true\n                end}))\n            return\n        end\n    end,\n    atlas = \"sdm_jokers\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "legionary_joker",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 4,
        "y": 5
      },
      "raw": "key = \"legionary_joker\",\n    name = \"Legionary Joker\",\n    rarity = 1,\n    blueprint_compat = true,\n    pos = {x = 4, y = 5},\n    cost = 5,\n    config = {extra = 5},\n    loc_vars = function(self, info_queue, card)\n        return {vars = {localize('Spades', 'suits_singular'), localize('Diamonds', 'suits_singular'), card.ability.extra}}\n    end,\n    calculate = function(self, card, context)\n        if not context.end_of_round and context.individual and context.cardarea == G.hand then\n            if context.other_card and context.other_card:is_suit(\"Spades\", nil, true)\n            or context.other_card:is_suit(\"Diamonds\", nil, true) then\n                if context.other_card.debuff then\n                    return {\n                        message = localize('k_debuffed'),\n                        colour = G.C.RED,\n                    }\n                else\n                    return {\n                        h_mult = card.ability.extra,\n                    }\n                end\n            end\n        end\n    end,\n    atlas = \"sdm_jokers\"",
      "config": {
        "extra": 5
      },
      "ability": {
        "extra": 5
      },
      "vars": [
        null,
        null,
        null,
        null,
        5
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "jack_a_dit",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 5,
        "y": 5
      },
      "raw": "key = \"jack_a_dit\",\n    name = \"Jack a Dit\",\n    rarity = 1,\n    blueprint_compat = true,\n    pos = {x = 5, y = 5},\n    cost = 5,\n    config = {extra = 20},\n    loc_vars = function(self, info_queue, card)\n        return {vars = {card.ability.extra, localize(card.ability.jack_poker_hand1, 'poker_hands'), localize(card.ability.jack_poker_hand2, 'poker_hands')}}\n    end,\n    set_ability = function(self, card, initial, delay_sprites)\n        local _poker_hands = {}\n        for _, v in ipairs(G.handlist) do\n            if SMODS.is_poker_hand_visible(v) then\n                table.insert(_poker_hands, v)\n            end\n        end\n        local idx\n        card.ability.jack_poker_hand1, idx = pseudorandom_element(_poker_hands, pseudoseed('jack1'))\n        table.remove(_poker_hands, idx)\n        card.ability.jack_poker_hand2 = pseudorandom_element(_poker_hands, pseudoseed('jack2'))\n    end,\n    calculate = function(self, card, context)\n        if context.joker_main and context.scoring_hand then\n            local has_jack = false\n            for i = 1, #context.scoring_hand do\n                if context.scoring_hand[i]:get_id() == 11 then\n                    has_jack = true\n                    break\n                end\n            end\n            if has_jack and (context.scoring_name and (context.scoring_name == card.ability.jack_poker_hand1 or context.scoring_name == card.ability.jack_poker_hand2)) then\n                return {\n                    mult = card.ability.extra,\n                }\n            end\n        end\n        if context.end_of_round and context.main_eval and SDM_0s_Stuff_Funcs.no_bp_retrigger(context) then\n            local _poker_hands = {}\n            for k, _ in pairs(G.GAME.hands) do\n                if SMODS.is_poker_hand_visible(k) then _poker_hands[k] = true end\n            end\n            local old_hand1, old_hand2 = card.ability.jack_poker_hand1, card.ability.jack_poker_hand2\n            _poker_hands[old_hand1] = nil\n            _poker_hands[old_hand2] = nil\n            _, card.ability.jack_poker_hand1 = pseudorandom_element(_poker_hands, pseudoseed('jack1'))\n            _poker_hands[card.ability.jack_poker_hand1] = nil\n            _, card.ability.jack_poker_hand2 = pseudorandom_element(_poker_hands, pseudoseed('jack2'))\n            return {\n                message = localize('k_reset')\n            }\n        end\n    end,\n    atlas = \"sdm_jokers\"",
      "config": {
        "extra": 20
      },
      "ability": {
        "extra": 20
      },
      "vars": [
        20,
        null,
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "chain_reaction",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 6,
        "y": 5
      },
      "raw": "key = \"chain_reaction\",\n    name = \"Chain Reaction\",\n    rarity = 2,\n    blueprint_compat = true,\n    pos = {x = 6, y = 5},\n    cost = 8,\n    config = {extra = {mult = 0}},\n    loc_vars = function(self, info_queue, card)\n        return {vars = {card.ability.extra.mult}}\n    end,\n    calculate = function(self, card, context)\n        if context.cardarea == G.jokers and context.before and context.full_hand and context.scoring_name and SDM_0s_Stuff_Funcs.no_bp_retrigger(context) then\n            if string.match(string.lower(context.scoring_name), \"%f[%w]kind%f[%W]$\") then\n                local _, _, _, scoring_hand = G.FUNCS.get_poker_hand_info(context.full_hand)\n                local scored_rank_cards = 0\n                for _, v in ipairs(scoring_hand) do\n                    if not SMODS.has_no_rank(v) then\n                        scored_rank_cards = scored_rank_cards + 1\n                    end\n                end\n                card.ability.extra.mult = card.ability.extra.mult + (next(SMODS.find_card(\"j_sdm_magic_hands\")) and math.min(G.hand.config.highlighted_limit, scored_rank_cards + 1) or scored_rank_cards)\n                return {\n                    message = localize{type='variable',key='a_mult',vars={card.ability.extra.mult}}\n                }\n            end\n        end\n        if context.joker_main and card.ability.extra.mult ~= 0 then\n            return {\n                mult = card.ability.extra.mult\n            }\n        end\n    end,\n    atlas = \"sdm_jokers\"",
      "config": {
        "extra": {
          "mult": 0
        }
      },
      "ability": {
        "extra": {
          "mult": 0
        }
      },
      "vars": [
        0
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "consolation_prize",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 7,
        "y": 5
      },
      "raw": "key = \"consolation_prize\",\n    name = \"Consolation Prize\",\n    rarity = 1,\n    blueprint_compat = true,\n    pos = {x = 7, y = 5},\n    cost = 5,\n    calculate = function(self, card, context)\n        if context.end_of_round and context.main_eval and G.GAME.current_round.hands_left == 0 then\n            G.E_MANAGER:add_event(Event({\n                func = (function()\n                local _tag_key = get_next_tag_key(\"conso_prize\")\n                local _tag = Tag(_tag_key)\n                if _tag.key == \"tag_orbital\" then\n                    local visible_hands = {}\n                    for k, _ in pairs(G.GAME.hands) do\n                        if SMODS.is_poker_hand_visible(k) then\n                            visible_hands[#visible_hands + 1] = k\n                        end\n                    end\n                    _tag.ability.orbital_hand = pseudorandom_element(visible_hands, pseudoseed('conso_prize_orbital'))\n                end\n                add_tag(_tag)\n                play_sound('generic1', 0.9 + math.random()*0.1, 0.8)\n                play_sound('holo1', 1.2 + math.random()*0.1, 0.4)\n                return true\n            end)\n            }))\n            card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {\n                message = localize('k_plus_tag'),\n                colour = G.C.FILTER,\n            })\n        end\n    end,\n    atlas = \"sdm_jokers\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "horoscopy",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 8,
        "y": 5
      },
      "raw": "key = \"horoscopy\",\n    name = \"Horoscopy\",\n    rarity = 3,\n    blueprint_compat = true,\n    pos = {x = 8, y = 5},\n    cost = 8,\n    config = {extra = 2},\n    loc_vars = function(self, info_queue, card)\n        local mod_num, mod_den = SMODS.get_probability_vars(card, 1, card.ability.extra)\n        return {vars = {mod_num, mod_den}}\n    end,\n    calculate = function(self, card, context)\n        if context.using_consumeable and SDM_0s_Stuff_Funcs.proba_check(card, card.ability.extra, 'horoscopy') then\n            G.E_MANAGER:add_event(Event({\n                func = (function()\n                if context.consumeable.ability.set == 'Planet' and #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then\n                    G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1\n                    G.E_MANAGER:add_event(Event({\n                        trigger = 'before',\n                        delay = 0.0,\n                        func = (function()\n                            SMODS.add_card({set = 'Tarot', key_append = 'ast'})\n                            G.GAME.consumeable_buffer = 0\n                            return true\n                    end)}))\n                card_eval_status_text(card, 'extra', nil, nil, nil, {message = localize('k_plus_tarot'), colour = G.C.SECONDARY_SET.Tarot})\n                end\n                return true\n            end)}))\n        end\n    end,\n    atlas = \"sdm_jokers\"",
      "config": {
        "extra": 2
      },
      "ability": {
        "extra": 2
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "roulette",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 9,
        "y": 5
      },
      "raw": "key = \"roulette\",\n    name = \"Roulette\",\n    rarity = 3,\n    blueprint_compat = true,\n    pos = {x = 9, y = 5},\n    cost = 7,\n    config = {extra = 3},\n    loc_vars = function(self, info_queue, card)\n        local mod_num, mod_den = SMODS.get_probability_vars(card, 1, card.ability.extra)\n        return {vars = {mod_num, mod_den}}\n    end,\n    calculate = function(self, card, context)\n        if context.first_hand_drawn then\n            if SDM_0s_Stuff_Funcs.proba_check(card, card.ability.extra, 'roulette') then\n                G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n                    local valid_cards = {}\n                    for i = 1, #G.hand.cards do\n                        if not G.hand.cards[i].edition then\n                            table.insert(valid_cards, G.hand.cards[i])\n                        end\n                    end\n                    for i = 1, #G.jokers.cards do\n                        if not G.jokers.cards[i].edition then\n                            table.insert(valid_cards, G.jokers.cards[i])\n                        end\n                    end\n                    local edition = poll_edition('wheel_of_fortune', nil, true, true)\n                    local random_card = valid_cards[pseudorandom('roulette', 1, #valid_cards)]\n                    random_card:set_edition(edition, true)\n                    card:juice_up(0.3, 0.5)\n                    return true\n                end }))\n            else\n                G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n                    attention_text({\n                        text = localize('k_nope_ex'),\n                        scale = 1,\n                        hold = 0.65*1.25-0.2,\n                        major = card,\n                        backdrop_colour = G.C.SECONDARY_SET.Tarot,\n                        align = 'bm',\n                        offset = {x = 0, y = 0.05*card.T.h},\n                        silent = true\n                        })\n                    G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.06*G.SETTINGS.GAMESPEED, blockable = false, blocking = false, func = function()\n                        play_sound('tarot2', 0.76, 0.4);\n                        return true\n                    end}))\n                    play_sound('tarot2', 1, 0.4)\n                    card:juice_up(0.6, 0.1)\n                    G.ROOM.jiggle = G.ROOM.jiggle + 0.7\n                    return true\n                end}))\n            end\n        end\n    end,\n    atlas = \"sdm_jokers\"",
      "config": {
        "extra": 3
      },
      "ability": {
        "extra": 3
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "carcinization",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 0,
        "y": 6
      },
      "raw": "key = \"carcinization\",\n    name = \"Carcinization\",\n    rarity = 2,\n    blueprint_compat = true,\n    pos = {x = 0, y = 6},\n    cost = 6,\n    config = {extra = {mult_mod = 6}},\n    loc_vars = function(self, info_queue, card)\n        local mlt = card.ability.extra.mult_mod * SDM_0s_Stuff_Funcs.get_crab_count()\n        return {vars = {card.ability.extra.mult_mod, mlt}}\n    end,\n    calculate = function(self, card, context)\n        if context.setting_blind and not card.getting_sliced and SDM_0s_Stuff_Funcs.no_bp_retrigger(context) then\n            local my_pos = nil\n            for i = 1, #G.jokers.cards do\n                if G.jokers.cards[i] == card then my_pos = i; break end\n            end\n            if my_pos and G.jokers.cards[my_pos-1] and G.jokers.cards[my_pos-1].ability.name ~= \"Carcinization\" and not SMODS.is_eternal(G.jokers.cards[my_pos-1]) then\n                local carcinized_card = G.jokers.cards[my_pos-1]\n                G.E_MANAGER:add_event(Event({func = function()\n                    -- \"set_ability\" doesn't change the card's sell cost\n                    carcinized_card.sell_cost = math.max(1, math.floor(G.jokers.cards[my_pos].cost/2)) + (carcinized_card.ability.extra_value or 0)\n                    carcinized_card:set_ability(G.P_CENTERS[\"j_sdm_carcinization\"], true)\n                    carcinized_card:juice_up(0.3, 0.5)\n                    card:juice_up(0.8, 0.8)\n                    return true\n                end}))\n                card_eval_status_text(card, 'extra', nil, nil, nil, {message = localize(\"k_crab_ex\"), colour = G.C.RED, no_juice = true})\n            end\n        end\n        if context.joker_main then\n            local mlt = card.ability.extra.mult_mod * SDM_0s_Stuff_Funcs.get_crab_count()\n            if mlt ~= 0 then\n                return {\n                    mult = mlt\n                }\n            end\n        end\n    end,\n    atlas = \"sdm_jokers\"",
      "config": {
        "extra": {
          "mult_mod": 6
        }
      },
      "ability": {
        "extra": {
          "mult_mod": 6
        }
      },
      "vars": [
        6,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "wormhole",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 1,
        "y": 6
      },
      "raw": "key = \"wormhole\",\n    name = \"Wormhole\",\n    rarity = 2,\n    pos = {x = 1, y = 6},\n    cost = 6,\n    atlas = \"sdm_jokers\"\n    -- Effect coded in lovely.toml",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "child",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 2,
        "y": 6
      },
      "raw": "key = \"child\",\n    name = \"Child\",\n    rarity = 1,\n    blueprint_compat = true,\n    pos = {x = 2, y = 6},\n    cost = 4,\n    config = {extra = 0.85},\n    loc_vars = function(self, info_queue, card)\n        return {vars = {card.ability.extra}}\n    end,\n    calculate = function(self, card, context)\n        if context.setting_blind and not card.getting_sliced then\n            G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.1,func = function()\n                G.GAME.blind.chips = math.floor(G.GAME.blind.chips * card.ability.extra)\n                G.GAME.blind.chip_text = number_format(G.GAME.blind.chips)\n                local chips_UI = G.hand_text_area.blind_chips\n                G.FUNCS.blind_chip_UI_scale(G.hand_text_area.blind_chips)\n                G.HUD_blind:recalculate()\n                if context.blueprint_card then context.blueprint_card:juice_up() else card:juice_up() end\n                chips_UI:juice_up()\n                if not silent then play_sound('chips2') end\n            return true end }))\n        end\n    end,\n    pixel_size = {w = 71, h = 71},\n    atlas = \"sdm_jokers\"",
      "config": {
        "extra": 0.85
      },
      "ability": {
        "extra": 0.85
      },
      "vars": [
        0.85
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "yo_yo",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 3,
        "y": 6
      },
      "raw": "key = \"yo_yo\",\n    name = \"Yo-Yo\",\n    rarity = 1,\n    blueprint_compat = true,\n    pos = {x = 3, y = 6},\n    cost = 6,\n    config = {extra = {low = false, low_xmult = 0.5, high_xmult = 2}},\n    loc_vars = function(self, info_queue, card)\n        return {vars = {card.ability.extra.low_xmult, card.ability.extra.high_xmult, (card.ability.extra.low and card.ability.extra.low_xmult) or card.ability.extra.high_xmult}}\n    end,\n    calculate = function(self, card, context)\n        if context.joker_main then\n            local curr_xmult = (card.ability.extra.low and card.ability.extra.low_xmult) or card.ability.extra.high_xmult\n            if curr_xmult ~= 1 then\n                return {\n                    Xmult = curr_xmult\n                }\n            end\n        end\n        if context.after and SDM_0s_Stuff_Funcs.no_bp_retrigger(context) then\n            card.ability.extra.low = not card.ability.extra.low\n            local curr_xmult = (card.ability.extra.low and card.ability.extra.low_xmult) or card.ability.extra.high_xmult\n            card_eval_status_text(card, 'extra', nil, nil, nil, {\n                message = localize{type='variable',key='a_xmult',vars={curr_xmult}},\n                colour = G.C.FILTER,\n            })\n        end\n    end,\n    atlas = \"sdm_jokers\"",
      "config": {
        "extra": {
          "low": false,
          "low_xmult": 0.5,
          "high_xmult": 2
        }
      },
      "ability": {
        "extra": {
          "low": false,
          "low_xmult": 0.5,
          "high_xmult": 2
        }
      },
      "vars": [
        0.5,
        2,
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "ditto_joker",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 4,
        "y": 6
      },
      "raw": "key = \"ditto_joker\",\n    name = \"Ditto Joker\",\n    rarity = 3,\n    eternal_compat = false,\n    pos = {x = 4, y = 6},\n    cost = 8,\n    calculate = function(self, card, context)\n        if context.setting_blind and not card.getting_sliced and SDM_0s_Stuff_Funcs.no_bp_retrigger(context) then\n            local valid_jokers = {}\n            if G.jokers and G.jokers.cards and #G.jokers.cards > 1 then\n                for i = 1, #G.jokers.cards do\n                    if not G.jokers.cards[i].debuff and G.jokers.cards[i] ~= card and G.jokers.cards[i].config.center.key ~= \"j_sdm_ditto_joker\" then\n                        valid_jokers[#valid_jokers+1] = G.jokers.cards[i]\n                    end\n                end\n            end\n            if #valid_jokers > 0 then\n                local old_card = card\n                local chosen_joker = pseudorandom_element(valid_jokers, pseudoseed('ditto'))\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        card:set_ability(G.P_CENTERS[chosen_joker.config.center.key], true)\n                        card:set_cost()\n                        for k, v in pairs(chosen_joker.ability) do\n                            if type(v) == 'table' then\n                                card.ability[k] = copy_table(v)\n                            elseif not SMODS.Stickers[k] then\n                                card.ability[k] = v\n                            end\n                        end\n                        card.ability.fusion = nil -- FusionJokers compat to remove fuse button\n                        card.ability.sdm_is_ditto = true\n                        return true\n                    end\n                }))\n                card_eval_status_text(old_card, 'extra', nil, nil, nil, {\n                    message = localize('k_ditto_ex'),\n                    colour = HEX('f06bf2'),\n                })\n            end\n        end\n    end,\n    in_pool = function()\n        if G.jokers and G.jokers.cards then\n            for _, v in ipairs(G.jokers.cards) do\n                if v.ability and v.ability.sdm_is_ditto then return false end\n            end\n        end\n        return true\n    end,\n    atlas = \"sdm_jokers\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "sdm_ditto_mark",
      "atlas": null,
      "pos": null,
      "raw": "key = \"sdm_ditto_mark\",\n    path = \"sdm_ditto_mark.png\",\n    px = 71,\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "DrawStep",
      "key": "ditto_mark",
      "atlas": null,
      "pos": null,
      "raw": "key = 'ditto_mark',\n    order = 19,\n    func = function(self)\n        if self.ability.sdm_is_ditto then\n            if not SDM_0s_Stuff_Mod.ditto_mark then SDM_0s_Stuff_Mod.ditto_mark = Sprite(0, 0, G.CARD_W, G.CARD_H, G.ASSET_ATLAS[\"sdm_ditto_mark\"], {x = 0,y = 0}) end\n            SDM_0s_Stuff_Mod.ditto_mark.role.draw_major = self\n            SDM_0s_Stuff_Mod.ditto_mark:draw_shader('dissolve', nil, nil, nil, self.children.center)\n        end\n    end,\n    conditions = {vortex = false, facing = 'front'}",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "pastry_chef",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 5,
        "y": 6
      },
      "raw": "key = \"pastry_chef\",\n        name = \"Pastry Chef\",\n        rarity = 3,\n        blueprint_compat = true,\n        pos = {x = 5, y = 6},\n        cost = 8,\n        calculate = function(self, card, context)\n            if context.sdm_bakery_consumed then\n                if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then\n                    G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1\n                    G.E_MANAGER:add_event(Event({\n                        func = (function()\n                            G.E_MANAGER:add_event(Event({\n                                func = function()\n                                    SMODS.add_card({set = 'Bakery', key_append = 'chef'})\n                                    G.GAME.consumeable_buffer = 0\n                                    return true\n                                end}))\n                        card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = localize('k_plus_bakery'), colour = G.C.ORANGE})\n                        return true\n                    end)}))\n                end\n            end\n        end,\n        atlas = \"sdm_jokers\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "archibald",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 0,
        "y": 3
      },
      "raw": "key = \"archibald\",\n    name = \"Archibald\",\n    rarity = 4,\n    config = {extra = {can_copy = true}},\n    pos = {x = 0, y = 3},\n    cost = 20,\n    loc_vars = function(self, info_queue, card)\n        if not card.edition or (card.edition and not card.edition.negative) then\n            info_queue[#info_queue+1] = G.P_CENTERS.e_negative\n        end\n        return {vars = {(card.ability.extra.can_copy and localize(\"k_sdm_active\")) or \"\", (not card.ability.extra.can_copy and localize(\"k_sdm_inactive\")) or \"\"}}\n    end,\n    calculate = function(self, card, context)\n        if context.ending_shop and SDM_0s_Stuff_Funcs.no_bp_retrigger(context) then\n            if card.ability.extra.can_copy and #G.jokers.cards > 0 then\n                local valid_cards = {}\n                for i = 1, #G.jokers.cards do\n                    if G.jokers.cards[i].ability.name ~= \"Archibald\" then\n                        table.insert(valid_cards, G.jokers.cards[i])\n                    end\n                end\n                if #valid_cards > 0 then\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            local rand_card = pseudorandom_element(valid_cards, pseudoseed('archi'))\n                            local new_card = copy_card(rand_card, nil, nil, nil, true)\n                            new_card:set_edition(\"e_negative\", true)\n                            new_card:start_materialize()\n                            new_card:add_to_deck()\n                            G.jokers:emplace(new_card)\n                            if SDM_0s_Stuff_Funcs.no_bp_retrigger(context) then\n                                card.ability.extra.can_copy = false\n                            end\n                            return true\n                        end\n                    }))\n                    card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {\n                        message = localize('k_plus_joker'),\n                        colour = G.C.DARK_EDITION,\n                    })\n                end\n            end\n        end\n        if context.end_of_round and context.main_eval and SDM_0s_Stuff_Funcs.no_bp_retrigger(context)\n        and G.GAME.blind.boss and not card.ability.extra.can_copy then\n            card.ability.extra.can_copy = true\n            card_eval_status_text(card, 'extra', nil, nil, nil, {\n                message = localize('k_active_ex'),\n                colour = G.C.FILTER,\n            })\n        end\n    end,\n    atlas = \"sdm_jokers\",\n    soul_pos = {x = 0, y = 4}",
      "config": {
        "extra": {
          "can_copy": true
        }
      },
      "ability": {
        "extra": {
          "can_copy": true
        }
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "sdm_0",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 1,
        "y": 3
      },
      "raw": "key = \"sdm_0\",\n    name = \"SDM_0\",\n    rarity = 4,\n    perishable_compat = false,\n    pos = {x = 1, y = 3},\n    cost = 20,\n    config = {extra = {jkr_slots = 1}},\n    loc_vars = function(self, info_queue, card)\n        return {vars = {card.ability.extra.jkr_slots}}\n    end,\n    calculate = function(self, card, context)\n        if context.cards_destroyed and SDM_0s_Stuff_Funcs.no_bp_retrigger(context) then\n            if #context.glass_shattered > 0 then\n                for _, v in ipairs(context.glass_shattered) do\n                    if v:get_id() == 2 then\n                        G.jokers.config.card_limit = G.jokers.config.card_limit + card.ability.extra.jkr_slots\n                        card_eval_status_text(card, 'extra', nil, nil, nil, {\n                            message = localize{type = 'variable', key = 'a_joker_slot', vars = {card.ability.extra.jkr_slots}},\n                            colour = G.C.DARK_EDITION,\n                        })\n                    end\n                end\n            end\n        elseif context.remove_playing_cards and SDM_0s_Stuff_Funcs.no_bp_retrigger(context) then\n            if #context.removed > 0 then\n                for _, v in ipairs(context.removed) do\n                    if v:get_id() == 2 then\n                        G.jokers.config.card_limit = G.jokers.config.card_limit + card.ability.extra.jkr_slots\n                        card_eval_status_text(card, 'extra', nil, nil, nil, {\n                            message = localize{type = 'variable', key = 'a_joker_slot', vars = {card.ability.extra.jkr_slots}},\n                            colour = G.C.DARK_EDITION,\n                        })\n                    end\n                end\n            end\n        end\n    end,\n    atlas = \"sdm_jokers\",\n    soul_pos = {x = 1, y = 4}",
      "config": {
        "extra": {
          "jkr_slots": 1
        }
      },
      "ability": {
        "extra": {
          "jkr_slots": 1
        }
      },
      "vars": [
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "skelton",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 3,
        "y": 3
      },
      "raw": "key = \"skelton\",\n    name = \"Skelton\",\n    rarity = 4,\n    pos = {x = 3, y = 3},\n    cost = 20,\n    config = {extra = {dollars = 0, dollar_mod = 1}},\n    loc_vars = function(self, info_queue, card)\n        return {vars = {card.ability.extra.dollars, card.ability.extra.dollar_mod}}\n    end,\n    calc_dollar_bonus = function(self, card)\n        if card.ability.extra.dollars ~= 0 then\n            return card.ability.extra.dollars\n        end\n    end,\n    calculate = function(self, card, context)\n        if context.destroy_card and context.cardarea == \"unscored\" and context.scoring_hand and SDM_0s_Stuff_Funcs.no_bp_retrigger(context) then\n            if #context.scoring_hand == 1 and context.scoring_hand[1]:get_id() == 11 then\n                card.ability.extra.dollars = card.ability.extra.dollars + card.ability.extra.dollar_mod\n                card.ability.skelton_triggered = true\n                return {\n                    remove = true,\n                }\n            end\n\t\tend\n        if context.after and card.ability.skelton_triggered and SDM_0s_Stuff_Funcs.no_bp_retrigger(context) then\n            card.ability.skelton_triggered = nil\n            return {\n                message = localize('k_upgrade_ex'),\n                colour = G.C.MONEY,\n            }\n        end\n    end,\n    atlas = \"sdm_jokers\",\n    soul_pos = {x = 3, y = 4}",
      "config": {
        "extra": {
          "dollars": 0,
          "dollar_mod": 1
        }
      },
      "ability": {
        "extra": {
          "dollars": 0,
          "dollar_mod": 1
        }
      },
      "vars": [
        0,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "trance_the_devil",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 2,
        "y": 3
      },
      "raw": "key = \"trance_the_devil\",\n    name = \"Trance The Devil\",\n    rarity = 4,\n    perishable_compat = false,\n    blueprint_compat = true,\n    pos = {x = 2, y = 3},\n    cost = 20,\n    config = {extra = {Xmult = 1, Xmult_mod = 0.25}},\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue+1] = {key = \"vanilla_consumable\", set = \"Other\"}\n        return {vars = {card.ability.extra.Xmult_mod, card.ability.extra.Xmult}}\n    end,\n    calculate = function(self, card, context)\n        if context.end_of_round and not card.getting_sliced and (context.individual or context.repetition) and SDM_0s_Stuff_Funcs.no_bp_retrigger(context) then\n            if G.consumeables and #G.consumeables.cards > 0 then\n                local destructable_consus = {}\n                for i = 1, #G.consumeables.cards do\n                    if not G.consumeables.cards[i].ability.eternal and not G.consumeables.cards[i].getting_sliced\n                    and not SDM_0s_Stuff_Funcs.is_bakery_good(G.consumeables.cards[i]) and (G.consumeables.cards[i].ability.set == \"Tarot\"\n                    or G.consumeables.cards[i].ability.set == \"Planet\" or G.consumeables.cards[i].ability.set == \"Spectral\") then\n                        destructable_consus[#destructable_consus+1] = G.consumeables.cards[i]\n                    end\n                end\n                if #destructable_consus > 0 then\n                    for _, v in ipairs(destructable_consus) do\n                        v.getting_sliced = true\n                        G.E_MANAGER:add_event(Event({func = function()\n                            card:juice_up(0.8, 0.8)\n                            v:start_dissolve({G.C.RED}, nil, 1.6)\n                        return true end }))\n                        card.ability.extra.Xmult = card.ability.extra.Xmult + card.ability.extra.Xmult_mod\n                        card_eval_status_text(card, 'extra', nil, nil, nil, {message = localize{type = 'variable', key = 'a_xmult', vars = {card.ability.extra.Xmult}}})\n                    end\n                end\n            end\n        end\n        if context.joker_main and card.ability.extra.Xmult ~= 1 then\n            return {\n                Xmult = card.ability.extra.Xmult\n            }\n        end\n    end,\n    atlas = \"sdm_jokers\",\n    soul_pos = {x = 2, y = 4}",
      "config": {
        "extra": {
          "Xmult": 1,
          "Xmult_mod": 0.25
        }
      },
      "ability": {
        "extra": {
          "Xmult": 1,
          "Xmult_mod": 0.25
        }
      },
      "vars": [
        0.25,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "ObjectType",
      "key": "SDM_0s_jokers",
      "atlas": null,
      "pos": null,
      "raw": "key = 'SDM_0s_jokers',\n        default = 'j_sdm_bounciest_ball',\n        cards = {},\n        inject = function(self)\n            SMODS.ObjectType.inject(self)\n            for k, _ in pairs(SDM_0s_Stuff_Mod.modded_jokers) do\n                local joker = nil\n                if G.P_CENTERS[k] then\n                    joker = G.P_CENTERS[k]\n                elseif SMODS.Centers[k] then\n                    joker = SMODS.Centers[k]\n                end\n                if joker then\n                    self:inject_card(joker)\n                end\n            end\n        end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "ObjectType",
      "key": "Space",
      "atlas": null,
      "pos": null,
      "raw": "key = 'Space',\n        default = 'j_space',\n        cards = {},\n        inject = function(self)\n            SMODS.ObjectType.inject(self)\n            for k, _ in pairs(SDM_0s_Stuff_Mod.space_jokers) do\n                local joker = nil\n                if G.P_CENTERS[k] then\n                    joker = G.P_CENTERS[k]\n                elseif SMODS.Centers[k] then\n                    joker = SMODS.Centers[k]\n                end\n                if joker then\n                    self:inject_card(joker)\n                end\n            end\n        end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "ObjectTypes",
      "key": "SDM_0s_consus",
      "atlas": null,
      "pos": null,
      "raw": "key = 'SDM_0s_consus',\n        default = default,\n        cards = {},\n        inject = function(self)\n            SMODS.ObjectType.inject(self)\n            for k, _ in pairs(SDM_0s_Stuff_Mod.modded_consumables) do\n                local consu = nil\n                if G.P_CENTERS[k] then\n                    consu = G.P_CENTERS[k]\n                elseif SMODS.Centers[k] then\n                    consu = SMODS.Centers[k]\n                end\n                if consu then\n                    self:inject_card(consu)\n                end\n            end\n        end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "sdm_vouchers",
      "atlas": null,
      "pos": null,
      "raw": "key = \"sdm_vouchers\",\n    path = \"sdm_vouchers.png\",\n    px = 71,\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Voucher",
      "key": "shadow",
      "atlas": "sdm_vouchers",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = 'shadow',\n    name = 'Shadow',\n    pos = {x = 0, y = 0},\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue+1] = G.P_TAGS.tag_negative\n    end,\n    redeem = function(self)\n        G.E_MANAGER:add_event(Event({\n            func = (function()\n                add_tag(Tag('tag_negative'))\n                play_sound('generic1', 0.9 + math.random()*0.1, 0.8)\n                play_sound('holo1', 1.2 + math.random()*0.1, 0.4)\n                return true\n            end)\n        }))\n    end,\n    atlas = \"sdm_vouchers\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Voucher",
      "key": "eclipse",
      "atlas": "sdm_vouchers",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = 'eclipse',\n    name = 'Eclipse',\n    pos = {x = 0, y = 1},\n    requires = {\"v_sdm_shadow\"},\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue+1] = G.P_TAGS.tag_negative\n    end,\n    calculate = function(self, card, context)\n        if context.end_of_round and context.main_eval and context.beat_boss then\n            G.E_MANAGER:add_event(Event({\n                func = (function()\n                    add_tag(Tag('tag_negative'))\n                    play_sound('generic1', 0.9 + math.random()*0.1, 0.8)\n                    play_sound('holo1', 1.2 + math.random()*0.1, 0.4)\n                    return true\n                end)\n            }))\n        end\n    end,\n    atlas = \"sdm_vouchers\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Voucher",
      "key": "drought",
      "atlas": "sdm_vouchers",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = 'drought',\n    name = 'Drought',\n    pos = {x = 1, y = 0},\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue+1] = {key = \"undefined_standard_pack\", set = \"Other\"}\n    end,\n    redeem = function(self)\n        for _, v in pairs(G.P_CENTERS) do\n            if v.set and v.set == \"Booster\" and v.kind and v.kind == \"Standard\" then\n                G.GAME.banned_keys[v.key] = true\n            end\n        end\n        if G.shop_booster then\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    for i = #G.shop_booster.cards, 1, -1 do\n                        local _center = G.shop_booster.cards[i].config.center\n                        if G.GAME.banned_keys[_center.key] and (_center.kind and _center.kind == \"Standard\") then\n                            G.shop_booster.cards[i]:remove()\n                            SMODS.add_booster_to_shop()\n                        end\n                    end\n                return true\n            end}))\n        end\n    end,\n    atlas = \"sdm_vouchers\"",
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Voucher",
      "key": "famine",
      "atlas": "sdm_vouchers",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = 'famine',\n    name = 'Famine',\n    pos = {x = 1, y = 1},\n    requires = {\"v_sdm_drought\"},\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue+1] = {key = \"undefined_buffoon_pack\", set = \"Other\"}\n    end,\n    redeem = function(self)\n        for _, v in pairs(G.P_CENTERS) do\n            if v.set and v.set == \"Booster\" and v.kind and v.kind == \"Buffoon\" then\n                G.GAME.banned_keys[v.key] = true\n            end\n        end\n        if G.shop_booster then\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    for i = #G.shop_booster.cards, 1, -1 do\n                        local _center = G.shop_booster.cards[i].config.center\n                        if G.GAME.banned_keys[_center.key] and (_center.kind and _center.kind == \"Buffoon\") then\n                            G.shop_booster.cards[i]:remove()\n                            SMODS.add_booster_to_shop()\n                        end\n                    end\n                return true\n            end}))\n        end\n    end,\n    atlas = \"sdm_vouchers\"",
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Voucher",
      "key": "joker_voucher",
      "atlas": "sdm_vouchers",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = 'joker_voucher',\n        name = 'Joker Voucher',\n        pos = {x = 2, y = 0},\n        config = {extra = {Xmult_mod = 0.5}},\n        loc_vars = function(self, info_queue, card)\n            return {vars = {card.ability.extra.Xmult_mod, 1 + (G.vouchers and #G.vouchers.cards or 0) * card.ability.extra.Xmult_mod}}\n        end,\n        calculate = function(self, card, context)\n            if context.joker_main then\n                local xmlt = 1 + (#G.vouchers.cards or 0) * card.ability.extra.Xmult_mod\n                if xmlt > 1 then\n                    return {\n                        message = localize{type='variable',key='a_xmult',vars={xmlt}},\n                        Xmult_mod = xmlt,\n                    }\n                end\n            end\n        end,\n        in_pool = function()\n            return false\n        end,\n        no_collection = true,\n        atlas = \"sdm_vouchers\"",
      "config": {
        "extra": {
          "Xmult_mod": 0.5
        }
      },
      "ability": {
        "extra": {
          "Xmult_mod": 0.5
        }
      },
      "vars": [
        0.5,
        0.5
      ],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "sdm_sleeves",
      "atlas": null,
      "pos": null,
      "raw": "key = \"sdm_sleeves\",\n    path = \"sdm_sleeves.png\",\n    px = 73,\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "mishmash",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"mishmash\",\n    name = \"Mishmash\",\n    rarity = \"evo\",\n    blueprint_compat = true,\n    pos = {x = 0, y = 0},\n    cost = 10,\n    config = {extra = {chips = 30, mult = 4, Xmult = 1.5, dollars = 3}},\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue + 1] = G.P_CENTERS.m_bonus\n        info_queue[#info_queue + 1] = G.P_CENTERS.m_mult\n        info_queue[#info_queue + 1] = G.P_CENTERS.m_gold\n        info_queue[#info_queue + 1] = G.P_CENTERS.m_steel\n        return {vars = {card.ability.extra.mult, card.ability.extra.chips, card.ability.extra.Xmult, card.ability.extra.dollars}}\n    end,\n    calculate = function(self, card, context)\n        if not context.end_of_round and context.individual and context.cardarea == G.play then\n            if context.other_card.ability.effect == \"Bonus Card\" then\n                return {\n                    mult = card.ability.extra.mult,\n                    card = card\n                }\n            elseif context.other_card.ability.effect == \"Mult Card\" then\n                return {\n                    chips = card.ability.extra.chips,\n                    card = card\n                }\n            end\n        end\n        if context.cardarea == G.hand and context.individual then\n            if not context.end_of_round and context.other_card.ability.effect == \"Gold Card\" then\n                return {\n                    x_mult = card.ability.extra.Xmult,\n                    colour = G.C.RED,\n                    card = card\n                }\n            elseif context.end_of_round and context.other_card.ability.effect == \"Steel Card\" then\n                G.GAME.dollar_buffer = (G.GAME.dollar_buffer or 0) + card.ability.extra.dollars\n                G.E_MANAGER:add_event(Event({func = (function()\n                    G.GAME.dollar_buffer = 0;\n                    return true\n                end)}))\n                return {\n                    dollars = card.ability.extra.dollars,\n                    card = card\n                }\n            end\n        end\n    end,\n    calculate_evo = function(self, card, context)\n        if context.joker_main and context.scoring_hand then\n            for i = 1, #context.scoring_hand do\n                local _card = context.scoring_hand[i]\n                if not _card.debuff and _card.ability.effect == \"Bonus Card\" or _card.ability.effect == \"Mult Card\" then\n                    card:increment_evo_condition()\n                end\n            end\n        end\n    end,\n    atlas = \"sdm_jokers\"",
      "config": {
        "extra": {
          "chips": 30,
          "mult": 4,
          "Xmult": 1.5,
          "dollars": 3
        }
      },
      "ability": {
        "extra": {
          "chips": 30,
          "mult": 4,
          "Xmult": 1.5,
          "dollars": 3
        }
      },
      "vars": [
        4,
        30,
        1.5,
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "ceo_joker",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"ceo_joker\",\n    name = \"CEO Joker\",\n    rarity = \"evo\",\n    pos = {x = 0, y = 0},\n    cost = 10,\n    config = {extra = {min = 5, max = 10}},\n    loc_vars = function(self, info_queue, card)\n        return {vars = {card.ability.extra.min, card.ability.extra.max}}\n    end,\n    calc_dollar_bonus = function(self, card)\n        local rand_dollar = pseudorandom(pseudoseed('ceo'), card.ability.extra.min, card.ability.extra.max)\n        return rand_dollar\n    end,\n    calculate_evo = function(self, card, context)\n        if context.selling_card then\n            if context.card.ability.set == 'Joker' then\n                local rarity = context.card.config.center.rarity\n                if rarity == 1 then card:increment_evo_condition() end\n            end\n        end\n    end,\n    atlas = \"sdm_jokers\"",
      "config": {
        "extra": {
          "min": 5,
          "max": 10
        }
      },
      "ability": {
        "extra": {
          "min": 5,
          "max": 10
        }
      },
      "vars": [
        5,
        10
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "maglev_train",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"maglev_train\",\n    name = \"Maglev Train\",\n    rarity = \"evo\",\n    pos = {x = 0, y = 0},\n    cost = 12,\n    config = {extra = 30},\n    loc_vars = function(self, info_queue, card)\n        return {vars = {card.ability.extra}}\n    end,\n    calculate = function(self, card, context)\n        if context.joker_main and G.GAME.current_round.hands_played == 0 and G.GAME.current_round.discards_used == 0 then\n            return {\n                message = localize{type = 'variable', key = 'a_mult', vars = {card.ability.extra}},\n                mult_mod = card.ability.extra\n            }\n        end\n    end,\n    calculate_evo = function(self, card, context)\n        if context.end_of_round and context.main_eval then\n            if G.GAME.current_round.hands_played == 1 then\n                card:increment_evo_condition()\n            end\n        end\n    end,\n    atlas = \"sdm_jokers\"",
      "config": {
        "extra": 30
      },
      "ability": {
        "extra": 30
      },
      "vars": [
        30
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "joker_voucher_voucher",
      "atlas": "sdm_jokers",
      "pos": {
        "x": 2,
        "y": 5
      },
      "raw": "key = \"joker_voucher_voucher\",\n    name = \"Joker Voucher Voucher\",\n    rarity = \"evo\",\n    pos = {x = 2, y = 5},\n    cost = 16,\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue+1] = G.P_CENTERS.v_sdm_joker_voucher\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        G.E_MANAGER:add_event(Event({func = (function()\n            G.CONTROLLER.locks.use = true\n            G.jokers:remove_card(card)\n            card:remove()\n            card = nil\n            local _card = create_card(\"Voucher\", nil, nil, nil, nil, nil, \"v_sdm_joker_voucher\")\n            G.play:emplace(_card)\n            _card.cost = 0\n            delay(0.1)\n            _card:redeem()\n            G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.2,func = function()\n                _card:start_dissolve()\n                G.CONTROLLER.locks.use = false\n                return true\n            end}))\n            return true end\n        )}))\n    end,\n    add_to_deck_evo = function(self, card, context)\n        card:set_evo_condition(((G.vouchers and #G.vouchers.cards) or 0))\n    end,\n    calculate_evo = function(self, card, context)\n        if context.buying_card then\n            if context.card and context.card.ability.set == 'Voucher' then\n                card:increment_evo_condition()\n            end\n        end\n    end,\n    atlas = \"sdm_jokers\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "sdm_partners",
      "atlas": null,
      "pos": null,
      "raw": "key = \"sdm_partners\",\n    path = \"sdm_partners.png\",\n    px = 46,\n    py = 58,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "modicon",
      "atlas": null,
      "pos": null,
      "raw": "key = \"modicon\",\n    path = \"sdm_modicon.png\",\n    px = 34,\n    py = 34,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    }
  ],
  "version": "1.7.3"
}