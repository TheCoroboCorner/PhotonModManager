{
  "locMap": {
    "b_soe_seal": {
      "name": "Seal Deck",
      "text": [
        "All cards in shop",
        "have seals"
      ],
      "type": "Back"
    },
    "b_cry_sl_deck": {
      "name": "Seal Deck",
      "text": [
        "All cards have a {C:dark_edition}#1#{}",
        "Cards cannot change seals",
        "{C:inactive}(Click to edit)"
      ],
      "type": "Back"
    },
    "bl_soe_theseal": {
      "name": "The Seal",
      "text": [
        "All cards are face down",
        "Seals show on the back of cards during this round"
      ],
      "type": "Blind"
    },
    "j_soe_stonecardjoker": {
      "name": "Stone Card Joker",
      "text": [
        "{C:chips}+#1#{} Chips"
      ],
      "type": "Joker"
    },
    "j_soe_sealjoker": {
      "name": "Seal",
      "text": [
        "Cards can have {s:3,C:soe_infinity}infinite{}",
        "seals"
      ],
      "type": "Joker"
    },
    "j_soe_sealjoker2": {
      "name": "Seal 2",
      "text": [
        "Cards can have {X:soe_infinity,C:white}Unlimited{} amounts",
        "of all {C:attention}properties{}",
        "{C:inactive}(Expect more than average lag!){}"
      ],
      "type": "Joker"
    },
    "j_soe_infinityred": {
      "name": "Infinity Red",
      "text": [
        "Every time a card triggers",
        "put a {C:red}Red Seal{} on it"
      ],
      "type": "Joker"
    },
    "j_soe_infinitypurple": {
      "name": "Infinity Purple",
      "text": [
        "Seals are {C:attention}forcetriggered{}",
        "when the card it's on is scored"
      ],
      "type": "Joker"
    },
    "j_soe_infinitygold": {
      "name": "Infinity Gold",
      "text": [
        "Cards played and held in hand along with jokers",
        "give {X:money,C:white}#1#*n{} when scored,",
        "where {C:attention}n{} is the amount of seals that card has"
      ],
      "type": "Joker"
    },
    "j_soe_infinityblue": {
      "name": "Infinity Blue",
      "text": [
        "{C:green}#1# in #2#{} chance for",
        "each scored card to be copied",
        "as a {C:dark_edition}Negative{} Joker"
      ],
      "type": "Joker"
    },
    "j_soe_extralife": {
      "name": "Extra Life",
      "text": [
        "Prevents a game over {C:attention}#1#{} times"
      ],
      "type": "Joker"
    },
    "j_soe_unorganizedjoker": {
      "name": "Unorganized Joker",
      "text": [
        "If a card has a property that was not meant for that card,",
        "it gives {X:mult,C:white}X#1#{} Mult"
      ],
      "type": "Joker"
    },
    "j_soe_seeder": {
      "name": "Seeder",
      "text": [
        "Change the current runs {C:attention}seed{}",
        "once per ante",
        "{C:inactive}(#1#){}"
      ],
      "type": "Joker"
    },
    "j_soe_v_blankjoker": {
      "name": "Blank Joker",
      "text": [
        "In {C:attention}#1#{} rounds, turn into",
        "{C:dark_edition}Antimatter Joker{}"
      ],
      "type": "Joker"
    },
    "j_soe_v_antimatterjoker": {
      "name": "Antimatter Joker",
      "text": [
        "{C:attention}ALL{} {C:dark_edition}Negative{} cards",
        "give {X:mult,C:white}X#1#{} Mult",
        "and {C:dark_edition}Negative{} is {X:dark_edition,C:white}#2#X{} as often to appear"
      ],
      "type": "Joker"
    },
    "j_soe_c_talismanjoker": {
      "name": "Talisman Joker",
      "text": [
        "Gives a random scoring card",
        "A {C:attention}Gold Seal{}",
        "{C:inactive}(if possible){}"
      ],
      "type": "Joker"
    },
    "j_soe_thinkingemoji": {
      "name": "Thinking Emoji",
      "text": [
        "Gains {X:dark_edition,C:white}^#1#{} Mult",
        "for every idea that I get",
        "Every non-playing card that mentions seals gives {X:dark_edition,C:white}^#3#{} Mult",
        "{C:inactive}(Currently {}{X:dark_edition,C:white}^#2#{} {C:inactive}Mult){}"
      ],
      "type": "Joker"
    },
    "j_soe_reversesplash": {
      "name": "Drought",
      "text": [
        "{C:attention}Played cards{} don't",
        "count in scoring"
      ],
      "type": "Joker"
    },
    "j_soe_ascendedjoker": {
      "name": "Every Joker",
      "text": [
        "All at the same time"
      ],
      "type": "Joker"
    },
    "j_soe_someinone": {
      "name": "Some Jokers",
      "text": [
        "Click this joker to choose a joker to replicate permanently!",
        "{C:inactive}(Expect crashes!){}"
      ],
      "type": "Joker"
    },
    "j_soe_allinone": {
      "name": "Almost LITERALLY EVERY Joker",
      "text": [
        "ALL at the same time"
      ],
      "type": "Joker"
    },
    "j_joker_u": {
      "name": "Joker",
      "text": [
        "{C:chips,s:1.1}+#2#{} Chips",
        "{C:red,s:1.1}+#1#{} Mult",
        "{X:red,s:1.1,C:white}X#3#{} Mult"
      ],
      "type": "Joker"
    },
    "j_soe_raspberryprint": {
      "name": "Raspberryprint",
      "text": [
        "Copies the ability of a random {C:attention}Joker{}",
        "{C:inactive}(Any Joker that exists is valid){}",
        "{C:inactive}(Resets every round and cannot copy itself){}",
        "{C:inactive}(Currently copying: #1#){}"
      ],
      "type": "Joker"
    },
    "j_soe_purpureusprint": {
      "name": "Purpureusprint",
      "text": [
        "Copies the ability of a random {C:tarot}Tarot{}/{C:planet}Planet{}",
        "{C:inactive}(Any Tarot/Planet that exists is valid){}",
        "{C:inactive}(Resets every round){}",
        "{C:inactive}(Currently copying: #1#){}"
      ],
      "type": "Joker"
    },
    "j_soe_amazonprint": {
      "name": "Amazonprint",
      "text": [
        "Copies the ability of a random {C:attention}Voucher{}",
        "{C:inactive}(Any Voucher that exists is valid){}",
        "{C:inactive}(Resets every round){}",
        "{C:inactive}(Currently copying: #1#){}"
      ],
      "type": "Joker"
    },
    "j_soe_newinfinifusion": {
      "name": "{C:dark_edition}NEW{} InfiniFusion",
      "text": [
        "A {C:dark_edition}NEW{} fusion of",
        "{C:attention}multiple{} Jokers"
      ],
      "type": "Joker"
    },
    "soe_sealseal_seal": {
      "name": "Seal Seal",
      "text": [
        "If this card has a second seal,",
        "Spread it to adjacent cards before scoring",
        "Otherwise, {C:mult}+#1#{} Mult"
      ],
      "type": "Other"
    },
    "soe_rainbowseal_seal": {
      "name": "Rainbow Seal",
      "text": [
        "This card counts as {C:dark_edition}Foil{}, {C:dark_edition}Holographic{},",
        "and {C:dark_edition}Polychrome{}"
      ],
      "type": "Other"
    },
    "soe_reverseseal_seal": {
      "name": "Reverse Seal",
      "text": [
        "If this card is facing {C:attention}down{},",
        "{X:mult,C:white}X#1#{} Mult"
      ],
      "type": "Other"
    },
    "soe_negativeseal_seal": {
      "name": "Negative Seal",
      "text": [
        "This card {C:attention}ignores{} the selection limit,"
      ],
      "type": "Other"
    },
    "soe_carmineseal_seal": {
      "name": "Carmine Seal",
      "text": [
        "If this card is played and not scored,",
        "destroy this card"
      ],
      "type": "Other"
    },
    "soe_aquaseal_seal": {
      "name": "Aqua Seal",
      "text": [
        "If this card is played and not scored,",
        "destroy this card"
      ],
      "type": "Other"
    },
    "soe_yellowseal_seal": {
      "name": "Yellow Seal",
      "text": [
        "This card is returned to hand",
        "after scoring"
      ],
      "type": "Other"
    },
    "soe_foilseal_seal": {
      "name": "Foil Seal",
      "text": [
        "{C:dark_edition}Editions{} on this card",
        "happen when {C:attention}triggered{} instead"
      ],
      "type": "Other"
    },
    "soe_holoseal_seal": {
      "name": "Holographic Seal",
      "text": [
        "This card will {C:attention}retrigger{}",
        "until a {C:green}probability{} hits"
      ],
      "type": "Other"
    },
    "soe_rustyseal_seal": {
      "name": "Rusty Seal",
      "text": [
        "{X:mult,C:white}X#1#{} Mult",
        "when this card is {C:attention}retriggered{}"
      ],
      "type": "Other"
    },
    "red_seal_joker": {
      "name": "Red Seal",
      "text": [
        "Retrigger this",
        "Joker {C:attention}1{} time"
      ],
      "type": "Other"
    },
    "purple_seal": {
      "name": "Purple Seal",
      "text": [
        "Creates a {C:tarot}Tarot{} card",
        "when {C:attention}discarded",
        "{C:inactive}(Must have room)"
      ],
      "type": "Other"
    },
    "purple_seal_joker": {
      "name": "Purple Seal",
      "text": [
        "Creates a {C:tarot}Tarot{} card",
        "when {C:attention}sold",
        "{C:inactive}(Must have room)"
      ],
      "type": "Other"
    },
    "gold_seal": {
      "name": "Gold Seal",
      "text": [
        "Earn {C:money}$3{} when this",
        "card is played",
        "and scores"
      ],
      "type": "Other"
    },
    "gold_seal_joker": {
      "name": "Gold Seal",
      "text": [
        "Earn {C:money}$3{} when this",
        "Joker triggers"
      ],
      "type": "Other"
    },
    "blue_seal_joker": {
      "name": "Blue Seal",
      "text": [
        "Creates the {C:planet}Planet{} card",
        "for final played {C:attention}poker hand{}",
        "of round",
        "{C:inactive}(Must have room)"
      ],
      "type": "Other"
    },
    "cry_green_seal_joker": {
      "name": "Green Seal",
      "text": [
        "Creates a {C:cry_code}Code{} card",
        "when this Joker does not score",
        "{C:inactive}(Must have room)"
      ],
      "type": "Other"
    },
    "cry_azure_seal_joker": {
      "name": "Azure Seal",
      "text": [
        "Create {C:attention}3{} {C:dark_edition}Negative{}",
        "{C:planet}Planets{} for played",
        "{C:attention}poker hand{}, then",
        "{C:red}destroy{} this Joker"
      ],
      "type": "Other"
    },
    "legallygold": {
      "name": "Gold Card",
      "text": [
        "{C:money}$#1#{} at",
        "end of round"
      ],
      "type": "Other"
    },
    "legallysleevePlasma": {
      "name": "Plasma Sleeve",
      "text": [],
      "type": "Other"
    },
    "sealevolve": {
      "name": "Seal Evolve",
      "text": [
        "If all Cards in deck have an enhancement, edition",
        "and 2 or more seals, evolve into {X:soe_infinity,C:white}Seal{} {X:soe_infinity,C:white}2{}"
      ],
      "type": "Other"
    },
    "p_soe_synonym_normal": {
      "name": "Synonym Pack",
      "text": [
        "Choose {C:attention}#1#{} of up to",
        "{C:attention}#2# {X:soe_synonym_gradient,C:white}Synonym{} cards to",
        "be used immediately"
      ],
      "type": "Other"
    },
    "c_soe_demjoker": {
      "name": "Dem Joker",
      "text": [
        "{S:0.8}({S:0.8,V:1}lvl.#2#{S:0.8}){} Level up",
        "{C:attention}#1#",
        "{C:mult}+#3#{} Mult and",
        "{C:chips}+#4#{} chips"
      ],
      "type": "Planet"
    },
    "c_soe_dejavuq": {
      "name": "Deja Vu?",
      "text": [
        "Add a {C:red}Red Seal{}",
        "to a random joker"
      ],
      "type": "Spectral"
    },
    "c_soe_tranceq": {
      "name": "Trance?",
      "text": [
        "Add a {C:blue}Blue Seal{}",
        "to a random joker"
      ],
      "type": "Spectral"
    },
    "c_soe_talismanq": {
      "name": "Talisman?",
      "text": [
        "Add a {C:gold}Gold Seal{}",
        "to a random joker"
      ],
      "type": "Spectral"
    },
    "c_soe_mediumq": {
      "name": "Medium?",
      "text": [
        "Add a {C:purple}Purple Seal{}",
        "to a random joker"
      ],
      "type": "Spectral"
    },
    "c_soe_typhoonq": {
      "name": "Typhoon?",
      "text": [
        "Add a {C:cry_azure}Azure Seal{}",
        "to a random joker"
      ],
      "type": "Spectral"
    },
    "c_soe_sourceq": {
      "name": "Source?",
      "text": [
        "Add a {C:cry_code}Green Seal{}",
        "to a random joker"
      ],
      "type": "Spectral"
    },
    "c_soe_eternalq": {
      "name": "Eternal?",
      "text": [
        "Add {C:attention}Eternal{}",
        "to a random card in hand"
      ],
      "type": "Spectral"
    },
    "c_soe_dejavuqq": {
      "name": "Deja Vu??",
      "text": [
        "Add a {C:red}Red Seal{}",
        "to a random consumable"
      ],
      "type": "Spectral"
    },
    "c_soe_dejavuqqq": {
      "name": "DEJA VU???",
      "text": [
        "Add a {C:red}Red Seal{}",
        "to the blind"
      ],
      "type": "Spectral"
    },
    "c_soe_allinone": {
      "name": "ALL IN ONE???",
      "text": [
        "UNBELIEVEABLE"
      ],
      "type": "Spectral"
    },
    "c_soe_devilq": {
      "name": "Devil?",
      "text": [
        "Add the {C:attention}Gold{} Enhancement",
        "to a random joker"
      ],
      "type": "Tarot"
    },
    "c_soe_towerq": {
      "name": "Tower?",
      "text": [
        "Add the {C:attention}Stone{} Enhancement",
        "to a random joker"
      ],
      "type": "Tarot"
    },
    "c_soe_chariotq": {
      "name": "Chariot?",
      "text": [
        "Add the {C:attention}Steel{} Enhancement",
        "to a random joker"
      ],
      "type": "Tarot"
    },
    "c_soe_empressq": {
      "name": "Empress?",
      "text": [
        "Add the {C:attention}Mult{} Enhancement",
        "to a random joker"
      ],
      "type": "Tarot"
    },
    "c_soe_hierophantq": {
      "name": "Hierophant?",
      "text": [
        "Add the {C:attention}Bonus{} Enhancement",
        "to a random joker"
      ],
      "type": "Tarot"
    },
    "c_soe_magicianq": {
      "name": "Magician?",
      "text": [
        "Add the {C:attention}Lucky{} Enhancement",
        "to a random joker"
      ],
      "type": "Tarot"
    },
    "c_soe_justiceq": {
      "name": "Justice?",
      "text": [
        "Add the {C:attention}Glass{} Enhancement",
        "to a random joker"
      ],
      "type": "Tarot"
    },
    "v_soe_blueprint": {
      "name": "Blueprint",
      "text": [
        "Copies ability of",
        "another {C:attention}Voucher{}",
        "{C:inactive}(Currently copying: #1#){}"
      ],
      "type": "Voucher"
    },
    "v_soe_brainstorm": {
      "name": "Brainstorm",
      "text": [
        "Copies the ability",
        "of another {C:attention}Voucher{}",
        "{C:inactive}(Currently copying: #1#){}"
      ],
      "type": "Voucher"
    },
    "v_soe_orbitalconnoisseur": {
      "name": "Orbital Connoisseur",
      "text": [
        "{C:attention}Joker Hands{} are now available and",
        "{C:soe_orbital}Orbital{} cards can now appear in the shop"
      ],
      "type": "Voucher"
    },
    "v_soe_rerolloverflow": {
      "name": "Reroll Overflow",
      "text": [
        "{C:green}Rerolls{} are",
        "{C:attention}#1#%{} off"
      ],
      "type": "Voucher"
    },
    "v_soe_legerdemain": {
      "name": "Legerdemain",
      "text": [
        "All cards can appear",
        "with an {C:dark_edition}Edition{}"
      ],
      "type": "Voucher"
    },
    "v_soe_phantasm": {
      "name": "Phantasm",
      "text": [
        "All cards can appear",
        "with an {C:attention}Enhancement{}"
      ],
      "type": "Voucher"
    },
    "v_soe_deception": {
      "name": "Deception",
      "text": [
        "All cards can appear",
        "with a {C:attention}Seal{}",
        "All cards are guaranteed to appear with either an",
        "{C:dark_edition}Edition{}, {C:attention}Enhancement{} or {C:attention}Seal{}"
      ],
      "type": "Voucher"
    },
    "sleeve_soe_seal": {
      "name": "Seal Sleeve",
      "text": [
        "All cards in shop",
        "have seals"
      ],
      "type": "Sleeve"
    },
    "sleeve_soe_seal_extra": {
      "name": "Seal Sleeve",
      "text": [
        "Cards can have {C:attention}2{} Seals"
      ],
      "type": "Sleeve"
    },
    "sleeve_soe_redseal": {
      "name": "Red Seal",
      "text": [
        "Effects of this deck",
        "happen twice",
        "{C:inactive}(#1#){}"
      ],
      "type": "Sleeve"
    },
    "sleeve_soe_goldseal": {
      "name": "Gold Seal",
      "text": [
        "First scoring card",
        "each hand gives {C:money}$3{}"
      ],
      "type": "Sleeve"
    },
    "BakeryCharm_soe_sealcharm": {
      "name": "Seal Charm",
      "text": [
        "Seal effects are doubled"
      ],
      "type": "BakeryCharm"
    },
    "sp_soe_egg_upgrade1": {
      "name": "Egg",
      "text": [
        "Egg upgrades by {C:money}$5{}",
        "{C:inactive}(#1#/1)"
      ],
      "type": "SkillPerks"
    },
    "sp_soe_egg_upgrade1_name": {
      "name": "Egg",
      "text": [
        "Egg"
      ],
      "type": "SkillPerks"
    },
    "sp_soe_egg_upgrade2": {
      "name": "Egg",
      "text": [
        "Egg upgrades by {C:money}$8{}",
        "{C:inactive}(#1#/1)"
      ],
      "type": "SkillPerks"
    },
    "sp_soe_egg_upgrade2_name": {
      "name": "Egg",
      "text": [
        "Egg"
      ],
      "type": "SkillPerks"
    },
    "sp_soe_egg_upgrade3": {
      "name": "Egg",
      "text": [
        "{C:green}1 in 4{} chance to give sell value",
        "at end of round",
        "{C:inactive}(#1#/1)"
      ],
      "type": "SkillPerks"
    },
    "sp_soe_egg_upgrade3_name": {
      "name": "Egg",
      "text": [
        "Egg"
      ],
      "type": "SkillPerks"
    },
    "sp_soe_egg_upgrade4": {
      "name": "Egg",
      "text": [
        "Egg upgrades by {C:money}$15{}",
        "{C:inactive}(#1#/1)"
      ],
      "type": "SkillPerks"
    },
    "sp_soe_egg_upgrade4_name": {
      "name": "Egg",
      "text": [
        "Egg"
      ],
      "type": "SkillPerks"
    },
    "sp_soe_egg_upgrade5": {
      "name": "Egg",
      "text": [
        "Egg upgrade 3's chance is improved to {C:green}1 in 2{}",
        "Guaranteed if blind is a boss blind",
        "{C:inactive}(#1#/1)"
      ],
      "type": "SkillPerks"
    },
    "sp_soe_egg_upgrade5_name": {
      "name": "Egg",
      "text": [
        "Egg"
      ],
      "type": "SkillPerks"
    },
    "c_soe_idiot": {
      "name": "The Idiot",
      "text": [
        "Creates the last",
        "{C:attention}Joker{} card",
        "sold during this run"
      ],
      "type": "soe_Vice"
    },
    "c_soe_governor": {
      "name": "The Governor",
      "text": [
        "Creates a {X:soe_synonym_gradient,C:white}Synonym{} card",
        "and its original",
        "{C:inactive}(Must have room)"
      ],
      "type": "soe_Vice"
    },
    "c_soe_energy": {
      "name": "Energy",
      "text": [
        "Increases all values of",
        "up to {C:attention}#1#{} selected",
        "#3# by {C:attention}#2#{}",
        "{C:inactive}(May cause issues){}"
      ],
      "type": "soe_Vice"
    },
    "c_soe_gallowsbird": {
      "name": "The Gallows Bird",
      "text": [
        "Destroys up to",
        "{C:attention}#1#{} selected Jokers",
        "{C:inactive}(Bypasses{} {X:dark_edition,C:soe_synonym_gradient}LITERALLY{} {X:dark_edition,C:soe_synonym_gradient}EVERYTHING{}{C:inactive}){}"
      ],
      "type": "soe_Vice"
    },
    "c_soe_murder": {
      "name": "Murder",
      "text": [
        "Select {C:attention}#1#{} Jokers,",
        "convert the {C:attention}left{} Joker",
        "into the {C:attention}right{} Joker",
        "{C:inactive}(Drag to rearrange)"
      ],
      "type": "soe_Vice"
    },
    "c_soe_degrade": {
      "name": "Degrade",
      "text": [
        "{S:0.8}({S:0.8,V:1}lvl.#2#{S:0.8}){} Level up",
        "{C:attention}#1#{}",
        "{C:mult}+#3#{} Mult and",
        "{C:chips}+#4#{} chip#<s>4#"
      ],
      "type": "soe_Orbital"
    },
    "c_soe_sacrifice": {
      "name": "Sacrifice",
      "text": [
        "Destroys {C:attention}#1#{} random",
        "Jokers,",
        "gain {C:money}$#2#"
      ],
      "type": "soe_Phantom"
    },
    "c_soe_decimal": {
      "name": "Decimal",
      "text": [
        "Add {C:dark_edition}Polychrome{} to a",
        "random {C:attention}Playing card{} in hand, destroy",
        "all other Playing cards in hand"
      ],
      "type": "soe_Phantom"
    },
    "c_soe_ghost": {
      "name": "Ghost",
      "text": [
        "Create {C:attention}#1#{} copies of",
        "{C:attention}1{} selected Joker"
      ],
      "type": "soe_Phantom"
    },
    "c_soe_psyche": {
      "name": "Psyche",
      "text": [
        "Creates an",
        "{X:soe_seal_gradient,C:white}Infinity{} Joker",
        "{C:inactive}(Must have room){}"
      ],
      "type": "soe_Phantom"
    },
    "c_soe_dejajed": {
      "name": "Dej{f:soe_11x6m}ajeD",
      "text": [
        "{C:attention}Detach{} a seal",
        "from any {C:attention}1{} selected",
        "card"
      ],
      "type": "soe_Phantom"
    },
    "Red": {
      "name": "Red Seal",
      "text": [
        "{C:attention}Retriggers{} the closest",
        "card or joker or consumable {C:attention}#1#{} time(s)"
      ],
      "type": "soe_DetachedSeal"
    },
    "Blue": {
      "name": "Blue Seal",
      "text": [
        "Creates the {C:planet}Planet{} card",
        "for final played {C:attention}poker hand{}",
        "of round"
      ],
      "type": "soe_DetachedSeal"
    },
    "Gold": {
      "name": "Gold Seal",
      "text": [
        "Gives {C:money}$#1#{}",
        "before scoring"
      ],
      "type": "soe_DetachedSeal"
    },
    "Purple": {
      "name": "Purple Seal",
      "text": [
        "Creates a {C:tarot}Tarot{} card",
        "when {C:attention}discarding{}",
        "{C:inactive}(Must have room)"
      ],
      "type": "soe_DetachedSeal"
    },
    "ach_soe_completionist_plus_plus_plus": {
      "name": "\"Earn a Gold Sticker on every Playing Card\"",
      "text": [],
      "type": "achievement_descriptions"
    },
    "k_soe_infinity": {
      "name": "\"Infinity\"",
      "text": [],
      "type": "dictionary"
    },
    "k_following_joker_hands": {
      "name": "\"Contributes to the following Joker Hands:\"",
      "text": [],
      "type": "dictionary"
    },
    "k_joker_hands": {
      "name": "\"Joker Hands\"",
      "text": [],
      "type": "dictionary"
    },
    "b_soe_orbital_cards": {
      "name": "\"Orbital Cards\"",
      "text": [],
      "type": "dictionary"
    },
    "k_soe_orbital": {
      "name": "\"Orbital\"",
      "text": [],
      "type": "dictionary"
    },
    "b_soe_phantom_cards": {
      "name": "\"Phantom Cards\"",
      "text": [],
      "type": "dictionary"
    },
    "k_soe_phantom": {
      "name": "\"Phantom\"",
      "text": [],
      "type": "dictionary"
    },
    "b_soe_vice_cards": {
      "name": "\"Vice Cards\"",
      "text": [],
      "type": "dictionary"
    },
    "k_soe_vice": {
      "name": "\"Vice\"",
      "text": [],
      "type": "dictionary"
    },
    "k_synonym_pack": {
      "name": "\"Synonym Pack\"",
      "text": [],
      "type": "dictionary"
    },
    "k_life_used": {
      "name": "\"Life Used!\"",
      "text": [],
      "type": "dictionary"
    },
    "soe_skill_tree_jokerupgrades": {
      "name": "\"Joker Upgrades\"",
      "text": [],
      "type": "dictionary"
    },
    "soe_joker_central": {
      "name": "\"Joker Central\"",
      "text": [],
      "type": "poker_hands"
    },
    "soe_nil": {
      "name": "\"nil\"",
      "text": [],
      "type": "poker_hands"
    },
    "soe_seal_flush": {
      "name": "\"Seal Flush\"",
      "text": [],
      "type": "poker_hands"
    },
    "soe_simple_jimbo": {
      "name": "\"A Simple Jimbo\"",
      "text": [],
      "type": "soe_joker_hands"
    },
    "soe_best_brothers": {
      "name": "\"Best Brothers\"",
      "text": [],
      "type": "soe_joker_hands"
    }
  },
  "atlases": {
    "What": {
      "path": "What.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/SealsOnJokers@Somethingcom515/3.0.0/What.png",
      "resolvedGitHubPath": "assets/1x/What.png"
    },
    "Confusion": {
      "path": "Confusion.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/SealsOnJokers@Somethingcom515/3.0.0/Confusion.png",
      "resolvedGitHubPath": "assets/1x/Confusion.png"
    },
    "Enhancers": {
      "path": "Enhancers.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/SealsOnJokers@Somethingcom515/3.0.0/Enhancers.png",
      "resolvedGitHubPath": "assets/1x/Enhancers.png"
    },
    "PlayingCards": {
      "path": "PlayingCards.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/SealsOnJokers@Somethingcom515/3.0.0/PlayingCards.png",
      "resolvedGitHubPath": "assets/1x/PlayingCards.png"
    },
    "BlueprintVouchers": {
      "path": "BlueprintVouchers.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/SealsOnJokers@Somethingcom515/3.0.0/BlueprintVouchers.png",
      "resolvedGitHubPath": "assets/1x/BlueprintVouchers.png"
    },
    "JokerEnhancements": {
      "path": "JokerEnhancements.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/SealsOnJokers@Somethingcom515/3.0.0/JokerEnhancements.png",
      "resolvedGitHubPath": "assets/1x/JokerEnhancements.png"
    },
    "JokerFronts": {
      "path": "JokerFronts.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/SealsOnJokers@Somethingcom515/3.0.0/JokerFronts.png",
      "resolvedGitHubPath": "assets/1x/JokerFronts.png"
    },
    "ExtraLife": {
      "path": "ExtraLife.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/SealsOnJokers@Somethingcom515/3.0.0/ExtraLife.png",
      "resolvedGitHubPath": "assets/1x/ExtraLife.png"
    },
    "Tarots": {
      "path": "Tarots.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/SealsOnJokers@Somethingcom515/3.0.0/Tarots.png",
      "resolvedGitHubPath": "assets/1x/Tarots.png"
    },
    "Synonyms": {
      "path": "Synonyms.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/SealsOnJokers@Somethingcom515/3.0.0/Synonyms.png",
      "resolvedGitHubPath": "assets/1x/Synonyms.png"
    },
    "VoucherSynonyms": {
      "path": "Vouchersynonyms.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/SealsOnJokers@Somethingcom515/3.0.0/Vouchersynonyms.png",
      "resolvedGitHubPath": "assets/1x/Vouchersynonyms.png"
    },
    "Vouchers": {
      "path": "Vouchers.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/SealsOnJokers@Somethingcom515/3.0.0/Vouchers.png",
      "resolvedGitHubPath": "assets/1x/Vouchers.png"
    },
    "Planets": {
      "path": "Planets.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/SealsOnJokers@Somethingcom515/3.0.0/Planets.png",
      "resolvedGitHubPath": "assets/1x/Planets.png"
    },
    "Sleeves": {
      "path": "Sleeves.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/SealsOnJokers@Somethingcom515/3.0.0/Sleeves.png",
      "resolvedGitHubPath": "assets/1x/Sleeves.png"
    },
    "Placeholders": {
      "path": "Placeholders.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/SealsOnJokers@Somethingcom515/3.0.0/Placeholders.png",
      "resolvedGitHubPath": "assets/1x/Placeholders.png"
    },
    "DeckSeals": {
      "path": "DeckSeals.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/SealsOnJokers@Somethingcom515/3.0.0/DeckSeals.png",
      "resolvedGitHubPath": "assets/1x/DeckSeals.png"
    },
    "Seals": {
      "path": "Seals.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/SealsOnJokers@Somethingcom515/3.0.0/Seals.png",
      "resolvedGitHubPath": "assets/1x/Seals.png"
    },
    "RainbowSeal": {
      "path": "rainbowseal.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/SealsOnJokers@Somethingcom515/3.0.0/rainbowseal.png",
      "resolvedGitHubPath": "assets/1x/rainbowseal.png"
    },
    "SealsIndividual": {
      "path": "SealsIndividual.png",
      "px": 27,
      "py": 27,
      "localPath": "/wiki-data/SealsOnJokers@Somethingcom515/3.0.0/SealsIndividual.png",
      "resolvedGitHubPath": "assets/1x/SealsIndividual.png"
    },
    "SecondSeals": {
      "path": "SecondSeals.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/SealsOnJokers@Somethingcom515/3.0.0/SecondSeals.png",
      "resolvedGitHubPath": "assets/1x/SecondSeals.png"
    },
    "Charms": {
      "path": "Charms.png",
      "px": 68,
      "py": 68,
      "localPath": "/wiki-data/SealsOnJokers@Somethingcom515/3.0.0/Charms.png",
      "resolvedGitHubPath": "assets/1x/Charms.png"
    },
    "Boosters": {
      "path": "Boosters.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/SealsOnJokers@Somethingcom515/3.0.0/Boosters.png",
      "resolvedGitHubPath": "assets/1x/Boosters.png"
    },
    "Exotics": {
      "path": "Exotics.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/SealsOnJokers@Somethingcom515/3.0.0/Exotics.png",
      "resolvedGitHubPath": "assets/1x/Exotics.png"
    },
    "Think": {
      "path": "Think.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/SealsOnJokers@Somethingcom515/3.0.0/Think.png",
      "resolvedGitHubPath": "assets/1x/Think.png"
    },
    "InfinitySeals": {
      "path": "InfinitySeals.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/SealsOnJokers@Somethingcom515/3.0.0/InfinitySeals.png",
      "resolvedGitHubPath": "assets/1x/InfinitySeals.png"
    },
    "Stakes": {
      "path": "Stakes.png",
      "px": 29,
      "py": 29,
      "localPath": "/wiki-data/SealsOnJokers@Somethingcom515/3.0.0/Stakes.png",
      "resolvedGitHubPath": "assets/1x/Stakes.png"
    },
    "modicon": {
      "path": "modicon.png",
      "px": 34,
      "py": 34,
      "localPath": "/wiki-data/SealsOnJokers@Somethingcom515/3.0.0/modicon.png",
      "resolvedGitHubPath": "assets/1x/modicon.png"
    },
    "VanillaSleeves": {
      "path": "VanillaSleeves.png",
      "px": 73,
      "py": 96,
      "localPath": "/wiki-data/SealsOnJokers@Somethingcom515/3.0.0/VanillaSleeves.png",
      "resolvedGitHubPath": "assets/1x/VanillaSleeves.png"
    },
    "Prints": {
      "path": "Prints.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/SealsOnJokers@Somethingcom515/3.0.0/Prints.png",
      "resolvedGitHubPath": "assets/1x/Prints.png"
    },
    "Blinds": {
      "path": "Blinds.png",
      "px": 34,
      "py": 34,
      "localPath": "/wiki-data/SealsOnJokers@Somethingcom515/3.0.0/Blinds.png",
      "resolvedGitHubPath": "assets/1x/Blinds.png"
    }
  },
  "cards": [
    {
      "type": "Joker",
      "key": "raspberryprint",
      "name": "RaspberryPrint",
      "atlas": "Prints",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "name = 'RaspberryPrint',\n    key = 'raspberryprint',\n    atlas = 'Prints',\n    pos = {x = 0, y = 0},\n    config = {extra = {}},\n    rarity = 4,\n    cost = 30,\n    unlocked = true,\n    discovered = true,\n    reroll_cost = 10,\n    blueprint_compat = true,\n    eternal_compat = true,\n    perishable_compat = true,\n    demicoloncompat = true,\n    update = function (self, card, dt)\n        card.children.center.atlas = G.ASSET_ATLAS[\"soe_Prints\"]\n        card.children.center:set_sprite_pos({x = 0, y = 0})\n        card.config.center.demicoloncompat = G.P_CENTERS[card.ability.extra.currentjoker] and G.P_CENTERS[card.ability.extra.currentjoker].demicoloncompat or nil\n    end,\n    loc_vars = function (self, info_queue, card)\n        info_queue[#info_queue+1] = G.P_CENTERS[card.ability.extra.currentjoker]\n        return {vars = {SEALS.safe_get(G.localization.descriptions, \"Joker\", card.ability.extra.currentjoker or \"ddfjvgbjbfjvbnfbcmvd\", \"name\") or \"Nothing\"}}\n    end,\n    calculate = function(self, card, context)\n        if context.end_of_round and context.main_eval and context.game_over == false then\n            SMODS.calculate_effect({message = localize('k_reset')}, card)\n            local jokers = {}\n            for k, v in pairs(G.P_CENTER_POOLS.Joker) do\n                if v.key ~= self.key then\n                    table.insert(jokers, v.key)\n                end\n            end\n            card.ability.extra.currentjoker = pseudorandom_element(jokers, pseudoseed(\"raspberry\"))\n        end\n        return SEALS.get_joker_return(card.ability.extra.currentjoker, context, card, not G.P_CENTERS[card.ability.extra.currentjoker].mod)\n    end,\n    add_to_deck = function (self, card, from_debuff)\n        local jokers = {}\n        for k, v in pairs(G.P_CENTER_POOLS.Joker) do\n            if not (v.mod and v.mod.id == \"SealsOnEverything\") then\n                table.insert(jokers, v.key)\n            end\n        end\n        card.ability.extra.currentjoker = pseudorandom_element(jokers, pseudoseed(\"raspberry\"))\n    end",
      "config": {
        "extra": {}
      },
      "ability": {
        "extra": {}
      },
      "vars": [
        null,
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "purpureusprint",
      "name": "PurpureusPrint",
      "atlas": "Prints",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "name = 'PurpureusPrint',\n    key = 'purpureusprint',\n    atlas = 'Prints',\n    pos = {x = 1, y = 0},\n    config = {extra = {}},\n    rarity = 3,\n    cost = 30,\n    unlocked = true,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    perishable_compat = true,\n    demicoloncompat = true,\n    loc_vars = function (self, info_queue, card)\n        info_queue[#info_queue+1] = G.P_CENTERS[card.ability.extra.currentjoker]\n        return {vars = {SEALS.safe_get(G.localization.descriptions, G.P_CENTERS[card.ability.extra.currentjoker] and G.P_CENTERS[card.ability.extra.currentjoker].set or \"ddfjvgbjbfjvbnfbcmvd\", card.ability.extra.currentjoker or \"ddfjvgbjbfjvbnfbcmvd\", \"name\") or \"Nothing\"}}\n    end,\n    calculate = function(self, card, context)\n        if context.end_of_round and context.main_eval and context.game_over == false then\n            SMODS.calculate_effect({message = localize('k_reset')}, card)\n            local jokers = {}\n            for k, v in pairs(G.P_CENTER_POOLS.Tarot_Planet) do\n                    table.insert(jokers, v.key)\n            end\n            card.ability.extra.currentjoker = pseudorandom_element(jokers, pseudoseed(\"purpureus\"))\n        end\n        if context.joker_main or context.forcetrigger then\n            local fake_card = SEALS.create_fake_card(card, card.ability.extra.currentjoker, \"use\", nil, nil, true, true)\n            if cryptidyeohna then\n                return Cryptid.forcetrigger(fake_card, context)\n            else\n                local thunk = G.GAME.probabilities.normal\n                G.GAME.probabilities.normal = 1e9\n                local effect = fake_card:use_consumeable()\n    \t\t\tG.GAME.probabilities.normal = thunk\n                return effect\n            end\n        end\n    end,\n    add_to_deck = function (self, card, from_debuff)\n        local jokers = {}\n        for k, v in pairs(G.P_CENTER_POOLS.Tarot_Planet) do\n            table.insert(jokers, v.key)\n        end\n        card.ability.extra.currentjoker = pseudorandom_element(jokers, pseudoseed(\"purpureus\"))\n    end",
      "config": {
        "extra": {}
      },
      "ability": {
        "extra": {}
      },
      "vars": [
        null,
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "amazonprint",
      "name": "AmazonPrint",
      "atlas": "Prints",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "name = 'AmazonPrint',\n    key = 'amazonprint',\n    atlas = 'Prints',\n    pos = {x = 2, y = 0},\n    config = {extra = {}},\n    rarity = 3,\n    cost = 30,\n    unlocked = true,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    perishable_compat = true,\n    demicoloncompat = true,\n    loc_vars = function (self, info_queue, card)\n        info_queue[#info_queue+1] = G.P_CENTERS[card.ability.extra.currentjoker]\n        return {vars = {SEALS.safe_get(G.localization.descriptions, \"Voucher\", card.ability.extra.currentjoker or \"ddfjvgbjbfjvbnfbcmvd\", \"name\") or \"Nothing\"}}\n    end,\n    calculate = function(self, card, context)\n        if context.end_of_round and context.main_eval and context.game_over == false then\n            SMODS.calculate_effect({message = localize('k_reset')}, card)\n            local jokers = {}\n            for k, v in pairs(G.P_CENTER_POOLS.Voucher) do\n                table.insert(jokers, v.key)\n            end\n            card.ability.extra.currentjoker = pseudorandom_element(jokers, pseudoseed(\"raspberry\"))\n        end\n        return SEALS.get_joker_return(card.ability.extra.currentjoker, context, card, not G.P_CENTERS[card.ability.extra.currentjoker].mod)\n    end,\n    add_to_deck = function (self, card, from_debuff)\n        local jokers = {}\n        for k, v in pairs(G.P_CENTER_POOLS.Joker) do\n            if v.key ~= self.key then\n                table.insert(jokers, v.key)\n            end\n        end\n        card.ability.extra.currentjoker = pseudorandom_element(jokers, pseudoseed(\"raspberry\"))\n    end",
      "config": {
        "extra": {}
      },
      "ability": {
        "extra": {}
      },
      "vars": [
        null,
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "newinfinifusion",
      "name": null,
      "atlas": "JokerEnhancements",
      "pos": {
        "x": 9,
        "y": 9
      },
      "raw": "key = 'newinfinifusion',\n    atlas = 'JokerEnhancements',\n    pos = {x = 9, y = 9},\n    soul_pos = {x = 1000, y = 1000},\n    config = {extra = {currentjokers = {}}},\n    rarity = 4,\n    cost = 1000,\n    no_collection = true,\n    unlocked = true,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    perishable_compat = true,\n    demicoloncompat = true,\n    update = function (self, card, dt)\n        card:set_eternal(true)\n        card.children.center.pinch.x = false\n        if card.children.floating_sprite.atlas ~= G.ASSET_ATLAS[\"soe_Enhancers\"] then\n            card.children.floating_sprite.atlas = G.ASSET_ATLAS[\"soe_Enhancers\"]\n            card.children.floating_sprite:set_sprite_pos({x = 5, y = 3})\n            card.children.center:set_sprite_pos({x = 9, y = 9})\n        end\n        if card.ability.extra.currentjokers then\n            for k, v in pairs(card.ability.extra.currentjokers) do\n                if v.key then v = v.key end\n                local center = G.P_CENTERS[v]\n                SEALS.run_joker_update(v, dt, card, not center.mod)\n            end\n        end\n    end,\n    loc_vars = function (self, info_queue, card)\n        for k, v in pairs(card.ability.extra.currentjokers) do\n            local center = G.P_CENTERS[v]\n            --info_queue[#info_queue+1] = {key = center.key, set = center.set, specific_vars = card.ability.savedvalues[v]}\n            info_queue[#info_queue+1] = center\n        end\n    end,\n    calculate = function(self, card, context)\n        return SEALS.get_some_jokers_returns_combined(context, card, card.ability.extra.currentjokers)\n    end,\n    in_pool = function(self, args)\n        return false\n    end",
      "config": {
        "extra": {
          "currentjokers": {}
        }
      },
      "ability": {
        "extra": {
          "currentjokers": {}
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "allinone",
      "name": "AllInOne",
      "atlas": "Placeholders",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "name = 'AllInOne',\n    key = 'allinone',\n    atlas = 'Placeholders',\n    pos = {x = 0, y = 0},\n    soul_pos = {x = 1000, y = 1000, extra = {x = 1000, y = 1000}},\n    config = {extra = {}},\n    rarity = 4,\n    cost = 1000,\n    unlocked = true,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    perishable_compat = true,\n    demicoloncompat = true,\n    update = function (self, card, dt)\n        --card:set_eternal(true)\n        card.children.center.pinch.x = false\n        ---SEALS.become_all_jokers_theoretically(nil, card, \"update\", dt)\n    end,\n    loc_vars = function (self, info_queue, card)\n        info_queue[#info_queue+1] = card.ability.extra.currentjoker\n    end,\n    calculate = function(self, card, context)\n        card.ability.soe_jokers = SEALS.get_allinone_jokers()\n        --return SEALS.become_all_jokers_theoretically(context, card, \"calculate\")\n    end,\n    --[[\n    remove_from_deck = function (self, card, from_debuff)\n        SEALS.become_all_jokers_theoretically(nil, card, \"remove_from_deck\")\n    end,\n    ]]\n    add_to_deck = function (self, card, from_debuff)\n        card.ability.soe_jokers = SEALS.get_allinone_jokers()\n        --SEALS.become_all_jokers_theoretically(nil, card, \"add_to_deck\")\n    end,\n    in_pool = function(self, args)\n        return false\n    end",
      "config": {
        "extra": {}
      },
      "ability": {
        "extra": {}
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Seal",
      "key": "allinoneseal",
      "name": "AllInOneSeal",
      "atlas": "Seals",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = 'allinoneseal',\n    name = 'AllInOneSeal',\n    badge_colour = G.C.DARK_EDITION,\n    atlas = 'Seals',\n    pos = { x = 0, y = 0 },\n    config = {},\n    loc_txt = {\n        name = \"All In One Seal\",\n        text = {\n            \"All In One Seal\",\n        }\n    },\n    calculate = function (self, card, context)\n        local effects_table = {}\n        for k, v in pairs(G.P_SEALS) do\n            if v.key == \"fam_maroon_seal\" then\n                effects_table[#effects_table+1] = SEALS.get_seal_return(v.key, context, card, not v.mod)\n            end\n        end\n        table.sort(effects_table, function(a, b)\n            local a_sort = sort_returns(a)\n            local b_sort = sort_returns(b)\n            if a_sort == -1 and b_sort == -1 then return b_sort > a_sort end\n            if a_sort == -1 then return true end\n            if b_sort == -1 then return false end\n            return a_sort < b_sort\n        end)\n        return SEALS.recursive_extra_for_non_jokers(effects_table, 1)\n    end,\n    get_p_dollars = function (self, card)\n        local dollars = 0\n        for k, v in pairs(G.P_SEALS) do\n            if v.mod then\n                dollars = dollars + SEALS.get_seal_dollars(v.key, card)\n            end\n        end\n        return dollars\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "allinoneenhancement",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"allinoneenhancement\",\n    weight = 0,\n    in_pool = function(self)\n        return false\n    end,\n    calculate = function(self, card, context)\n        local effects_table = {}\n        for k, v in pairs(G.P_CENTER_POOLS.Enhanced) do\n            if v.mod then\n                local effect = SEALS.get_joker_return(v.key, context, card, not v.mod)\n                if effect and type(effect) == 'table' then\n                    effects_table[#effects_table+1] = effect\n                end\n            end\n        end\n        table.sort(effects_table, function(a, b)\n            local a_sort = sort_returns(a)\n            local b_sort = sort_returns(b)\n            if a_sort == -1 and b_sort == -1 then return b_sort > a_sort end\n            if a_sort == -1 then return true end\n            if b_sort == -1 then return false end\n            return a_sort < b_sort\n        end)\n        return SEALS.recursive_extra(effects_table, 1)\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "someinone",
      "name": "SomeInOne",
      "atlas": "Placeholders",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "name = 'SomeInOne',\n    key = 'someinone',\n    atlas = 'Placeholders',\n    pos = {x = 0, y = 0},\n    soul_pos = {x = 1000, y = 1000, extra = {x = 1000, y = 1000}},\n    config = {extra = {jokerkeys = {}}},\n    rarity = 4,\n    cost = 1000,\n    unlocked = true,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    perishable_compat = true,\n    loc_vars = function (self, info_queue, card)\n        if #card.ability.extra.jokerkeys > 0 then\n            for k, v in pairs(card.ability.extra.jokerkeys) do\n                info_queue[#info_queue+1] = G.P_CENTERS[v]\n            end\n        end\n    end,\n    calculate = function(self, card, context)\n        return SEALS.get_some_jokers_returns_combined(context, card, card.ability.extra.jokerkeys)\n    end",
      "config": {
        "extra": {
          "jokerkeys": {}
        }
      },
      "ability": {
        "extra": {
          "jokerkeys": {}
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "playingcardjokersactivator",
      "name": "Playing Card Joker Activator",
      "atlas": "Placeholders",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = 'playingcardjokersactivator',\n        atlas = 'Placeholders',\n        pos = {x = 0, y = 0},\n        rarity = 1,\n        cost = 5,\n        unlocked = true,\n        unique = true,\n        discovered = true,\n        blueprint_compat = false,\n        eternal_compat = true,\n        perishable_compat = true,\n        config = {extra = {}},\n        loc_txt = {\n            name = 'Playing Card Joker Activator',\n            text = {\n                \"If a scoring card is a Joker,\",\n                \"trigger it\"\n            }\n        },\n        update = function (self, card, dt)\n            card.debuff = nil\n        end,\n        calculate = function (self, card, context)\n            if not context.blueprint and context.scoring_hand and not context.retrigger_joker then\n                local effects_table = {}\n                for k, v in pairs(context.scoring_hand) do\n                    if not v.debuff and v.ability.set == \"Joker\" then\n                        local effect, fake_card = SEALS.get_joker_return(v.config.center.key, context, card, not v.config.center.mod, v)\n                        if cryptidyeohna and context.individual and context.other_card == v and Cryptid.demicolonGetTriggerable(fake_card)[1] then\n                            local results = Cryptid.forcetrigger(fake_card, context)\n                            if results and results.jokers then effects_table[#effects_table+1] = results.jokers end \n                        end\n                        if effect and type(effect) == 'table' then\n                            effect.message_card = effect.message_card or effect.card or context.other_card or v\n                        end\n                        effects_table[#effects_table+1] = effect\n                    end\n                end\n                return SEALS.recursive_extra(effects_table, 1)\n            end\n        end,\n        in_pool = function(self)\n            return false\n        end",
      "config": {
        "extra": {}
      },
      "ability": {
        "extra": {}
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "jokerdeck",
      "name": "JokerDeck",
      "atlas": null,
      "pos": null,
      "raw": "key = 'jokerdeck',\n        name = 'JokerDeck',\n        loc_txt = {\n            name = 'Joker Deck',\n            text = {\n                'Start run with',\n                '{C:attention}52 Jokers{}',\n            }\n        },\n        apply = function(self, back)\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    if not G.playing_cards then return false end\n                    for i=#G.playing_cards, 1, -1 do\n                        G.playing_cards[i].getting_sliced = true\n                        G.playing_cards[i]:remove()\n                    end\n                    for i=1, 52 do\n                        local card = SMODS.add_card({set = 'Joker', no_edition = true, area = G.deck})\n                        card:set_edition(nil, true, true)\n                        table.insert(G.playing_cards, card)\n                    end\n                    local card2 = SMODS.add_card({key = \"j_soe_playingcardjokersactivator\", edition = \"e_negative\"})\n                    SMODS.Stickers[\"akyrs_sigma\"]:apply(card2, true)\n                    return true\n                end\n            }))\n        end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Suits",
      "key": "j_soe_newinfinifusion",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key_pressed = ']',\n    event = 'pressed',\n    action = function(self)\n        if G.jokers and G.jokers.highlighted and #G.jokers.highlighted == 2 then\n            local nonfinifusionjokers, infinifusionjokers = {}, {}\n            for k, v in pairs(G.jokers.highlighted) do\n                if v.config.center.key ~= 'j_soe_newinfinifusion' then\n                    table.insert(nonfinifusionjokers, v)\n                else\n                    table.insert(infinifusionjokers, v)\n                end\n            end\n            if not next(infinifusionjokers) then\n                play_sound('explosion_release1')\n                local card = SMODS.add_card({key = \"j_soe_newinfinifusion\", no_edition = true})\n                card:set_edition(nil, true, true)\n                for k, v in pairs(nonfinifusionjokers) do\n                    table.insert(card.ability.extra.currentjokers, v.config.center.key)\n                    v:remove()\n                end\n            else\n                if #infinifusionjokers == 1 then\n                    play_sound('explosion_release1')\n                    local card = infinifusionjokers[1]\n                    for k, v in pairs(nonfinifusionjokers) do\n                        table.insert(card.ability.extra.currentjokers, v.config.center.key)\n                        v:remove()\n                    end\n                elseif #infinifusionjokers == 2 then\n                    play_sound('explosion_release1')\n                    local card = infinifusionjokers[1]\n                    for k, v in pairs(infinifusionjokers) do\n                        if v ~= card then\n                            for kk, vv in pairs(v.ability.extra.currentjokers) do\n                                table.insert(card.ability.extra.currentjokers, vv)\n                            end\n                            v:remove{}\n                        end\n                    end\n                else\n                    sendInfoMessage(\"Quite the conundrum, wouldn't you say?\", \"SEALS\")\n                end\n            end\n        end\n    end",
      "config": {
        "key": "j_soe_newinfinifusion",
        "no_edition": true
      },
      "ability": {
        "key": "j_soe_newinfinifusion",
        "no_edition": true
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "ConsumableType",
      "key": "soe_Orbital",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"soe_Orbital\",\n    primary_colour = HEX(\"A2334C\"),\n    secondary_colour = HEX(\"A2334C\"),\n    collection_rows = { 6, 6 },\n    default = \"c_soe_degrade\",\n    shop_rate = 0,\n    can_stack = true,\n    can_divide = true,\n    inject_card = function(self, center)\n        SMODS.ObjectType.inject_card(self, center)\n        SMODS.insert_pool(G.P_CENTER_POOLS['soe_Synonyms'], center)\n    end,\n    delete_card = function(self, center)\n        SMODS.ObjectType.delete_card(self, center)\n        SMODS.remove_pool(G.P_CENTER_POOLS['soe_Synonyms'], center.key)\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "degrade",
      "name": null,
      "atlas": "Synonyms",
      "pos": {
        "x": 8,
        "y": 3
      },
      "raw": "key = 'degrade',\n    set = 'soe_Orbital',\n    atlas = 'Synonyms',\n    pos = {x = 8, y = 3},\n    unlocked = true,\n    discovered = true,\n    soe_alternative = 'c_pluto',\n    config = {joker_hand_type = \"soe_simple_jimbo\"},\n\tloc_vars = function(self, info_queue, center)\n\t\treturn {\n\t\t\tvars = {\n\t\t\t\tlocalize(\"soe_simple_jimbo\", \"soe_joker_hands\"),\n                G.GAME.soe_joker_hands[\"soe_simple_jimbo\"].level,\n                G.GAME.soe_joker_hands[\"soe_simple_jimbo\"].l_mult,\n                G.GAME.soe_joker_hands[\"soe_simple_jimbo\"].l_chips,\n\t\t\t\tcolours = {\n\t\t\t\t\t(\n\t\t\t\t\t\tto_big(G.GAME.soe_joker_hands[\"soe_simple_jimbo\"].level) == to_big(1) and G.C.UI.TEXT_DARK\n\t\t\t\t\t\tor G.C.HAND_LEVELS[to_big(math.min(7, G.GAME.soe_joker_hands[\"soe_simple_jimbo\"].level)):to_number()]\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\tend,\n    use = function (self, card, area, copier)\n        SEALS.level_up_joker_hand(card, \"soe_simple_jimbo\")\n    end,\n    can_use = function (self, card)\n        return true\n    end,",
      "config": {
        "joker_hand_type": "soe_simple_jimbo"
      },
      "ability": {
        "joker_hand_type": "soe_simple_jimbo"
      },
      "vars": [
        null,
        null,
        null,
        null,
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "ConsumableType",
      "key": "soe_Phantom",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"soe_Phantom\",\n    primary_colour = HEX(\"882D33\"),\n    secondary_colour = HEX(\"882D33\"),\n    collection_rows = { 6, 6 },\n    can_stack = true,\n    can_divide = true,\n    inject_card = function(self, center)\n        SMODS.ObjectType.inject_card(self, center)\n        SMODS.insert_pool(G.P_CENTER_POOLS['soe_Synonyms'], center)\n    end,\n    delete_card = function(self, center)\n        SMODS.ObjectType.delete_card(self, center)\n        SMODS.remove_pool(G.P_CENTER_POOLS['soe_Synonyms'], center.key)\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "sacrifice",
      "name": null,
      "atlas": "Synonyms",
      "pos": {
        "x": 9,
        "y": 4
      },
      "raw": "key = 'sacrifice',\n    set = 'soe_Phantom',\n    atlas = 'Synonyms',\n    pos = {x = 9, y = 4},\n    unlocked = true,\n    discovered = true,\n    soe_alternative = 'c_immolate',\n    config = { extra = { destroy = 5, dollars = 20 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.destroy, card.ability.extra.dollars } }\n    end,\n    use = function(self, card, area, copier)\n        local destroyed_cards = {}\n        local temp_hand = {}\n\n        for _, ccard in ipairs(G.jokers.cards) do if not ccard.ability.eternal then temp_hand[#temp_hand + 1] = ccard end end\n        pseudoshuffle(temp_hand, pseudoseed('sacrifice'))\n        for i = 1, card.ability.extra.destroy do destroyed_cards[#destroyed_cards + 1] = temp_hand[i] end\n\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.4,\n            func = function()\n                play_sound('tarot1')\n                card:juice_up(0.3, 0.5)\n                return true\n            end\n        }))\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.1,\n            func = function()\n                SMODS.destroy_cards(destroyed_cards)\n                return true\n            end\n        }))\n        delay(0.5)\n        ease_dollars(card.ability.extra.dollars)\n        delay(0.3)\n    end,\n    can_use = function(self, card)\n        return G.jokers and #G.jokers.cards > 0\n    end,",
      "config": {
        "extra": {
          "destroy": 5,
          "dollars": 20
        }
      },
      "ability": {
        "extra": {
          "destroy": 5,
          "dollars": 20
        }
      },
      "vars": [
        5,
        20
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "decimal",
      "name": null,
      "atlas": "Synonyms",
      "pos": {
        "x": 2,
        "y": 5
      },
      "raw": "key = 'decimal',\n    set = 'soe_Phantom',\n    atlas = 'Synonyms',\n    pos = {x = 2, y = 5},\n    unlocked = true,\n    discovered = true,\n    soe_alternative = 'c_hex',\n    config = {},\n    can_use = function(self,card)\n        if (G.STATE == G.STATES.SELECTING_HAND or G.STATE == G.STATES.TAROT_PACK or G.STATE == G.STATES.SPECTRAL_PACK or G.STATE == G.STATES.PLANET_PACK or G.STATE == G.STATES.SMODS_BOOSTER_OPENED) and #G.hand.cards > 1 and #SMODS.Edition:get_edition_cards(G.hand, true) > 0 then\n            return true\n        end\n        return false\n    end,\n    use = function(self, card, area, copier)\n        local editionless_cards = SMODS.Edition:get_edition_cards(G.hand, true)\n        local destroyed_cards = {}\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.4,\n            func = function()\n                local eligible_card = pseudorandom_element(editionless_cards, pseudoseed('decimal'))\n                eligible_card:set_edition({ polychrome = true })\n                local _first_dissolve = nil\n                for _, card in pairs(G.hand.cards) do\n                    if card ~= eligible_card and (not card.ability.eternal) then\n                        table.insert(destroyed_cards, card)\n                        card:start_dissolve(nil, _first_dissolve)\n                        _first_dissolve = true\n                    end\n                end\n\n                card:juice_up(0.3, 0.5)\n                return true\n            end\n        }))\n        SMODS.calculate_context({ remove_playing_cards = true, removed = destroyed_cards })\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "ghost",
      "name": null,
      "atlas": "Synonyms",
      "pos": {
        "x": 5,
        "y": 5
      },
      "raw": "key = 'ghost',\n    set = 'soe_Phantom',\n    atlas = 'Synonyms',\n    pos = {x = 5, y = 5},\n    unlocked = true,\n    discovered = true,\n    soe_alternative = 'c_cryptid',\n    config = { max_highlighted = 1, extra = { cards = 2 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.cards, card.ability.max_highlighted } }\n    end,\n    can_use = function(self, card)\n        return G.jokers and #G.jokers.highlighted <= card.ability.max_highlighted and #G.jokers.highlighted > 0\n    end,\n    use = function(self, card, area, copier)\n        G.E_MANAGER:add_event(Event({\n            func = function()\n                local _first_dissolve = nil\n                local new_cards = {}\n                for i = 1, card.ability.extra.cards do\n                    local _card = copy_card(G.jokers.highlighted[1])\n                    _card:add_to_deck()\n                    G.jokers:emplace(_card)\n                    _card:start_materialize(nil, _first_dissolve)\n                    _first_dissolve = true\n                end\n                return true\n            end\n        }))\n    end,",
      "config": {
        "max_highlighted": 1,
        "extra": {
          "cards": 2
        }
      },
      "ability": {
        "max_highlighted": 1,
        "extra": {
          "cards": 2
        }
      },
      "vars": [
        2,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "psyche",
      "name": null,
      "atlas": "Synonyms",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "key = 'psyche',\n    set = 'soe_Phantom',\n    atlas = 'Synonyms',\n    pos = {x = 2, y = 2},\n    unlocked = true,\n    discovered = true,\n    soe_alternative = 'c_soul',\n    soul_set = 'soe_Phantom',\n    config = {},\n    hidden = true,\n    can_use = function(self, card)\n        return #G.jokers.cards < G.jokers.config.card_limit\n    end,\n    use = function(self, card, area, copier)\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.4,\n            func = function()\n                play_sound('timpani')\n                SMODS.add_card({set = 'soe_Infinity'})\n                card:juice_up(0.3, 0.5)\n                return true\n            end\n        }))\n        delay(0.6)\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "dejajed",
      "name": null,
      "atlas": "Confusion",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = 'dejajed',\n    set = 'soe_Phantom',\n    atlas = 'Confusion',\n    pos = {x = 0, y = 0},\n    hidden = true,\n    soul_set = 'soe_Phantom',\n    soul_rate = 0.05,\n    soe_alternative = 'c_deja_vu',\n    unlocked = true,\n    discovered = true,\n    use = function(self, card, area, copier)\n        local conv_card\n        for i, v in ipairs(G.I.CARD) do\n            if v.highlighted and v ~= card then\n                conv_card = v\n                break\n            end\n        end\n        G.E_MANAGER:add_event(Event({\n            func = function()\n                play_sound('tarot1')\n                card:juice_up(0.3, 0.5)\n                return true\n            end\n        }))\n\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.1,\n            func = function()\n                local oldseal = conv_card.seal\n                SEALS.remove_seal(conv_card)\n                conv_card:juice_up(0.3, 0.3)\n                play_sound(\"soe_laes_dlog\", 1.2, 0.4)\n                local detachedseal = Card(conv_card.T.x, conv_card.T.y, G.CARD_W/2.63, G.CARD_H/3.52, G.P_CARDS.empty, G.P_CENTERS.c_base)\n                for k, v in pairs((SEALS.detached_seals[oldseal] or {}).config or {}) do\n                    detachedseal.ability[k] = copy_table(v)\n                end\n                detachedseal.ability.set = \"Seal\"\n                detachedseal.ability.soe_detached_seal = oldseal\n                if detachedseal.children.center then detachedseal.children.center:remove() end\n                detachedseal.children.center = Sprite(detachedseal.T.x, detachedseal.T.y, detachedseal.T.w, detachedseal.T.h, G.ASSET_ATLAS[\"soe_SealsIndividual\"], {x = ({Red=0,Blue=1,Gold=2,Purple=3})[oldseal], y = 0})\n                detachedseal.children.center.states.hover = detachedseal.states.hover\n                detachedseal.children.center.states.click = detachedseal.states.click\n                detachedseal.children.center.states.drag = detachedseal.states.drag\n                detachedseal.children.center.states.collide.can = false\n                detachedseal.children.center:set_role({major = detachedseal, role_type = 'Glued', draw_major = detachedseal})\n                detachedseal:juice_up(0.3, 0.3)\n                G.GAME.soe_detached_seal_keys = G.GAME.soe_detached_seal_keys or {}\n                table.insert(G.GAME.soe_detached_seal_keys, oldseal)\n                G.GAME.soe_detached_seals = G.GAME.soe_detached_seals or {}\n                table.insert(G.GAME.soe_detached_seals, detachedseal)\n                return true\n            end\n        }))\n\n        delay(0.5)\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.2,\n            func = function()\n                conv_card.area:unhighlight_all()\n                return true\n            end\n        }))\n    end,\n    can_use = function (self, card)\n        local highlighted_cards = {}\n        for i, v in ipairs(G.I.CARD) do\n            if v and v.highlighted and v ~= card then\n                table.insert(highlighted_cards, v)\n            end\n        end\n        return G.STAGE == G.STAGES.RUN and #highlighted_cards == 1 and highlighted_cards[1].seal and ({Red=true,Blue=true,Gold=true,Purple=true})[highlighted_cards[1].seal]\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "DrawStep",
      "key": "psychesoul",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'psychesoul',\n    order = 50,\n    func = function(self)\n        if self.config.center.key == \"c_soe_psyche\" and (self.config.center.discovered or self.bypass_discovery_center) then\n            local scale_mod = 0.05 + 0.05*math.sin(1.8*G.TIMERS.REAL) + 0.07*math.sin((G.TIMERS.REAL - math.floor(G.TIMERS.REAL))*math.pi*14)*(1 - (G.TIMERS.REAL - math.floor(G.TIMERS.REAL)))^3\n            local rotate_mod = 0.1*math.sin(1.219*G.TIMERS.REAL) + 0.07*math.sin((G.TIMERS.REAL)*math.pi*5)*(1 - (G.TIMERS.REAL - math.floor(G.TIMERS.REAL)))^2\n\n            G.shared_psyche.role.draw_major = self\n            G.shared_psyche:draw_shader('dissolve',0, nil, nil, self.children.center,scale_mod, rotate_mod,nil, 0.1 + 0.03*math.sin(1.8*G.TIMERS.REAL),nil, 0.6)\n            G.shared_psyche:draw_shader('dissolve', nil, nil, nil, self.children.center, scale_mod, rotate_mod)\n        end\n    end,\n    conditions = { vortex = false, facing = 'front' },",
      "config": {
        "vortex": false,
        "facing": "front"
      },
      "ability": {
        "vortex": false,
        "facing": "front"
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "ConsumableType",
      "key": "soe_Vice",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"soe_Vice\",\n    primary_colour = HEX(\"2D5E5A\"),\n    secondary_colour = HEX(\"2D5E5A\"),\n    collection_rows = { 6, 6 },\n    can_stack = true,\n    can_divide = true,\n    default = \"c_idiot\",\n    inject_card = function(self, center)\n        SMODS.ObjectType.inject_card(self, center)\n        SMODS.insert_pool(G.P_CENTER_POOLS['soe_Synonyms'], center)\n    end,\n    delete_card = function(self, center)\n        SMODS.ObjectType.delete_card(self, center)\n        SMODS.remove_pool(G.P_CENTER_POOLS['soe_Synonyms'], center.key)\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "idiot",
      "name": null,
      "atlas": "Synonyms",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = 'idiot',\n    set = 'soe_Vice',\n    pos = { x = 0, y = 0 },\n    atlas = 'Synonyms',\n    soe_alternative = 'c_fool',\n    loc_vars = function(self, info_queue, card)\n        local fool_c = G.GAME.soe_last_sold_joker and G.P_CENTERS[G.GAME.soe_last_sold_joker] or nil\n        local last_tarot_planet = fool_c and localize { type = 'name_text', key = fool_c.key, set = fool_c.set } or\n            localize('k_none')\n        local colour = (not fool_c or fool_c.name == 'The Fool') and G.C.RED or G.C.GREEN\n\n        if not (not fool_c or fool_c.name == 'The Fool') then\n            info_queue[#info_queue + 1] = fool_c\n        end\n\n        local main_end = {\n            {\n                n = G.UIT.C,\n                config = { align = \"bm\", padding = 0.02 },\n                nodes = {\n                    {\n                        n = G.UIT.C,\n                        config = { align = \"m\", colour = colour, r = 0.05, padding = 0.05 },\n                        nodes = {\n                            { n = G.UIT.T, config = { text = ' ' .. last_tarot_planet .. ' ', colour = G.C.UI.TEXT_LIGHT, scale = 0.3, shadow = true } },\n                        }\n                    }\n                }\n            }\n        }\n\n        return { vars = { last_tarot_planet }, main_end = main_end }\n    end,\n    use = function(self, card, area, copier)\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.4,\n            func = function()\n                if G.jokers.config.card_limit > #G.jokers.cards then\n                    play_sound('timpani')\n                    SMODS.add_card({ key = G.GAME.soe_last_sold_joker, area = G.jokers })\n                    card:juice_up(0.3, 0.5)\n                end\n                return true\n            end\n        }))\n        delay(0.6)\n    end,\n    can_use = function(self, card)\n        return G.jokers.config.card_limit > #G.jokers.cards and G.GAME.soe_last_sold_joker\n    end",
      "config": {
        "align": "bm",
        "padding": 0.02
      },
      "ability": {
        "align": "bm",
        "padding": 0.02
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "governor",
      "name": null,
      "atlas": "Synonyms",
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "key = 'governor',\n    set = 'soe_Vice',\n    atlas = 'Synonyms',\n    pos = { x = 4, y = 0 },\n    soe_alternative = 'c_emperor',\n    config = {extra = {key = \"\"}},\n    use = function(self, card, area, copier)\n        for i = 1, 2 do\n            G.E_MANAGER:add_event(Event({\n                trigger = 'after',\n                delay = 0.4,\n                func = function()\n                    play_sound('timpani')\n                    if i == 1 then\n                        local _card = SMODS.add_card({set = 'soe_Synonyms'})\n                        card.ability.extra.key = _card.config.center.soe_alternative\n                    elseif i == 2 then\n                        SMODS.add_card({key = card.ability.extra.key})\n                    end\n                    card:juice_up(0.3, 0.5)\n                    return true\n                end\n            }))\n        end\n        delay(0.6)\n    end,\n    can_use = function(self, card)\n        return G.consumeables and (#G.consumeables.cards + (card.area == G.consumeables and 0 or 1)) < G.consumeables.config.card_limit\n    end",
      "config": {
        "extra": {
          "key": ""
        }
      },
      "ability": {
        "extra": {
          "key": ""
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "energy",
      "name": null,
      "atlas": "Synonyms",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = 'energy',\n    set = 'soe_Vice',\n    atlas = 'Synonyms',\n    soe_alternative = 'c_strength',\n    pos = { x = 1, y = 1 },\n    config = { max_highlighted = 1, extra = { jokeradd = 1 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.max_highlighted, card.ability.extra.jokeradd, card.ability.max_highlighted ~= 1 and 'Jokers' or 'Joker' } }\n    end,\n    use = function(self, card, area, copier)\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.4,\n            func = function()\n                play_sound('tarot1')\n                card:juice_up(0.3, 0.5)\n                return true\n            end\n        }))\n        for i = 1, #G.jokers.highlighted do\n            local percent = 1.15 - (i - 0.999) / (#G.jokers.highlighted - 0.998) * 0.3\n            G.E_MANAGER:add_event(Event({\n                trigger = 'after',\n                delay = 0.15,\n                func = function()\n                    G.jokers.highlighted[i]:flip()\n                    play_sound('card1', percent)\n                    G.jokers.highlighted[i]:juice_up(0.3, 0.3)\n                    return true\n                end\n            }))\n        end\n        delay(0.2)\n        for i = 1, #G.jokers.highlighted do\n            G.E_MANAGER:add_event(Event({\n                trigger = 'after',\n                delay = 0.1,\n                func = function()\n                    SEALS.modify_joker_values(G.jokers.highlighted[i], {[\"+\"] = card.ability.extra.jokeradd}, {x_mult = 1, x_chips = 1, h_size = 0, extra_value = true, cry_prob = true, d_size = 0})\n                    return true\n                end\n            }))\n        end\n        for i = 1, #G.jokers.highlighted do\n            local percent = 0.85 + (i - 0.999) / (#G.jokers.highlighted - 0.998) * 0.3\n            G.E_MANAGER:add_event(Event({\n                trigger = 'after',\n                delay = 0.15,\n                func = function()\n                    G.jokers.highlighted[i]:flip()\n                    play_sound('tarot2', percent, 0.6)\n                    G.jokers.highlighted[i]:juice_up(0.3, 0.3)\n                    return true\n                end\n            }))\n        end\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.2,\n            func = function()\n                G.jokers:unhighlight_all()\n                return true\n            end\n        }))\n        delay(0.5)\n    end,\n    can_use = function(self, card)\n        if G.jokers and #G.jokers.highlighted > 0 and #G.jokers.highlighted <= card.ability.max_highlighted then\n            for k, v in pairs(G.jokers.highlighted) do\n                if v.config.center.immutable then\n                    return false\n                end\n            end\n            return true\n        end\n        return false\n    end",
      "config": {
        "max_highlighted": 1,
        "extra": {
          "jokeradd": 1
        }
      },
      "ability": {
        "max_highlighted": 1,
        "extra": {
          "jokeradd": 1
        }
      },
      "vars": [
        1,
        1,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "gallowsbird",
      "name": null,
      "atlas": "Synonyms",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = 'gallowsbird',\n    set = 'soe_Vice',\n    atlas = 'Synonyms',\n    pos = { x = 2, y = 1 },\n    soe_alternative = 'c_hanged_man',\n    config = {max_highlighted = 2, min_highlighted = 1},\n    loc_vars = function (self, info_queue, card)\n        return {vars = {card.ability.max_highlighted}}\n    end,\n    use = function(self, card, area, copier)\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.4,\n            func = function()\n                play_sound('tarot1')\n                card:juice_up(0.3, 0.5)\n                return true\n            end\n        }))\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.2,\n            func = function()\n                for k, v in pairs(G.jokers.highlighted) do\n                    v:soe_no_touching2()\n                end\n                return true\n            end\n        }))\n        delay(0.3)\n    end,\n    can_use = function(self, card)\n        return G.jokers and #G.jokers.highlighted >= card.ability.min_highlighted and #G.jokers.highlighted <= card.ability.max_highlighted\n    end",
      "config": {
        "max_highlighted": 2,
        "min_highlighted": 1
      },
      "ability": {
        "max_highlighted": 2,
        "min_highlighted": 1
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "murder",
      "name": null,
      "atlas": "Synonyms",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = 'murder',\n    set = 'soe_Vice',\n    atlas = 'Synonyms',\n    pos = {x = 3, y = 1},\n    unlocked = true,\n    discovered = true,\n    soe_alternative = 'c_death',\n    config = {max_highlighted = 2, min_highlighted = 2},\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.max_highlighted } }\n    end,\n    can_use = function(self, card)\n        return G.jokers and #G.jokers.highlighted >= card.ability.min_highlighted and #G.jokers.highlighted <= card.ability.max_highlighted\n    end,\n    use = function(self, card, area, copier)\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.4,\n            func = function()\n                play_sound('tarot1')\n                card:juice_up(0.3, 0.5)\n                return true\n            end\n        }))\n        for i = 1, #G.jokers.highlighted do\n            local percent = 1.15 - (i - 0.999) / (#G.jokers.highlighted - 0.998) * 0.3\n            G.E_MANAGER:add_event(Event({\n                trigger = 'after',\n                delay = 0.15,\n                func = function()\n                    G.jokers.highlighted[i]:flip()\n                    play_sound('card1', percent)\n                    G.jokers.highlighted[i]:juice_up(0.3, 0.3)\n                    return true\n                end\n            }))\n        end\n        delay(0.2)\n        local rightmost = G.jokers.highlighted[1]\n        for i = 1, #G.jokers.highlighted do\n            if G.jokers.highlighted[i].T.x > rightmost.T.x then\n                rightmost = G.jokers.highlighted[i]\n            end\n        end\n        for i = 1, #G.jokers.highlighted do\n            G.E_MANAGER:add_event(Event({\n                trigger = 'after',\n                delay = 0.1,\n                func = function()\n                    if G.jokers.highlighted[i] ~= rightmost then\n                        copy_card(rightmost, G.jokers.highlighted[i])\n                    end\n                    return true\n                end\n            }))\n        end\n        for i = 1, #G.jokers.highlighted do\n            local percent = 0.85 + (i - 0.999) / (#G.jokers.highlighted - 0.998) * 0.3\n            G.E_MANAGER:add_event(Event({\n                trigger = 'after',\n                delay = 0.15,\n                func = function()\n                    G.jokers.highlighted[i]:flip()\n                    play_sound('tarot2', percent, 0.6)\n                    G.jokers.highlighted[i]:juice_up(0.3, 0.3)\n                    return true\n                end\n            }))\n        end\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.2,\n            func = function()\n                G.jokers:unhighlight_all()\n                return true\n            end\n        }))\n        delay(0.5)\n    end,",
      "config": {
        "max_highlighted": 2,
        "min_highlighted": 2
      },
      "ability": {
        "max_highlighted": 2,
        "min_highlighted": 2
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "What",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'What',\n    path = 'What.png',\n    px = 71,\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "Confusion",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'Confusion',\n    path = 'Confusion.png',\n    px = 71,\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "Enhancers",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'Enhancers',\n    path = 'Enhancers.png',\n    px = 71,\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "PlayingCards",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'PlayingCards',\n    path = 'PlayingCards.png',\n    px = 71,\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "BlueprintVouchers",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'BlueprintVouchers',\n    path = 'BlueprintVouchers.png',\n    px = 71,\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "JokerEnhancements",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'JokerEnhancements',\n    path = 'JokerEnhancements.png',\n    px = 71,\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "JokerFronts",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'JokerFronts',\n    path = 'JokerFronts.png',\n    px = 71,\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "ExtraLife",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'ExtraLife',\n    path = 'ExtraLife.png',\n    px = 71,\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "Tarots",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'Tarots',\n    path = 'Tarots.png',\n    px = 71,\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "Synonyms",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'Synonyms',\n    path = 'Synonyms.png',\n    px = 71,\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "VoucherSynonyms",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'VoucherSynonyms',\n    path = 'Vouchersynonyms.png',\n    px = 71,\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "Vouchers",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'Vouchers',\n    path = 'Vouchers.png',\n    px = 71,\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "Planets",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'Planets',\n    path = 'Planets.png',\n    px = 71,\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "Sleeves",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'Sleeves',\n    path = 'Sleeves.png',\n    px = 71,\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "Placeholders",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'Placeholders',\n    path = 'Placeholders.png',\n    px = 71,\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "DeckSeals",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'DeckSeals',\n    path = 'DeckSeals.png',\n    px = 71,\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "Seals",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'Seals',\n    path = 'Seals.png',\n    px = 71,\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "RainbowSeal",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'RainbowSeal',\n    path = 'rainbowseal.png',\n    px = 71,\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "SealsIndividual",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'SealsIndividual',\n    path = 'SealsIndividual.png',\n    px = 27,\n    py = 27",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "SecondSeals",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'SecondSeals',\n    path = 'SecondSeals.png',\n    px = 71,\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "Charms",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'Charms',\n    path = 'Charms.png',\n    px = 68,\n    py = 68",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "Boosters",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'Boosters',\n    path = 'Boosters.png',\n    px = 71,\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "Exotics",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'Exotics',\n    path = 'Exotics.png',\n    px = 71,\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "Think",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'Think',\n    path = 'Think.png',\n    px = 71,\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "InfinitySeals",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'InfinitySeals',\n    path = 'InfinitySeals.png',\n    px = 71,\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "Stakes",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'Stakes',\n    path = 'Stakes.png',\n    px = 29,\n    py = 29",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "modicon",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'modicon',\n    path = 'modicon.png',\n    px = 34,\n    py = 34",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "VanillaSleeves",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'VanillaSleeves',\n    path = 'VanillaSleeves.png',\n    px = 73,\n    py = 96",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "Prints",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'Prints',\n    path = 'Prints.png',\n    px = 71,\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "Blinds",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'Blinds',\n    path = 'Blinds.png',\n    atlas_table = 'ANIMATION_ATLAS',\n    frames = 21,\n    px = 34,\n    py = 34",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "synonymmusic",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'synonymmusic',\n    path = 'synonymmusicmain.ogg',\n    sync = true,\n    select_music_track = function()\n        return not SEALS.config.synonymmusicdisable and (G.booster_pack and not G.booster_pack.REMOVED and SMODS.OPENED_BOOSTER and SMODS.OPENED_BOOSTER.config.center.kind == 'soe_Synonym' and 2e12) or nil\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "laes_dlog",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'laes_dlog',\n    path = 'laes_dlog.ogg',",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Font",
      "key": "11x6m",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"11x6m\",\n    path = \"11x6m.ttf\",\n    render_scale = 200,\n    TEXT_HEIGHT_SCALE = 0.83,\n    TEXT_OFFSET = { x = 10, y = 0 },\n    FONTSCALE = 0.1,\n    squish = 1,\n    DESCSCALE = 1",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "dejavuq",
      "name": null,
      "atlas": "What",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = 'dejavuq',\n    set = 'Spectral',\n    atlas = 'What',\n    pos = {x = 0, y = 0},\n    config = {mod_conv = \"Red\", cards = 1},\n    loc_vars = function(self,info_queue,center)\n        info_queue[#info_queue+1] = { key = \"red_seal_joker\", set = \"Other\"}\n    end,\n    unlocked = true,\n    discovered = true,\n    can_use = function(self,card)\n        local eligible = {}\n        for k, v in pairs(G.jokers.cards) do\n            if IsEligibleForSeal(v) then\n                eligible[#eligible + 1] = v\n            end\n        end\n        return #eligible > 0 and true or false\n    end,\n    use = function(self,card,area,copier)\n        local eligible = {}\n        for k, v in pairs(G.jokers.cards) do\n            if IsEligibleForSeal(v) then\n                eligible[#eligible + 1] = v\n            end\n        end\n        local highlighted = pseudorandom_element(eligible, pseudoseed('dejavu'))\n        if highlighted then\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    play_sound(\"tarot1\")\n                    highlighted:juice_up(0.3, 0.5)\n                    return true\n                end,\n            }))\n            G.E_MANAGER:add_event(Event({\n                trigger = \"after\",\n                delay = 0.1,\n                func = function()\n                    if highlighted then\n                        highlighted:set_seal(\"Red\", nil, true)\n                    end\n                    return true\n                end,\n            }))\n        end\n    end",
      "config": {
        "mod_conv": "Red",
        "cards": 1
      },
      "ability": {
        "mod_conv": "Red",
        "cards": 1
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "tranceq",
      "name": null,
      "atlas": "What",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = 'tranceq',\n    set = 'Spectral',\n    atlas = 'What',\n    pos = {x = 1, y = 0},\n    config = {mod_conv = \"Blue\", cards = 1},\n    loc_vars = function(self,info_queue,center)\n        info_queue[#info_queue+1] = { key = \"blue_seal_joker\", set = \"Other\"}\n    end,\n    unlocked = true,\n    discovered = true,\n    can_use = function(self,card)\n        local eligible = {}\n        for k, v in pairs(G.jokers.cards) do\n            if IsEligibleForSeal(v) then\n                eligible[#eligible + 1] = v\n            end\n        end\n        return #eligible > 0 and true or false\n    end,\n    use = function(self,card,area,copier)\n        local eligible = {}\n        for k, v in pairs(G.jokers.cards) do\n            if IsEligibleForSeal(v) then\n                eligible[#eligible + 1] = v\n            end\n        end\n        local highlighted = pseudorandom_element(eligible, pseudoseed('trance'))\n        if highlighted then\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    play_sound(\"tarot1\")\n                    highlighted:juice_up(0.3, 0.5)\n                    return true\n                end,\n            }))\n            G.E_MANAGER:add_event(Event({\n                trigger = \"after\",\n                delay = 0.1,\n                func = function()\n                    if highlighted then\n                        highlighted:set_seal(\"Blue\", nil, true)\n                    end\n                    return true\n                end,\n            }))\n        end\n    end",
      "config": {
        "mod_conv": "Blue",
        "cards": 1
      },
      "ability": {
        "mod_conv": "Blue",
        "cards": 1
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "talismanq",
      "name": null,
      "atlas": "What",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = 'talismanq',\n    set = 'Spectral',\n    atlas = 'What',\n    pos = {x = 2, y = 0},\n    config = {mod_conv = \"Gold\", cards = 1},\n    loc_vars = function(self,info_queue,center)\n        info_queue[#info_queue+1] = { key = \"gold_seal_joker\", set = \"Other\"}\n    end,\n    unlocked = true,\n    discovered = true,\n    can_use = function(self,card)\n        local eligible = {}\n        for k, v in pairs(G.jokers.cards) do\n            if IsEligibleForSeal(v) then\n                eligible[#eligible + 1] = v\n            end\n        end\n        return #eligible > 0 and true or false\n    end,\n    use = function(self,card,area,copier)\n        local eligible = {}\n        for k, v in pairs(G.jokers.cards) do\n            if IsEligibleForSeal(v) then\n                eligible[#eligible + 1] = v\n            end\n        end\n        local highlighted = pseudorandom_element(eligible, pseudoseed('talisman'))\n        if highlighted then\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    play_sound(\"tarot1\")\n                    highlighted:juice_up(0.3, 0.5)\n                    return true\n                end,\n            }))\n            G.E_MANAGER:add_event(Event({\n                trigger = \"after\",\n                delay = 0.1,\n                func = function()\n                    if highlighted then\n                        highlighted:set_seal(\"Gold\", nil, true)\n                    end\n                    return true\n                end,\n            }))\n        end\n    end",
      "config": {
        "mod_conv": "Gold",
        "cards": 1
      },
      "ability": {
        "mod_conv": "Gold",
        "cards": 1
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "mediumq",
      "name": null,
      "atlas": "What",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = 'mediumq',\n    set = 'Spectral',\n    atlas = 'What',\n    pos = {x = 3, y = 0},\n    config = {mod_conv = \"Purple\", cards = 1},\n    loc_vars = function(self,info_queue,center)\n        info_queue[#info_queue+1] = { key = \"purple_seal_joker\", set = \"Other\"}\n    end,\n    unlocked = true,\n    discovered = true,\n    can_use = function(self,card)\n        local eligible = {}\n        for k, v in pairs(G.jokers.cards) do\n            if IsEligibleForSeal(v) then\n                eligible[#eligible + 1] = v\n            end\n        end\n        return #eligible > 0 and true or false\n    end,\n    use = function(self,card,area,copier)\n        local eligible = {}\n        for k, v in pairs(G.jokers.cards) do\n            if IsEligibleForSeal(v) then\n                eligible[#eligible + 1] = v\n            end\n        end\n        local highlighted = pseudorandom_element(eligible, pseudoseed('medium'))\n        if highlighted then\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    play_sound(\"tarot1\")\n                    highlighted:juice_up(0.3, 0.5)\n                    return true\n                end,\n            }))\n            G.E_MANAGER:add_event(Event({\n                trigger = \"after\",\n                delay = 0.1,\n                func = function()\n                    if highlighted then\n                        highlighted:set_seal(\"Purple\", nil, true)\n                    end\n                    return true\n                end,\n            }))\n        end\n    end",
      "config": {
        "mod_conv": "Purple",
        "cards": 1
      },
      "ability": {
        "mod_conv": "Purple",
        "cards": 1
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "typhoonq",
      "name": null,
      "atlas": "What",
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "key = 'typhoonq',\n        set = 'Spectral',\n        atlas = 'What',\n        pos = {x = 4, y = 0},\n        config = {mod_conv = \"cry_azure\", cards = 1},\n        loc_vars = function(self,info_queue,center)\n            info_queue[#info_queue+1] = { key = \"cry_azure_seal_joker\", set = \"Other\"}\n        end,\n        unlocked = true,\n        discovered = true,\n        can_use = function(self,card)\n            local eligible = {}\n            for k, v in pairs(G.jokers.cards) do\n                if IsEligibleForSeal(v) then\n                    eligible[#eligible + 1] = v\n                end\n            end\n            return #eligible > 0 and true or false\n        end,\n        use = function(self,card,area,copier)\n            local eligible = {}\n            for k, v in pairs(G.jokers.cards) do\n                if IsEligibleForSeal(v) then\n                    eligible[#eligible + 1] = v\n                end\n            end\n            local highlighted = pseudorandom_element(eligible, pseudoseed('typhoon'))\n            if highlighted then\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        play_sound(\"tarot1\")\n                        highlighted:juice_up(0.3, 0.5)\n                        return true\n                    end,\n                }))\n                G.E_MANAGER:add_event(Event({\n                    trigger = \"after\",\n                    delay = 0.1,\n                    func = function()\n                        if highlighted then\n                            highlighted:set_seal(\"cry_azure\", nil, true)\n                        end\n                        return true\n                    end,\n                }))\n            end\n        end",
      "config": {
        "mod_conv": "cry_azure",
        "cards": 1
      },
      "ability": {
        "mod_conv": "cry_azure",
        "cards": 1
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "sourceq",
      "name": null,
      "atlas": "What",
      "pos": {
        "x": 5,
        "y": 0
      },
      "raw": "key = 'sourceq',\n        set = 'Spectral',\n        atlas = 'What',\n        pos = {x = 5, y = 0},\n        config = {mod_conv = \"cry_green\", cards = 1},\n        loc_vars = function(self,info_queue,center)\n            info_queue[#info_queue+1] = { key = \"cry_green_seal_joker\", set = \"Other\"}\n        end,\n        unlocked = true,\n        discovered = true,\n        can_use = function(self,card)\n            local eligible = {}\n            for k, v in pairs(G.jokers.cards) do\n                if IsEligibleForSeal(v) then\n                    eligible[#eligible + 1] = v\n                end\n            end\n            return #eligible > 0 and true or false\n        end,\n        use = function(self,card,area,copier)\n            local eligible = {}\n            for k, v in pairs(G.jokers.cards) do\n                if IsEligibleForSeal(v) then\n                    eligible[#eligible + 1] = v\n                end\n            end\n            local highlighted = pseudorandom_element(eligible, pseudoseed('source'))\n            if highlighted then\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        play_sound(\"tarot1\")\n                        highlighted:juice_up(0.3, 0.5)\n                        return true\n                    end,\n                }))\n                G.E_MANAGER:add_event(Event({\n                    trigger = \"after\",\n                    delay = 0.1,\n                    func = function()\n                        if highlighted then\n                            highlighted:set_seal(\"cry_green\", nil, true)\n                        end\n                        return true\n                    end,\n                }))\n            end\n        end",
      "config": {
        "mod_conv": "cry_green",
        "cards": 1
      },
      "ability": {
        "mod_conv": "cry_green",
        "cards": 1
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "devilq",
      "name": null,
      "atlas": "What",
      "pos": {
        "x": 6,
        "y": 0
      },
      "raw": "key = 'devilq',\n    set = 'Tarot',\n    atlas = 'What',\n    pos = {x = 6, y = 0},\n    unlocked = true,\n    discovered = true,\n    can_use = function(self,card)\n        local eligible = {}\n        for k, v in pairs(G.jokers.cards) do\n            if (not (v.ability.soe_legalenhancements and next(v.ability.soe_legalenhancements))) or next(SMODS.find_card('j_soe_sealjoker2')) then\n                eligible[#eligible + 1] = v\n            end\n        end\n        return #eligible > 0 and true or false\n    end,\n    use = function(self,card,area,copier)\n        local eligible = {}\n        for k, v in pairs(G.jokers.cards) do\n            if (not (v.ability.soe_legalenhancements and next(v.ability.soe_legalenhancements))) or next(SMODS.find_card('j_soe_sealjoker2')) then\n                eligible[#eligible + 1] = v\n            end\n        end\n        local highlighted = pseudorandom_element(eligible, pseudoseed('devil'))\n        if highlighted then\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    play_sound(\"tarot1\")\n                    highlighted:juice_up(0.3, 0.5)\n                    return true\n                end,\n            }))\n            G.E_MANAGER:add_event(Event({\n                trigger = \"after\",\n                delay = 0.1,\n                func = function()\n                    if highlighted then\n                        SEALS.set_joker_enhancement(highlighted, G.P_CENTERS.m_gold)\n                    end\n                    return true\n                end,\n            }))\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "towerq",
      "name": null,
      "atlas": "What",
      "pos": {
        "x": 7,
        "y": 0
      },
      "raw": "key = 'towerq',\n    set = 'Tarot',\n    atlas = 'What',\n    pos = {x = 7, y = 0},\n    unlocked = true,\n    discovered = true,\n    can_use = function(self,card)\n        local eligible = {}\n        for k, v in pairs(G.jokers.cards) do\n            if (not (v.ability.soe_legalenhancements and next(v.ability.soe_legalenhancements))) or next(SMODS.find_card('j_soe_sealjoker2')) then\n                eligible[#eligible + 1] = v\n            end\n        end\n        return #eligible > 0 and true or false\n    end,\n    use = function(self,card,area,copier)\n        local eligible = {}\n        for k, v in pairs(G.jokers.cards) do\n            if (not (v.ability.soe_legalenhancements and next(v.ability.soe_legalenhancements))) or next(SMODS.find_card('j_soe_sealjoker2')) then\n                eligible[#eligible + 1] = v\n            end\n        end\n        local highlighted = pseudorandom_element(eligible, pseudoseed('tower'))\n        if highlighted then\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    play_sound(\"tarot1\")\n                    highlighted:juice_up(0.3, 0.5)\n                    return true\n                end,\n            }))\n            G.E_MANAGER:add_event(Event({\n                trigger = \"after\",\n                delay = 0.1,\n                func = function()\n                    if highlighted then\n                        highlighted:set_ability(G.P_CENTERS.j_soe_stonecardjoker)\n                    end\n                    return true\n                end,\n            }))\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "chariotq",
      "name": null,
      "atlas": "What",
      "pos": {
        "x": 8,
        "y": 0
      },
      "raw": "key = 'chariotq',\n    set = 'Tarot',\n    atlas = 'What',\n    pos = {x = 8, y = 0},\n    unlocked = true,\n    discovered = true,\n    can_use = function(self,card)\n        local eligible = {}\n        for k, v in pairs(G.jokers.cards) do\n            if (not (v.ability.soe_legalenhancements and next(v.ability.soe_legalenhancements))) or next(SMODS.find_card('j_soe_sealjoker2')) then\n                eligible[#eligible + 1] = v\n            end\n        end\n        return #eligible > 0 and true or false\n    end,\n    use = function(self,card,area,copier)\n        local eligible = {}\n        for k, v in pairs(G.jokers.cards) do\n            if (not (v.ability.soe_legalenhancements and next(v.ability.soe_legalenhancements))) or next(SMODS.find_card('j_soe_sealjoker2')) then\n                eligible[#eligible + 1] = v\n            end\n        end\n        local highlighted = pseudorandom_element(eligible, pseudoseed('chariot'))\n        if highlighted then\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    play_sound(\"tarot1\")\n                    highlighted:juice_up(0.3, 0.5)\n                    return true\n                end,\n            }))\n            G.E_MANAGER:add_event(Event({\n                trigger = \"after\",\n                delay = 0.1,\n                func = function()\n                    if highlighted then\n                        SEALS.set_joker_enhancement(highlighted, G.P_CENTERS.m_steel)\n                    end\n                    return true\n                end,\n            }))\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "empressq",
      "name": null,
      "atlas": "What",
      "pos": {
        "x": 9,
        "y": 0
      },
      "raw": "key = 'empressq',\n    set = 'Tarot',\n    atlas = 'What',\n    pos = {x = 9, y = 0},\n    unlocked = true,\n    discovered = true,\n    can_use = function(self,card)\n        local eligible = {}\n        for k, v in pairs(G.jokers.cards) do\n            if (not (v.ability.soe_legalenhancements and next(v.ability.soe_legalenhancements))) or next(SMODS.find_card('j_soe_sealjoker2')) then\n                eligible[#eligible + 1] = v\n            end\n        end\n        return #eligible > 0 and true or false\n    end,\n    use = function(self,card,area,copier)\n        local eligible = {}\n        for k, v in pairs(G.jokers.cards) do\n            if (not (v.ability.soe_legalenhancements and next(v.ability.soe_legalenhancements))) or next(SMODS.find_card('j_soe_sealjoker2')) then\n                eligible[#eligible + 1] = v\n            end\n        end\n        local highlighted = pseudorandom_element(eligible, pseudoseed('empress'))\n        if highlighted then\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    play_sound(\"tarot1\")\n                    highlighted:juice_up(0.3, 0.5)\n                    return true\n                end,\n            }))\n            G.E_MANAGER:add_event(Event({\n                trigger = \"after\",\n                delay = 0.1,\n                func = function()\n                    if highlighted then\n                        SEALS.set_joker_enhancement(highlighted, G.P_CENTERS.m_mult)\n                    end\n                    return true\n                end,\n            }))\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "hierophantq",
      "name": null,
      "atlas": "What",
      "pos": {
        "x": 10,
        "y": 0
      },
      "raw": "key = 'hierophantq',\n    set = 'Tarot',\n    atlas = 'What',\n    pos = {x = 10, y = 0},\n    unlocked = true,\n    discovered = true,\n    can_use = function(self,card)\n        local eligible = {}\n        for k, v in pairs(G.jokers.cards) do\n            if (not (v.ability.soe_legalenhancements and next(v.ability.soe_legalenhancements))) or next(SMODS.find_card('j_soe_sealjoker2')) then\n                eligible[#eligible + 1] = v\n            end\n        end\n        return #eligible > 0 and true or false\n    end,\n    use = function(self,card,area,copier)\n        local eligible = {}\n        for k, v in pairs(G.jokers.cards) do\n            if (not (v.ability.soe_legalenhancements and next(v.ability.soe_legalenhancements))) or next(SMODS.find_card('j_soe_sealjoker2')) then\n                eligible[#eligible + 1] = v\n            end\n        end\n        local highlighted = pseudorandom_element(eligible, pseudoseed('hierophant'))\n        if highlighted then\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    play_sound(\"tarot1\")\n                    highlighted:juice_up(0.3, 0.5)\n                    return true\n                end,\n            }))\n            G.E_MANAGER:add_event(Event({\n                trigger = \"after\",\n                delay = 0.1,\n                func = function()\n                    if highlighted then\n                        SEALS.set_joker_enhancement(highlighted, G.P_CENTERS.m_bonus)\n                    end\n                    return true\n                end,\n            }))\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "magicianq",
      "name": null,
      "atlas": "What",
      "pos": {
        "x": 11,
        "y": 0
      },
      "raw": "key = 'magicianq',\n    set = 'Tarot',\n    atlas = 'What',\n    pos = {x = 11, y = 0},\n    unlocked = true,\n    discovered = true,\n    can_use = function(self,card)\n        local eligible = {}\n        for k, v in pairs(G.jokers.cards) do\n            if (not (v.ability.soe_legalenhancements and next(v.ability.soe_legalenhancements))) or next(SMODS.find_card('j_soe_sealjoker2')) then\n                eligible[#eligible + 1] = v\n            end\n        end\n        return #eligible > 0 and true or false\n    end,\n    use = function(self,card,area,copier)\n        local eligible = {}\n        for k, v in pairs(G.jokers.cards) do\n            if (not (v.ability.soe_legalenhancements and next(v.ability.soe_legalenhancements))) or next(SMODS.find_card('j_soe_sealjoker2')) then\n                eligible[#eligible + 1] = v\n            end\n        end\n        local highlighted = pseudorandom_element(eligible, pseudoseed('magician'))\n        if highlighted then\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    play_sound(\"tarot1\")\n                    highlighted:juice_up(0.3, 0.5)\n                    return true\n                end,\n            }))\n            G.E_MANAGER:add_event(Event({\n                trigger = \"after\",\n                delay = 0.1,\n                func = function()\n                    if highlighted then\n                        SEALS.set_joker_enhancement(highlighted, G.P_CENTERS.m_lucky)\n                    end\n                    return true\n                end,\n            }))\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "justiceq",
      "name": null,
      "atlas": "What",
      "pos": {
        "x": 12,
        "y": 0
      },
      "raw": "key = 'justiceq',\n    set = 'Tarot',\n    atlas = 'What',\n    pos = {x = 12, y = 0},\n    unlocked = true,\n    discovered = true,\n    can_use = function(self,card)\n        local eligible = {}\n        for k, v in pairs(G.jokers.cards) do\n            if (not (v.ability.soe_legalenhancements and next(v.ability.soe_legalenhancements))) or next(SMODS.find_card('j_soe_sealjoker2')) then\n                eligible[#eligible + 1] = v\n            end\n        end\n        return #eligible > 0 and true or false\n    end,\n    use = function(self,card,area,copier)\n        local eligible = {}\n        for k, v in pairs(G.jokers.cards) do\n            if (not (v.ability.soe_legalenhancements and next(v.ability.soe_legalenhancements))) or next(SMODS.find_card('j_soe_sealjoker2')) then\n                eligible[#eligible + 1] = v\n            end\n        end\n        local highlighted = pseudorandom_element(eligible, pseudoseed('justice'))\n        if highlighted then\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    play_sound(\"tarot1\")\n                    highlighted:juice_up(0.3, 0.5)\n                    return true\n                end,\n            }))\n            G.E_MANAGER:add_event(Event({\n                trigger = \"after\",\n                delay = 0.1,\n                func = function()\n                    if highlighted then\n                        SEALS.set_joker_enhancement(highlighted, G.P_CENTERS.m_glass)\n                    end\n                    return true\n                end,\n            }))\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "eternalq",
      "name": null,
      "atlas": "What",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = 'eternalq',\n    set = 'Spectral',\n    atlas = 'What',\n    pos = {x = 0, y = 0},\n    unlocked = true,\n    discovered = true,\n    can_use = function(self,card)\n        local eligible = {}\n        for k, v in pairs(G.hand.cards) do\n            if not v.ability.eternal then\n                eligible[#eligible + 1] = v\n            end\n        end\n        return #eligible > 0 and true or false\n    end,\n    use = function(self,card,area,copier)\n        local eligible = {}\n        for k, v in pairs(G.hand.cards) do\n            if not v.ability.eternal then\n                eligible[#eligible + 1] = v\n            end\n        end\n        local highlighted = pseudorandom_element(eligible, pseudoseed('eternal'))\n        if highlighted then\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    play_sound(\"tarot1\")\n                    highlighted:juice_up(0.3, 0.5)\n                    return true\n                end,\n            }))\n            G.E_MANAGER:add_event(Event({\n                trigger = \"after\",\n                delay = 0.1,\n                func = function()\n                    if highlighted then\n                        SMODS.Stickers[\"eternal\"]:apply(highlighted, true)\n                    end\n                    return true\n                end,\n            }))\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "dejavuqq",
      "name": null,
      "atlas": "What",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = 'dejavuqq',\n    set = 'Spectral',\n    atlas = 'What',\n    pos = {x = 0, y = 0},\n    config = {mod_conv = \"Red\", cards = 1},\n    loc_vars = function(self,info_queue,center)\n        info_queue[#info_queue+1] = { key = \"red_seal_joker\", set = \"Other\"}\n    end,\n    unlocked = true,\n    discovered = true,\n    can_use = function(self,card)\n        local eligible = {}\n        for k, v in pairs(G.consumeables.cards) do\n            if IsEligibleForSeal(v) and v ~= card then\n                eligible[#eligible + 1] = v\n            end\n        end\n        return #eligible > 0 and true or false\n    end,\n    use = function(self,card,area,copier)\n        local eligible = {}\n        for k, v in pairs(G.consumeables.cards) do\n            if IsEligibleForSeal(v) and v ~= card then\n                eligible[#eligible + 1] = v\n            end\n        end\n        local highlighted = pseudorandom_element(eligible, pseudoseed('dejavu'))\n        if highlighted then\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    play_sound(\"tarot1\")\n                    highlighted:juice_up(0.3, 0.5)\n                    return true\n                end,\n            }))\n            G.E_MANAGER:add_event(Event({\n                trigger = \"after\",\n                delay = 0.1,\n                func = function()\n                    if highlighted then\n                        highlighted:set_seal(\"Red\", nil, true)\n                    end\n                    return true\n                end,\n            }))\n        end\n    end",
      "config": {
        "mod_conv": "Red",
        "cards": 1
      },
      "ability": {
        "mod_conv": "Red",
        "cards": 1
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "dejavuqqq",
      "name": null,
      "atlas": "What",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = 'dejavuqqq',\n    set = 'Spectral',\n    atlas = 'What',\n    pos = {x = 0, y = 0},\n    config = {mod_conv = \"Red\", cards = 1},\n    loc_vars = function(self,info_queue,center)\n        info_queue[#info_queue+1] = { key = \"red_seal_joker\", set = \"Other\"}\n    end,\n    unlocked = true,\n    discovered = true,\n    can_use = function(self,card)\n        if G.GAME.blind.seal then\n            return false\n        elseif G.GAME.blind.in_blind then\n            return true\n        end\n    end,\n    use = function(self,card,area,copier)\n        G.GAME.blind.seal = \"Red\"\n        if G.GAME.blind.config.blind.key == \"bl_akyrs_final_periwinkle_pinecone\" then\n            G.GAME.blind.permasealdebuffha = true\n        end\n    end",
      "config": {
        "mod_conv": "Red",
        "cards": 1
      },
      "ability": {
        "mod_conv": "Red",
        "cards": 1
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "ObjectType",
      "key": "soe_Synonyms",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"soe_Synonyms\",\n    default = \"c_soe_idiot\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "ObjectType",
      "key": "soe_Infinity",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = \"soe_Infinity\",\n    cards = {\n        j_soe_infinityred = true,\n        j_soe_infinityblue = true,\n        j_soe_infinitygold = true,\n        j_soe_infinitypurple = true,\n        j_soe_sealjoker = true,\n    },",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Voucher",
      "key": "orbitalconnoisseur",
      "name": null,
      "atlas": "VoucherSynonyms",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = 'orbitalconnoisseur',\n    cost = 10,\n    atlas = 'VoucherSynonyms',\n    pos = { x = 2, y = 0 },\n    unlocked = true,\n    discovered = true,\n    redeem = function (self, voucher)\n        G.soe_jokerhandsbutton.states.visible = true\n        G.soe_jokerhandsbutton.states.click.can = true\n        G.GAME.soe_joker_hands_available = true\n        G.GAME.soe_orbital_rate = 2\n    end,\n    unredeem = function (self, voucher)\n        G.soe_jokerhandsbutton.states.visible = false\n        G.soe_jokerhandsbutton.states.click.can = false\n        G.GAME.soe_joker_hands_available = false\n        G.GAME.soe_orbital_rate = 0\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Voucher",
      "key": "rerolloverflow",
      "name": null,
      "atlas": "VoucherSynonyms",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = 'rerolloverflow',\n    cost = 10,\n    atlas = 'VoucherSynonyms',\n    pos = {x = 0, y = 2},\n    unlocked = true,\n    discovered = true,\n    config = {extra = {discount = 25}},\n    loc_vars = function (self, info_queue, card)\n        return {vars = {card.ability.extra.discount}}\n    end,\n    redeem = function (self, voucher)\n        voucher.ability.extra.thunk = G.GAME.soe_reroll_discount_percent\n        G.GAME.soe_reroll_discount_percent = voucher.ability.extra.discount\n        calculate_reroll_cost(true)\n    end,\n    unredeem = function (self, voucher)\n        G.GAME.soe_reroll_discount_percent = voucher.ability.extra.thunk\n        calculate_reroll_cost(true)\n    end",
      "config": {
        "extra": {
          "discount": 25
        }
      },
      "ability": {
        "extra": {
          "discount": 25
        }
      },
      "vars": [
        25
      ],
      "infoQueue": []
    },
    {
      "type": "Voucher",
      "key": "legerdemain",
      "name": null,
      "atlas": "VoucherSynonyms",
      "pos": {
        "x": 4,
        "y": 2
      },
      "raw": "key = 'legerdemain',\n    cost = 10,\n    atlas = 'VoucherSynonyms',\n    pos = {x = 4, y = 2},\n    unlocked = true,\n    discovered = true,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Voucher",
      "key": "phantasm",
      "name": null,
      "atlas": "VoucherSynonyms",
      "pos": {
        "x": 4,
        "y": 3
      },
      "raw": "key = 'phantasm',\n    cost = 10,\n    atlas = 'VoucherSynonyms',\n    pos = {x = 4, y = 3},\n    requires = {'v_soe_legerdemain'},\n    unlocked = true,\n    discovered = true,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Voucher",
      "key": "deception",
      "name": null,
      "atlas": "Vouchers",
      "pos": {
        "x": 8,
        "y": 0
      },
      "raw": "key = 'deception',\n        cost = 10,\n        atlas = 'Vouchers',\n        pos = {x = 8, y = 0},\n        requires = {'v_soe_phantasm'},\n        unlocked = true,\n        discovered = true,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Gradient",
      "key": "synonym_gradient",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'synonym_gradient',\n    cycle = 5,\n    colours = {\n        HEX(\"2D5E5A\"),\n        HEX(\"A2334C\"),\n        HEX(\"882D33\"),\n    }",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "synonym_normal",
      "name": null,
      "atlas": "Boosters",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"synonym_normal\",\n    weight = 0.25,\n    kind = 'soe_Synonym',\n    cost = 4,\n    atlas = \"Boosters\",\n    pos = { x = 0, y = 0 },\n    config = { extra = 3, choose = 1 },\n    group_key = \"k_synonym_pack\",\n    draw_hand = true,\n    loc_vars = function(self, info_queue, card)\n        local cfg = (card and card.ability) or self.config\n        return {\n            vars = { cfg.choose, cfg.extra },\n        }\n    end,\n    ease_background_colour = function(self)\n        ease_colour(G.C.DYN_UI.MAIN, SMODS.Gradients.soe_synonym_gradient)\n        ease_background_colour{new_colour = SMODS.Gradients.soe_synonym_gradient, special_colour = darken(G.C.BLACK, 0.2), contrast = 1.5}\n    end,\n    update_pack = function (self, dt)\n        SMODS.Booster.update_pack(self, dt)\n        if G.STATE_COMPLETE then\n            self:ease_background_colour()\n            if G.booster_pack_sparkles then G.booster_pack_sparkles.colours = { lighten(SMODS.Gradients.soe_synonym_gradient, 0.1), SMODS.Gradients.soe_synonym_gradient, darken(SMODS.Gradients.soe_synonym_gradient, 0.1) } end\n        end\n    end,\n    particles = function(self)\n        G.booster_pack_sparkles = Particles(1, 1, 0, 0, {\n            timer = 0.015,\n            scale = 0.2,\n            initialize = true,\n            lifespan = 1,\n            speed = 1.1,\n            padding = -1,\n            attach = G.ROOM_ATTACH,\n            colours = { lighten(SMODS.Gradients.soe_synonym_gradient, 0.1), SMODS.Gradients.soe_synonym_gradient, darken(SMODS.Gradients.soe_synonym_gradient, 0.1) },\n            fill = true\n        })\n        G.booster_pack_sparkles.fade_alpha = 1\n        G.booster_pack_sparkles:fade(1, 0)\n    end,\n    create_card = function(self, card, i)\n        local _card = {set = \"soe_Synonyms\", area = G.pack_cards, skip_materialize = true, soulable = true, key_append = \"soe_synonympack\"}\n        if G.GAME.soe_joker_hands_available then return _card end\n        local set = SEALS.weighted_random({\n            soe_Vice = #G.P_CENTER_POOLS['soe_Vice'],\n            soe_Phantom = #G.P_CENTER_POOLS['soe_Phantom'],\n        }, \"synonym_pack\")\n        _card.set = set\n        return _card\n    end,",
      "config": {
        "extra": 3,
        "choose": 1
      },
      "ability": {
        "extra": 3,
        "choose": 1
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "j_joker",
      "name": "Joker",
      "atlas": "JokerEnhancements",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"j_joker\",\n    loc_txt = {\n        name = 'Joker',\n        text = {\n            '{C:red,s:1.1}+#1#{} Mult',\n        }\n    },\n    loc_vars = function(self, info_queue)\n        return {vars = {self.config.mult}}\n    end,\n    atlas = 'JokerEnhancements',\n    pos = {x = 0, y = 0},\n    config = {mult = 4},\n    replace_base_card = true,\n    always_scores = true,\n    no_suit = true,\n    no_rank = true,\n    weight = 0,\n    in_pool = function(self)\n        return false\n    end",
      "config": {
        "x": 0,
        "y": 0
      },
      "ability": {
        "x": 0,
        "y": 0
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "j_jolly",
      "name": "Jolly Joker",
      "atlas": "JokerEnhancements",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"j_jolly\",\n    loc_txt = {\n        name=\"Jolly Joker\",\n        text={\n            \"{C:red}+#1#{} Mult if played\",\n            \"hand contains\",\n            \"a {C:attention}#2#\",\n        },\n    },\n    loc_vars = function(self, info_queue)\n        return {vars = {self.config.extra.mult, self.config.extra.type}}\n    end,\n    atlas = 'JokerEnhancements',\n    pos = {x = 2, y = 0},\n    config = {extra = {mult = 8, type = 'Pair'}},\n    replace_base_card = true,\n    always_scores = true,\n    no_suit = true,\n    no_rank = true,\n    weight = 0,\n    in_pool = function(self)\n        return false\n    end,\n    calculate = function(self, card, context)\n        if context.cardarea == G.play and context.main_scoring and next(context.poker_hands[self.config.extra.type]) then\n            return {mult = self.config.extra.mult}\n        end\n    end",
      "config": {
        "x": 2,
        "y": 0
      },
      "ability": {
        "x": 2,
        "y": 0
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "j_zany",
      "name": "Zany Joker",
      "atlas": "JokerEnhancements",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"j_zany\",\n    loc_txt = {\n        name=\"Zany Joker\",\n        text={\n            \"{C:red}+#1#{} Mult if played\",\n            \"hand contains\",\n            \"a {C:attention}#2#\",\n        },\n    },\n    loc_vars = function(self, info_queue)\n        return {vars = {self.config.extra.mult, self.config.extra.type}}\n    end,\n    atlas = 'JokerEnhancements',\n    pos = {x = 3, y = 0},\n    config = {extra = {mult = 12, type = 'Three of a Kind'}},\n    replace_base_card = true,\n    always_scores = true,\n    no_suit = true,\n    no_rank = true,\n    weight = 0,\n    in_pool = function(self)\n        return false\n    end,\n    calculate = function(self, card, context)\n        if context.cardarea == G.play and context.main_scoring and next(context.poker_hands[self.config.extra.type]) then\n            return {mult = self.config.extra.mult}\n        end\n    end",
      "config": {
        "x": 3,
        "y": 0
      },
      "ability": {
        "x": 3,
        "y": 0
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "j_blueprint",
      "name": "Blueprint",
      "atlas": "JokerEnhancements",
      "pos": {
        "x": 0,
        "y": 3
      },
      "raw": "key = \"j_blueprint\",\n    loc_txt = {\n        name=\"Blueprint\",\n        text={\n            \"Copies ability of\",\n            \"{C:attention}Playing Card{} to the right\",\n        },\n    },\n    atlas = 'JokerEnhancements',\n    pos = {x = 0, y = 3},\n    replace_base_card = true,\n    overrides_base_rank = true,\n    always_scores = true,\n    weight = 0,\n    in_pool = function(self)\n        return false\n    end,\n    calculate = function(self, card, context)\n        if card.area and card.area.cards then\n            local other_card\n            for i = 1, #card.area.cards do\n                if card.area.cards[i] == card and card.area.cards[i+1] then\n                    other_card = card.area.cards[i+1]\n                end\n            end\n            if other_card then\n                local eval, _ = eval_card(other_card, context)\n                local ret = {}\n                for k, v in pairs(eval) do\n                    if type(v) == 'table' and k ~= 'edition' and k ~= 'seals' then\n                        if not v.card then v.card = card end\n                        ret[#ret+1] = v\n                    end\n                end\n                return SMODS.merge_effects(ret)\n            end\n        end\n    end,\n    update = function(self, card, dt)\n        if G.play ~= nil then\n            if #G.play.cards ~= 0 then\n                for i = 1, #G.play.cards do\n                    if G.play.cards[i] == card then\n                        if #G.play.cards == 1 and i == 1 then\n                            card.ability.no_rank = true\n                            card.ability.no_suit = true\n                        else\n                            if i < #G.play.cards then\n                                local suit_prefix = G.play.cards[i+1].base.suit\n                                local rank_suffix = G.play.cards[i+1].base.value\n                                card.ability.no_rank = false\n                                card.ability.no_suit = false\n                                assert(SEALS.safe_change_base(card, suit_prefix, rank_suffix))\n                            end\n                        end\n                    end\n                end\n            end\n            if G.hand and G.hand.cards and #G.hand.cards ~= 0 then\n                for i = 1, #G.hand.cards do\n                    if G.hand.cards[i] == card then\n                        if #G.hand.cards == 1 and i == 1 then\n                            card.ability.no_rank = true\n                            card.ability.no_suit = true\n                        else\n                            if i < #G.hand.cards then\n                                local suit_prefix = G.hand.cards[i+1].base.suit\n                                local rank_suffix = G.hand.cards[i+1].base.value\n                                card.ability.no_rank = false\n                                card.ability.no_suit = false\n                                assert(SEALS.safe_change_base(card, suit_prefix, rank_suffix))\n                            end\n                        end\n                    end\n                end\n            end\n        end\n        if G.hand ~= nil then\n            if #G.hand.highlighted ~= 0 then\n                for i = 1, #G.hand.highlighted do\n                    if G.hand.highlighted[i] == card then\n                        if #G.hand.highlighted == 1 and i == 1 then\n                            card.ability.no_rank = true\n                            card.ability.no_suit = true\n                        else\n                            if i < #G.hand.highlighted then\n                                local suit_prefix = G.hand.highlighted[i+1].base.suit\n                                local rank_suffix = G.hand.highlighted[i+1].base.value\n                                card.ability.no_rank = false\n                                card.ability.no_suit = false\n                                assert(SEALS.safe_change_base(card, suit_prefix, rank_suffix))\n                            end\n                        end\n                    end\n                end\n            end\n        end\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "j_brainstorm",
      "name": "Brainstorm",
      "atlas": "JokerEnhancements",
      "pos": {
        "x": 7,
        "y": 7
      },
      "raw": "key = \"j_brainstorm\",\n    loc_txt = {\n        name=\"Brainstorm\",\n        text={\n            \"Copies the ability\",\n            \"of leftmost {C:attention}Playing Card\",\n        },\n    },\n    atlas = 'JokerEnhancements',\n    pos = {x = 7, y = 7},\n    replace_base_card = true,\n    always_scores = true,\n    no_rank = true,\n    weight = 0,\n    config = {extra = {blueprint = {}}},\n    in_pool = function(self)\n        return false\n    end,\n    calculate = function(self, card, context)\n        if card.area and card.area.cards then\n            local other_card\n            for i = 1, #card.area.cards do\n                if card.area.cards[i] == card and card.area.cards[i+1] then\n                    other_card = card.area.cards[i+1]\n                end\n            end\n            if other_card then\n                local eval, _ = eval_card(other_card, context)\n                local ret = {}\n                for k, v in pairs(eval) do\n                    if type(v) == 'table' and k ~= 'edition' and k ~= 'seals' then\n                        if not v.card then v.card = card end\n                        ret[#ret+1] = v\n                    end\n                end\n                return SMODS.merge_effects(ret)\n            end\n        end\n    end,\n    update = function(self, card, dt)\n        if G.play ~= nil then\n            if #G.play.cards ~= 0 then\n                if #G.play.cards[1] == card then\n                    card.ability.no_rank = true\n                    card.ability.no_suit = true\n                else\n                    local suit_prefix = G.play.cards[1].base.suit\n                    local rank_suffix = G.play.cards[1].base.value\n                    card.ability.no_rank = false\n                    card.ability.no_suit = false\n                    assert(SEALS.safe_change_base(card, suit_prefix, rank_suffix))\n                end\n            end\n            if G.hand and G.hand.cards and #G.hand.cards ~= 0 then\n                if G.hand.cards[1] == card then\n                    card.ability.no_rank = true\n                    card.ability.no_suit = true\n                else\n                    local suit_prefix = G.hand.cards[1].base.suit\n                    local rank_suffix = G.hand.cards[1].base.value\n                    card.ability.no_rank = false\n                    card.ability.no_suit = false\n                    assert(SEALS.safe_change_base(card, suit_prefix, rank_suffix))\n                end\n            end\n        end\n        if G.hand ~= nil then\n            if #G.hand.highlighted ~= 0 then\n                for i = 1, #G.hand.highlighted do\n                    if G.hand.highlighted[i] == card then\n                        if #G.hand.highlighted == 1 and i == 1 then\n                            card.ability.no_rank = true\n                            card.ability.no_suit = true\n                        else\n                            if i < #G.hand.highlighted then\n                                local suit_prefix = G.hand.highlighted[1].base.suit\n                                local rank_suffix = G.hand.highlighted[1].base.value\n                                card.ability.no_rank = false\n                                card.ability.no_suit = false\n                                assert(SEALS.safe_change_base(card, suit_prefix, rank_suffix))\n                            end\n                        end\n                    end\n                end\n            end\n        end\n    end,",
      "config": {
        "extra": {
          "blueprint": {}
        }
      },
      "ability": {
        "extra": {
          "blueprint": {}
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "j_burnt",
      "name": "Burnt Joker",
      "atlas": "JokerEnhancements",
      "pos": {
        "x": 3,
        "y": 7
      },
      "raw": "key = \"j_burnt\",\n    loc_txt = {\n        name=\"Burnt Joker\",\n        text={\n            \"Upgrade the level of\",\n            \"the first {C:attention}discarded\",\n            \"poker hand each round\",\n        },\n    },\n    atlas = 'JokerEnhancements',\n    pos = {x = 3, y = 7},\n    replace_base_card = true,\n    always_scores = true,\n    no_suit = true,\n    no_rank = true,\n    weight = 0,\n    in_pool = function(self)\n        return false\n    end,\n    calculate = function(self, card, context)\n        if context.pre_discard and G.GAME.current_round.discards_used <= 0 and not context.hook and context.cardarea ~= G.discard then\n            local text,disp_text = G.FUNCS.get_poker_hand_info(G.hand.highlighted)\n            card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = localize('k_upgrade_ex')})\n            update_hand_text({sound = 'button', volume = 0.7, pitch = 0.8, delay = 0.3}, {handname=localize(text, 'poker_hands'),chips = G.GAME.hands[text].chips, mult = G.GAME.hands[text].mult, level=G.GAME.hands[text].level})\n            level_up_hand(context.blueprint_card or card, text, nil, 1)\n            update_hand_text({sound = 'button', volume = 0.7, pitch = 1.1, delay = 0}, {mult = 0, chips = 0, handname = '', level = ''})\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "j_perkeo",
      "name": "Perkeo",
      "atlas": "JokerEnhancements",
      "pos": {
        "x": 7,
        "y": 8
      },
      "raw": "key = \"j_perkeo\",\n    loc_txt = {\n        name = 'Perkeo',\n        text = {\n            \"Creates a {C:dark_edition}Negative{} copy of\",\n            \"{C:attention}1{} random {C:attention}consumable{}\",\n            \"card in your possession\",\n            \"at the end of the {C:attention}shop\",\n        }\n    },\n    atlas = 'JokerEnhancements',\n    pos = {x = 7, y = 8},\n    replace_base_card = true,\n    always_scores = true,\n    no_suit = true,\n    no_rank = true,\n    weight = 0,\n    in_pool = function(self)\n        return false\n    end,\n    calculate = function(self, card, context)\n        if G.consumeables.cards[1] and context.main_scoring and context.cardarea == G.play then\n            G.E_MANAGER:add_event(Event({\n                func = function() \n                    local card = copy_card(pseudorandom_element(G.consumeables.cards, pseudoseed('perkeo')), nil)\n                    card:set_edition({negative = true}, true)\n                    card:add_to_deck()\n                    G.consumeables:emplace(card)\n                    card:juice_up()\n                    return true\n                end}))\n            card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = localize('k_duplicated_ex')})\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "DrawStep",
      "key": "perkeoenhance",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'perkeoenhance',\n    order = 15,\n    func = function(self)\n        if SMODS.has_enhancement(self, 'm_soe_j_perkeo') then\n            self.children.floating_sprite = Sprite(self.T.x, self.T.y, self.T.w, self.T.h, je, {x = 7, y = 9})\n            self.children.floating_sprite.role.draw_major = self\n            self.children.floating_sprite:draw_shader('dissolve', 0, nil, nil, self.children.center)\n            self.children.floating_sprite:draw_shader('dissolve', nil, nil, nil, self.children.center)\n        end\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "PokerHand",
      "key": "joker_central",
      "name": "Joker Central",
      "atlas": null,
      "pos": null,
      "raw": "key = \"joker_central\",\n    name = \"Joker Central\",\n    above_hand = abovehand,\n    visible = false,\n    chips = 250,\n    mult = 250,\n    l_chips = 25,\n    l_mult = 10,\n    example = {\n        { \"S_2\", true, enhancement = \"m_soe_j_joker\" },\n        { \"S_2\", true, enhancement = \"m_soe_j_perkeo\" },\n        { \"S_2\", true, enhancement = \"m_soe_j_joker\" },\n        { \"S_2\", true, enhancement = \"m_soe_j_perkeo\" },\n        { \"S_2\", true, enhancement = \"m_soe_j_perkeo\" },\n    },\n    evaluate = function(parts)\n        return parts.soe_jc_orig\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "PokerHandPart",
      "key": "jc_orig",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'jc_orig',\n    func = function(hand)\n        if #hand < 5 then return {} end\n        local ret = {}\n        local jokers = 0\n        for i = 1, #hand do\n            local v = hand[i].base.value\n            if v then\n                if table.contains(vanilla_jokers_as_enhanced, hand[i].config.center.key) and jokers < 5 then\n                jokers = jokers + 1\n                table.insert(ret, hand[i])\n                end\n            end\n        end\n        if jokers >= 5 and #ret >= 5 then\n            return { ret }\n        else\n            return {}\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "PokerHand",
      "key": "seal_flush",
      "name": "Seal Flush",
      "atlas": null,
      "pos": null,
      "raw": "key = \"seal_flush\",\n    name = \"Seal Flush\",\n    above_hand = \"Straight Flush\",\n    visible = false,\n    chips = 120,\n    mult = 20,\n    l_chips = 50,\n    l_mult = 10,\n    example = {\n        { \"H_T\", true, seal = \"Red\" },\n        { \"C_2\", true, seal = \"Red\" },\n        { \"C_5\", true, seal = \"Red\" },\n        { \"S_7\", true, seal = \"Red\" },\n        { \"D_3\", true, seal = \"Red\" },\n    },\n    evaluate = function(parts)\n        return parts.soe_sf_orig\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "PokerHandPart",
      "key": "sf_orig",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'sf_orig',\n    func = function(hand)\n        local ret = {}\n        local four_fingers = SMODS.four_fingers()\n        local seals = {}\n        for k, v in pairs(G.P_SEALS) do\n            table.insert(seals, v.key)\n        end\n        if #hand < four_fingers then\n            return ret\n        else\n            for j = 1, #seals do\n                local t = {}\n                local seal = seals[j]\n                local flush_count = 0\n                for i = 1, #hand do\n                    if SEALS.has_seal(hand[i], seal) then\n                        flush_count = flush_count + 1; t[#t + 1] = hand[i]\n                    end\n                end\n                if flush_count >= four_fingers then\n                    table.insert(ret, t)\n                    return ret\n                end\n            end\n            return {}\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "demjoker",
      "name": null,
      "atlas": "Planets",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "set = \"Planet\",\n\tkey = \"demjoker\",\n\tconfig = {hand_type = \"soe_joker_central\", softlock = true},\n\tpos = {x = 0, y = 0},\n\tatlas = \"Planets\",\n\tloc_vars = function(self, info_queue, center)\n\t\treturn {\n\t\t\tvars = {\n\t\t\t\tlocalize(\"soe_joker_central\", \"poker_hands\"),\n\t\t\t\tG.GAME.hands[\"soe_joker_central\"].level,\n\t\t\t\tG.GAME.hands[\"soe_joker_central\"].l_mult,\n\t\t\t\tG.GAME.hands[\"soe_joker_central\"].l_chips,\n\t\t\t\tcolours = {\n\t\t\t\t\t(\n\t\t\t\t\t\tto_big(G.GAME.hands[\"soe_joker_central\"].level) == to_big(1) and G.C.UI.TEXT_DARK\n\t\t\t\t\t\tor G.C.HAND_LEVELS[to_big(math.min(7, G.GAME.hands[\"soe_joker_central\"].level)):to_number()]\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\tend,",
      "config": {
        "hand_type": "soe_joker_central",
        "softlock": true
      },
      "ability": {
        "hand_type": "soe_joker_central",
        "softlock": true
      },
      "vars": [
        null,
        null,
        null,
        null,
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "PokerHand",
      "key": "nil",
      "name": "nil",
      "atlas": null,
      "pos": null,
      "raw": "key = \"nil\",\n    name = \"nil\",\n    above_hand = \"soe_joker_central\",\n    visible = false,\n    chips = 50,\n    mult = 25,\n    l_chips = 12,\n    l_mult = 12,\n    example = {\n        { \"C_T\", false},\n        { \"S_Q\", false},\n        { \"H_8\", false},\n        { \"S_J\", false},\n        { \"C_3\", false},\n    },\n    evaluate = function(parts)\n        return parts.soe_nil_orig\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "PokerHandPart",
      "key": "nil_orig",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'nil_orig',\n    func = function(hand)\n        if #SMODS.find_card('j_soe_reversesplash') > 0 then\n            local ret = {}\n            local cards = 0\n            for i = 1, #hand do\n                cards = cards + 1\n                table.insert(ret, hand[i])\n            end\n            if cards > 0 and #ret > 0 then\n                return { ret }\n            else\n                return {}\n            end\n        else\n            return {}\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Voucher",
      "key": "blueprint",
      "name": null,
      "atlas": "BlueprintVouchers",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = 'blueprint',\n    cost = 10,\n    atlas = 'BlueprintVouchers',\n    pos = { x = 0, y = 0 },\n    unlocked = true,\n    discovered = true,\n    loc_vars = function(self, info_queue, card)\n        return {vars = {localize({type = \"name_text\", set = \"Voucher\", key = G.GAME.blueprintvouchertocopy}) or \"Nothing\"}}\n    end,\n    calculate = function(self, card, context)\n        if G.GAME.blueprintvouchertocopy then\n            local other_voucher\n            for k, v in pairs(G.vouchers.cards) do\n                if v.config.center.key == G.GAME.blueprintvouchertocopy then\n                    other_voucher = v\n                    break\n                end\n            end\n            if other_voucher then\n                return SMODS.blueprint_effect(card, other_voucher, context)\n            else\n                G.GAME.blueprintvouchertocopy = nil\n            end\n        end\n    end",
      "vars": [
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Voucher",
      "key": "brainstorm",
      "name": null,
      "atlas": "BlueprintVouchers",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = 'brainstorm',\n    cost = 10,\n    atlas = 'BlueprintVouchers',\n    pos = { x = 1, y = 0 },\n    unlocked = true,\n    discovered = true,\n    loc_vars = function(self, info_queue, card)\n        return {vars = {localize({type = \"name_text\", set = \"Voucher\", key = G.GAME.brainstormvouchertocopy}) or \"Nothing\"}}\n    end,\n    calculate = function(self, card, context)\n        local other_voucher\n        for k, v in pairs(G.vouchers.cards) do\n            if v.config.center.key == G.GAME.brainstormvouchertocopy then\n                other_voucher = v\n                break\n            end\n        end\n        if other_voucher then\n            return SMODS.blueprint_effect(card, other_voucher, context)\n        else\n            G.GAME.brainstormvouchertocopy = nil\n        end\n    end",
      "vars": [
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "reversesplash",
      "name": "ReverseSplash",
      "atlas": "Placeholders",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "name = 'ReverseSplash',\n    key = 'reversesplash',\n    atlas = 'Placeholders',\n    pos = {x = 0, y = 0},\n    rarity = 1,\n    cost = 5,\n    unlocked = true,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    perishable_compat = true,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "ascendedjoker",
      "name": "AscendedJoker",
      "atlas": "JokerEnhancements",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "name = 'AscendedJoker',\n    key = 'ascendedjoker',\n    atlas = 'JokerEnhancements',\n    pos = {x = 0, y = 0},\n    soul_pos = {x = 1000, y = 1000},\n    rarity = 4,\n    cost = 30,\n    unlocked = true,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    perishable_compat = true,\n    config = {\n        frames = {\n            xlevels = 0,\n            ylevels = 0\n        },\n        extra = {\n            mult = 4,\n            suitmult = 3,\n            mpair = 8,\n            mtoak = 12,\n            mtwopair = 10,\n            mstraight = 12,\n            mflush = 10,\n            cpair = 50,\n            ctoak = 100,\n            ctwopair = 80,\n            cstraight = 100,\n            cflush = 80,\n            halfmult = 20,\n            xmult = 1,\n            normretriggers = 1,\n            chadretriggers = 2,\n            debt = 20,\n            chips = 0,\n            mystic = 15,\n            loyaltyremaining = 5,\n            freerolls = 1,\n            fibmult = 8,\n            scarychips = 30,\n            evenmult = 4,\n            oddchips = 31,\n            scholar = {chips = 20, mult = 4},\n            businessodds = 2,\n            businessmoney = 2,\n            ridethebusgain = 1,\n            spaceodds = 4,\n            eggsellgain = 3,\n            burglarhands = 3,\n            blackboardxmult = 3,\n            runnergain = 15,\n            runnerchips = 0,\n            icecreamchips = 100,\n            icecreamloss = 5,\n            bluechips = 2,\n            constellationgain = 0.1,\n            hikerchips = 5,\n            facelessmoney = 5,\n            greengainloss = 1,\n            todomoney = 4,\n            cavendish = 3,\n            cardsharp = 3,\n            redcardgain = 3,\n            madnessgain = 0.5,\n            squaregain = 4,\n            vampiregain = 0.1,\n            hologramgain = 0.25,\n            vagabondmoney = 4,\n            baronxmult = 1.5,\n            cloudninemoney = 1,\n            money = 0,\n            rocketgain = 1,\n            obeliskgain = 0.2,\n            photoxmult = 2,\n            giftmoney = 1,\n            turtlebean = {handsize = 5, loss = 1},\n            erosiongain = 4,\n            reservedparkingmoney = 1,\n            maininrebatemoney = 5,\n            tothemoongain = 1, \t\n            hallucinationodds = 2,\n            fortunegain = 1,\n            juggler = 1,\n            drunkard = 1,\n            stonejokergain = 25,\n            luckycatgain = 0.25,\n            baseballxmult = 1.5,\n            bullchips = 2,\n            tradingcardmoney = 3,\n            flashcardgain = 2,\n            popcornloss = 4,\n            pantsgain = 2,\n            ancientxmult = 1.5,\n            ramen = {xmult = 2, loss = 0.01},\n            walkie = {chips = 10, mult = 4},\n            seltzerhandsleft = 10,\n            isseltzerdranken = false,\n            castlegain = 3,\n            smileymult = 5,\n            campfiregain = 0.25,\n            goldenticketmoney = 4,\n            mrbonesrequire = 0.25,\n            acrobatxmult = 3,\n            troubadour = {handsize = 2, hands = 1},\n            throwbackgain = 0.25,\n            roughgemmoney = 1,\n            bloodstone = {odds = 2, xmult = 1.5},\n            arrowheadchips = 50,\n            onyxagatemult = 7,\n            glassgain = 0.75,\n            flowerxmult = 3,\n            weegain = 8,\n            merryandy = {discards = 3, handsize = 1},\n            idolxmult = 2,\n            seeingdoublexmult = 2,\n            matadormoney = 8,\n            hittheroadgain = 0.5,\n            duoxmult = 2,\n            trioxmult = 3,\n            familyxmult = 4,\n            orderxmult = 3,\n            tribexmult = 2,\n            stuntman = {chips = 250, handsize = 2},\n            invisiblerounds = 2,\n            satelitegain = 1,\n            shootthemoonmult = 13,\n            driverslicensexmult = 3,\n            bootstraps = {mult = 2, dollars = 5},\n            cainogain = 1,\n            tribouletxmult = 2,\n            yorickgain = 1,\n        }\n    },\n    add_to_deck = function (self, card, from_debuff)\n        G.GAME.round_resets.discards = G.GAME.round_resets.discards + card.ability.extra.drunkard + card.ability.extra.merryandy.discards\n        ease_discard(card.ability.extra.drunkard + card.ability.extra.merryandy.discards)\n        G.GAME.bankrupt_at = G.GAME.bankrupt_at - card.ability.extra.debt\n        for k, v in pairs(G.GAME.probabilities) do \n            G.GAME.probabilities[k] = v*2\n        end\n        SMODS.change_free_rerolls(1)\n        calculate_reroll_cost(true)\n        G.hand:change_size(card.ability.extra.turtlebean.handsize)\n        G.GAME.interest_amount = G.GAME.interest_amount + 1\n        G.E_MANAGER:add_event(Event({func = function()\n            for k, v in pairs(G.I.CARD) do\n                if v.set_cost then v:set_cost() end\n            end\n            return true\n        end }))\n        G.hand:change_size(card.ability.extra.troubadour.handsize)\n        G.GAME.round_resets.hands = G.GAME.round_resets.hands + card.ability.extra.troubadour.hands\n        G.hand:change_size(-card.ability.extra.stuntman.handsize)\n    end,\n    remove_from_deck = function (self, card, from_debuff)\n        G.GAME.round_resets.discards = G.GAME.round_resets.discards - card.ability.extra.drunkard - card.ability.extra.merryandy.discards\n        ease_discard(card.ability.extra.drunkard + card.ability.extra.merryandy.discards)\n        G.GAME.bankrupt_at = G.GAME.bankrupt_at + card.ability.extra.debt\n        for k, v in pairs(G.GAME.probabilities) do \n            G.GAME.probabilities[k] = v/2\n        end\n        SMODS.change_free_rerolls(-1)\n        calculate_reroll_cost(true)\n        G.hand:change_size(-card.ability.extra.turtlebean.handsize)\n        G.GAME.interest_amount = G.GAME.interest_amount - 1\n        G.E_MANAGER:add_event(Event({func = function()\n            for k, v in pairs(G.I.CARD) do\n                if v.set_cost then v:set_cost() end\n            end\n            return true\n        end }))\n        G.hand:change_size(-card.ability.extra.troubadour.handsize)\n        G.GAME.round_resets.hands = G.GAME.round_resets.hands + card.ability.extra.troubadour.hands\n        G.hand:change_size(card.ability.extra.stuntman.handsize)\n    end,\n    calculate = function(self, card, context)\n        if context.setting_blind and not (context.blueprint_card or self).getting_sliced then\n            --[[\n            local my_pos\n            for i = 1, #G.jokers.cards do\n                if G.jokers.cards[i] == card then my_pos = i; break end\n            end\n            if my_pos and G.jokers.cards[my_pos+1] and not G.jokers.cards[my_pos+1].ability.eternal and not G.jokers.cards[my_pos+1].getting_sliced and not context.blueprint then \n                local sliced_card = G.jokers.cards[my_pos+1]\n                sliced_card.getting_sliced = true\n                G.GAME.joker_buffer = G.GAME.joker_buffer - 1\n                G.E_MANAGER:add_event(Event({func = function()\n                    card.children.center:set_sprite_pos({x = 5, y = 5})\n                    G.GAME.joker_buffer = 0\n                    card.ability.extra.mult = card.ability.extra.mult + sliced_card.sell_cost*2\n                    card:juice_up(0.8, 0.8)\n                    sliced_card:start_dissolve({HEX(\"57ecab\")}, nil, 1.6)\n                    play_sound('slice1', 0.96+math.random()*0.08)\n                return true end }))\n                card_eval_status_text(card, 'extra', card, nil, nil, {message = localize{type = 'variable', key = 'a_mult', vars = {card.ability.extra.mult+2*sliced_card.sell_cost}}, colour = G.C.RED, no_juice = true})\n            end\n            ]]\n            --[[\n            local front = pseudorandom_element(G.P_CARDS, pseudoseed('marb_fr'))\n            G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n            local card = Card(G.discard.T.x + G.discard.T.w/2, G.discard.T.y, G.CARD_W, G.CARD_H, front, G.P_CENTERS.m_stone, {playing_card = G.playing_card})\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    card.children.center:set_sprite_pos({x = 3, y = 2})\n                    card:start_materialize({G.C.SECONDARY_SET.Enhanced})\n                    G.play:emplace(card)\n                    table.insert(G.playing_cards, card)\n                    return true\n                end}))\n            card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = localize('k_plus_stone'), colour = G.C.SECONDARY_SET.Enhanced})\n            ]]\n        end\n        if context.ending_shop then\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    card.children.center:set_sprite_pos({x = 7, y = 8})\n                    return true\n                end\n            }))\n            local eligibleJokers = {}\n            for i = 1, #G.consumeables.cards do\n                if G.consumeables.cards[i].ability.consumeable then\n                    eligibleJokers[#eligibleJokers + 1] = G.consumeables.cards[i]\n                end\n            end\n            if #eligibleJokers > 0 then\n                G.E_MANAGER:add_event(Event({\n                    func = function() \n                        local card = copy_card(pseudorandom_element(eligibleJokers, pseudoseed('perkeo')), nil)\n                        card:set_edition({negative = true}, true)\n                        card:add_to_deck()\n                        G.consumeables:emplace(card)\n                        card.ability.qty = 1\n                        return true\n                    end}))\n                card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = localize('k_duplicated_ex')})\n                return nil, true\n            end\n            return\n        end\n        if context.joker_main then\n            SMODS.calculate_effect({mult = card.ability.extra.mult, card = card}, card)\n            if next(context.poker_hands[\"Pair\"]) then\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        card.children.center:set_sprite_pos({x = 2, y = 0})\n                        return true\n                    end\n                }))\n                SMODS.calculate_effect({mult = card.ability.extra.mpair, card = card}, card)\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        card.children.center:set_sprite_pos({x = 0, y = 14})\n                        return true\n                    end\n                }))\n                SMODS.calculate_effect({chips = card.ability.extra.cpair, card = card}, card)\n            end\n            if next(context.poker_hands[\"Three of a Kind\"]) then\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        card.children.center:set_sprite_pos({x = 3, y = 0})\n                        return true\n                    end\n                }))\n                SMODS.calculate_effect({mult = card.ability.extra.mtoak, card = card}, card)\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        card.children.center:set_sprite_pos({x = 1, y = 14})\n                        return true\n                    end\n                }))\n                SMODS.calculate_effect({chips = card.ability.extra.ctoak, card = card}, card)\n            end\n            if next(context.poker_hands[\"Two Pair\"]) then\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        card.children.center:set_sprite_pos({x = 4, y = 0})\n                        return true\n                    end\n                }))\n                SMODS.calculate_effect({mult = card.ability.extra.mtwopair, card = card}, card)\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        card.children.center:set_sprite_pos({x = 2, y = 14})\n                        return true\n                    end\n                }))\n                SMODS.calculate_effect({chips = card.ability.extra.ctwopair, card = card}, card)\n            end\n            if next(context.poker_hands[\"Straight\"]) then\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        card.children.center:set_sprite_pos({x = 5, y = 0})\n                        return true\n                    end\n                }))\n                SMODS.calculate_effect({mult = card.ability.extra.mstraight, card = card}, card)\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        card.children.center:set_sprite_pos({x = 3, y = 14})\n                        return true\n                    end\n                }))\n                SMODS.calculate_effect({chips = card.ability.extra.cstraight, card = card}, card)\n            end\n            if next(context.poker_hands[\"Flush\"]) then\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        card.children.center:set_sprite_pos({x = 6, y = 0})\n                        return true\n                    end\n                }))\n                SMODS.calculate_effect({mult = card.ability.extra.mflush, card = card}, card)\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        card.children.center:set_sprite_pos({x = 4, y = 14})\n                        return true\n                    end\n                }))\n                SMODS.calculate_effect({chips = card.ability.extra.cflush, card = card}, card)\n            end\n            if #context.full_hand < 3 then\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        card.children.center:set_sprite_pos({x = 7, y = 0})\n                        return true\n                    end\n                }))\n                SMODS.calculate_effect({mult = card.ability.extra.halfmult, card = card}, card)\n            end\n            if G.GAME.current_round.discards_left == 0 then\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        card.children.center:set_sprite_pos({x = 2, y = 2})\n                        return true\n                    end\n                }))\n                SMODS.calculate_effect({mult = card.ability.extra.mystic, card = card}, card)\n            end\n            return nil, true\n        end\n        if context.individual then\n            if context.cardarea == G.play then\n                if context.other_card:is_suit(\"Hearts\") then\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            card.children.center:set_sprite_pos({x = 7, y = 1})\n                            return true\n                        end\n                    }))\n                    SMODS.calculate_effect({mult = card.ability.extra.suitmult, card = context.other_card}, card)\n                end\n                if context.other_card:is_suit(\"Diamonds\") then\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            card.children.center:set_sprite_pos({x = 6, y = 1})\n                            return true\n                        end\n                    }))\n                    SMODS.calculate_effect({mult = card.ability.extra.suitmult, card = context.other_card}, card)\n                end\n                if context.other_card:is_suit(\"Spades\") then\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            card.children.center:set_sprite_pos({x = 8, y = 1})\n                            return true\n                        end\n                    }))\n                    SMODS.calculate_effect({mult = card.ability.extra.suitmult, card = context.other_card}, card)\n                end\n                if context.other_card:is_suit(\"Clubs\") then\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            card.children.center:set_sprite_pos({x = 9, y = 1})\n                            return true\n                        end\n                    }))\n                    SMODS.calculate_effect({mult = card.ability.extra.suitmult, card = context.other_card}, card)\n                end\n                if context.other_card:is_suit(\"Diamonds\") then\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            card.children.center:set_sprite_pos({x = 9, y = 7})\n                            return true\n                        end\n                    }))\n                    SMODS.calculate_effect({dollars = card.ability.extra.roughgemmoney, card = context.other_card}, card)\n                end\n                if context.other_card:is_suit(\"Spades\") then\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            card.children.center:set_sprite_pos({x = 1, y = 8})\n                            return true\n                        end\n                    }))\n                    SMODS.calculate_effect({chips = card.ability.extra.arrowheadchips, card = context.other_card}, card)\n                end\n                if context.other_card:is_suit(\"Clubs\") then\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            card.children.center:set_sprite_pos({x = 2, y = 8})\n                            return true\n                        end\n                    }))\n                    SMODS.calculate_effect({mult = card.ability.extra.onyxagatemult, card = context.other_card}, card)\n                end\n                if context.other_card:is_suit(\"Hearts\") and SMODS.pseudorandom_probability(self, 'bloodstone', 1, card.ability.extra.bloodstone.odds) then\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            card.children.center:set_sprite_pos({x = 0, y = 8})\n                            return true\n                        end\n                    }))\n                    SMODS.calculate_effect({x_mult = card.ability.extra.bloodstone.xmult, card = context.other_card}, card)\n                end\n                if context.other_card:get_id() == 12 or context.other_card:get_id() == 13 then\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            card.children.center:set_sprite_pos({x = 4, y = 8})\n                            return true\n                        end\n                    }))\n                    SMODS.calculate_effect({x_mult = card.ability.extra.tribouletxmult, card = context.other_card}, card)\n                end\n                return nil, true\n            end\n            if context.cardarea == G.hand then\n                if not context.end_of_round then\n                    if context.other_card:get_id() == 12 then\n                        G.E_MANAGER:add_event(Event({\n                            func = function()\n                                card.children.center:set_sprite_pos({x = 2, y = 6})\n                                return true\n                            end\n                        }))\n                        if context.other_card.debuff then\n                            return {\n                                message = localize('k_debuffed'),\n                                colour = G.C.RED,\n                                card = card,\n                            }\n                        else\n                            return {\n                                mult = card.ability.extra.shootthemoonmult,\n                                card = card\n                            }\n                        end\n                    end\n                    if context.other_card:get_id() == 13 then\n                        G.E_MANAGER:add_event(Event({\n                            func = function()\n                                card.children.center:set_sprite_pos({x = 6, y = 12})\n                                return true\n                            end\n                        }))\n                        if context.other_card.debuff then\n                            return {\n                                message = localize('k_debuffed'),\n                                colour = G.C.RED,\n                                card = card,\n                            }\n                        else\n                            return {\n                                x_mult = card.ability.extra.baronxmult,\n                                card = card\n                            }\n                        end\n                    end\n                end\n            end\n        end\n        if context.repetition then\n            if context.cardarea == G.hand then\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        card.children.center:set_sprite_pos({x = 4, y = 1})\n                        return true\n                    end\n                })) \n                return {\n                    message = localize('k_again_ex'),\n                    repetitions = card.ability.extra.normretriggers,\n                    card = card,\n                }\n            end\n            if context.cardarea == G.play then\n                local retriggeramount = 0\n                if not card.ability.extra.isseltzerdranken then\n                    retriggeramount = retriggeramount + card.ability.extra.normretriggers\n                end\n                if context.other_card:is_face() then\n                    retriggeramount = retriggeramount + card.ability.extra.normretriggers\n                end\n                if context.other_card:get_id() == 2 or context.other_card:get_id() == 3 or context.other_card:get_id() == 4 or context.other_card:get_id() == 5 then\n                    retriggeramount = retriggeramount + card.ability.extra.normretriggers\n                end\n                if G.GAME.current_round.hands_left == 0 then\n                    retriggeramount = retriggeramount + card.ability.extra.normretriggers\n                end\n                if context.other_card == context.scoring_hand[1] then\n                    retriggeramount = retriggeramount + card.ability.extra.chadretriggers\n                end\n                return {\n                    message = localize('k_again_ex'),\n                    repetitions = retriggeramount,\n                    card = card,\n                }\n            end\n        end\n        if context.after then\n            if card.ability.extra.seltzerhandsleft - 1 <= 0 and not card.ability.extra.isseltzerdranken then\n                card.ability.extra.seltzerhandsleft = 0\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        card.children.center:set_sprite_pos({x = 3, y = 15})\n                        play_sound('tarot1')\n                        card:juice_up(0.3, 0.4)\n                        return true\n                    end\n                })) \n                SMODS.calculate_effect({message = localize('k_drank_ex'), colour = G.C.FILTER}, card)\n                card.ability.extra.isseltzerdranken = true\n            elseif not card.ability.extra.isseltzerdranken then\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        card.children.center:set_sprite_pos({x = 3, y = 15})\n                        return true\n                    end\n                }))\n                card.ability.extra.seltzerhandsleft = card.ability.extra.seltzerhandsleft - 1\n                SMODS.calculate_effect({message = card.ability.extra.seltzerhandsleft..'', colour = G.C.FILTER}, card)\n            end\n        end\n    end,\n    update = function(self, card, dt)\n        if card.children.center.sprite_pos and card.children.center.sprite_pos.x >= 3 and card.children.center.sprite_pos.x <= 7 and card.children.center.sprite_pos.y == 8 then\n            card.children.floating_sprite:set_sprite_pos({x = card.children.center.sprite_pos.x, y = card.children.center.sprite_pos.y + 1})\n        elseif card.children.center.sprite_pos and card.children.center.sprite_pos.x == 4  and card.children.center.sprite_pos.y == 12 then\n            card.children.floating_sprite:set_sprite_pos({x = 2, y = 9})\n        else\n            card.children.floating_sprite:set_sprite_pos({x = 1000, y = 1000})\n        end\n        --[[\n        anim = {}\n        if not anim.t then anim.t = 0 end\n        anim.t = anim.t + dt\n        if anim.t > 1/(anim.fps or 10) then\n            anim.t = anim.t - 1/(anim.fps or 10)\n            next_frame = true\n        end\n        ]]\n        --[[\n        if true then\n            card.ability.frames.xlevels = card.ability.frames.xlevels + 0.1\n            if card.ability.frames.ylevels >= 9 and card.ability.frames.ylevels < 10 then\n                card.ability.frames.ylevels = 10\n            end\n            if card.ability.frames.xlevels >= 9 then\n                card.ability.frames.ylevels = card.ability.frames.ylevels + 0.1\n            end\n            if card.ability.frames.xlevels >= 10 then\n                card.ability.frames.xlevels = 0\n            end\n            if card.ability.frames.ylevels >= 15 then\n                card.ability.frames.xlevels = 0\n                card.ability.frames.ylevels = 0\n            end\n            card.children.center:set_sprite_pos({x = math.floor(card.ability.frames.xlevels), y = math.floor(card.ability.frames.ylevels)})\n        end\n        ]]\n    end,\n    in_pool = function(self)\n        return false\n    end",
      "config": {
        "frames": {
          "xlevels": 0,
          "ylevels": 0
        },
        "extra": {
          "mult": 4,
          "suitmult": 3,
          "mpair": 8,
          "mtoak": 12,
          "mtwopair": 10,
          "mstraight": 12,
          "mflush": 10,
          "cpair": 50,
          "ctoak": 100,
          "ctwopair": 80,
          "cstraight": 100,
          "cflush": 80,
          "halfmult": 20,
          "xmult": 1,
          "normretriggers": 1,
          "chadretriggers": 2,
          "debt": 20,
          "chips": 0,
          "mystic": 15,
          "loyaltyremaining": 5,
          "freerolls": 1,
          "fibmult": 8,
          "scarychips": 30,
          "evenmult": 4,
          "oddchips": 31,
          "scholar": {
            "chips": 20,
            "mult": 4
          },
          "businessodds": 2,
          "businessmoney": 2,
          "ridethebusgain": 1,
          "spaceodds": 4,
          "eggsellgain": 3,
          "burglarhands": 3,
          "blackboardxmult": 3,
          "runnergain": 15,
          "runnerchips": 0,
          "icecreamchips": 100,
          "icecreamloss": 5,
          "bluechips": 2,
          "constellationgain": 0.1,
          "hikerchips": 5,
          "facelessmoney": 5,
          "greengainloss": 1,
          "todomoney": 4,
          "cavendish": 3,
          "cardsharp": 3,
          "redcardgain": 3,
          "madnessgain": 0.5,
          "squaregain": 4,
          "vampiregain": 0.1,
          "hologramgain": 0.25,
          "vagabondmoney": 4,
          "baronxmult": 1.5,
          "cloudninemoney": 1,
          "money": 0,
          "rocketgain": 1,
          "obeliskgain": 0.2,
          "photoxmult": 2,
          "giftmoney": 1,
          "turtlebean": {
            "handsize": 5,
            "loss": 1
          },
          "erosiongain": 4,
          "reservedparkingmoney": 1,
          "maininrebatemoney": 5,
          "tothemoongain": 1,
          "hallucinationodds": 2,
          "fortunegain": 1,
          "juggler": 1,
          "drunkard": 1,
          "stonejokergain": 25,
          "luckycatgain": 0.25,
          "baseballxmult": 1.5,
          "bullchips": 2,
          "tradingcardmoney": 3,
          "flashcardgain": 2,
          "popcornloss": 4,
          "pantsgain": 2,
          "ancientxmult": 1.5,
          "ramen": {
            "xmult": 2,
            "loss": 0.01
          },
          "walkie": {
            "chips": 10,
            "mult": 4
          },
          "seltzerhandsleft": 10,
          "isseltzerdranken": false,
          "castlegain": 3,
          "smileymult": 5,
          "campfiregain": 0.25,
          "goldenticketmoney": 4,
          "mrbonesrequire": 0.25,
          "acrobatxmult": 3,
          "troubadour": {
            "handsize": 2,
            "hands": 1
          },
          "throwbackgain": 0.25,
          "roughgemmoney": 1,
          "bloodstone": {
            "odds": 2,
            "xmult": 1.5
          },
          "arrowheadchips": 50,
          "onyxagatemult": 7,
          "glassgain": 0.75,
          "flowerxmult": 3,
          "weegain": 8,
          "merryandy": {
            "discards": 3,
            "handsize": 1
          },
          "idolxmult": 2,
          "seeingdoublexmult": 2,
          "matadormoney": 8,
          "hittheroadgain": 0.5,
          "duoxmult": 2,
          "trioxmult": 3,
          "familyxmult": 4,
          "orderxmult": 3,
          "tribexmult": 2,
          "stuntman": {
            "chips": 250,
            "handsize": 2
          },
          "invisiblerounds": 2,
          "satelitegain": 1,
          "shootthemoonmult": 13,
          "driverslicensexmult": 3,
          "bootstraps": {
            "mult": 2,
            "dollars": 5
          },
          "cainogain": 1,
          "tribouletxmult": 2,
          "yorickgain": 1
        }
      },
      "ability": {
        "frames": {
          "xlevels": 0,
          "ylevels": 0
        },
        "extra": {
          "mult": 4,
          "suitmult": 3,
          "mpair": 8,
          "mtoak": 12,
          "mtwopair": 10,
          "mstraight": 12,
          "mflush": 10,
          "cpair": 50,
          "ctoak": 100,
          "ctwopair": 80,
          "cstraight": 100,
          "cflush": 80,
          "halfmult": 20,
          "xmult": 1,
          "normretriggers": 1,
          "chadretriggers": 2,
          "debt": 20,
          "chips": 0,
          "mystic": 15,
          "loyaltyremaining": 5,
          "freerolls": 1,
          "fibmult": 8,
          "scarychips": 30,
          "evenmult": 4,
          "oddchips": 31,
          "scholar": {
            "chips": 20,
            "mult": 4
          },
          "businessodds": 2,
          "businessmoney": 2,
          "ridethebusgain": 1,
          "spaceodds": 4,
          "eggsellgain": 3,
          "burglarhands": 3,
          "blackboardxmult": 3,
          "runnergain": 15,
          "runnerchips": 0,
          "icecreamchips": 100,
          "icecreamloss": 5,
          "bluechips": 2,
          "constellationgain": 0.1,
          "hikerchips": 5,
          "facelessmoney": 5,
          "greengainloss": 1,
          "todomoney": 4,
          "cavendish": 3,
          "cardsharp": 3,
          "redcardgain": 3,
          "madnessgain": 0.5,
          "squaregain": 4,
          "vampiregain": 0.1,
          "hologramgain": 0.25,
          "vagabondmoney": 4,
          "baronxmult": 1.5,
          "cloudninemoney": 1,
          "money": 0,
          "rocketgain": 1,
          "obeliskgain": 0.2,
          "photoxmult": 2,
          "giftmoney": 1,
          "turtlebean": {
            "handsize": 5,
            "loss": 1
          },
          "erosiongain": 4,
          "reservedparkingmoney": 1,
          "maininrebatemoney": 5,
          "tothemoongain": 1,
          "hallucinationodds": 2,
          "fortunegain": 1,
          "juggler": 1,
          "drunkard": 1,
          "stonejokergain": 25,
          "luckycatgain": 0.25,
          "baseballxmult": 1.5,
          "bullchips": 2,
          "tradingcardmoney": 3,
          "flashcardgain": 2,
          "popcornloss": 4,
          "pantsgain": 2,
          "ancientxmult": 1.5,
          "ramen": {
            "xmult": 2,
            "loss": 0.01
          },
          "walkie": {
            "chips": 10,
            "mult": 4
          },
          "seltzerhandsleft": 10,
          "isseltzerdranken": false,
          "castlegain": 3,
          "smileymult": 5,
          "campfiregain": 0.25,
          "goldenticketmoney": 4,
          "mrbonesrequire": 0.25,
          "acrobatxmult": 3,
          "troubadour": {
            "handsize": 2,
            "hands": 1
          },
          "throwbackgain": 0.25,
          "roughgemmoney": 1,
          "bloodstone": {
            "odds": 2,
            "xmult": 1.5
          },
          "arrowheadchips": 50,
          "onyxagatemult": 7,
          "glassgain": 0.75,
          "flowerxmult": 3,
          "weegain": 8,
          "merryandy": {
            "discards": 3,
            "handsize": 1
          },
          "idolxmult": 2,
          "seeingdoublexmult": 2,
          "matadormoney": 8,
          "hittheroadgain": 0.5,
          "duoxmult": 2,
          "trioxmult": 3,
          "familyxmult": 4,
          "orderxmult": 3,
          "tribexmult": 2,
          "stuntman": {
            "chips": 250,
            "handsize": 2
          },
          "invisiblerounds": 2,
          "satelitegain": 1,
          "shootthemoonmult": 13,
          "driverslicensexmult": 3,
          "bootstraps": {
            "mult": 2,
            "dollars": 5
          },
          "cainogain": 1,
          "tribouletxmult": 2,
          "yorickgain": 1
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "seeder",
      "name": "Seeder",
      "atlas": "Placeholders",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "name = 'Seeder',\n    key = 'seeder',\n    atlas = 'Placeholders',\n    pos = {x = 2, y = 0},\n    rarity = 3,\n    cost = 15,\n    unlocked = true,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    perishable_compat = true,\n    config = {\n        extra = {\n            seed = \"2K9H9HN\",\n            runnable = true\n        }\n    },\n    loc_vars = function(self,info_queue,card)\n        return {vars = {card.ability.extra.seed}}\n    end,\n    calculate = function(self, card, context)\n        if context.end_of_round and context.main_eval and context.game_over == false and G.GAME.blind.boss then\n            if not card.ability.extra.runnable then\n                card.ability.extra.runnable = true\n                return {\n                    message = localize('k_reset'),\n                }\n            end\n        end\n        if context.using_consumeable and card.ability.extra.runnable then\n            G.ENTERED_SEED = \"\"\n            G.E_MANAGER:add_event(Event({\n\t\t\t\tblockable = false,\n\t\t\t\tfunc = function()\n\t\t\t\t\tG.REFRESH_ALERTS = true\n\t\t\t\t\treturn true\n\t\t\t\tend,\n\t\t\t}))\n\t\t\tG.UIBOXGENERICOPTIONSREALLYSEED = create_UIBox_generic_options({\n\t\t\t\tno_back = true,\n\t\t\t\tcolour = HEX(\"04200c\"),\n\t\t\t\toutline_colour = G.C.SECONDARY_SET.Code,\n\t\t\t\tcontents = {\n\t\t\t\t\t{\n\t\t\t\t\t\tn = G.UIT.R,\n\t\t\t\t\t\tnodes = {\n\t\t\t\t\t\t\tcreate_text_input({\n\t\t\t\t\t\t\t\tcolour = G.C.SET.Code,\n\t\t\t\t\t\t\t\thooked_colour = darken(copy_table(G.C.SET.Code), 0.3),\n\t\t\t\t\t\t\t\tw = 4.5,\n\t\t\t\t\t\t\t\th = 1,\n\t\t\t\t\t\t\t\tmax_length = 8,\n\t\t\t\t\t\t\t\textended_corpus = true,\n\t\t\t\t\t\t\t\tprompt_text = \"ENTER A SEED\",\n\t\t\t\t\t\t\t\tref_table = G,\n\t\t\t\t\t\t\t\tref_value = \"ENTERED_SEED\",\n\t\t\t\t\t\t\t\tkeyboard_offset = 1,\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tn = G.UIT.R,\n\t\t\t\t\t\tconfig = { align = \"cm\" },\n\t\t\t\t\t\tnodes = {\n\t\t\t\t\t\t\tUIBox_button({\n\t\t\t\t\t\t\t\tcolour = G.C.SET.Code,\n\t\t\t\t\t\t\t\tbutton = \"seed_apply\",\n\t\t\t\t\t\t\t\tlabel = {\"SEED\"},\n\t\t\t\t\t\t\t\tminw = 4.5,\n\t\t\t\t\t\t\t\tfocus_args = { snap_to = true },\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t})\n            G.UIBOXFORSEED = UIBox({\n                definition = G.UIBOXGENERICOPTIONSREALLYSEED,\n                config = {\n                    align = \"cm\",\n                    offset = { x = 0, y = 10 },\n                    major = G.ROOM_ATTACH,\n                    bond = \"Weak\",\n                    instance_type = \"POPUP\",\n                },\n            })\n            G.UIBOXFORSEED.alignment.offset.y = 0\n            G.ROOM.jiggle = G.ROOM.jiggle + 1\n            G.UIBOXFORSEED:align_to_major()\n            G.FUNCS.seed_apply = function()\n                G.ENTERED_SEED = string.upper(G.ENTERED_SEED) or \"r\"\n                card.ability.extra.runnable = false\n                card.ability.extra.seed = G.ENTERED_SEED\n                G.GAME.pseudorandom.seed = G.ENTERED_SEED\n                G.GAME.pseudorandom.hashed_seed = pseudohash(G.GAME.pseudorandom.seed)\n                G.UIBOXFORSEED:remove()\n            end\n        end\n    end,\n    in_pool = function(self)\n        return false\n    end",
      "config": {
        "extra": {
          "seed": "2K9H9HN",
          "runnable": true
        }
      },
      "ability": {
        "extra": {
          "seed": "2K9H9HN",
          "runnable": true
        }
      },
      "vars": [
        "2K9H9HN"
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "c_talismanjoker",
      "name": "TalismanJoker",
      "atlas": "Tarots",
      "pos": {
        "x": 3,
        "y": 4
      },
      "raw": "name = 'TalismanJoker',\n    key = 'c_talismanjoker',\n    atlas = 'Tarots',\n    pos = {x = 3, y = 4},\n    rarity = 3,\n    cost = 10,\n    boostershader = true,\n    unlocked = true,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    perishable_compat = true,\n    calculate = function(self, card, context)\n        local free = false\n        if context.before then\n            local cards = {}\n            for k, v in pairs(context.scoring_hand) do\n                if IsEligibleForSeal(v) then\n                    table.insert(cards, v)\n                end\n            end\n            if #cards <= 0 then\n                return {\n                    message = localize('k_nope_ex'),\n                    card = card,\n                }\n            end\n            local randomcard = pseudorandom_element(cars, pseudoseed('talisman'))\n            if randomcard then\n                return {\n                    message = 'Talisman!',\n                    card = card,\n                    randomcard:set_seal('Gold')\n                }\n            end\n        end\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "thesouljoker",
      "name": "TheSoulJoker",
      "atlas": "Tarots",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "name = 'TheSoulJoker',\n    key = 'thesouljoker',\n    atlas = 'Tarots',\n    pos = {x = 2, y = 2},\n    rarity = 3,\n    cost = 10,\n    boostershader = true,\n    unlocked = true,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    perishable_compat = true,\n    calculate = function(self, card, context)\n        if context.before then\n            return {\n                message = localize('k_nope_ex'),\n                card = card,\n            }\n        end\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "DrawStep",
      "key": "thesoulpos",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'thesoulpos',\n    order = 20,\n    func = function(self)\n        if self.config.center.key == 'thesouljoker' then\n            local scale_mod = 0.05 + 0.05*math.sin(1.8*G.TIMERS.REAL) + 0.07*math.sin((G.TIMERS.REAL - math.floor(G.TIMERS.REAL))*math.pi*14)*(1 - (G.TIMERS.REAL - math.floor(G.TIMERS.REAL)))^3\n            local rotate_mod = 0.1*math.sin(1.219*G.TIMERS.REAL) + 0.07*math.sin((G.TIMERS.REAL)*math.pi*5)*(1 - (G.TIMERS.REAL - math.floor(G.TIMERS.REAL)))^2\n            \n            local sprite = Sprite(self.T.x, self.T.y, self.T.w, self.T.h, G.ASSET_ATLAS[\"soe_Enhancers\"], {x = 0, y = 1})\n            sprite.role.draw_major = self\n            sprite:draw_shader('dissolve',0, nil, nil, self.children.center,scale_mod, rotate_mod,nil, 0.1 + 0.03*math.sin(1.8*G.TIMERS.REAL),nil, 0.6)\n            sprite:draw_shader('dissolve', nil, nil, nil, self.children.center, scale_mod, rotate_mod)\n        end\n    end",
      "config": {
        "x": 0,
        "y": 1
      },
      "ability": {
        "x": 0,
        "y": 1
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "v_blankjoker",
      "name": "BlankJoker",
      "atlas": "Vouchers",
      "pos": {
        "x": 7,
        "y": 0
      },
      "raw": "name = 'BlankJoker',\n    key = 'v_blankjoker',\n    atlas = 'Vouchers',\n    pos = {x = 7, y = 0},\n    rarity = 3,\n    cost = 10,\n    vouchershader = true,\n    unlocked = true,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    perishable_compat = true,\n    config = {\n        extra = {\n            roundsleft = 20\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        return {vars = {card.ability.extra.roundsleft}}\n    end,\n    calculate = function(self, card, context)\n        if context.end_of_round and context.main_eval then\n            card.ability.extra.roundsleft = card.ability.extra.roundsleft - 1\n            if card.ability.extra.roundsleft <= 0 then\n                card:set_ability(G.P_CENTERS.j_soe_v_antimatterjoker)\n            else\n                return {\n                    message = 'Doing nothing...',\n                    sound = 'holo1'\n                }\n            end\n        end\n    end,",
      "config": {
        "extra": {
          "roundsleft": 20
        }
      },
      "ability": {
        "extra": {
          "roundsleft": 20
        }
      },
      "vars": [
        20
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "v_antimatterjoker",
      "name": "AntimatterJoker",
      "atlas": "Vouchers",
      "pos": {
        "x": 7,
        "y": 1
      },
      "raw": "name = 'AntimatterJoker',\n    key = 'v_antimatterjoker',\n    atlas = 'Vouchers',\n    pos = {x = 7, y = 1},\n    rarity = 4,\n    cost = 10,\n    negativeshader = true,\n    unlocked = true,\n    discovered = true,\n    no_doe = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    perishable_compat = true,\n    config = {\n        extra = {\n            weightmult = 105,\n            xmult = 1.2\n        }\n    },\n    loc_vars = function(self, info_queue, card)\n        return {vars = {card.ability.extra.xmult, card.ability.extra.weightmult}}\n    end,\n    calculate = function(self, card, context)\n        if (context.other_joker and context.other_joker.edition and context.other_joker.edition.key == 'e_negative') or (context.other_consumeable and context.other_consumeable.edition and context.other_consumeable.edition.key == 'e_negative') or (context.individual and context.other_card.edition and context.other_card.edition.key == 'e_negative' and not context.end_of_round) then\n            return {\n                Xmult_mod = card.ability.extra.xmult,\n                colour = G.C.MULT,\n                message = 'Negative!!',\n                card = card,\n            }\n        end\n    end,\n    in_pool = function(self)\n        return false\n    end",
      "config": {
        "extra": {
          "weightmult": 105,
          "xmult": 1.2
        }
      },
      "ability": {
        "extra": {
          "weightmult": 105,
          "xmult": 1.2
        }
      },
      "vars": [
        1.2,
        105
      ],
      "infoQueue": []
    },
    {
      "type": "DrawStep",
      "key": "boostershader",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'boostershader',\n    order = 10,\n    func = function(self)\n        if self.config.center.boostershader or self.ability.set == \"soe_Phantom\" then\n            self.children.center:draw_shader('booster',nil, self.ARGS.send_to_shader)\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "DrawStep",
      "key": "editionshaders",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'editionshaders',\n    order = 21,\n    func = function(self)\n        if self and self.edition and self.ability and self.ability.soe_editions then\n            for k, v in pairs(self.ability.soe_editions) do\n                if \"e_\"..v ~= self.edition.key then\n                    self.children.center:draw_shader(G.P_CENTERS[\"e_\"..v].shader,nil, self.ARGS.send_to_shader)\n                end\n            end\n        end\n    end,\n    conditions = {vortex = false, facing = 'front'},",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "DrawStep",
      "key": "vouchershader",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'vouchershader',\n    order = 20,\n    func = function(self)\n        if self.config.center.vouchershader or (self.ability and self.ability.soe_detached_seal == \"Gold\") then\n            self.children.center:draw_shader('voucher',nil, self.ARGS.send_to_shader)\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "unorganizedjoker",
      "name": "UnorganizedJoker",
      "atlas": "Placeholders",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "name = 'UnorganizedJoker',\n    key = 'unorganizedjoker',\n    atlas = 'Placeholders',\n    pos = {x = 3, y = 0},\n    rarity = unorganizedrarity,\n    cost = 20,\n    unlocked = true,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    perishable_compat = true,\n    config = {\n        extra = {\n            xmult = unorganizedxmult\n        }\n    },\n    loc_vars = function(self,info_queue,center)\n        return {vars = {center.ability.extra.xmult}}\n    end,\n    calculate = function(self, card, context)\n        if (context.other_joker and (context.other_joker:get_seal() or (context.other_joker.ability.soe_legalenhancements and next(context.other_joker.ability.soe_legalenhancements)) or context.other_joker.ability.legallysleeve)) or (context.other_consumeable and context.other_consumeable:get_seal()) then\n            return {\n                x_mult = card.ability.extra.xmult,\n                colour = G.C.MULT,\n                card = context.other_joker or context.other_consumeable\n            }\n        end\n        if context.individual then\n            for k, v in pairs(SMODS.Stickers) do\n                if context.other_card.ability[k] then\n                    return {\n                        x_mult = card.ability.extra.xmult,\n                        colour = G.C.MULT,\n                        card = context.other_card\n                    }\n                end\n            end\n        end\n    end,",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "kingofheartscardjoker",
      "name": "KingofHeartsCardJoker",
      "atlas": "PlayingCards",
      "pos": {
        "x": 11,
        "y": 0
      },
      "raw": "name = 'KingofHeartsCardJoker',\n    key = 'kingofheartscardjoker',\n    atlas = 'PlayingCards',\n    pos = {x = 11, y = 0},\n    rarity = 3,\n    cost = 10,\n    unlocked = true,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    perishable_compat = true,\n    calculate = function(self, card, context)\n        if context.individual and (context.cardarea == G.play or context.cardarea == G.hand) and not context.end_of_round then\n            local kingcontext = {cardarea = G.play, main_scoring = true, other_card = context.other_card}\n            local eval, post = eval_card(context.other_card, kingcontext)\n            for k, v in pairs(eval) do\n                if type(v) == 'table' then\n                    for k, v in pairs(v) do\n                        eval[k] = v\n                    end\n                end\n            end\n            return eval\n        end\n    end,\n    in_pool = function(self)\n        return false\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "extralife",
      "name": "ExtraLife",
      "atlas": "ExtraLife",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "name = 'ExtraLife',\n    key = 'extralife',\n    atlas = 'ExtraLife',\n    pos = {x = 0, y = 0},\n    rarity = 3,\n    cost = 10,\n    unlocked = true,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = false,\n    perishable_compat = true,\n    no_collection = true,\n    config = {\n        extra = {\n            lives = 1\n        }\n    },\n    loc_vars = function(self,info_queue,card)\n        return {vars = {card.ability.extra.lives}}\n    end,\n    calculate = function(self, card, context)\n        if context.game_over then\n            card.ability.extra.lives = card.ability.extra.lives - 1\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    G.hand_text_area.blind_chips:juice_up()\n                    G.hand_text_area.game_chips:juice_up()\n                    if card.ability.extra.lives < 1 then\n                        card:start_dissolve()\n                    end\n                    return true\n                end\n            }))\n            return {\n                message = localize('k_saved_ex'),\n                saved = \"k_life_used\",\n                colour = G.C.RED\n            }\n        end\n    end,\n    in_pool = function(self)\n        return false\n    end,\n    add_to_deck = function (self, card, from_debuff)\n        if next(SMODS.find_card('j_soe_extralife')) then\n            local total = 0\n            for i, v in ipairs(G.jokers.cards) do\n                if v ~= card and v.config.center.key == 'j_soe_extralife' then\n                    total = total + (v.ability.extra.lives or 0)\n                    v:start_dissolve()\n                end\n            end\n            card.ability.extra.lives = (card.ability.extra.lives or 0) + total\n        end\n        card:set_edition(\"e_negative\", true)\n    end",
      "config": {
        "extra": {
          "lives": 1
        }
      },
      "ability": {
        "extra": {
          "lives": 1
        }
      },
      "vars": [
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "sealjoker",
      "name": "SealJoker",
      "atlas": "Exotics",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "name = 'SealJoker',\n    key = 'sealjoker',\n    atlas = 'Exotics',\n    pos = {x = 0, y = 0},\n    soul_pos = {x = 1, y = 0},\n    rarity = exoticrarity,\n    cost = 55,\n    unlocked = true,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    perishable_compat = false,\n    loc_vars = function (self, info_queue, card)\n        info_queue[#info_queue + 1] = { key = \"sealevolve\", set = \"Other\" }\n        info_queue[#info_queue + 1] = G.P_CENTERS.j_soe_sealjoker2\n    end,\n    calculate = function (self, card, context)\n        if context.joker_main then\n            local passed = true\n            for k, v in pairs(G.playing_cards) do\n                if not (v.edition and next(SMODS.get_enhancements(v)) and v.seal and v.ability and #SEALS.get_seals(v) >= 2) then\n                    passed = false\n                    break\n                end\n            end\n            if passed then\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        play_sound(\"tarot1\")\n                        card:juice_up(0.3, 0.5)\n                        card:flip()\n                        return true\n                    end,\n                }))\n                G.E_MANAGER:add_event(Event({\n                    trigger = \"after\",\n                    delay = 0.1,\n                    func = function()\n                        if card then\n                            card:set_ability(G.P_CENTERS.j_soe_sealjoker2)\n                        end\n                        return true\n                    end,\n                }))\n                delay(0.5)\n                G.E_MANAGER:add_event(Event({\n                    trigger = \"after\",\n                    delay = 0.2,\n                    func = function()\n                        play_sound(\"tarot2\")\n                        card:set_cost()\n                        card:flip()\n                        return true\n                    end,\n                }))\n            end\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "sealjoker2",
      "name": "SealJoker2",
      "atlas": "Exotics",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "name = 'SealJoker2',\n    key = 'sealjoker2',\n    atlas = 'Exotics',\n    pos = {x = 0, y = 0},\n    soul_pos = {x = 1, y = 0},\n    rarity = (Entropy and \"entr_entropic\") or exoticrarity,\n    cost = 55,\n    unlocked = true,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    perishable_compat = false,\n    in_pool = function(self)\n        return false\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "thinkingemoji",
      "name": "ThinkingEmoji",
      "atlas": "Think",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "name = 'ThinkingEmoji',\n        key = 'thinkingemoji',\n        atlas = 'Think',\n        pos = {x = 0, y = 0},\n        soul_pos = {x = 1, y = 0},\n        config = {extra = {emult_mod = 0.2, idea_count = 19, sealemult = 2.2}},\n        rarity = \"cry_exotic\",\n        cost = 62,\n        unlocked = true,\n        discovered = true,\n        blueprint_compat = true,\n        eternal_compat = true,\n        perishable_compat = false,\n        loc_vars = function(self,info_queue,card)\n            return {vars = {card.ability.extra.emult_mod, card.ability.extra.emult or (1 + (card.ability.extra.emult_mod * card.ability.extra.idea_count)), card.ability.extra.sealemult}}\n        end,\n        calculate = function(self, card, context)\n            if context.joker_main then\n                card.ability.extra.emult = 1 + (card.ability.extra.emult_mod * card.ability.extra.idea_count)\n                return {\n                    emult = card.ability.extra.emult,\n                    emult_message = {\n                        message = \"^\"..card.ability.extra.emult..\" \"..localize(\"k_mult\"),\n                        colour =  G.C.DARK_EDITION,\n                        sound = Talisman and \"talisman_emult\" or \"cry_emult\",\n                    }\n                }\n            end\n            if context.other_main and context.other_main ~= card then\n                local key, set = context.other_main.config.center.key, context.other_main.config.center.set\n                local name = localize({type = 'name_text', key = key, set = set})\n                local description = ''\n                if type(G.localization.descriptions[set][key].text[1]) == 'string' then\n                    description = table.concat(G.localization.descriptions[set][key].text)\n                elseif type(G.localization.descriptions[set][key].text[1]) == 'table' then\n                    for i, v in ipairs(G.localization.descriptions[set][key].text) do\n                        description = description .. table.concat(v)\n                    end\n                end\n                local searchline = name .. description\n                searchline = string.gsub(searchline, \"{[^}]+",
      "config": {
        "extra": {
          "emult_mod": 0.2,
          "idea_count": 19,
          "sealemult": 2.2
        }
      },
      "ability": {
        "extra": {
          "emult_mod": 0.2,
          "idea_count": 19,
          "sealemult": 2.2
        }
      },
      "vars": [
        0.2,
        4.800000000000001,
        2.2
      ],
      "infoQueue": []
    },
    {
      "type": "Gradient",
      "key": "seal_gradient",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'seal_gradient',\n        colours = {\n            HEX('E8463D'),\n            HEX('009CFD'),\n            HEX('A267E4'),\n            HEX('F7AF38'),\n        }",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Rarity",
      "key": "infinity",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'infinity',\n    badge_colour = sealoverlords,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "infinityred",
      "name": "InfinityRed",
      "atlas": "InfinitySeals",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "name = 'InfinityRed',\n    key = 'infinityred',\n    atlas = 'InfinitySeals',\n    pos = {x = 0, y = 0},\n    soul_pos = {x = 4, y = 0},\n    rarity = 'soe_infinity',\n    cost = 55,\n    unlocked = true,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    perishable_compat = false,\n    calculate = function(self, card, context)\n\t\tif context.post_trigger and context.other_card.set_seal and not context.other_card:is_rarity('soe_infinity') then\n            return {\n                message = 'Red!!!',\n                colour = G.C.RED,\n                card = card,\n                message_card = card,\n                func = function()\n                    local other_card = context.other_card\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            other_card:set_seal('Red', nil, true)\n                            return true\n                        end\n                    }))\n                end\n            }\n\t\tend\n        if context.individual and context.cardarea == G.play then\n            return {\n                message = 'Red!!!',\n                colour = G.C.RED,\n                card = card,\n                message_card = card,\n                func = function()\n                    local other_card = context.other_card\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            other_card:set_seal('Red', nil, true)\n                            return true\n                        end\n                    }))\n                end\n            }\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "infinitypurple",
      "name": "InfinityPurple",
      "atlas": "InfinitySeals",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "name = 'InfinityPurple',\n    key = 'infinitypurple',\n    atlas = 'InfinitySeals',\n    pos = {x = 1, y = 0},\n    soul_pos = {x = 5, y = 0,},\n    rarity = 'soe_infinity',\n    cost = 55,\n    unlocked = true,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    perishable_compat = false,\n    calculate = function (self, card, context)\n        if ((context.individual and context.cardarea == G.play) or (context.post_trigger)) and next(SEALS.get_seals(context.other_card)) then\n            return {func = function()\n                local results = SEALS.forcetriggerseals(context.other_card)\n                if results then\n                    for i, v in ipairs(results) do\n                        v.message_card = card\n                        v.remove_default_message = true\n                        v.message = \"Sealtrigger!\"\n                        v.colour = G.C.PURPLE\n                        if cryptidyeohna then v.sound = \"cry_demitrigger\" end\n                    end\n                    results = SMODS.merge_effects(results)\n\n                    SMODS.calculate_effect(results, card)\n                end\n            end}\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "infinitygold",
      "name": "InfinityGold",
      "atlas": "InfinitySeals",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "name = 'InfinityGold',\n    key = 'infinitygold',\n    atlas = 'InfinitySeals',\n    pos = {x = 2, y = 0},\n    soul_pos = {x = 6, y = 0,\n    draw = function(card, scale_mod, rotate_mod)\n        card.children.floating_sprite:draw_shader('dissolve', 0, nil, nil, card.children.center, scale_mod, rotate_mod, nil, 0.1 + 0.03*math.sin(1.8*G.TIMERS.REAL),nil, 0.6)\n        card.children.floating_sprite:draw_shader('dissolve', nil, nil, nil, card.children.center, scale_mod, rotate_mod)\n        card.children.floating_sprite:draw_shader('voucher', 0, nil, nil, card.children.center, scale_mod, rotate_mod, nil, 0.1 + 0.03*math.sin(1.8*G.TIMERS.REAL),nil, 0.6)\n        card.children.floating_sprite:draw_shader('voucher', nil, nil, nil, card.children.center, scale_mod, rotate_mod)\n    end},\n    rarity = 'soe_infinity',\n    cost = 55,\n    unlocked = true,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    perishable_compat = false,\n    config = {extra = {dollars = 3}},\n    loc_vars = function(self, info_queue, card)\n        return {vars = {card.ability.extra.dollars}}\n    end,\n    calculate = function(self, card, context)\n        if context.post_trigger or (context.individual and (context.cardarea == G.play or context.cardarea == G.hand)) then\n            local other_card = context.other_main or context.other_card\n            local count = #SEALS.get_seals(other_card, nil, true)\n            if count > 0 then\n                return {\n                    message = 'Gold!!!',\n                    colour = G.C.GOLD,\n                    dollars = count*card.ability.extra.dollars,\n                    card = card,\n                    message_card = card,\n                    remove_default_message = true\n                }\n            end\n        end\n    end",
      "config": {
        "extra": {
          "dollars": 3
        }
      },
      "ability": {
        "extra": {
          "dollars": 3
        }
      },
      "vars": [
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "infinityblue",
      "name": "InfinityBlue",
      "atlas": "InfinitySeals",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "name = 'InfinityBlue',\n    key = 'infinityblue',\n    atlas = 'InfinitySeals',\n    pos = {x = 3, y = 0},\n    soul_pos = {x = 7, y = 0},\n    rarity = 'soe_infinity',\n    cost = 55,\n    config = {extra = {odds = 8}},\n    unlocked = true,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    perishable_compat = false,\n    loc_vars = function (self, info_queue, card)\n        local numerator, denominator = SMODS.get_probability_vars(card, 1, card.ability.extra.odds)\n        return {vars = {numerator, denominator}}\n    end,\n    calculate = function (self, card, context)\n        --[[\n        if context.using_consumeable and context.consumeable.ability.set == \"Planet\" then\n            table.insert(card.ability.extra.planets, context.consumeable.config.center.key)\n            return {\n                message = localize('k_upgrade_ex'),\n                colour = G.C.BLUE\n            }\n        end\n        if context.joker_main and next(card.ability.extra.planets) then\n            return {func = function()\n                SMODS.calculate_effect({message = \"Blue!!!\", colour = G.C.BLUE}, card)\n                local vals_after_level\n                if SMODS.displaying_scoring then\n                    vals_after_level = copy_table(G.GAME.current_round.current_hand)\n                    vals_after_level.level = (G.GAME.hands[vals_after_level.handname] or {}).level or ''\n                end\n                for i, v in ipairs(card.ability.extra.planets) do\n                    local center = G.P_CENTERS[v]\n                    local fake_card = {config = {}}\n                    SEALS.safe_set_ability(fake_card, center, true)\n                    for k, v in pairs(Card) do\n                        if type(v) == 'function' then\n                            fake_card[k] = v\n                        end\n                    end\n                    fake_card.juice_up = function(self, ...) return card:juice_up(...) end\n                    SMODS.calculate_effect({message = localize({type = \"name_text\", key = v, set = \"Planet\"}), colour = G.C.BLUE}, card)\n                    Card.use_consumeable(fake_card)\n                end\n                update_hand_text({sound = 'button', volume = 0.7, pitch = 1.1, delay = 0}, vals_after_level or {mult = 0, chips = 0, handname = '', level = ''})\n            end}\n        end\n        ]]\n        if context.individual and context.cardarea == G.play and not (context.other_card.area == G.jokers and context.other_card.ability.set == 'Joker') then\n            if SMODS.pseudorandom_probability(card, 'infinityblue', 1, card.ability.extra.odds) then\n                return {\n                    message = localize('k_copied_ex'),\n                    message_card = card,\n                    colour = G.C.BLUE,\n                    func = function()\n                        local other_card = context.other_card\n                        SEALS.event(function()\n                            local enhancements, seals, editions = SEALS.get_enhancements(other_card), SEALS.get_seals(other_card), {}\n                            if other_card.edition then table.insert(editions, other_card.edition.type) end\n                            for i, v in ipairs(SEALS.get_quantum_editions(other_card)) do\n                                table.insert(editions, v)\n                            end\n                            editions[1] = 'negative'\n                            local newcard = SMODS.add_card({key = 'j_joker', seal = seals[1], edition = 'e_negative'})\n                            if enhancements[1] and G.P_CENTERS[enhancements[1]] and (G.P_CENTERS[enhancements[1]].replace_base_card or enhancements[1] == 'm_stone') then\n                                newcard:set_ability('j_soe_'..(enhancements[1] == 'm_stone' and 'stone' or G.P_CENTERS[enhancements[1]].original_key or enhancements[1])..'cardjoker')\n                            end\n                            newcard:set_base(other_card.config.card)\n                            newcard.ability.soe_quantum_suits = other_card.ability.soe_quantum_suits\n                            newcard.ability.soe_quantum_ranks = other_card.ability.soe_quantum_ranks\n                            newcard.ability.soe_editions = editions\n                            for i, v in ipairs(enhancements) do\n                                if i > 1 or not (enhancements[1] and G.P_CENTERS[enhancements[1]] and (G.P_CENTERS[enhancements[1]].replace_base_card or enhancements[1] == 'm_stone')) then\n                                    SEALS.set_joker_enhancement(newcard, v)\n                                end\n                            end\n                            for i, v in ipairs(seals) do\n                                if i > 1 then\n                                    newcard:set_seal(v, true, true)\n                                end\n                            end\n                            return true\n                        end)\n                    end\n                }\n            end\n        end\n    end",
      "config": {
        "extra": {
          "odds": 8
        }
      },
      "ability": {
        "extra": {
          "odds": 8
        }
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Sounds",
      "key": "sealseal",
      "name": "SealSeal",
      "atlas": "Seals",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = 'sealseal',\n    name = 'SealSeal',\n    badge_colour = HEX('E8463D'),\n    atlas = 'Seals',\n    pos = { x = 0, y = 0 },\n    config = {omult = 5},\n    loc_vars = function(self, info_queue)\n        return {vars = {self.config.omult}}\n    end,\n    calculate = function(self, card, context)\n        if card.ability.soe_quantum_seals and #card.ability.soe_quantum_seals > 0 and context.before then\n            local adjacentright, adjacentleft\n            if context.cardarea == G.jokers or context.cardarea == G.hand or context.cardarea == G.consumeables or context.cardarea == G.play then\n                for i=1, #card.area.cards do\n                    if card.area.cards[i] == card then\n                        if card.area.cards[i+1] then\n                            adjacentright = card.area.cards[i+1]\n                        end\n                        if card.area.cards[i-1] then\n                            adjacentleft = card.area.cards[i-1]\n                        end\n                    end\n                end\n                if adjacentright then\n                    adjacentright:set_seal(card.extraseal)\n                end\n                if adjacentleft then\n                    adjacentleft:set_seal(card.extraseal)\n                end\n            end\n        end\n        if not card.extraseal and context.main_scoring then\n            return {\n                mult = self.config.omult,\n                colour = G.C.MULT,\n                card = card\n            }\n        end\n    end",
      "config": {
        "omult": 5
      },
      "ability": {
        "omult": 5
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Seal",
      "key": "rainbowseal",
      "name": "RainbowSeal",
      "atlas": "RainbowSeal",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = 'rainbowseal',\n    name = 'RainbowSeal',\n    badge_colour = G.C.DARK_EDITION,\n    atlas = 'RainbowSeal',\n    pos = { x = 0, y = 0 },",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Seal",
      "key": "reverseseal",
      "name": "ReverseSeal",
      "atlas": "Seals",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = 'reverseseal',\n    name = 'ReverseSeal',\n    badge_colour = G.C.UI.TEXT_DARK,\n    atlas = 'Seals',\n    pos = { x = 0, y = 0 },\n    config = {extra = {downxmult = 3}},\n    loc_vars = function (self, info_queue, card)\n        return {vars = {self.config.extra.downxmult}}\n    end",
      "config": {
        "extra": {
          "downxmult": 3
        }
      },
      "ability": {
        "extra": {
          "downxmult": 3
        }
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Seal",
      "key": "negativeseal",
      "name": "NegativeSeal",
      "atlas": "Enhancers",
      "pos": {
        "x": 6,
        "y": 4
      },
      "raw": "key = 'negativeseal',\n    name = 'NegativeSeal',\n    badge_colour = G.C.DARK_EDITION,\n    atlas = 'Enhancers',\n    pos = { x = 6, y = 4 },\n    draw = function(self, card, layer)\n        G.shared_seals[self.key].role.draw_major = card\n        G.shared_seals[self.key]:draw_shader('dissolve', nil, nil, nil, card.children.center)\n        G.shared_seals[self.key]:draw_shader('negative', nil, card.ARGS.send_to_shader, nil, card.children.center)\n        G.shared_seals[self.key]:draw_shader('negative_shine', nil, card.ARGS.send_to_shader, nil, card.children.center)\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Seal",
      "key": "carmineseal",
      "name": "CarmineSeal",
      "atlas": "Enhancers",
      "pos": {
        "x": 5,
        "y": 4
      },
      "raw": "key = 'carmineseal',\n    name = 'CarmineSeal',\n    badge_colour = HEX('FF0040'),\n    atlas = 'Enhancers',\n    pos = { x = 5, y = 4 },",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Seal",
      "key": "aquaseal",
      "name": "AquaSeal",
      "atlas": "Enhancers",
      "pos": {
        "x": 5,
        "y": 4
      },
      "raw": "key = 'aquaseal',\n    name = 'AquaSeal',\n    badge_colour = HEX('00FFFF'),\n    atlas = 'Enhancers',\n    pos = { x = 5, y = 4 },",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Seal",
      "key": "yellowseal",
      "name": "YellowSeal",
      "atlas": "Enhancers",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = 'yellowseal',\n    name = 'YellowSeal',\n    badge_colour = HEX('F7AF38'),\n    atlas = 'Enhancers',\n    pos = {x = 2, y = 0},",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Seal",
      "key": "foilseal",
      "name": "FoilSeal",
      "atlas": "Enhancers",
      "pos": {
        "x": 5,
        "y": 4
      },
      "raw": "key = 'foilseal',\n    name = 'FoilSeal',\n    badge_colour = G.C.DARK_EDITION,\n    atlas = 'Enhancers',\n    pos = { x = 5, y = 4 },\n    draw = function(self, card, layer)\n        G.shared_seals[self.key].role.draw_major = card\n        G.shared_seals[self.key]:draw_shader('dissolve', nil, nil, nil, card.children.center)\n        G.shared_seals[self.key]:draw_shader('foil', nil, card.ARGS.send_to_shader, nil, card.children.center)\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Seal",
      "key": "holoseal",
      "name": "HolographicSeal",
      "atlas": "Enhancers",
      "pos": {
        "x": 5,
        "y": 4
      },
      "raw": "key = 'holoseal',\n    name = 'HolographicSeal',\n    badge_colour = G.C.DARK_EDITION,\n    atlas = 'Enhancers',\n    pos = { x = 5, y = 4 },\n    draw = function(self, card, layer)\n        G.shared_seals[self.key].role.draw_major = card\n        G.shared_seals[self.key]:draw_shader('dissolve', nil, nil, nil, card.children.center)\n        G.shared_seals[self.key]:draw_shader('holo', nil, card.ARGS.send_to_shader, nil, card.children.center)\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Seal",
      "key": "rustyseal",
      "name": "RustySeal",
      "atlas": "Seals",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = 'rustyseal',\n    name = 'RustySeal',\n    badge_colour = HEX(\"D3795C\"),\n    atlas = 'Seals',\n    config = {extra = {xmult = 1.5}},\n    pos = { x = 1, y = 0 },\n    loc_vars = function(self, info_queue, card)\n        return {vars = {card.ability.seal.extra.xmult}}\n    end,\n    forcetrigger = function(self, card)\n        return {x_mult = card.ability.seal.extra.xmult}\n    end",
      "config": {
        "extra": {
          "xmult": 1.5
        }
      },
      "ability": {
        "extra": {
          "xmult": 1.5
        }
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "seal",
      "name": "AllSealsDeck",
      "atlas": "Enhancers",
      "pos": {
        "x": 5,
        "y": 2
      },
      "raw": "key = 'seal',\n    name = 'AllSealsDeck',\n    atlas = 'Enhancers',\n    pos = {x = 5, y = 2},",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Stake",
      "key": "seal",
      "name": "Seal Stake",
      "atlas": "Stakes",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = 'seal',\n    applied_stakes = {'stake_gold'},\n    loc_txt = {\n        name = 'Seal Stake',\n        text = {\n            'I dont know',\n        },\n        sticker = {\n            name = 'Seal Sticker',\n            text = {\n                'I dont know',\n            }\n        }\n    },\n    atlas = 'Stakes',\n    pos = {x = 0, y = 0},\n    colour = G.C.RED",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Achievement",
      "key": "completionist_plus_plus_plus",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'completionist_plus_plus_plus',\n    unlock_condition = function(self, args)\n        return G.PROGRESS.card_stickers.tally/G.PROGRESS.card_stickers.of >= 1 \n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "OPENED_BOOSTER",
      "key": "sealdeck",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'sealdeck', guaranteed = true",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "a_hands",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "calculate = function(self, card, context)\n            if context.setting_blind and not (context.blueprint_card or card).getting_sliced then\n                return {\n                    G.E_MANAGER:add_event(Event({func = function()\n                        ease_discard(-G.GAME.current_round.discards_left, nil, true)\n                        ease_hands_played(card.ability.extra)\n                        card_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = localize{type = 'variable', key = 'a_hands', vars = {card.ability.extra}}})\n                    return true end }))\n                }\n            end\n        end",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "j_soe_extralife",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "calculate = function(self, card, context)\n            if context.game_over and to_big(G.GAME.chips)/G.GAME.blind.chips >= to_big(0.25) and not context.retrigger_joker then\n                local effects = {{\n                    no_retrigger = true,\n                    message = localize('k_saved_ex'),\n                    saved = true,\n                    colour = G.C.RED,\n                }}\n                if SEALS.has_seal(card, 'Red') then\n                    table.insert(effects, {\n                        message = localize('k_again_ex'),\n                        colour = G.C.FILTER\n                    })\n                    table.insert(effects, {\n                        message = 'Extra Life!',\n                        func = function()\n                            SEALS.event(function()\n                                local extralife = SMODS.add_card({key = 'j_soe_extralife'})\n                                extralife.ability.extra.lives = SEALS.get_seal_count(card, 'Red')\n                                return true\n                            end)\n                        end\n                    })\n                end\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        G.hand_text_area.blind_chips:juice_up()\n                        G.hand_text_area.game_chips:juice_up()\n                        play_sound('tarot1')\n                        card:start_dissolve()\n                        return true\n                    end\n                }))\n                return SMODS.merge_effects(effects)\n            end\n        end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "DrawStep",
      "key": "sealsforall",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'sealsforall',\n    order = 100,\n    func = function(self)\n        if (self.ability.set ~= 'Joker' and (self.ability.set ~= 'Default' and self.ability.set ~= 'Enhanced')) and self.seal then\n            local seal = G.P_SEALS[self.seal] or {}\n            if type(seal.draw) == 'function' then\n                seal:draw(self, layer)\n            elseif self.seal then\n                G.shared_seals[self.seal].role.draw_major = self\n                G.shared_seals[self.seal]:draw_shader('dissolve', nil, nil, nil, self.children.center)\n                if self.seal == 'Gold' then G.shared_seals[self.seal]:draw_shader('voucher', nil, self.ARGS.send_to_shader, nil, self.children.center) end\n            end\n        end\n    end,\n    conditions = {vortex = false, facing = 'front'},",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "DrawStep",
      "key": "randomplacedsealsforall",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'randomplacedsealsforall',\n    order = 110,\n    func = function(self)\n        if self and self.ability and SEALS.get_seals(self, true) then\n            for i, v in ipairs(SEALS.get_seals(self, true)) do\n                if not self.children[\"extraseal\"..i] then\n                    self.children[\"extraseal\"..i] = Sprite(0, 0, 71, 95, G.ASSET_ATLAS[G.P_SEALS[v].atlas], G.P_SEALS[v].pos)\n                    self.children[\"extraseal\"..i].role.draw_major = self\n                    self.children[\"extraseal\"..i].scale.x = 32*self.T.scale\n                    self.children[\"extraseal\"..i].scale.y = 32*self.T.scale\n                    local pos = {x = pseudorandom(\"seal\"), y = pseudorandom(\"seal2\")}\n                    self.children[\"extraseal\"..i]:draw_shader('dissolve', 0, nil, nil, self.children.center, nil, nil, pos.x*(self.T.w/71), pos.y*(self.T.h/95) + (0.1+0.03*math.sin(1.8*G.TIMERS.REAL)), nil, 0.6)\n                    self.children[\"extraseal\"..i]:draw_shader('dissolve', nil, nil, nil, self.children.center, nil, nil, pos.x*(self.T.w/71), pos.y*(self.T.h/95))\n                end\n            end\n        end\n    end,\n    conditions = {vortex = false, facing = 'front'},",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "DrawStep",
      "key": "threeenhancementsforjokers",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'threeenhancementsforjokers',\n    order = 90,\n    func = function(self, card)\n        local passed = {}\n        for k, v in pairs(self.ability.soe_legalenhancements or {}) do\n            if (k == 'm_wild' or k == 'm_bonus' or k == 'm_mult') and not passed[k] then\n                G.shared_jokerenhancements[k].role.draw_major = self\n                G.shared_jokerenhancements[k]:draw_shader('dissolve', nil, nil, nil, self.children.center)\n                passed[k] = true\n            end\n        end\n    end,\n    conditions = {vortex = false, facing = 'front'},",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "DrawStep",
      "key": "sleevesforjokersandplayingcards",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'sleevesforjokersandplayingcards',\n    order = 200,\n    func = function(self, card)\n        if self.ability.legallysleeve then\n            G.shared_sleeves[self.ability.legallysleeve].role.draw_major = self\n            G.shared_sleeves[self.ability.legallysleeve]:draw_shader('dissolve', nil, nil, nil, self.children.center)\n        end\n    end,\n    conditions = {vortex = false, facing = 'front'},",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "DrawStep",
      "key": "therestenhancementsforvanillajokers",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'therestenhancementsforvanillajokers',\n    order = 0,\n    func = function(self, card)\n        if self.ability.soe_legalenhancements and (self.ability.soe_legalenhancements.m_lucky or self.ability.soe_legalenhancements.m_gold or self.ability.soe_legalenhancements.m_steel or self.ability.soe_legalenhancements.m_glass) and not self.config.center.original_mod and G.shared_jokerfronts[self.config.center.key] then\n            if not self.oldatlas or not self.oldpos then\n                self.oldatlas = self.children.center.atlas\n                self.oldpos =  self.children.center.sprite_pos\n            end\n            self.children.center.atlas = G.ASSET_ATLAS[\"soe_Enhancers\"]\n            local center\n            for k, v in pairs(self.ability.soe_legalenhancements) do\n                if k == 'm_lucky' or k == 'm_gold' or k == 'm_steel' or k == 'm_glass' then\n                    center = G.P_CENTERS[k]\n                    break\n                end\n            end\n            self.children.center:set_sprite_pos(center.pos)\n            G.shared_jokerfronts[self.config.center.key].role.draw_major = self\n            G.shared_jokerfronts[self.config.center.key]:draw_shader('dissolve', nil, nil, nil, self.children.center)\n        elseif self.oldatlas and self.oldpos then\n            self.children.center.atlas = self.oldatlas\n            self.children.center:set_sprite_pos(self.oldpos)\n            self.oldatlas = nil\n            self.oldpos = nil\n        end\n    end,\n    conditions = {vortex = false, facing = 'front'},",
      "config": {
        "vortex": false,
        "facing": "front"
      },
      "ability": {
        "vortex": false,
        "facing": "front"
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "DrawStep",
      "key": "stickersforplayingcards",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'stickersforplayingcards',\n    order = 13,\n    func = function(self, card)\n        if (self.ability.set == 'Default' or self.ability.set == 'Enhanced') and G.playing_cards and self.facing == 'front' then\n            if self.sticker and G.shared_stickers[self.sticker] then\n                G.shared_stickers[self.sticker].role.draw_major = self\n                G.shared_stickers[self.sticker]:draw_shader('dissolve', nil, nil, nil, self.children.center)\n                G.shared_stickers[self.sticker]:draw_shader('voucher', nil, self.ARGS.send_to_shader, nil, self.children.center)\n            elseif (self.sticker_run and G.shared_stickers[self.sticker_run]) and G.SETTINGS.run_stake_stickers then\n                G.shared_stickers[self.sticker_run].role.draw_major = self\n                G.shared_stickers[self.sticker_run]:draw_shader('dissolve', nil, nil, nil, self.children.center)\n                G.shared_stickers[self.sticker_run]:draw_shader('voucher', nil, self.ARGS.send_to_shader, nil, self.children.center)\n            end\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "DrawStep",
      "key": "reversesealonback",
      "name": null,
      "atlas": null,
      "pos": null,
      "raw": "key = 'reversesealonback',\n    order = 14,\n    func = function(self, card)\n        if (self.seal == 'soe_reverseseal' or ((G and G.GAME and G.GAME.blind and G.GAME.blind.config.blind.key == 'bl_soe_theseal') and self.seal)) and self.facing == 'back' then\n            G.shared_seals[self.seal].role.draw_major = self\n            G.shared_seals[self.seal]:draw_shader('dissolve', nil, nil, nil, self.children.center)\n            if self.seal == 'Gold' then G.shared_seals[self.seal]:draw_shader('voucher', nil, self.ARGS.send_to_shader, nil, self.children.center) end\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "theseal",
      "name": null,
      "atlas": "Blinds",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = 'theseal',\n    atlas = 'Blinds',\n    discovered = true,\n    pos = {x = 0, y = 0},\n    dollars = 8,\n    boss = {min = 1, max = 10, showdown = true},\n    boss_colour = HEX('E8463D'),\n    stay_flipped = function (self, area, card)\n        return area == G.hand\n    end,\n    set_blind = function (self)\n        for k, v in pairs(G.jokers.cards) do\n            if v.facing == 'front' then\n                v:flip()\n            end\n        end\n        for k, v in pairs(G.consumeables.cards) do\n            if v.facing == 'front' then\n                v:flip()\n            end\n        end\n    end,\n    defeat = function (self)\n        for k, v in pairs(G.jokers.cards) do\n            if v.facing == 'back' then\n                v:flip()\n            end\n        end\n        for k, v in pairs(G.consumeables.cards) do\n            if v.facing == 'back' then\n                v:flip()\n            end\n        end\n    end,\n    disable = function (self)\n        for k, v in pairs(G.jokers.cards) do\n            if v.facing == 'back' then\n                v:flip()\n            end\n        end\n        for k, v in pairs(G.consumeables.cards) do\n            if v.facing == 'back' then\n                v:flip()\n            end\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    }
  ],
  "version": "3.0.0"
}