{
  "locMap": {
    "b_picubed_wonderfuldeck": {
      "name": "Wonderful Deck",
      "text": [
        "Start with a",
        "{C:dark_edition,T:e_foil}Foil{} {C:attention,T:j_picubed_talkingflower}Talking Flower{}"
      ],
      "type": "Back"
    },
    "b_picubed_myepicdeck": {
      "name": "my epic deck by pi_cubed",
      "text": [
        "{C:tarot}pi_cubed's Jokers{}' {C:attention}Jokers{}",
        "are {C:attention}3x{} more likely to appear,",
        "Start with an extra {C:money}$#1#"
      ],
      "type": "Back"
    },
    "b_picubed_rejuvinationdeck": {
      "name": "Rejuvenation Deck",
      "text": [
        "{C:red}#1#{} Joker slots,",
        "{C:attention}+#2#{} Joker slot after every",
        "other Boss Blind defeated"
      ],
      "type": "Back"
    },
    "b_picubed_covetousdeck": {
      "name": "Covetous Deck",
      "text": [
        "Start with a",
        "{C:attention,T:j_picubed_shoppingtrolley}#1#{},",
        "{C:attention,T:j_picubed_preorderbonus}#2#{},",
        "and {C:attention,T:v_seed_money}#3#{}"
      ],
      "type": "Back"
    },
    "b_picubed_collectorsdeck": {
      "name": "Collector's Deck",
      "text": [
        "Start with a {C:attention,T:v_magic_trick}#1#{},",
        "{C:attention,T:v_illusion}#2#{}, and {C:attention,T:v_overstock_norm}#3#{}"
      ],
      "type": "Back"
    },
    "b_picubed_medusadeck": {
      "name": "Medusa Deck",
      "text": [
        "Start with 8 {C:attention,T:m_stone}Stone cards{}",
        "instead of Kings and Queens"
      ],
      "type": "Back"
    },
    "b_picubed_duplicitousdeck": {
      "name": "Duplicitous Deck",
      "text": [
        "{C:attention}+#1#{} Joker Slot,",
        "Jokers can appear with",
        "the {C:attention}Contractual{} sticker",
        "{C:inactive,s:0.8}(Eternal and Perishable combined){}",
        "Start with a",
        "{C:attention}Contractual{} {C:attention,T:j_credit_card}Credit Card{}"
      ],
      "type": "Back"
    },
    "sleeve_picubed_covetoussleeve": {
      "name": "Covetous Sleeve",
      "text": [
        "Start with a",
        "{C:attention,T:j_picubed_shoppingtrolley}#1#{},",
        "{C:attention,T:j_picubed_preorderbonus}#2#{},",
        "and {C:attention,T:v_seed_money}#3#{}"
      ],
      "type": "Sleeve"
    },
    "sleeve_picubed_covetoussleeve_alt": {
      "name": "Covetous Sleeve",
      "text": [
        "Start with 3 copies of",
        "{C:attention,T:j_picubed_shoppingtrolley}#1#{},",
        "a {C:attention,T:j_picubed_preorderbonus}#2#{},",
        "{C:attention,T:v_seed_money}#3#{}, and {C:attention,T:v_money_tree}#4#{}"
      ],
      "type": "Sleeve"
    },
    "sleeve_picubed_myepicsleeve": {
      "name": "my epic sleeve by pi_cubed",
      "text": [
        "{C:tarot}pi_cubed's Jokers{}' {C:attention}Jokers{}",
        "are {C:attention}3x{} more likely to appear,",
        "Start with an extra {C:money}$#1#"
      ],
      "type": "Sleeve"
    },
    "sleeve_picubed_myepicsleeve_alt": {
      "name": "my epic sleeve by pi_cubed",
      "text": [
        "{C:tarot}pi_cubed's Jokers{}' {C:attention}Jokers{}",
        "are {C:attention}3x{} more likely to appear,",
        "Start with an extra {C:money}$#1#",
        "and an {C:attention,T:j_picubed_inkjetprinter}#2#{}"
      ],
      "type": "Sleeve"
    },
    "sleeve_picubed_medusasleeve": {
      "name": "Medusa Sleeve",
      "text": [
        "Start with 8 {C:attention,T:m_stone}Stone cards{}",
        "instead of Kings and Queens"
      ],
      "type": "Sleeve"
    },
    "sleeve_picubed_medusasleeve_alt": {
      "name": "Medusa Sleeve",
      "text": [
        "Start with 16 {C:attention,T:m_stone}Stone cards{}",
        "instead of Kings, Queens,",
        "2s, and 3s"
      ],
      "type": "Sleeve"
    },
    "sleeve_picubed_wonderfulsleeve": {
      "name": "Wonderful Sleeve",
      "text": [
        "Start with a",
        "{C:dark_edition,T:e_foil}Foil{} {C:attention,T:j_picubed_talkingflower}Talking Flower{}"
      ],
      "type": "Sleeve"
    },
    "sleeve_picubed_wonderfulsleeve_alt": {
      "name": "Wonderful Sleeve",
      "text": [
        "Start with a",
        "{C:dark_edition,T:e_foil}Foil{} {C:attention,T:j_picubed_talkingflower}Talking Flower{}",
        "and a {C:dark_edition,T:e_polychrome}Polychrome{}",
        "{C:attention,T:j_picubed_talkingflower}Talking Flower{}"
      ],
      "type": "Sleeve"
    },
    "sleeve_picubed_collectorssleeve": {
      "name": "Collector's Sleeve",
      "text": [
        "{C:attention}+1{} Shop Slot,",
        "Start with a {C:attention,T:v_magic_trick}#1#{}",
        "and {C:attention,T:v_illusion}#2#{}"
      ],
      "type": "Sleeve"
    },
    "sleeve_picubed_collectorssleeve_alt": {
      "name": "Collector's Sleeve",
      "text": [
        "Start with a {C:attention,T:v_magic_trick}#1#{},",
        "{C:attention,T:v_illusion}#2#{}, {C:attention,T:v_overstock_norm}#3#{}",
        "and {C:attention,T:v_overstock_plus}#4#{}",
        " ",
        "Create a {C:attention,T:tag_standard}#5#{}",
        "When Blind is defeated"
      ],
      "type": "Sleeve"
    },
    "sleeve_picubed_rejuvinationsleeve": {
      "name": "Rejuvenation Sleeve",
      "text": [
        "{C:red}#1#{} Joker slots,",
        "{C:attention}+#2#{} Joker slot after every",
        "other Boss Blind defeated"
      ],
      "type": "Sleeve"
    },
    "sleeve_picubed_rejuvinationsleeve_alt": {
      "name": "Rejuvenation Sleeve",
      "text": [
        "{C:red}#1#{} Joker slots,",
        "{C:attention}+#2#{} Joker slot after",
        "{C:attention}any{} Boss Blind defeated"
      ],
      "type": "Sleeve"
    },
    "sleeve_picubed_duplicitoussleeve": {
      "name": "Duplicitous Sleeve",
      "text": [
        "{C:attention}+#1#{} Joker Slot,",
        "Jokers can appear with",
        "the {C:attention}Contractual{} sticker",
        "{C:inactive,s:0.8}(Eternal and Perishable combined){}",
        "Start with a",
        "{C:attention}Contractual{} {C:attention,T:j_credit_card}Credit Card{}"
      ],
      "type": "Sleeve"
    },
    "sleeve_picubed_duplicitoussleeve_alt": {
      "name": "Duplicitous Sleeve",
      "text": [
        "{C:attention}+#1#{} Joker Slots,",
        "Jokers can appear with",
        "the {C:attention}Contractual{} sticker",
        "{C:inactive,s:0.8}(Eternal and Perishable combined){}",
        "Start with 2",
        "{C:attention}Contractual{} {C:attention,T:j_credit_card}Credit Cards{}",
        "{s:0.8}Contractual Jokers appear more often"
      ],
      "type": "Sleeve"
    },
    "j_picubed_itsaysjokerontheceiling": {
      "name": "It Says \"Joker\" on the Ceiling",
      "text": [
        "Round {C:chips}Chips{} to the next #1#,",
        "Round {C:mult}Mult{} to the next #2#"
      ],
      "type": "Joker"
    },
    "j_picubed_d2": {
      "name": "D2",
      "text": [
        "{C:green}#2# in #3#{} chance",
        "to give {C:mult}+#1#{} Mult"
      ],
      "type": "Joker"
    },
    "j_picubed_wordsearch": {
      "name": "Word Search",
      "text": [
        "This Joker gains {C:mult}+#2#{} Mult",
        "per scoring {C:attention}#1#{} card",
        "{s:0.8}Rank changes every round",
        "{C:inactive}(Currently {C:mult}+#3#{C:inactive} Mult)"
      ],
      "type": "Joker"
    },
    "j_picubed_moltenjoker": {
      "name": "Molten Joker",
      "text": [
        "Retrigger {C:attention}Gold{}, {C:attention}Steel{},",
        "and {C:attention}Stone{} cards"
      ],
      "type": "Joker"
    },
    "j_picubed_chisel": {
      "name": "Chisel",
      "text": [
        "If {C:attention}first{} played card",
        "is a {C:attention}Stone{} card, {C:attention}remove{}",
        "the enhancement and add",
        "{C:chips}+#1# {C:attention}bonus{} {C:attention}chips{} to the card"
      ],
      "type": "Joker"
    },
    "j_picubed_upgradedjoker": {
      "name": "Upgraded Joker",
      "text": [
        "Each played {C:attention}Enhanced card{}",
        "gives {C:chips}+#1#{} Chips and",
        "{C:mult}+#2#{} Mult when scored"
      ],
      "type": "Joker"
    },
    "j_picubed_jokinhood": {
      "name": "Jokin' Hood",
      "text": [
        "{C:attention}Non-face cards{} earn {C:money}$#1#{}",
        "when scored, {C:attention}face cards{}",
        "earn {C:mult}-$#2#{} when scored"
      ],
      "type": "Joker"
    },
    "j_picubed_prime7": {
      "name": "Prime 7",
      "text": [
        "If hand is a single {C:attention}7{},",
        "it becomes {C:dark_edition}Negative{}"
      ],
      "type": "Joker"
    },
    "j_picubed_landslide": {
      "name": "Landslide",
      "text": [
        "A random card held in hand",
        "becomes a {C:attention}Stone Card{}",
        "if {C:chips}Chips{} exceeds {C:mult}Mult",
        "after scoring"
      ],
      "type": "Joker"
    },
    "j_picubed_runnerup": {
      "name": "Runner-up",
      "text": [
        "{X:mult,C:white}X#1#{} Mult on {C:attention}second{}",
        "hand of round"
      ],
      "type": "Joker"
    },
    "j_picubed_oooshiny": {
      "name": "Ooo! Shiny!",
      "text": [
        "{C:dark_edition}Polychrome{} cards",
        "give {C:money}$#1#{} when scored"
      ],
      "type": "Joker"
    },
    "j_picubed_stonemason": {
      "name": "Stonemason",
      "text": [
        "{C:attention}Stone{} cards permanently",
        "gain {X:mult,C:white}X#1#{} Mult when scored",
        "Stone cards have a {C:green}#2# in #3#{} chance",
        "to be {C:attention}destroyed{} after scoring"
      ],
      "type": "Joker"
    },
    "j_picubed_snakeeyes": {
      "name": "Snake Eyes",
      "text": [
        "When this card is {C:attention}sold{}, Joker",
        "to the {C:attention}left{} has its listed ",
        "{E:1,C:green}probabilities {C:attention}guaranteed",
        "{C:inactive}(ex: {C:green}1 in 6 {C:inactive}-> {C:green}1 in 1{C:inactive})"
      ],
      "type": "Joker"
    },
    "j_picubed_789": {
      "name": "7 8 9",
      "text": [
        "If played hand contains a {C:attention}scoring",
        "{C:attention}7 {}and {C:attention}9{}, {C:attention}destroy{} all scored {C:attention}9s{},",
        "and gain {X:mult,C:white}X#1#{} Mult per 9 scored",
        "{C:inactive}(Currently {X:mult,C:white}X#2#{} {C:inactive}Mult)"
      ],
      "type": "Joker"
    },
    "j_picubed_hiddengem": {
      "name": "Hidden Gem",
      "text": [
        "{C:attention}Discarded{} cards have a {C:green}#1# in #2#{}",
        "chance to be {C:attention}destroyed{} and",
        "create a {C:spectral}Spectral{} card",
        "{C:inactive}(Must have room)"
      ],
      "type": "Joker"
    },
    "j_picubed_ambigram": {
      "name": "Ambigram",
      "text": [
        "{C:attention}6s{} and {C:attention}9s{} can",
        "{C:attention}swap ranks{} anytime",
        "{C:inactive}(Select cards and",
        "{C:inactive}then press 'Swap!')"
      ],
      "type": "Joker"
    },
    "j_picubed_superwrathfuljoker": {
      "name": "Super Wrathful Joker",
      "text": [
        "All played {C:spades}Spade{} cards",
        "become {C:attention}Kings{} when scored"
      ],
      "type": "Joker"
    },
    "j_picubed_acecomedian": {
      "name": "Ace Comedian",
      "text": [
        "Retrigger each played",
        "{C:attention}Ace{}, {C:attention}10{}, {C:attention}9{}, and {C:attention}8{}"
      ],
      "type": "Joker"
    },
    "j_picubed_advancedskipping": {
      "name": "Advanced Skipping",
      "text": [
        "Receive {C:attention}#1#{} additional random {C:attention}tags",
        "when blind is {C:attention}skipped{},",
        "{C:attention}+#2# tag{} after each skip",
        "{C:inactive}(Capped at current {}{C:attention}Ante{}{C:inactive}){}"
      ],
      "type": "Joker"
    },
    "j_picubed_echolocation": {
      "name": "Echolocation",
      "text": [
        "{C:attention}+#3#{} hand size,",
        "{C:green}#1# in #2#{} playing cards",
        "are drawn {C:attention}face down"
      ],
      "type": "Joker"
    },
    "j_picubed_shoppingtrolley": {
      "name": "Shopping Trolley",
      "text": [
        "{C:green}#1# in #2#{} chance for",
        "{C:attention}+#3#{} hand size",
        "in {C:attention}Booster Packs"
      ],
      "type": "Joker"
    },
    "j_picubed_extrapockets": {
      "name": "Extra Pockets",
      "text": [
        "{C:attention}+#1#{} hand size for",
        "each held {C:attention}Consumable"
      ],
      "type": "Joker"
    },
    "j_picubed_peartree": {
      "name": "Pear Tree",
      "text": [
        "{C:mult}+#1#{} Mult if cards",
        "{C:attention}held in hand{}",
        "contain a {C:attention}Pair"
      ],
      "type": "Joker"
    },
    "j_picubed_spectraljoker": {
      "name": "Spectral Joker",
      "text": [
        "After {C:attention}Boss Blind{} is",
        "defeated, create a",
        "free {C:attention}Ethereal Tag{}"
      ],
      "type": "Joker"
    },
    "j_picubed_siphon": {
      "name": "Siphon",
      "text": [
        "This Joker gains {C:chips}+#1#{} Chips",
        "when another Joker is {C:attention}sold",
        "or {C:attention}destroyed",
        "{C:inactive}(Currently {C:chips}+#2#{C:inactive} Chips)"
      ],
      "type": "Joker"
    },
    "j_picubed_inkjetprinter": {
      "name": "Inkjet Printer",
      "text": [
        "{C:attention}Consumables{} have a {C:green}#1# in #2#",
        "chance to be {C:attention}recreated{} on use,",
        "this card has a {C:green}#3# in #4#{} chance to",
        "be {C:attention}destroyed{} after activating",
        "{C:inactive}(Must have room){}"
      ],
      "type": "Joker"
    },
    "j_picubed_blackjoker": {
      "name": "Black Joker",
      "text": [
        "If the {C:attention}sum rank{} of",
        "{C:attention}first{} played or discarded",
        "cards is {C:attention}#2#{}, earn {C:money}$#3#{}"
      ],
      "type": "Joker"
    },
    "j_picubed_bisexualflag": {
      "name": "Bisexual Flag",
      "text": [
        "If {C:attention}played hand{} contains a",
        "{C:attention}Straight{} and {C:attention}four suits{},",
        "create #1# {C:dark_edition}Negative {C:purple}Tarot{} cards"
      ],
      "type": "Joker"
    },
    "j_picubed_tradein": {
      "name": "Trade-in",
      "text": [
        "Earn {C:money}$#1#{} when a",
        "playing card is",
        "{C:attention}destroyed"
      ],
      "type": "Joker"
    },
    "j_picubed_apartmentcomplex": {
      "name": "Apartment Complex",
      "text": [
        "This Joker gains {X:mult,C:white}X#1#{} Mult if",
        "{C:attention}played hand{} is a {C:attention}Flush House{}",
        "{C:inactive}(Currently {X:mult,C:white}X#2#{} {C:inactive}Mult)"
      ],
      "type": "Joker"
    },
    "j_picubed_incompletesurvey": {
      "name": "Incomplete Survey",
      "text": [
        "Earn {C:money}$#1#{} at start of round",
        "When drawing cards to",
        "hand, {C:attention}last card{} drawn is",
        "always drawn {C:attention}face down{}"
      ],
      "type": "Joker"
    },
    "j_picubed_allin": {
      "name": "All In",
      "text": [
        "Played {C:attention}face down{} cards are",
        "retriggered {C:attention}#1#{} additonal times",
        "{C:attention}Face down{} Jokers and",
        "cards held in hand are",
        "retriggered {C:attention}#2#{} additional time",
        "{C:inactive}(except All In)"
      ],
      "type": "Joker"
    },
    "j_picubed_gottheworm": {
      "name": "Got the Worm",
      "text": [
        "{C:attention}Skipping{} a blind",
        "also gives {C:money}$#1#{}"
      ],
      "type": "Joker"
    },
    "j_picubed_extralimb": {
      "name": "Extra Limb",
      "text": [],
      "type": "Joker"
    },
    "j_picubed_perfectscore": {
      "name": "Perfect Score",
      "text": [
        "{C:chips}+#1# {}Chips if scoring",
        "hand contains a {C:attention}10{}"
      ],
      "type": "Joker"
    },
    "j_picubed_explosher": {
      "name": "Explosher",
      "text": [
        "After scoring is complete,",
        "give {C:attention}#1# {}random cards",
        "held in hand a {C:attention}random suit"
      ],
      "type": "Joker"
    },
    "j_picubed_rhythmicjoker": {
      "name": "Rhythmic Joker",
      "text": [
        "{C:mult}+#1#{} Mult if Hands",
        "remaining is {C:attention}even"
      ],
      "type": "Joker"
    },
    "j_picubed_goldenpancakes": {
      "name": "Golden Pancakes",
      "text": [
        "Scoring cards earn {C:money}$#1#{}",
        "{C:green}#2# in #3#{} chance this",
        "card is {C:attention}destroyed",
        "at end of round"
      ],
      "type": "Joker"
    },
    "j_picubed_preorderbonus": {
      "name": "Preorder Bonus",
      "text": [
        "Booster Packs",
        "cost {C:attention}#1#% less{}"
      ],
      "type": "Joker"
    },
    "j_picubed_waterbottle": {
      "name": "Water Bottle",
      "text": [
        "{C:chips}+#1#{} Chips for each",
        "Consumable used this {C:attention}Ante{}",
        "{C:inactive}(Currently {C:chips}+#2# {C:inactive}Chips)"
      ],
      "type": "Joker"
    },
    "j_picubed_currencyexchange": {
      "name": "Currency Exchange",
      "text": [
        "Cards held in hand",
        "give {C:mult}+#1#{} Mult"
      ],
      "type": "Joker"
    },
    "j_picubed_arrogantjoker": {
      "name": "Arrogant Joker",
      "text": [
        "{X:mult,C:white}X#1#{} Mult if this Joker",
        "is the {C:attention}left-most {}Joker"
      ],
      "type": "Joker"
    },
    "j_picubed_fusionmagic": {
      "name": "Fusion Magic",
      "text": [
        "After {C:attention}selling #1#{} {C:inactive}[#2#]{} {C:tarot}Tarot{} cards,",
        "create a {C:spectral}Spectral {}card",
        "{C:inactive}(Must have room)"
      ],
      "type": "Joker"
    },
    "j_picubed_supergreedyjoker": {
      "name": "Super Greedy Joker",
      "text": [
        "Create a random {C:attention}Editioned {}Joker",
        "when a {C:diamonds}Diamond {}card scores",
        "{C:inactive}(Must have room?)"
      ],
      "type": "Joker"
    },
    "j_picubed_pi": {
      "name": "Pi",
      "text": [
        "Cards with an {C:attention}edition{}",
        "have a {C:green}#2# in #3#{} chance to",
        "give {X:mult,C:white}X#1#{} Mult"
      ],
      "type": "Joker"
    },
    "j_picubed_onbeat": {
      "name": "On-beat",
      "text": [
        "Retrigger the {C:attention}1st{}, {C:attention}3rd{},",
        "and {C:attention}5th{} scoring card",
        "{s:0.8}After hand is played,",
        "{s:0.8}becomes {s:0.8,C:attention}Off-beat{}"
      ],
      "type": "Joker"
    },
    "j_picubed_offbeat": {
      "name": "Off-beat",
      "text": [
        "Retrigger the {C:attention}2nd{}",
        "and {C:attention}4th{} scoring card",
        "{s:0.8}After hand is played,",
        "{s:0.8}becomes {s:0.8,C:attention}On-beat{}"
      ],
      "type": "Joker"
    },
    "j_picubed_polyrhythm": {
      "name": "Polyrhythm",
      "text": [
        "Receive {C:money}$#1#{} every",
        "{C:attention}#2#{} {C:inactive}[#4#]{} hands played",
        "Create a {C:tarot}Tarot{} card",
        "every {C:attention}#3#{} {C:inactive}[#5#]{} discards",
        "{C:inactive}(Must have room){}"
      ],
      "type": "Joker"
    },
    "j_picubed_pot": {
      "name": "Pot",
      "text": [
        "{C:green}#1# in #2#{} chance for {X:mult,C:white}X#3#{} Mult,",
        "gives a {C:attention}cue{} if this Joker",
        "will activate for played hand",
        "{C:inactive}Currently #4#{}"
      ],
      "type": "Joker"
    },
    "j_picubed_supergluttonousjoker": {
      "name": "Super Gluttonous Joker",
      "text": [
        "When a {C:clubs}Club{} card is",
        "drawn to hand, draw an",
        "{C:attention}additional{} card to hand"
      ],
      "type": "Joker"
    },
    "j_picubed_mountjoker": {
      "name": "Mount Joker",
      "text": [
        "If played hand has at",
        "least 4 {C:attention}Stone{} cards,",
        "poker hand is your",
        "{C:attention}highest level poker hand{}"
      ],
      "type": "Joker"
    },
    "j_picubed_oxplow": {
      "name": "Ox Plow",
      "text": [
        "Earn {C:money}$#1#{} if {C:attention}most played{}",
        "{C:attention}poker hand{} wasn't played",
        "by end of round",
        "{C:inactive}(Currently #2#){}"
      ],
      "type": "Joker"
    },
    "j_picubed_offthehook": {
      "name": "Off the Hook",
      "text": [
        "After play, all {C:attention}unenhanced{}",
        "cards held in hand",
        "are {C:attention}discarded{}",
        "Gain {C:chips}+#1#{} Hands",
        "when {C:attention}Blind{} is selected"
      ],
      "type": "Joker"
    },
    "j_picubed_eyepatch": {
      "name": "Eye Patch",
      "text": [
        "This Joker gains {X:mult,C:white}X#2#{} Mult",
        "if {C:attention}poker hand{} has {C:attention}not{}",
        "been played this {C:attention}Ante{}, resets",
        "when {C:attention}Boss Blind{} is defeated",
        "{C:inactive}(Currently {X:mult,C:white}X#1#{} {C:inactive}Mult){}"
      ],
      "type": "Joker"
    },
    "j_picubed_timidjoker": {
      "name": "Timid Joker",
      "text": [
        "{C:mult}+#1#{} Mult if this Joker",
        "is the {C:attention}right-most{} Joker"
      ],
      "type": "Joker"
    },
    "j_picubed_rushedjoker": {
      "name": "Rushed Joker",
      "text": [
        "{C:attention}First{} card played",
        "gives {C:mult}+#1#{} Mult",
        "when scored"
      ],
      "type": "Joker"
    },
    "j_picubed_tyredumpyard": {
      "name": "Tyre Dumpyard",
      "text": [
        "When {C:attention}Boss Blind{} is selected,",
        "fill all Consumable slots",
        "with {C:attention}The Wheel of Fortune{}",
        "{C:inactive}(Must have room){}"
      ],
      "type": "Joker"
    },
    "j_picubed_acorntree": {
      "name": "Acorn Tree",
      "text": [
        "When {C:attention}Blind{} is selected, all",
        "Jokers are {C:attention}flipped and{}",
        "{C:attention}shuffled{}, and earn {C:money}$#1#{} for",
        "each other Joker affected"
      ],
      "type": "Joker"
    },
    "j_picubed_forgery": {
      "name": "Forgery",
      "text": [
        "When {C:attention}Blind{} is selected,",
        "{C:attention}destroy{} 1 random card in",
        "{C:attention}deck{}, and add half its",
        "{C:chips}Chips{} to this Joker as {C:mult}Mult",
        "{C:inactive}(Currently {C:mult}+#1#{C:inactive} Mult)"
      ],
      "type": "Joker"
    },
    "j_picubed_yawningcat": {
      "name": "Yawning Cat",
      "text": [
        "If {C:attention}played hand{} contains",
        "at least {C:attention}#1#{} scoring",
        "cards, {C:attention}retrigger{} playing",
        "cards {C:attention}#2# additional times{}"
      ],
      "type": "Joker"
    },
    "j_picubed_weemini": {
      "name": "Wee Mini",
      "text": [
        "If played hand or cards held",
        "in hand contain a {C:attention}2{},",
        "played hand contains a",
        "{C:attention}Two Pair{} and apply {C:attention}Splash{}"
      ],
      "type": "Joker"
    },
    "j_picubed_lowballdraw": {
      "name": "Lowball Draw",
      "text": [
        "Earn {C:money}$#1#{} when a",
        "{C:attention}2{} or {C:attention}7{} is drawn",
        "to hand during Blind"
      ],
      "type": "Joker"
    },
    "j_picubed_chickenjoker": {
      "name": "Chicken Joker!",
      "text": [
        "If scoring hand contains",
        "a {C:attention}Stone{} card or a {C:attention}Steel{}",
        "card, {C:attention}fill{} empty Joker",
        "slots with {C:dark_edition}Editioned{} {C:attention}Popcorn{}"
      ],
      "type": "Joker"
    },
    "j_picubed_shrapnel": {
      "name": "Shrapnel",
      "text": [
        "When a {C:attention}Consumable card{} is",
        "used, all playing cards in hand",
        "receive a {C:attention}permanent{} {C:mult}+#1#{} Mult"
      ],
      "type": "Joker"
    },
    "j_picubed_victimcard": {
      "name": "Victim Card",
      "text": [
        "This Joker gains {X:mult,C:white}X#1#{} Mult if",
        "played hand does {C:attention}not beat{} the",
        "blind, this Joker is {C:attention}destroyed{}",
        "after reaching {X:mult,C:white}X#2#{} Mult",
        "{C:inactive}(Currently{} {X:mult,C:white}X#3#{} {C:inactive}Mult){}"
      ],
      "type": "Joker"
    },
    "j_picubed_translucentjoker": {
      "name": "Translucent Joker",
      "text": [
        "After {C:attention}#1#{} rounds,",
        "sell this card to",
        "create an {C:attention}Invisible Joker{}",
        "{C:inactive}(Currently {}{C:attention}#2#{}{C:inactive}/#1# rounds){}"
      ],
      "type": "Joker"
    },
    "j_picubed_cyclone": {
      "name": "Cyclone",
      "text": [
        "Scored cards with a {C:attention}Seal{}",
        "create the {C:planet}Planet{} card of",
        "played {C:attention}poker hand{}"
      ],
      "type": "Joker"
    },
    "j_picubed_missingfinger": {
      "name": "Missing Finger",
      "text": [
        "{X:mult,C:white}X#1#{} Mult, {C:attention}#2#{} playing",
        "card {C:attention}selection limit{}",
        "for {C:blue}playing{} and {C:red}discarding{}"
      ],
      "type": "Joker"
    },
    "j_picubed_roundabout": {
      "name": "Round-a-bout",
      "text": [
        "Allows {C:attention}Straights{} to be made",
        "using {C:attention}Wrap-around Straights{}",
        "This Joker gains {X:mult,C:white}X#1#{} Mult per",
        "played {C:attention}Wrap-around Straight{}",
        "{C:inactive}(Currently {X:mult,C:white}X#2#{C:inactive} Mult)"
      ],
      "type": "Joker"
    },
    "j_picubed_hypemoments": {
      "name": "Hype Moments",
      "text": [
        "When {C:attention}Boss Blind{} is selected,",
        "create an {C:attention}Aura{}",
        "{C:inactive}(Must have room){}"
      ],
      "type": "Joker"
    },
    "j_picubed_panicfire": {
      "name": "Panic Fire",
      "text": [
        "{X:mult,C:white}X#1#{} Mult for {C:attention}this round{}",
        "after #3# {C:inactive}[#4#]{} cards have",
        "been {C:attention}sold{} during {C:attention}Blind{}",
        "{C:inactive}(Currently #2#){}"
      ],
      "type": "Joker"
    },
    "j_picubed_nightvision": {
      "name": "Night Vision",
      "text": [
        "After Play, {C:attention}flip{} all cards in hand,",
        "earn {C:money}$#1#{} per card flipped",
        "{C:attention}face up{} by this Joker"
      ],
      "type": "Joker"
    },
    "j_picubed_talkingflower": {
      "name": "Talking Flower",
      "text": [
        "{C:dark_edition}+#1#{} Joker Slot,",
        "{C:mult}+#2#{} Mult"
      ],
      "type": "Joker"
    },
    "j_picubed_superlustyjoker": {
      "name": "Super Lusty Joker",
      "text": [
        "{C:attention}Retrigger{} played {C:hearts}Heart{} cards,",
        "{C:green}#2# in #3#{} chance to retrigger",
        "them {C:attention}#1#{} additional time"
      ],
      "type": "Joker"
    },
    "j_picubed_laserprinter": {
      "name": "Laser Printer",
      "text": [
        "{C:attention}Consumables{} have a {C:green}#1# in #2#{} chance",
        "to be {C:attention}recreated{} on use and a",
        "{C:green}#5# in #6#{} chance to be made {C:dark_edition}Negative{},",
        "this card has a {C:green}#3# in #4#{} ",
        "chance to be {C:attention}disabled{} for",
        "this Ante after activating",
        "{C:inactive}(Must have room){}"
      ],
      "type": "Joker"
    },
    "j_picubed_bigtwo": {
      "name": "Big Two",
      "text": [
        "Each played {C:attention}2{} has a ",
        "{C:green}#2# in #3#{} chance to give",
        "{X:mult,C:white}X#1#{} Mult when scored"
      ],
      "type": "Joker"
    },
    "j_picubed_psychicspirit": {
      "name": "Psychic Spirit",
      "text": [
        "{C:chips}+#1#{} Hands after Blind is selected,",
        "decreases by {C:mult}#2#{} if played hand",
        "does not contain {C:attention}#3#{} cards"
      ],
      "type": "Joker"
    },
    "j_picubed_sprinkler": {
      "name": "Sprinkler",
      "text": [
        "On {C:attention}Discard{}, give #1# held",
        "card your full deck's",
        "{C:attention}most common suit{}",
        "{C:inactive}(Currently {V:1}#2#{}{C:inactive}){}"
      ],
      "type": "Joker"
    },
    "j_picubed_monkeyseemonkeydo": {
      "name": "Monkey See, Monkey Do",
      "text": [
        "Each played {C:attention}#1#{} and {C:attention}#2#{}",
        "gives {C:mult}+#3#{} Mult when scored",
        "{s:0.8}Ranks change every {}{s:0.8,C:attention}hand{}"
      ],
      "type": "Joker"
    },
    "j_picubed_weighteddie": {
      "name": "Weighted Die",
      "text": [
        "The {C:attention}Wheel of Fortune{} is",
        "{E:1,C:green}guaranteed{} to succeed"
      ],
      "type": "Joker"
    },
    "j_picubed_splatzone": {
      "name": "Splat Zone",
      "text": [
        "{C:mult}+#1#{} Mult if all cards",
        "{C:attention}held in hand{} share",
        "the {C:attention}same suit{}"
      ],
      "type": "Joker"
    },
    "j_picubed_jokercircuit": {
      "name": "Joker Circuit",
      "text": [
        "Every {C:attention}#1#{} {C:inactive}[#2#]{} hands",
        "containing a {C:attention}Straight{},",
        "create a free {C:attention}Speed Tag{}"
      ],
      "type": "Joker"
    },
    "j_picubed_satanist": {
      "name": "Satanist",
      "text": [
        "If played hand contains a {C:attention}6{}",
        "and a {C:attention}Three of a Kind{},",
        "create a {C:attention}The Devil{} card",
        "and a random {C:purple}Tarot{} card",
        "{C:inactive}(Must have room)"
      ],
      "type": "Joker"
    },
    "j_picubed_boomerang": {
      "name": "Boomerang",
      "text": [
        "Scoring cards are",
        "{C:attention}shuffled back{}",
        "into the deck"
      ],
      "type": "Joker"
    },
    "j_picubed_hierarchy": {
      "name": "Hierarchy",
      "text": [
        "If scoring hand contains a {C:attention}King{},",
        "the {C:attention}first{} scoring card of",
        "each {C:attention}rank{} gives {X:mult,C:white}X#1#{} Mult"
      ],
      "type": "Joker"
    },
    "j_picubed_turfwar": {
      "name": "Turf War",
      "text": [
        "Gains {X:mult,C:white}X#1#{} Mult for every",
        "{C:attention}#2#{} {V:1}#4#{} cards in {C:attention}full deck{}",
        "when Boss Blind is defeated",
        "{s:0.8,C:attention}Suit {}{s:0.8}changes afterwards too{}",
        "{C:inactive}(Currently {X:mult,C:white}X#3#{}{C:inactive} Mult){}"
      ],
      "type": "Joker"
    },
    "j_picubed_nobelprize": {
      "name": "Nobel Prize",
      "text": [
        "Create a {C:spectral}Spectral {}card",
        "after playing a poker hand",
        "for the {C:attention}first time{} this run",
        "{C:inactive}(Must have room)",
        "{S:1.1,C:red,E:2}self destructs{}"
      ],
      "type": "Joker"
    },
    "j_picubed_jokerinanutshell": {
      "name": "Joker in a Nutshell",
      "text": [
        "When {C:attention}Blind{} is selected, destroy",
        "Joker to the right, and for",
        "each {C:attention}line of description text{}",
        "it had add {X:mult,C:white}X#2#{} Mult to this Joker",
        "{C:inactive}(Currently {X:mult,C:white}X#1#{C:inactive} Mult)"
      ],
      "type": "Joker"
    },
    "j_picubed_surgeon": {
      "name": "Surgeon",
      "text": [
        "This card gains {C:attention}+#1#{} Hand Size",
        "when a {C:attention}6{} is destroyed",
        "{C:inactive}(Currently {C:attention}+#2#{C:inactive} Hand Size)"
      ],
      "type": "Joker"
    },
    "j_picubed_thecube": {
      "name": "The Cube",
      "text": [
        "Scored {C:attention}numbered{} cards give",
        "{C:money}${} equal to their {C:attention}Rank{}",
        "{s:0.8}Aces give {s:0.8,C:money}$11{}"
      ],
      "type": "Joker"
    },
    "j_picubed_ordersector": {
      "name": "",
      "text": [
        "This card gives {X:mult,C:white}X#1#{} Mult",
        "per {V:1}#3#{} card in {C:attention}graveyard{}",
        "{s:0.8,C:attention}Suit {}{s:0.8}changes at end of round{}",
        "{C:inactive}(Currently {X:mult,C:white}X#2#{}{C:inactive} Mult){}"
      ],
      "type": "Joker"
    },
    "j_picubed_blueberrypie": {
      "name": "Blueberry Pie",
      "text": [
        "Copies ability of",
        "{C:attention}Joker{} to the right,",
        "this card is {C:attention}destroyed{}",
        "after {C:attention}#1#{} rounds"
      ],
      "type": "Joker"
    },
    "j_picubed_encore": {
      "name": "Encore",
      "text": [
        "On {C:attention}final hand{} of",
        "{C:attention}Boss Blind{}, played",
        "cards earn {C:money}$#1#{}",
        "when scored"
      ],
      "type": "Joker"
    },
    "j_picubed_otamatone": {
      "name": "Otamatone",
      "text": [
        ""
      ],
      "type": "Joker"
    },
    "j_picubed_leeroooooy": {
      "name": "LEEROOOOOY!!",
      "text": [
        "{C:attention}Retrigger{} all played cards",
        "per {C:attention}Blind skipped{} this {C:attention}Ante",
        "{C:inactive}(Currently {C:attention}#1#{} {C:inactive}retriggers)"
      ],
      "type": "Joker"
    },
    "j_picubed_athrowawayjoker": {
      "name": "A Throwaway Joker",
      "text": [
        "This Joker gains {C:chips}+Chips{}",
        "equal to the base {C:mult}Mult{}",
        "of {C:attention}discarded poker hand{}",
        "{C:inactive}(Currently {C:chips}+#1#{C:inactive} Chips)"
      ],
      "type": "Joker"
    },
    "c_picubed_commander": {
      "name": "Commander",
      "text": [
        "{C:attention}Destroy{} #1# random",
        "Consumable if slots are",
        "filled, add {C:dark_edition}Negative{}",
        "to all others"
      ],
      "type": "Spectral"
    },
    "c_picubed_rupture": {
      "name": "Rupture",
      "text": [
        "{C:attention}Destroy{} left-most Joker,",
        "create {C:attention}#1#{} random",
        "{C:spectral}Spectral{} cards"
      ],
      "type": "Spectral"
    },
    "c_picubed_extinction": {
      "name": "Extinction",
      "text": [
        "{C:attention}Destroy{} all cards of",
        "a {C:attention}random rank{}",
        "from your deck"
      ],
      "type": "Spectral"
    },
    "tag_picubed_jokercircuitskip": {
      "name": "Speed Tag",
      "text": [
        "Gives {C:money}$#1#{} per skipped",
        "Blind this run",
        "{C:inactive}(Will give {C:money}$#2#{C:inactive})"
      ],
      "type": "Tag"
    },
    "tag_picubed_rebound": {
      "name": "Rebound Tag",
      "text": [
        "Retrigger played cards {C:attention}#1#{}",
        "additional times for",
        "next round"
      ],
      "type": "Tag"
    },
    "pnr_picubed_roof": {
      "name": "Roof",
      "text": [
        "{C:green}#2# in #3#{} chance to",
        "round {C:money}${} to the next {C:money}$#1#{},",
        "before end of round"
      ],
      "type": "Partner"
    },
    "pnr_picubed_refine": {
      "name": "Refine",
      "text": [
        "{C:attention}Enhanced{} cards gain",
        "{C:mult}+#1#{} Mult when scored"
      ],
      "type": "Partner"
    },
    "pnr_picubed_copy": {
      "name": "Copy",
      "text": [
        "{C:attention}Consumables{} have a {C:green}#1# in #2#",
        "chance to be {C:attention}recreated{} on use,",
        "this card has a {C:green}#3# in #4#{} chance to",
        "be {C:attention}disabled{} for this Ante",
        "after activating",
        "{C:inactive}(Must have room){}"
      ],
      "type": "Partner"
    },
    "pnr_picubed_polymelia": {
      "name": "Polymelia",
      "text": [
        "{C:attention}+#1#{} Consumable Slots,",
        "held Consumables give",
        "{C:chips}+#2#{} Chips"
      ],
      "type": "Partner"
    },
    "picubedsjokers": {
      "name": "pi_cubed's Jokers",
      "text": [
        "A collection of vanilla-friendly Jokers (and more) made by",
        "yours truly. Follow me on bluesky at @picubed.bsky.social!",
        "Thanks franderman123 for Español (México) localization!"
      ],
      "type": "Mod"
    },
    "wraparound": {
      "name": "Wrap-around Straight",
      "text": [
        "A non-standard Straight",
        "containing both",
        "{C:attention}high and low{} ranks",
        "{C:inactive}(ex:{} {C:attention}3 2 A K Q{}{C:inactive}){}"
      ],
      "type": "Other"
    },
    "onbeat_tooltip": {
      "name": "On-beat",
      "text": [
        "Retrigger the {C:attention}1st{}, {C:attention}3rd{},",
        "and {C:attention}5th{} scoring card",
        "{s:0.8}After hand is played,",
        "{s:0.8}becomes {s:0.8,C:attention}Off-beat{}"
      ],
      "type": "Other"
    },
    "offbeat_tooltip": {
      "name": "Off-beat",
      "text": [
        "Retrigger the {C:attention}2nd{}",
        "and {C:attention}4th{} scoring card",
        "{s:0.8}After hand is played,",
        "{s:0.8}becomes {s:0.8,C:attention}On-beat{}"
      ],
      "type": "Other"
    },
    "invisiblejoker_tooltip": {
      "name": "Invisible Joker",
      "text": [
        "After {C:attention}2{} rounds,",
        "sell this card to",
        "{C:attention}Duplicate{} a random Joker",
        "{C:inactive}(Currently {C:attention}0{C:inactive}/2)"
      ],
      "type": "Other"
    },
    "speedtag_tooltip": {
      "name": "Speed Tag",
      "text": [
        "Gives {C:money}$5{} per skipped",
        "Blind this run",
        "{C:inactive}(Will give {C:money}$#1#{C:inactive})"
      ],
      "type": "Other"
    },
    "picubed_contractual": {
      "name": "Contractual",
      "text": [
        "Can't be sold or destroyed",
        "for the next {C:attention}#1#{} rounds,",
        "then expires and is removed",
        "{C:inactive}({C:attention}#2#{C:inactive} remaining)"
      ],
      "type": "Other"
    },
    "ach_picubed_printererror": {
      "name": "\"Printer Error!\"",
      "text": [],
      "type": "achievement_names"
    },
    "ach_picubed_grossedoff": {
      "name": "\"Grossed Off\"",
      "text": [],
      "type": "achievement_names"
    },
    "ach_picubed_stoned": {
      "name": "\"Stoned\"",
      "text": [],
      "type": "achievement_names"
    },
    "ach_picubed_agrandmemorial": {
      "name": "\"A Grand Memorial\"",
      "text": [],
      "type": "achievement_names"
    },
    "ach_picubed_dontgetcookedstay": {
      "name": "\"Don't Get Cooked",
      "text": [],
      "type": "achievement_names"
    },
    "ach_picubed_bananabreaker": {
      "name": "\"Banana Breaker\"",
      "text": [],
      "type": "achievement_names"
    },
    "ach_picubed_wrapastraightflush": {
      "name": "\"Wrap-a-Straight Flush\"",
      "text": [],
      "type": "achievement_names"
    },
    "ach_picubed_criticalhit": {
      "name": "\"Critical Hit!\"",
      "text": [],
      "type": "achievement_names"
    },
    "ach_picubed_balatrothemecustomremix": {
      "name": "\"Balatro Theme Custom Remix\"",
      "text": [],
      "type": "achievement_names"
    },
    "k_picubeds_pot_active": {
      "name": "\"Active!\"",
      "text": [],
      "type": "v_dictionary"
    },
    "k_picubeds_pot_inactive": {
      "name": "\"Inactive\"",
      "text": [],
      "type": "v_dictionary"
    },
    "k_picubeds_pi": {
      "name": "\"pi\"",
      "text": [],
      "type": "v_dictionary"
    },
    "c_picubed_nostalgicrejuvinationdeck": {
      "name": "\"Nostalgic Rejuvination Deck\"",
      "text": [],
      "type": "challenge_names"
    },
    "k_picubeds_gullible": {
      "name": "\"Gullible!\"",
      "text": [],
      "type": "dictionary"
    },
    "k_picubeds_chisel": {
      "name": "\"Chisel!\"",
      "text": [],
      "type": "dictionary"
    },
    "k_picubeds_prime": {
      "name": "\"Prime!\"",
      "text": [],
      "type": "dictionary"
    },
    "k_picubeds_tumble": {
      "name": "\"Tumble!\"",
      "text": [],
      "type": "dictionary"
    },
    "k_picubeds_snakeeyes": {
      "name": "\"Snake Eyes!\"",
      "text": [],
      "type": "dictionary"
    },
    "k_picubeds_print": {
      "name": "\"Print!\"",
      "text": [],
      "type": "dictionary"
    },
    "k_picubeds_error": {
      "name": "\"Error!\"",
      "text": [],
      "type": "dictionary"
    },
    "k_picubeds_pride": {
      "name": "\"Pride!\"",
      "text": [],
      "type": "dictionary"
    },
    "k_picubeds_slosh": {
      "name": "\"Slosh!\"",
      "text": [],
      "type": "dictionary"
    },
    "k_picubeds_swap": {
      "name": "\"Swap!\"",
      "text": [],
      "type": "dictionary"
    },
    "k_picubeds_pot_ready": {
      "name": "\"Ready?\"",
      "text": [],
      "type": "dictionary"
    },
    "k_picubeds_pot_hit": {
      "name": "\"Hit!\"",
      "text": [],
      "type": "dictionary"
    },
    "k_picubeds_pot_miss": {
      "name": "\"Miss...\"",
      "text": [],
      "type": "dictionary"
    },
    "k_picubeds_club": {
      "name": "\"Club!\"",
      "text": [],
      "type": "dictionary"
    },
    "k_picubeds_spade": {
      "name": "\"Spade!\"",
      "text": [],
      "type": "dictionary"
    },
    "k_picubeds_diamond": {
      "name": "\"Diamond!\"",
      "text": [],
      "type": "dictionary"
    },
    "k_picubeds_offthehook": {
      "name": "\"Hooked!\"",
      "text": [],
      "type": "dictionary"
    },
    "k_picubeds_victimcard": {
      "name": "\"Revoked!\"",
      "text": [],
      "type": "dictionary"
    },
    "k_picubeds_panicfire_ready": {
      "name": "\"Ready!\"",
      "text": [],
      "type": "dictionary"
    },
    "k_picubeds_fixed": {
      "name": "\"Fixed!\"",
      "text": [],
      "type": "dictionary"
    },
    "k_picubeds_active": {
      "name": "\"Active!\"",
      "text": [],
      "type": "dictionary"
    },
    "k_picubeds_inactive": {
      "name": "\"Inactive\"",
      "text": [],
      "type": "dictionary"
    },
    "k_picubeds_plusjokerslot": {
      "name": "\"+1 Joker Slot\"",
      "text": [],
      "type": "dictionary"
    },
    "k_picubeds_splat": {
      "name": "\"Splat!\"",
      "text": [],
      "type": "dictionary"
    },
    "config_picubeds_newspectrals": {
      "name": "\"New Spectral Cards (restart required)\"",
      "text": [],
      "type": "dictionary"
    },
    "config_picubeds_newtags": {
      "name": "\"New Tags (restart required)\"",
      "text": [],
      "type": "dictionary"
    },
    "config_picubeds_customsfx": {
      "name": "\"Custom Sound Effects (restart required)\"",
      "text": [],
      "type": "dictionary"
    },
    "config_picubeds_pokerhandchangers": {
      "name": "\"Hand type-affecting Jokers (restart required)\"",
      "text": [],
      "type": "dictionary"
    },
    "k_picubeds_chips": {
      "name": "\"Chips\"",
      "text": [],
      "type": "dictionary"
    }
  },
  "atlases": {
    "picubed_partners": {
      "path": "picubedspartner.png",
      "px": 46,
      "py": 58,
      "localPath": "/wiki-data/pi_cubeds_jokers@pi-cubed-cat/v1.1.3/picubedspartner.png",
      "resolvedGitHubPath": "assets/1x/picubedspartner.png"
    },
    "picubedssleeve": {
      "path": "picubedssleeve.png",
      "px": 73,
      "py": 95,
      "localPath": "/wiki-data/pi_cubeds_jokers@pi-cubed-cat/v1.1.3/picubedssleeve.png",
      "resolvedGitHubPath": "assets/1x/picubedssleeve.png"
    },
    "PiCubedsJokers": {
      "path": "picubedsjokers.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/pi_cubeds_jokers@pi-cubed-cat/v1.1.3/picubedsjokers.png",
      "resolvedGitHubPath": "assets/1x/picubedsjokers.png"
    },
    "modicon": {
      "path": "picubedsicon.png",
      "px": 32,
      "py": 32,
      "localPath": "/wiki-data/pi_cubeds_jokers@pi-cubed-cat/v1.1.3/picubedsicon.png",
      "resolvedGitHubPath": "assets/1x/picubedsicon.png"
    },
    "picubedsdeck": {
      "path": "picubedsdeck.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/pi_cubeds_jokers@pi-cubed-cat/v1.1.3/picubedsdeck.png",
      "resolvedGitHubPath": "assets/1x/picubedsdeck.png"
    },
    "picubedsstickers": {
      "path": "picubedsstickers.png",
      "px": 71,
      "py": 95,
      "localPath": "/wiki-data/pi_cubeds_jokers@pi-cubed-cat/v1.1.3/picubedsstickers.png",
      "resolvedGitHubPath": "assets/1x/picubedsstickers.png"
    },
    "picubed_tags": {
      "path": "picubedstag.png",
      "px": 34,
      "py": 34,
      "localPath": "/wiki-data/pi_cubeds_jokers@pi-cubed-cat/v1.1.3/picubedstag.png",
      "resolvedGitHubPath": "assets/1x/picubedstag.png"
    }
  },
  "cards": [
    {
      "type": "Tag",
      "key": "jollytopup",
      "atlas": "picubed_tags",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "-- Jolly Top-up Tag (Cryptid)\n\tkey = 'jollytopup',\n\tloc_txt = {\n\t\tname = \"Jolly Top-up Tag\",\n\t\ttext = {\n\t\t\t\"Create #1# {C:attention}Jolly Jokers\",\n\t\t\t\"{C:inactive}(Does not require room){}\"\n\t\t}\n\t},\n\tconfig = { extra = { spawn_jokers = 5 } },\n\tatlas = \"picubed_tags\",\n\tpos = { x = 0, y = 0 },\n\tdiscovered = true,\n\tmin_ante = 2,\n\tloc_vars = function(self, info_queue, card)\n\t\tinfo_queue[#info_queue+1] = G.P_CENTERS.j_jolly\n\t\treturn { vars = { card.config.extra.spawn_jokers } }\n\tend,\n\tapply = function(self, tag, context)\n\t\tif context.type == \"immediate\" then\n\t\t\ttag:yep(\"+\", G.C.RED, function()\n\t\t\t\t\tfor i = 1, tag.config.extra.spawn_jokers do\n\t\t\t\t\t\tSMODS.add_card({set = 'Joker', area = G.jokers, key = 'j_jolly'})\n\t\t\t\t\tend\n\t\t\t\treturn true\n\t\t\t\tend)\n\t\t\ttag.triggered = true\n\t\t\treturn true\n\t\tend\n\tend",
      "config": {
        "extra": {
          "spawn_jokers": 5
        }
      },
      "ability": {
        "extra": {
          "spawn_jokers": 5
        }
      },
      "vars": [
        5
      ],
      "infoQueue": []
    },
    {
      "type": "Tag",
      "key": "jollytopup_negative",
      "atlas": "picubed_tags",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "-- gaT pu-poT ylloJ (Cryptid)\n\tkey = 'jollytopup_negative',\n\tloc_txt = {\n\t\tname = \"gaT pu-poT ylloJ\",\n\t\ttext = {\n\t\t\t\"Create #1# {C:dark_edition}Negative{}\",\n\t\t\t\"{C:attention}Jolly Jokers\"\n\t\t}\n\t},\n\tconfig = { extra = { spawn_jokers = 2 } },\n\tatlas = \"picubed_tags\",\n\tpos = { x = 1, y = 0 },\n\tdiscovered = true,\n\tmin_ante = 2,\n\tloc_vars = function(self, info_queue, card)\n\t\tinfo_queue[#info_queue+1] = G.P_CENTERS.j_jolly\n\t\tinfo_queue[#info_queue+1] = G.P_CENTERS.e_negative\n\t\treturn { vars = { card.config.extra.spawn_jokers } }\n\tend,\n\tapply = function(self, tag, context)\n\t\tif context.type == \"immediate\" then\n\t\t\ttag:yep(\"+\", G.C.RED, function()\n\t\t\t\t\tfor i = 1, tag.config.extra.spawn_jokers do\n\t\t\t\t\t\tSMODS.add_card({set = 'Joker', area = G.jokers, key = 'j_jolly', edition = \"e_negative\"})\n\t\t\t\t\tend\n\t\t\t\treturn true\n\t\t\t\tend)\n\t\t\ttag.triggered = true\n\t\t\treturn true\n\t\tend\n\tend",
      "config": {
        "extra": {
          "spawn_jokers": 2
        }
      },
      "ability": {
        "extra": {
          "spawn_jokers": 2
        }
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "xm",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 9,
        "y": 10
      },
      "raw": "--XM (Cryptid)\n    key = 'xm',\n    loc_txt = {\n        name = 'XM',\n        text = {\n            \"This card gives\",\n            \"{B:1,C:white}XM{}\",\n        }\n    },\n    rarity = 3,\n    atlas = 'PiCubedsJokers',\n    pos = { x = 9, y = 10 },\n    cost = 9,\n    discovered = true,\n    blueprint_compat = true,\n    perishable_compat = true,\n    eternal_compat = true,\n    config = { extra = { repetitions = 1 } },\n\tpools = { [\"M\"] = true },\n\tdependencies = {\n\t\titems = { \"set_cry_m\" },\n\t},\n    loc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.repetitions, colours = { HEX('7DC6F3') } } }\n    end,\n    in_pool = function(self, args) \n\t\tlocal jollycount = 0\n\t\tfor i = 1, #G.jokers.cards do\n\t\t\tif\n\t\t\t\tG.jokers.cards[i]:is_jolly()\n\t\t\t\tor Cryptid.safe_get(G.jokers.cards[i].config.center, \"pools\", \"M\")\n\t\t\t\tor G.jokers.cards[i].ability.name == \"cry-mprime\"\n\t\t\tthen\n\t\t\t\tjollycount = jollycount + 1\n\t\t\tend\n\t\tend\n\t\treturn jollycount > 0\n\tend,\n    calculate = function(self, card, context)\n        if context.retrigger_joker_check and not context.retrigger_joker and context.other_card.ability.name ~= 'j_picubed_allin' then\n            if context.other_card:is_jolly() or Cryptid.safe_get(context.other_card.config.center, \"pools\", \"M\")\n\t\t\tor context.other_card.ability.name == \"cry-mprime\" then\n                return {\n                    repetitions = card.ability.extra.repetitions,\n                    card = card\n                }\n            end\n\t\tend\n    end",
      "config": {
        "extra": {
          "repetitions": 1
        }
      },
      "ability": {
        "extra": {
          "repetitions": 1
        }
      },
      "vars": [
        1,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "mrsjankman_joker",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 2,
        "y": 7
      },
      "raw": "-- Mrs. Jankman (Cryptid & MoreFluff)\n\tkey = 'mrsjankman_joker',\n\tloc_txt = {\n\t\tname = 'Mrs. Jankman',\n\t\ttext = {\n\t\t\t\"All Jokers with a\", \n\t\t\t\"{C:attention}modded Edition{}\",\n\t\t\t\"give {X:chips,C:white}X#1#{} Chips\",\n\t\t\t\"{s:0.8,C:inactive,E:2}Heteronormative Jank!\"\n\t\t\t\n\t\t}\n\t},\n\tpronouns = 'she_her',\n\tconfig = { extra = { x_chips = 27.41 } },\n\trarity = 4,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 2, y = 7 },\n\tsoul_pos = { x = 3, y = 7 },\n\tcost = 20,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tpools = { [\"Meme\"] = true },\n\tin_pool = function(self, args)\n\t\treturn (#find_joker(\"j_mf_jankman\") > 0)\n\tend,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.x_chips } }\n\tend,\n\t\n\tcalculate = function(self, card, context)\n\t\tif context.other_joker and context.other_joker.edition then\n\t\t\tif context.other_joker.edition.key ~= 'e_polychrome' then\n\t\t\t\tif context.other_joker.edition.key ~= 'e_foil' then\n\t\t\t\t\tif context.other_joker.edition.key ~= 'e_holographic' then\n\t\t\t\t\t\tif context.other_joker.edition.key ~= 'e_negative' then\n\t\t\t\t\t\t\tif (not context.other_joker.debuff) then\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\txchips = card.ability.extra.x_chips,\n\t\t\t\t\t\t\t\t\tcard = card\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend",
      "config": {
        "extra": {
          "x_chips": 27.41
        }
      },
      "ability": {
        "extra": {
          "x_chips": 27.41
        }
      },
      "vars": [
        27.41
      ],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "picubed_partners",
      "atlas": null,
      "pos": null,
      "raw": "key = \"picubed_partners\",\n    path = \"picubedspartner.png\",\n    px = 46,\n    py = 58",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "inkjetprinterprinter",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 0,
        "y": 9
      },
      "raw": "-- Inkjet Printer Printer (Revo's Vault)\n\tkey = 'inkjetprinterprinter', \n\tloc_txt = {\n\t\tname = 'Inkjet Printer Printer',\n\t\ttext = {\n\t\t\t\"When Blind is selected,\",\n\t\t\t\"print an {C:attention}Inkjet Printer{}\",\n\t\t\t\"{C:inactive}(Must have room)\",\n\t\t}\n\t},\n\tconfig = { extra = { x_chips = 27.41 } },\n\trarity = \"crv_p\",\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 0, y = 9 },\n\tcost = 10,\n\tdiscovered = true,\n\tperishable_compat = true,\n\teternal_compat = true,\n\tblueprint_compat = true,\n\tloc_vars = function(self, info_queue, card)\n\t\tinfo_queue[#info_queue+1] = G.P_CENTERS.j_picubed_inkjetprinter\n\t\treturn { vars = { card.ability.max_highlighted } }\n\tend,\n\t\n\tcalculate = function(self, card, context)\n\t\tif context.setting_blind then -- code from Jimbo Printer\n\t\t\tif G.GAME.used_vouchers[\"v_crv_printerup\"] == true then\n\t\t\t\tlocal new_card = create_card(\"Joker\", G.jokers, nil, nil, nil, nil, \"j_picubed_inkjetprinter\")\n\t\t\t\tnew_card:set_edition({\n\t\t\t\t\tnegative = true,\n\t\t\t\t}, true)\n\t\t\t\tnew_card:add_to_deck()\n\t\t\t\tG.jokers:emplace(new_card)\n\t\t\telse\n\t\t\t\tif #G.jokers.cards < G.jokers.config.card_limit or self.area == G.jokers then\n\t\t\t\t\tlocal new_card = create_card(\"Joker\", G.jokers, nil, nil, nil, nil, \"j_picubed_inkjetprinter\")\n\t\t\t\t\tnew_card:add_to_deck()\n\t\t\t\t\tG.jokers:emplace(new_card)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend,",
      "config": {
        "extra": {
          "x_chips": 27.41
        }
      },
      "ability": {
        "extra": {
          "x_chips": 27.41
        }
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "picubedssleeve",
      "atlas": null,
      "pos": null,
      "raw": "key = \"picubedssleeve\",\n    path = \"picubedssleeve.png\",\n    px = 73,\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "ordersector",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 0,
        "y": 11
      },
      "raw": "-- Order Sector (Þe Autumn Circus)\n\tkey = 'ordersector',\n\tloc_txt = {\n\t\tname = 'Order Sector',\n\t\ttext = {\n\t\t\t\"This card gives {X:mult,C:white}X#1#{} Mult\", \n\t\t\t\"per {V:1}#3#{} card in {C:attention}graveyard{}\",\n\t\t\t\"{s:0.8,C:attention}Suit {}{s:0.8}changes at end of round{}\",\n\t\t\t\"{C:inactive}(Currently {X:mult,C:white}X#2#{}{C:inactive} Mult){}\",\n\t\t}\n\t},\n\tconfig = { extra = { Xmult_mod = 0.25 } },\n\trarity = 2,\n\tatlas = 'PiCubedsJokers', -- art by AutumnMood !!!!!!!!!\n\tpos = { x = 0, y = 11 },\n\tcost = 7,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tin_pool = function(self, args)\n\t\treturn #G.graveyard > 1\n\tend,\n    loc_vars = function(self, info_queue, card)\n\t\tif not card.fake_card then info_queue[#info_queue+1] = {generate_ui = TheAutumnCircus.func.artcredit, key = 'autumn'} end\n\t\tlocal card_count = 0\n\t\tfor k,v in ipairs(G.graveyard or {}) do\n\t\t\tif v:is_suit(G.GAME.current_round.picubed_ordersector.suit) or (v.debuff and v.base.suit == G.GAME.current_round.picubed_ordersector.suit) then \n\t\t\t\tcard_count = card_count + 1\n\t\t\tend\n\t\tend\n\t\tlocal suit = (G.GAME.current_round.picubed_ordersector or {}).suit or 'Spades'\n\t\treturn { vars = { card.ability.extra.Xmult_mod, 1 + card.ability.extra.Xmult_mod * card_count, localize(suit, 'suits_singular'), colours = { G.C.SUITS[suit] } } \n\t\t}\n\tend,\n\t\n\tcalculate = function(self, card, context)\n\t\tif context.joker_main then\n\t\t\tlocal card_count = 0\n\t\t\tfor k,v in ipairs(G.graveyard) do\n\t\t\t\tif v:is_suit(G.GAME.current_round.picubed_ordersector.suit) or (v.debuff and v.base.suit == G.GAME.current_round.picubed_ordersector.suit) then \n\t\t\t\t\tcard_count = card_count + 1\n\t\t\t\tend\n\t\t\tend\n            return {\n                Xmult = 1 + card.ability.extra.Xmult_mod * card_count,\n            }\n        end\n\tend",
      "config": {
        "extra": {
          "Xmult_mod": 0.25
        }
      },
      "ability": {
        "extra": {
          "Xmult_mod": 0.25
        }
      },
      "vars": [
        0.25,
        null,
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "luckycolorchip",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 6,
        "y": 10
      },
      "raw": "-- Lucky Color Chip (Þe Autumn Circus)\n\tkey = 'luckycolorchip',\n\tloc_txt = {\n\t\tname = 'Lucky Color Chip',\n\t\ttext = {\n\t\t\t\"Create an random {C:attention}Oddity{}\", \n\t\t\t\"if all cards {C:attention}held in hand{}\",\n\t\t\t\"share the {C:attention}same suit{}\",\n\t\t\t\"{C:inactive}(Must have room){}\"\n\t\t\t\n\t\t}\n\t},\n\trarity = 2,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 6, y = 10 },\n\tcost = 6,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\t\n\tcalculate = function(self, card, context)\n\t\tif context.joker_main and #G.hand.cards > 0 then\n\t\t\tlocal all_same_suit = false\n\t\t\tlocal suit_list = {}\n            for k, v in pairs(SMODS.Suits) do\n                suit_list[k] = 0\n            end\n\t\t\tfor k, v in ipairs(G.hand.cards) do\n\t\t\t\tfor kk, vv in pairs(suit_list) do\n\t\t\t\t\tif v:is_suit(kk, true) then \n\t\t\t\t\t\tsuit_list[kk] = suit_list[kk] + 1\n\t\t\t\t\tend \n\t\t\t\tend\n            end\n\t\t\tfor kk, vv in pairs(suit_list) do\n                if suit_list[kk] == #G.hand.cards then \n                    all_same_suit = true\n\t\t\t\t\tbreak\n                end \n            end \n            if all_same_suit then\n\t\t\t\tif #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then\n\t\t\t\t\tG.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1\n\t\t\t\t\tG.E_MANAGER:add_event(Event({\n\t\t\t\t\t\tfunc = (function()\n\t\t\t\t\t\t\tG.E_MANAGER:add_event(Event({\n\t\t\t\t\t\t\t\tfunc = function() \n\t\t\t\t\t\t\t\t\tlocal card = create_card('Oddity',G.consumeables, nil, nil, nil, nil, nil, 'luckycolorchip')\n\t\t\t\t\t\t\t\t\tcard:add_to_deck()\n\t\t\t\t\t\t\t\t\tG.consumeables:emplace(card)\n\t\t\t\t\t\t\t\t\tG.GAME.consumeable_buffer = 0\n\t\t\t\t\t\t\t\t\treturn true\n\t\t\t\t\t\t\t\tend}))   \n\t\t\t\t\t\t\t\tcard_eval_status_text(context.blueprint_card or card, 'extra', nil, nil, nil, {message = localize('k_plus_oddity'), colour = G.C.PURPLE})                       \n\t\t\t\t\t\t\treturn true\n\t\t\t\t\t\tend)\n\t\t\t\t\t}))\n\t\t\t\tend\n            end\n        end\n\tend",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "PiCubedsJokers",
      "atlas": null,
      "pos": null,
      "raw": "key = \"PiCubedsJokers\",\r\n    path = \"picubedsjokers.png\",\r\n    px = 71,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "modicon",
      "atlas": null,
      "pos": null,
      "raw": "key = 'modicon',\r\n    path = 'picubedsicon.png',\r\n    px = 32,\r\n    py = 32",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "picubedsdeck",
      "atlas": null,
      "pos": null,
      "raw": "key = \"picubedsdeck\",\r\n    path = \"picubedsdeck.png\",\r\n    px = 71,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "picubedsstickers",
      "atlas": null,
      "pos": null,
      "raw": "key = \"picubedsstickers\",\r\n    path = \"picubedsstickers.png\",\r\n    px = 71,\r\n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "picubed_tags",
      "atlas": null,
      "pos": null,
      "raw": "key = \"picubed_tags\",\r\n\tpath = \"picubedstag.png\",\r\n\tpx = 34,\r\n\tpy = 34",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "rhythm2",
      "atlas": null,
      "pos": null,
      "raw": "key = \"rhythm2\",\r\n\tpath = \"rhythm2.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Achievement",
      "key": "printererror",
      "atlas": null,
      "pos": null,
      "raw": "-- Printer Error\n    key = 'printererror',\n    --reset_on_startup = true,\n    order = 1,\n    unlock_condition = function(self, args)\n        if args.type == 'picubed_printer_error' then return true end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Achievement",
      "key": "grossedoff",
      "atlas": null,
      "pos": null,
      "raw": "-- Grossed Off\n    key = 'grossedoff',\n    --reset_on_startup = true,\n    order = 2,\n    unlock_condition = function(self, args)\n        if args.type == 'picubed_extinction_grossedoff' then return true end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Achievement",
      "key": "stoned",
      "atlas": null,
      "pos": null,
      "raw": "-- Stoned\n    key = 'stoned',\n    --reset_on_startup = true,\n    order = 3,\n    unlock_condition = function(self, args)\n        local all_stone = true\n        if G and G.playing_cards and #G.playing_cards > 0 then\n            for k,v in ipairs(G.playing_cards) do\n                if not SMODS.has_enhancement(v, 'm_stone') then\n                    all_stone = false\n                    break\n                end\n            end\n            if all_stone then return true end\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Achievement",
      "key": "agrandmemorial",
      "atlas": null,
      "pos": null,
      "raw": "-- A Grand Memorial\n    key = 'agrandmemorial',\n    --reset_on_startup = true,\n    order = 4,\n    unlock_condition = function(self, args)\n        if args.type == 'picubed_straightflush_agrandmemorial' then return true end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Achievement",
      "key": "dontgetcookedstay",
      "atlas": null,
      "pos": null,
      "raw": "-- Don't Get Cooked, Stay...\n    key = 'dontgetcookedstay',\n    --reset_on_startup = true,\n    order = 5,\n    unlock_condition = function(self, args)\n        if args.type == 'picubed_discard12_dontgetcookedstay' then return true end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Achievement",
      "key": "bananabreaker",
      "atlas": null,
      "pos": null,
      "raw": "-- Banana Breaker\n    key = 'bananabreaker',\n    --reset_on_startup = true,\n    order = 6,\n    unlock_condition = function(self, args)\n        if args.type == 'picubed_snakeeyes_bananabreaker' then return true end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Achievement",
      "key": "wrapastraightflush",
      "atlas": null,
      "pos": null,
      "raw": "-- Wrap-a-Straight Flush\n    key = 'wrapastraightflush',\n    --reset_on_startup = true,\n    order = 7,\n    unlock_condition = function(self, args)\n        if args.type == 'picubed_roundabout_wrapastraightflush' then return true end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Achievement",
      "key": "criticalhit",
      "atlas": null,
      "pos": null,
      "raw": "-- Critical Hit!\n    key = 'criticalhit',\n    --reset_on_startup = true,\n    order = 8,\n    unlock_condition = function(self, args)\n        if args.type == 'picubed_forgery_criticalhit' then return true end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Achievement",
      "key": "balatrothemecustomremix",
      "atlas": null,
      "pos": null,
      "raw": "-- Balatro Theme Custom Remix\n    key = 'balatrothemecustomremix',\n    --reset_on_startup = true,\n    order = 9,\n    unlock_condition = function(self, args)\n        local rh_count = 0\n        if G and G.jokers and G.jokers.cards then\n            for k,v in ipairs(G.jokers.cards) do\n                for i=1,#rhythm_heaven_list do\n                    if string.find(v.config.center.key, rhythm_heaven_list[i]) then\n                        rh_count = rh_count + 1\n                    end\n                end\n            end\n            if rh_count >= 4 then return true end\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "covetousdeck",
      "atlas": "picubedsdeck",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "-- Covetous Deck\n    name = \"Covetous Deck\",\n    key = \"covetousdeck\",\n    loc_txt = {\n        name = \"Covetous Deck\",\n        text = {\n        \"Start with a\",\n        \"{C:attention,T:j_picubed_shoppingtrolley}#1#{},\",\n        \"{C:attention,T:j_picubed_preorderbonus}#2#{},\",\n        \"and {C:attention,T:v_seed_money}#3#{}\",\n        },\n    },\n    pos = { x = 3, y = 0 },\n    atlas = \"picubedsdeck\",\n    unlocked = true,\n    config = { \n        jokers = {'j_picubed_shoppingtrolley', 'j_picubed_preorderbonus'}, \n        vouchers = {'v_seed_money'},\n    },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { \n            localize { type = 'name_text', set = 'Joker', key = 'j_picubed_shoppingtrolley' },\n            localize { type = 'name_text', set = 'Joker', key = 'j_picubed_preorderbonus' },\n            localize { type = 'name_text', set = 'Voucher', key = self.config.vouchers[1] },\n        } }\n    end,",
      "config": {},
      "ability": {},
      "vars": [
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "myepicdeck",
      "atlas": "picubedsdeck",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "-- my epic deck by pi_cubed\n    name = \"my epic deck by pi_cubed\",\n    key = \"myepicdeck\",\n    loc_txt = {\n        name = \"my epic deck by pi_cubed\",\n        text = {\n        \"{C:tarot}pi_cubed's Jokers{}' {C:attention}Jokers{}\",\n        \"are {C:attention}3x{} more likely to appear,\",\n        \"Start with an extra {C:money}$#1#\",\n        },\n    },\n    pos = { x = 1, y = 0 },\n    atlas = \"picubedsdeck\",\n    unlocked = true,\n    config = { dollars = 6 },\n    loc_vars = function(self, info_queue, back)\n        return { vars = { self.config.dollars } }\n    end,",
      "config": {
        "dollars": 6
      },
      "ability": {
        "dollars": 6
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "medusadeck",
      "atlas": "picubedsdeck",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "-- Medusa Deck\n    name = \"Medusa Deck\",\n    key = \"medusadeck\",\n    loc_txt = {\n        name = \"Medusa Deck\",\n        text = {\n        \"Start with 8 {C:attention,T:m_stone}Stone cards{}\",\n        \"instead of Kings and Queens\",\n        },\n    },\n    pos = { x = 0, y = 1 },\n    atlas = \"picubedsdeck\",\n    unlocked = true,\n    apply = function(self, back)\n        G.E_MANAGER:add_event(Event({\n            func = function()\n                for k, v in pairs(G.playing_cards) do\n                    if v:get_id() == 13 or v:get_id() == 12 then\n                        v:set_ability('m_stone', nil, true)\n                    end\n                end\n                return true\n            end\n        }))\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "wonderfuldeck",
      "atlas": "picubedsdeck",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "-- Wonderful Deck\n    name = \"Wonderful Deck\",\n    key = \"wonderfuldeck\",\n    loc_txt = {\n        name = \"Wonderful Deck\",\n        text = {\n        \"Start with a\",\n        \"{C:dark_edition,T:e_foil}Foil{} {C:attention,T:j_picubed_talkingflower}Talking Flower{}\",\n        },\n    },\n    pos = { x = 0, y = 0 },\n    atlas = \"picubedsdeck\",\n    unlocked = true,\n    apply = function(self)\n        G.E_MANAGER:add_event(Event({\n            func = function()\n                SMODS.add_card({set = 'Joker', area = G.jokers, skip_materialize = true, key = \"j_picubed_talkingflower\", edition = 'e_foil'})\n            return true end\n        }))\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "collectorsdeck",
      "atlas": "picubedsdeck",
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "-- Collector's Deck\n    name = \"Collector's Deck\",\n    key = \"collectorsdeck\",\n    loc_txt = {\n        name = \"Collector's Deck\",\n        text = {\n        \"Start with a {C:attention,T:v_magic_trick}#1#{},\",\n        \"{C:attention,T:v_illusion}#2#{}, and {C:attention,T:v_overstock_norm}#3#{}\",\n        },\n    },\n    pos = { x = 4, y = 0 },\n    atlas = \"picubedsdeck\",\n    unlocked = true,\n    config = { \n        vouchers = {'v_magic_trick', 'v_illusion', 'v_overstock_norm'},\n    },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { \n            localize { type = 'name_text', set = 'Voucher', key = self.config.vouchers[1] },\n            localize { type = 'name_text', set = 'Voucher', key = self.config.vouchers[2] },\n            localize { type = 'name_text', set = 'Voucher', key = self.config.vouchers[3] },\n        } }\n    end,",
      "config": {},
      "ability": {},
      "vars": [
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "rejuvinationdeck",
      "atlas": "picubedsdeck",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "-- Rejuvenation Deck (Rejuvination)\n    name = \"Rejuvenation Deck\",\n    key = \"rejuvinationdeck\",\n    loc_txt = {\n        name = \"Rejuvenation Deck\",\n        text = {\n        \"{C:red}#1#{} Joker slots,\",\n        \"{C:attention}+#2#{} slot for every\",\n        \"other Boss Blind defeated\",\n        },\n    },\n    pos = { x = 2, y = 0 },\n    atlas = \"picubedsdeck\",\n    unlocked = true,\n    config = {joker_slot = -2, joker_slot_mod = 1 },\n    loc_vars = function(self, info_queue, card)\n        return {vars = {self.config.joker_slot, self.config.joker_slot_mod}}\n    end,\n    calculate = function(self, back, context)\n        if context.context == 'eval' and G.GAME.last_blind and G.GAME.last_blind.boss then\n            G.E_MANAGER:add_event(Event({\n                trigger = 'before',\n                func = function()\n                    if G.GAME.current_round.pi_cubed_rejuvenation_secondboss == true then\n                        G.GAME.current_round.pi_cubed_rejuvenation_secondboss = false\n                        not_original_modify_joker_slot_count_func()\n                    else\n                        G.GAME.current_round.pi_cubed_rejuvenation_secondboss = true\n                    end\n                return true\n                end\n            }))\n        end\n    end",
      "config": {
        "joker_slot": -2,
        "joker_slot_mod": 1
      },
      "ability": {
        "joker_slot": -2,
        "joker_slot_mod": 1
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Challenge",
      "key": "nostalgicrejuvinationdeck",
      "atlas": null,
      "pos": null,
      "raw": "-- Nostalgic Rejuvination Deck Challenge Deck\n    key = 'nostalgicrejuvinationdeck',\n    rules = {\n        custom = {\n            { id = 'picubed_slots_gain', value = 1 },\n        },\n        modifiers = {\n            { id = 'joker_slots', value = 0 },\n            { id = 'dollars',  value = 8 },\n        }\n    },",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "duplicitousdeck",
      "atlas": "picubedsdeck",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "-- Duplicitous Deck\n    name = \"Duplicitous Deck\",\n    key = \"duplicitousdeck\",\n    loc_txt = {\n        name = \"Duplicitous Deck\",\n        text = {\n            \"{C:attention}+#1#{} Joker Slot,\",\n            \"Jokers can appear with\",\n            \"the {C:attention}Contractual{} sticker\",\n            \"{C:inactive,s:0.8}(Eternal and Perishable combined){}\",\n            \"Start with a\",\n            \"{C:attention}Contractual{} {C:attention,T:j_credit_card}Credit Card{}\",\n        },\n    },\n    pos = { x = 1, y = 1 },\n    atlas = \"picubedsdeck\",\n    unlocked = true,\n    config = { joker_slot = 1 },\n    loc_vars = function(self, info_queue, back)\n        return { vars = { self.config.joker_slot } }\n    end,\n    apply = function(self, back)\n        G.GAME.modifiers.enable_picubed_contractuals_in_shop = true\n        G.GAME.modifiers['enable_duplicitousdeck'] = true\n        G.E_MANAGER:add_event(Event({\n            func = function()\n                local card = SMODS.add_card({set = 'Joker', area = G.jokers, skip_materialize = true, key = \"j_credit_card\", stickers = { 'picubed_contractual' }, no_edition = true })\n                card:set_picubed_contractual()\n                --table.insert(G.playing_cards, card)\n                --G.jokers:emplace(card)\n            return true end\n        }))\n        --G.jokers.cards[1]:set_picubed_contractual()\n    end,",
      "config": {
        "joker_slot": 1
      },
      "ability": {
        "joker_slot": 1
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "789",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "--7 8 9\n    key = '789',\n    loc_txt = {\n        name = '7 8 9',\n        text = {\n            \"If played hand contains a {C:attention}scoring\",\n            \"{C:attention}7 {}and {C:attention}9{}, {C:attention}destroy{} all scored {C:attention}9s{},\",\n            \"and gain {X:mult,C:white}X#1#{} Mult per 9 scored\",\n            \"{C:inactive}(Currently {X:mult,C:white}X#2#{} {C:inactive}Mult)\"\n        }\n    },\n    pronouns = 'she_they',\n    rarity = 2,\n    atlas = 'PiCubedsJokers',\n    pos = { x = 3, y = 1 },\n    cost = 7,\n    config = { extra = { Xmult_mod = 0.3, Xmult = 1 } },\n    discovered = true,\n    blueprint_compat = true,\n    perishable_compat = false,\n    eternal_compat = true,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.Xmult_mod, card.ability.extra.Xmult} }\n    end,\n    calculate = function(self, card, context)\n        if context.individual and context.cardarea == G.play then\n            local has_7 = false\n            for k,v in ipairs(context.scoring_hand) do\n                if v:get_id() == 7 then\n                    has_7 = true\n                end\n            end\n            if has_7 == true then\n                if context.other_card:get_id() == 9 and not context.blueprint and not context.retrigger_joker\n                and not context.other_card.debuff then\n                    card.ability.extra.Xmult = card.ability.extra.Xmult + card.ability.extra.Xmult_mod\n                    return {\n                        message = localize('k_upgrade_ex'),\n                        colour = G.C.MULT,\n                        card = card\n                    }\n                end\n            end\n        end\n        if context.joker_main and card.ability.extra.Xmult > 1 then\n            return {\n                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.Xmult } },\n                Xmult_mod = card.ability.extra.Xmult, \n                colour = G.C.MULT\n            }\n        end\n        if context.destroying_card and context.cardarea == G.play and not context.blueprint and not context.retrigger_joker then\n            local has_7 = false\n            for k,v in ipairs(context.scoring_hand) do\n                if v:get_id() == 7 then\n                    has_7 = true\n                end\n            end\n            if has_7 == true then\n                if context.destroying_card:get_id() == 9 and not context.destroying_card.debuff then\n                    return {\n                        remove = true\n                    }\n                end\n            end\n        end\n    end",
      "config": {
        "extra": {
          "Xmult_mod": 0.3,
          "Xmult": 1
        }
      },
      "ability": {
        "extra": {
          "Xmult_mod": 0.3,
          "Xmult": 1
        }
      },
      "vars": [
        0.3,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "acecomedian",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 7,
        "y": 1
      },
      "raw": "--Ace Comedian\n    key = 'acecomedian',\n    loc_txt = {\n        name = 'Ace Comedian',\n        text = {\n            \"Retrigger each played\",\n            \"{C:attention}Ace{}, {C:attention}10{}, {C:attention}9{}, and {C:attention}8{}\"\n        }\n    },\n    pronouns = 'they_them',\n    rarity = 2,\n    config = { extra = { repetitions = 1 } },\n    atlas = 'PiCubedsJokers',\n    pos = { x = 7, y = 1 },\n    cost = 7,\n    discovered = true,\n    blueprint_compat = true,\n    perishable_compat = true,\n    eternal_compat = true,\n    calculate = function(self, card, context)\n        if context.cardarea == G.play and context.repetition and not context.repetition_only then\n            if \n            context.other_card:get_id() == 8 or\n            context.other_card:get_id() == 9 or\n            context.other_card:get_id() == 10 or\n            context.other_card:get_id() == 14 then\n\t\t\t\treturn {\n\t\t\t\t\tmessage = localize('k_again_ex'),\n                    repetitions = card.ability.extra.repetitions,\n                    card = card\n\t\t\t\t}\n\t\t\tend\n\t\tend\n    end",
      "config": {
        "extra": {
          "repetitions": 1
        }
      },
      "ability": {
        "extra": {
          "repetitions": 1
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "acorntree",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 6,
        "y": 6
      },
      "raw": "--Acorn Tree\n\tkey = 'acorntree',\n\tloc_txt = {\n\t\tname = 'Acorn Tree',\n\t\ttext = {\n\t\t\t\"When {C:attention}Blind{} is selected, all\",\n\t\t\t\"Jokers are {C:attention}flipped and{}\",\n\t\t\t\"{C:attention}shuffled{}, and earn {C:money}$#1#{} for\",\n\t\t\t\"each other Joker affected\"\n\t\t}\n\t},\n\tpronouns = 'she_they',\n\trarity = 2,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 6, y = 6 },\n\tcost = 6,\n\tdiscovered = true,\n\tblueprint_compat = false,\n\tperishable_compat = true,\n\teternal_compat = true,\n\tconfig = { extra = { money = 2 } },\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.money } }\n\tend,\n\tcalculate = function(self, card, context)\n\t\tif context.setting_blind and not context.blueprint then\n\t\t\tG.E_MANAGER:add_event(Event({ trigger = 'after', delay = 0.2, func = function() \n\t\t\t\tfor k, v in ipairs(G.jokers.cards) do\n\t\t\t\t\tv:flip()\n\t\t\t\tend\n\t\t\treturn true end }))\n\t\t\tif #G.jokers.cards > 1 then \n\t\t\t\tG.E_MANAGER:add_event(Event({ trigger = 'after', delay = 0.2, func = function() \n                    G.E_MANAGER:add_event(Event({ func = function() G.jokers:shuffle('aajk'); play_sound('cardSlide1', 0.85);return true end })) \n                    delay(0.15)\n                    G.E_MANAGER:add_event(Event({ func = function() G.jokers:shuffle('aajk'); play_sound('cardSlide1', 1.15);return true end })) \n                    delay(0.15)\n                    G.E_MANAGER:add_event(Event({ func = function() G.jokers:shuffle('aajk'); play_sound('cardSlide1', 1);return true end })) \n                    delay(0.5)\n\t\t\t\treturn true end }))\n\t\t\t\treturn {\n\t\t\t\t\tdollars = card.ability.extra.money * (#G.jokers.cards - 1),\n\t\t\t\t\tcard = card,\n\t\t\t\t}\n\t\t\tend\n\t\tend\n\tend",
      "config": {
        "extra": {
          "money": 2
        }
      },
      "ability": {
        "extra": {
          "money": 2
        }
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "advancedskipping",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 8,
        "y": 1
      },
      "raw": "--Advanced Skipping\n    key = 'advancedskipping',\n    loc_txt = {\n        name = 'Advanced Skipping',\n        text = {\n            \"Receive {C:attention}#1#{} additional random {C:attention}tags\",\n            \"when blind is {C:attention}skipped{},\",\n            \"{C:attention}+#2# tag{} after each skip\",\n            \"{C:inactive}(Capped at current {}{C:attention}Ante{}{C:inactive}){}\"\n        }\n    },\n    pronouns = 'he_him',\n    rarity = 2,\n    atlas = 'PiCubedsJokers',\n    pos = { x = 8, y = 1 },\n    cost = 5,\n    discovered = true,\n    blueprint_compat = true,\n    perishable_compat = true,\n    eternal_compat = true,\n    config = { extra = { add_tags = 1, add_tags_mod = 1} },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.add_tags, card.ability.extra.add_tags_mod} }\n    end,\n    calculate = function(self, card, context)\n        if context.skip_blind and not context.blueprint then\n            --code below taken from Ortalab's Recycled Enhancement\n            local tag_pool = get_current_pool('Tag')\n            for i=1,card.ability.extra.add_tags do         \n                local selected_tag = pseudorandom_element(tag_pool, pseudoseed('advancedskipping'..G.GAME.round_resets.ante))\n                local it = 1\n                while selected_tag == 'UNAVAILABLE' do\n                    it = it + 1\n                    selected_tag = pseudorandom_element(tag_pool, pseudoseed('advancedskipping'..it..G.GAME.round_resets.ante))\n                end\n                if selected_tag ~= 'tag_orbital' then\n                    add_tag(Tag(selected_tag))\n                else --i can't be assed dealing with orbital tag rn\n                    add_tag(Tag('tag_meteor'))\n                end\n            end\n            card:juice_up()\n            if G.GAME.round_resets.ante > card.ability.extra.add_tags then\n                card.ability.extra.add_tags = card.ability.extra.add_tags + card.ability.extra.add_tags_mod\n                return {\n                    message = localize('k_upgrade_ex'),\n                    card = card\n                }\n            end\n        end\n    end",
      "config": {
        "extra": {
          "add_tags": 1,
          "add_tags_mod": 1
        }
      },
      "ability": {
        "extra": {
          "add_tags": 1,
          "add_tags_mod": 1
        }
      },
      "vars": [
        1,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "allin",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 1,
        "y": 3
      },
      "raw": "--All In\n    key = 'allin',\n    loc_txt = {\n        name = 'All In',\n        text = {\n            {\n                \"Played {C:attention}face down{} cards are\",\n                \"retriggered {C:attention}#1#{} additonal times\"\n            },\n            {\n                \"{C:attention}Face down{} Jokers and\",\n                \"cards held in hand are\",\n                \"retriggered {C:attention}#2#{} additional time\",\n                \"{C:inactive}(except All In)\"\n            }\n        }\n    },\n    pronouns = 'he_they',\n    rarity = 2,\n    atlas = 'PiCubedsJokers',\n    pos = { x = 1, y = 3 },\n    cost = 6,\n    discovered = true,\n    blueprint_compat = true,\n    perishable_compat = true,\n    eternal_compat = true,\n    config = { extra = { repetitions = 2, other_repetitions = 1, face_down_cards = {} } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.repetitions, card.ability.extra.other_repetitions } }\n    end,\n    in_pool = function(self, args) return G.GAME.round_resets.ante >= 2 end,\n    calculate = function(self, card, context) --don't base your joker ideas on face-down cards.\n        if G.hand and #G.hand.highlighted and context.press_play then\n            for i = 1, #G.hand.highlighted do\n                if G.hand.highlighted[i].facing == 'back' then\n                    --print(\"kys\")\n                    card.ability.extra.face_down_cards[i] = true\n                    --print(i)\n                    --print(card.ability.extra.face_down_cards[i])\n                else\n                    --print(\"hi!\")\n                    card.ability.extra.face_down_cards[i] = false\n                    --print(i)\n                    --print(card.ability.extra.face_down_cards[i])\n                end\n            --print(#(card.ability.extra.face_down_cards or {6,6,6,6,6,6}))\n            end\n        end\n        if context.cardarea == G.play and context.repetition and not context.repetition_only then\n                --print(card.ability.extra.face_down_cards)\n                local card_pos = 1\n                for i = 1, #context.full_hand do\n                    if context.full_hand[i] == context.other_card then\n                        card_pos = i\n                        --print(i)\n                    end\n                end\n                --print(card.ability.extra.face_down_cards[card_pos])\n                if card.ability.extra.face_down_cards[card_pos] == true or context.other_card.facing == 'back' then\n                    --print(tostring(card_pos)..\"FACE DOWN!\")\n                    return {\n                        repetitions = card.ability.extra.repetitions,\n                        card = card\n                    }\n                end\n\t\tend\n        if context.final_scoring_step and context.cardarea == G.play then\n            card.ability.extra.face_down_cards = {}\n        end\n        if context.cardarea == G.hand and context.repetition and not context.repetition_only then\n            if context.other_card.facing == 'back' then\n\t\t\t\treturn {\n                    repetitions = card.ability.extra.other_repetitions,\n                    card = card\n\t\t\t\t}\n            end\n        end\n        if context.retrigger_joker_check and not context.retrigger_joker and context.other_card.ability.name ~= 'j_picubed_allin' then\n            if context.other_card.facing == 'back' then\n                return {\n                    repetitions = card.ability.extra.other_repetitions,\n                    card = card\n                }\n            end\n\t\tend\n    end",
      "config": {
        "extra": {
          "repetitions": 2,
          "other_repetitions": 1,
          "face_down_cards": {}
        }
      },
      "ability": {
        "extra": {
          "repetitions": 2,
          "other_repetitions": 1,
          "face_down_cards": {}
        }
      },
      "vars": [
        2,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "ambigram",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 5,
        "y": 1
      },
      "raw": "--Ambigram\n    key = 'ambigram',\n    loc_txt = {\n        name = 'Ambigram',\n        text = {\n            \"{C:attention}6s{} and {C:attention}9s{} can\",\n            \"{C:attention}swap ranks{} anytime\",\n            \"{C:inactive}(Select cards and\",\n            \"{C:inactive}then press 'Swap!')\",\n        }\n    },\n    pronouns = 'they_them',\n    rarity = 1,\n    atlas = 'PiCubedsJokers',\n    pos = { x = 5, y = 1 },\n    cost = 5,\n    discovered = true,\n    blueprint_compat = false,\n    perishable_compat = true,\n    eternal_compat = true,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "apartmentcomplex",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 9,
        "y": 2
      },
      "raw": "--Apartment Complex\n    key = 'apartmentcomplex',\n    loc_txt = {\n        name = 'Apartment Complex',\n        text = {\n            \"This Joker gains {X:mult,C:white}X#1#{} Mult if\",\n            \"{C:attention}played hand{} is a {C:attention}Flush House{}\",\n            \"{C:inactive}(Currently {X:mult,C:white}X#2#{} {C:inactive}Mult)\"\n        }\n    },\n    pronouns = 'he_they',\n    rarity = 3,\n    atlas = 'PiCubedsJokers',\n    pos = { x = 9, y = 2 },\n    cost = 7,\n    discovered = true,\n    blueprint_compat = true,\n    perishable_compat = false,\n    eternal_compat = true,\n    in_pool = function(self, args)\n        if G.GAME.hands[\"Flush House\"].played ~= 0 then\n            return true\n        end\n        if G.GAME.hands[\"Flush\"].played >= 2 and G.GAME.hands[\"Full House\"].played >= 2 then\n            return true\n        end\n        return false\n    end,\n    config = { extra = { Xmult_mod = 0.75, Xmult = 1 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.Xmult_mod, card.ability.extra.Xmult } }\n    end,\n    calculate = function(self, card, context)\n        if context.before and not context.blueprint and not context.retrigger_joker then\n            if next(context.poker_hands[\"Flush House\"]) then\n                card.ability.extra.Xmult = card.ability.extra.Xmult + card.ability.extra.Xmult_mod\n                return {\n                    message = localize('k_upgrade_ex'),\n                    colour = G.C.MULT,\n                    card = card\n                }\n            end\n        end\n        if context.joker_main and card.ability.extra.Xmult > 1 then\n            return {\n\t\t\t\tmessage = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.Xmult } },\n\t\t\t\tXmult_mod = card.ability.extra.Xmult\n\t\t\t}\n        end\n    end",
      "config": {
        "extra": {
          "Xmult_mod": 0.75,
          "Xmult": 1
        }
      },
      "ability": {
        "extra": {
          "Xmult_mod": 0.75,
          "Xmult": 1
        }
      },
      "vars": [
        0.75,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "arrogantjoker",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 8,
        "y": 3
      },
      "raw": "--Arrogant Joker\n\tkey = 'arrogantjoker',\n\tloc_txt = {\n\t\tname = 'Arrogant Joker',\n\t\ttext = {\n\t\t\t\"{X:mult,C:white}X#1#{} Mult if this Joker\",\n\t\t\t\"is the {C:attention}left-most {}Joker\"\n\t\t}\n\t},\n\tpronouns = 'he_him',\n\trarity = 1,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 8, y = 3 },\n\tdisplay_size = { w = 1.1 * 71, h = 1.1 * 95 },\n\tcost = 6,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tperishable_compat = true,\n\teternal_compat = true,\n\tconfig = { extra = { Xmult = 2 } },\n\tpools = { [\"Meme\"] = true },\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.Xmult } }\n\tend,\n\tupdate = function(self, card, dt)\n\t\tif G.jokers then\n\t\t\tif G.jokers.cards[1] == card then\n\t\t\t\tcard.children.center:set_sprite_pos({x = 8, y = 3})\n\t\t\telse\n\t\t\t\tcard.children.center:set_sprite_pos({x = 8, y = 4})\n\t\t\tend\n\t\telse\n\t\t\tcard.children.center:set_sprite_pos({x = 8, y = 3})\n\t\tend\n\tend,\n\t\n\tcalculate = function(self, card, context)\n\t\tif context.joker_main and G.jokers.cards[1] == card then\n\t\t\treturn {\n\t\t\t\tmessage = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.Xmult } },\n\t\t\t\tXmult_mod = card.ability.extra.Xmult\n\t\t\t}\n\t\tend\n\tend",
      "config": {
        "extra": {
          "Xmult": 2
        }
      },
      "ability": {
        "extra": {
          "Xmult": 2
        }
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "athrowawayjoker",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 6,
        "y": 11
      },
      "raw": "--A Throwaway Joker\n\tkey = 'athrowawayjoker',\n\tloc_txt = {\n\t\tname = 'A Throwaway Joker',\n\t\ttext = {\n\t\t\t\"This Joker gains {C:chips}+Chips{}\",\n\t\t\t\"equal to the base {C:mult}Mult{}\",\n            \"of {C:attention}discarded poker hand{}\",\n            \"{C:inactive}(Currently {C:chips}+#1#{C:inactive} Chips)\"\n\t\t}\n\t},\n\tpronouns = 'it_its',\n\trarity = 2,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 6, y = 11 },\n\tcost = 6,\n\tdiscovered = true,\n\tblueprint_compat = true,\n    perishable_compat = false,\n\teternal_compat = true,\n\tconfig = { extra = { chips = 0 } },\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.chips } }\n\tend,\n\tcalculate = function(self, card, context)\n        if context.pre_discard and not context.hook and not context.blueprint and not context.retrigger_joker then\n\t\t\tlocal text, _ = G.FUNCS.get_poker_hand_info(G.hand.highlighted)\n\t\t\tlocal basemult = G.GAME.hands[text].mult\n\t\t\tcard.ability.extra.chips = card.ability.extra.chips + basemult\n\t\t\treturn {\n                message = '+'..tostring(basemult),\n                colour = G.C.CHIPS\n            }\n\t\tend\n\t\tif context.joker_main then\n            return {\n                chip_mod = card.ability.extra.chips,\n                message = localize { type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }\n            }\n        end\n\tend",
      "config": {
        "extra": {
          "chips": 0
        }
      },
      "ability": {
        "extra": {
          "chips": 0
        }
      },
      "vars": [
        0
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "bigtwo",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 1,
        "y": 9
      },
      "raw": "--Big Two\n\tkey = 'bigtwo',\n\tloc_txt = {\n\t\tname = 'Big Two',\n\t\ttext = {\n\t\t\t\"Each played {C:attention}2{} has a \", \n\t\t\t\"{C:green}#2# in #3#{} chance to give\",\n            \"{X:mult,C:white}X#1#{} Mult when scored\",\n\t\t}\n\t},\n\tpronouns = 'they_them',\n\tconfig = { extra = { Xmult = 2, odds = 2 } },\n\trarity = 3,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 1, y = 9 },\n\tsoul_pos = { x = 1, y = 11 },\n\tcost = 8,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tloc_vars = function(self, info_queue, card)\n\t\tlocal numerator, denominator = SMODS.get_probability_vars(card, 1, card.ability.extra.odds, 'picubed_bigtwo')\n\t\treturn { vars = { card.ability.extra.Xmult, \n\t\t\tnumerator, denominator } \n\t\t}\n\tend,\n\tcalculate = function(self, card, context)\n        if context.individual and context.cardarea == G.play and context.other_card:get_id() == 2 then\n            if SMODS.pseudorandom_probability(card, 'picubed_bigtwo', 1, card.ability.extra.odds) then\n                return {\n                    xmult = card.ability.extra.Xmult\n                }\n            end\n        end\n\tend",
      "config": {
        "extra": {
          "Xmult": 2,
          "odds": 2
        }
      },
      "ability": {
        "extra": {
          "Xmult": 2,
          "odds": 2
        }
      },
      "vars": [
        2,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "bisexualflag",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 7,
        "y": 2
      },
      "raw": "--Bisexual Flag\n    key = 'bisexualflag',\n    loc_txt = {\n        name = 'Bisexual Flag',\n        text = {\n            \"If {C:attention}played hand{} contains a\",\n            \"{C:attention}Straight{} and {C:attention}four suits{},\",\n            \"create #1# {C:dark_edition}Negative {C:purple}Tarot{} cards\",\n        }\n    },\n    pronouns = 'it_its',\n    rarity = 3,\n    atlas = 'PiCubedsJokers',\n    pos = { x = 7, y = 2 },\n    cost = 8,\n    config = { extra = { tarots = 3 } },\n    discovered = true,\n    blueprint_compat = true,\n    perishable_compat = true,\n    eternal_compat = true,\n    loc_vars = function(self, info_queue, card)\n            info_queue[#info_queue + 1] = {key = 'e_negative_consumable', set = 'Edition', config = {extra = 1}}\n        return {\n            vars = { card.ability.extra.tarots }\n        }\n    end,\n    --[[in_pool = function(self, args)\n        if not G.GAME.challenge == 'ch_c_picubed_balalajokerpoker' then return true end\n    end,]]\n    calculate = function(self, card, context)\n        if context.joker_main then\n            local suit_list = {}\n            for k, v in pairs(SMODS.Suits) do\n                suit_list[k] = 0\n            end\n            for k, v in ipairs(context.scoring_hand) do --checking for all non-wild cards\n                if not SMODS.has_any_suit(v) then\n                    for kk, vv in pairs(suit_list) do\n                        if v:is_suit(kk, true) and suit_list[kk] ~= 1 then \n                            suit_list[kk] = 1\n                            break\n                        end \n                    end\n                end\n            end\n            for k, v in ipairs(context.scoring_hand) do --checking for all wild cards\n                if SMODS.has_any_suit(v) then\n                    for kk, vv in pairs(suit_list) do\n                        if v:is_suit(kk, true) and suit_list[kk] ~= 1 then \n                            suit_list[kk] = 1\n                            break\n                        end \n                    end\n                end\n            end\n            local suit_count = 0\n            for kk, vv in pairs(suit_list) do\n                if suit_list[kk] == 1 then \n                    suit_count = suit_count + 1\n                end \n            end \n            if string.find(context.scoring_name, \"Straight Spectrum\") or (next(context.poker_hands[\"Straight\"]) or next(context.poker_hands[\"Straight Flush\"])) and \n            suit_count >= 4 then\n                local card_type = 'Tarot'\n                for i=1,card.ability.extra.tarots do\n                    G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1\n                    G.E_MANAGER:add_event(Event({\n                        trigger = 'before',\n                        delay = 0.0,\n                        func = (function()\n                            local card = create_card(card_type,G.consumeables, nil, nil, nil, nil, nil, 'sup')\n                            card:set_edition('e_negative', true)\n                            card:add_to_deck()\n                            G.consumeables:emplace(card)\n                            G.GAME.consumeable_buffer = 0\n                            return true\n                        end\n                    )}))\n                    card_eval_status_text(card, 'extra', nil, nil, nil, {message = localize(\"k_picubeds_pride\"), colour = G.C.PURPLE})\n                end\n            end\n        end\n    end",
      "config": {
        "extra": {
          "tarots": 3
        }
      },
      "ability": {
        "extra": {
          "tarots": 3
        }
      },
      "vars": [
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "blackjoker",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 6,
        "y": 2
      },
      "raw": "--Black Joker\n    key = 'blackjoker',\n    loc_txt = {\n        name = 'Black Joker',\n        text = {\n            \"If the {C:attention}sum rank{} of\",\n            \"{C:attention}first{} played or discarded\",\n            \"cards is {C:attention}#2#{}, earn {C:money}$#3#{}\",\n        }\n    },\n    pronouns = 'it_its',\n    rarity = 1,\n    atlas = 'PiCubedsJokers',\n    pos = { x = 6, y = 2 },\n    cost = 5,\n    discovered = true,\n    blueprint_compat = true,\n    perishable_compat = true,\n    eternal_compat = true,\n    config = { extra = { sum_rank = 0, cap = 21, money = 7, ace_count = 0 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.sum_rank, card.ability.extra.cap, card.ability.extra.money } }\n    end,\n    calculate = function(self, card, context)\n        if context.first_hand_drawn then\n            local eval = function() return G.GAME.current_round.discards_used == 0 and G.GAME.current_round.hands_played == 0 and not G.RESET_JIGGLES end\n            juice_card_until(card, eval, true)\n        end\n        if ((context.cardarea == G.jokers and context.before) or context.pre_discard) and (G.GAME.current_round.discards_used <= 0 and G.GAME.current_round.hands_played <= 0) then\n            \n            card.ability.extra.sum_rank = 0\n            card.ability.extra.ace_count = 0\n            if card.ability.extra.cap ~= 21 then card.ability.extra.has_decimal = true end\n            for k,v in ipairs(context.full_hand) do\n                if SMODS.has_no_rank(v) then -- rankless cards\n                    card.ability.extra.sum_rank = card.ability.extra.sum_rank + 0\n                elseif v:get_id() == 14 then --aces \n                    card.ability.extra.sum_rank = card.ability.extra.sum_rank + 11\n                    card.ability.extra.ace_count = card.ability.extra.ace_count + 1\n                else\n                    card.ability.extra.sum_rank = card.ability.extra.sum_rank + (v.base.nominal or 0)\n                end\n                --return { message = tostring(card.ability.extra.sum_rank), card = card }\n            end\n\n            while card.ability.extra.sum_rank >= card.ability.extra.cap + 1 and card.ability.extra.ace_count > 0 do\n                card.ability.extra.sum_rank = card.ability.extra.sum_rank - 10\n                card.ability.extra.ace_count = card.ability.extra.ace_count - 1\n            end\n            if card.ability.extra.sum_rank < card.ability.extra.cap + 1 and card.ability.extra.sum_rank > card.ability.extra.cap - 1 then\n                return {\n                    dollars = card.ability.extra.money,\n                    card = card\n                }\n            else\n                return {\n                    message = tostring(card.ability.extra.sum_rank),\n                    card = card\n                }\n            end\n        end\n    end",
      "config": {
        "extra": {
          "sum_rank": 0,
          "cap": 21,
          "money": 7,
          "ace_count": 0
        }
      },
      "ability": {
        "extra": {
          "sum_rank": 0,
          "cap": 21,
          "money": 7,
          "ace_count": 0
        }
      },
      "vars": [
        0,
        21,
        7
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "blueberrypie",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 2,
        "y": 11
      },
      "raw": "--Blueberry Pie\n\tkey = 'blueberrypie',\n\tloc_txt = {\n\t\tname = 'Blueberry Pie',\n\t\ttext = {\n\t\t\t\"Copies ability of\",\n\t\t\t\"{C:attention}Joker{} to the right,\",\n\t\t\t\"this card is {C:attention}destroyed{}\",\n\t\t\t\"after {C:attention}#1#{} rounds\"\n\t\t},\n\t},\n    pronouns = 'she_they',\n\trarity = 2,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 2, y = 11 },\n\tcost = 7,\n\tdiscovered = true,\n\tblueprint_compat = true,\n    perishable_compat = true,\n\teternal_compat = false,\n    pools = { [\"Food\"] = true },\n\tconfig = { extra = { rounds = 5 } },\n\tloc_vars = function(self, info_queue, card)\n        if card.area and card.area == G.jokers then\n            local compatible = G.jokers.cards[1] and G.jokers.cards[1] ~= card and\n                G.jokers.cards[1].config.center.blueprint_compat\n            main_end = {\n                {\n                    n = G.UIT.C,\n                    config = { align = \"bm\", minh = 0.4 },\n                    nodes = {\n                        {\n                            n = G.UIT.C,\n                            config = { ref_table = card, align = \"m\", colour = compatible and mix_colours(G.C.GREEN, G.C.JOKER_GREY, 0.8) or mix_colours(G.C.RED, G.C.JOKER_GREY, 0.8), r = 0.05, padding = 0.06 },\n                            nodes = {\n                                { n = G.UIT.T, config = { text = ' ' .. localize('k_' .. (compatible and 'compatible' or 'incompatible')) .. ' ', colour = G.C.UI.TEXT_LIGHT, scale = 0.32 * 0.8 } },\n                            }\n                        }\n                    }\n                }\n            }\n            return { vars = { card.ability.extra.rounds }, main_end = main_end }\n        end\n\t\treturn { vars = { card.ability.extra.rounds } }\n    end,\n\tcalculate = function(self, card, context)\n        if context.end_of_round and not context.repetition and not context.individual and not context.retrigger_joker then \n            if card.ability.extra.rounds <= 1 then\n                SMODS.destroy_cards(card, nil, nil, true)\n                return {\n                    message = localize('k_eaten_ex'),\n                    colour = G.C.FILTER\n                }\n            else\n                card.ability.extra.rounds = card.ability.extra.rounds - 1\n                return {\n                    message = localize{type='variable',key='a_remaining',vars={card.ability.extra.rounds}},\n                    colour = G.C.FILTER\n                }\n            end\n        end\n        local other_joker = nil\n        for i = 1, #G.jokers.cards do\n            if G.jokers.cards[i] == card then other_joker = G.jokers.cards[i + 1] end\n        end\n        return SMODS.blueprint_effect(card, other_joker, context)\n    end",
      "config": {
        "extra": {
          "rounds": 5
        }
      },
      "ability": {
        "extra": {
          "rounds": 5
        }
      },
      "vars": [
        5
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "boomerang",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 9,
        "y": 9
      },
      "raw": "--Boomerang\n\tkey = 'boomerang',\n\tloc_txt = {\n\t\tname = 'Boomerang',\n\t\ttext = {\n\t\t\t\"Scoring cards are\",\n\t\t\t\"{C:attention}shuffled back{}\",\n\t\t\t\"into the deck\",\n\t\t}\n\t},\n\tpronouns = 'it_its',\n\trarity = 2,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 9, y = 9 },\n\tcost = 4,\n\tdiscovered = true,\n\tblueprint_compat = false,\n    perishable_compat = true,\n\teternal_compat = true,\n\tcalculate = function(self, card, context)\n\t\tif context.after and not context.blueprint then -- makeshift jankshit context.scoring_hand but \"global\"\n\t\t\tpicubed_boomerang_scoring = {}\n\t\t\tfor i=1,#context.full_hand do\n\t\t\t\tfor k,v in ipairs(context.scoring_hand) do\n\t\t\t\t\tif context.full_hand[i] == v then\n\t\t\t\t\t\tpicubed_boomerang_scoring[v] = true\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "chickenjoker",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 7,
        "y": 8
      },
      "raw": "--Chicken Joker!\n\tkey = 'chickenjoker',\n\tloc_txt = {\n\t\tname = 'Chicken Joker!',\n\t\ttext = {\n\t\t\t\"If scoring hand contains\",\n\t\t\t\"a {C:attention}Stone{} card or a {C:attention}Steel{}\",\n\t\t\t\"card, {C:attention}fill{} empty Joker\",\n\t\t\t\"slots with {C:dark_edition}Editioned{} {C:attention}Popcorn{}\"\n\t\t}\n\t},\n\tpronouns = 'it_its',\n\trarity = 1,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 7, y = 8 },\n\tcost = 5,\n\tdiscovered = true,\n\tblueprint_compat = false,\n\tperishable_compat = true,\n\teternal_compat = true,\n\tloc_vars = function(self, info_queue, card)\n\t\tinfo_queue[#info_queue+1] = G.P_CENTERS.m_stone\n\t\tinfo_queue[#info_queue+1] = G.P_CENTERS.m_steel\n\t\tinfo_queue[#info_queue+1] = G.P_CENTERS.j_popcorn\n\t\treturn { vars = { card.ability.max_highlighted } }\n\tend,\n\tin_pool = function(self, args)\n\t\tfor kk, vv in pairs(G.playing_cards or {}) do\n            if SMODS.has_enhancement(vv, 'm_stone') or SMODS.has_enhancement(vv, 'm_steel') then\n                return true\n            end\n\t\tend\n\t\treturn false\n\tend,\n\tcalculate = function(self, card, context)\n\t\tif context.before and context.main_eval and not context.blueprint then\n\t\t\tlocal has_flint_or_steel = false\n\t\t\tfor kk, vv in ipairs(context.scoring_hand) do\n\t\t\t\tif SMODS.has_enhancement(vv, 'm_stone') or SMODS.has_enhancement(vv, 'm_steel') then\n\t\t\t\t\t\thas_flint_or_steel = true\n\t\t\t\tend\n\t\t\tend\n\t\t\tif has_flint_or_steel then\n\t\t\t\tlocal joker_limit_buffer = 0\n\t\t\t\tfor i=1, (G.jokers.config.card_limit) do\n\t\t\t\t\tif (#G.jokers.cards - joker_limit_buffer) < G.jokers.config.card_limit then\n\t\t\t\t\t\tlocal polled_edition = poll_edition('iamsteve'..G.GAME.round_resets.ante, 1, false, true)\n\t\t\t\t\t\tif polled_edition ~= 'e_negative' then joker_limit_buffer = joker_limit_buffer - 1 end\n\t\t\t\t\t\tG.E_MANAGER:add_event(Event({\n\t\t\t\t\t\t\ttrigger = 'before',\n\t\t\t\t\t\t\tdelay = 0.25,\n\t\t\t\t\t\t\tfunc = (function()\n\t\t\t\t\t\t\t\tlocal mpcard = create_card('Joker', G.jokers, nil, nil, nil, nil, 'j_popcorn', 'chi')\n\t\t\t\t\t\t\t\tmpcard:set_edition(polled_edition, false, true)\n\t\t\t\t\t\t\t\tmpcard:add_to_deck()\n\t\t\t\t\t\t\t\tG.jokers:emplace(mpcard)\n\t\t\t\t\t\t\t\tmpcard:start_materialize()\n\t\t\t\t\t\t\t\tcard:juice_up()\n\t\t\t\t\t\t\t\treturn true\n\t\t\t\t\t\tend)}))\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "chisel",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "--Chisel\n\tkey = 'chisel',\n\tloc_txt = {\n\t\tname = 'Chisel',\n\t\ttext = {\n\t\t\t\"If {C:attention}first{} played card\",\n\t\t\t\"is a {C:attention}Stone{} card, {C:attention}remove{}\", \n\t\t\t\"the enhancement and add\",\n\t\t\t\"{C:chips}+#1# {C:attention}bonus{} {C:attention}chips{} to the card\"\n\t\t}\n\t},\n\tpronouns = 'it_its',\n\tconfig = { extra = { big_bonus = 50 } },\n\trarity = 1,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 4, y = 0 },\n\tcost = 4,\n\tdiscovered = true,\n\tblueprint_compat = false,\n\tperishable_compat = true,\n\teternal_compat = true,\n\tenhancement_gate = 'm_stone',\n\tloc_vars = function(self, info_queue, card)\n\t\tinfo_queue[#info_queue+1] = G.P_CENTERS.m_stone\n\t\treturn {\n\t\t\tvars = { card.ability.extra.big_bonus, card.ability.max_highlighted }\n\t\t}\n\tend,\n\t\n\tcalculate = function(self, card, context)\n\t\tif context.cardarea == G.play and context.individual and not context.blueprint then\n\t\t\tif context.other_card == context.scoring_hand[1] and SMODS.has_enhancement(context.other_card, 'm_stone') then\n\t\t\t\tif not context.other_card.debuff then \n\t\t\t\t\tcontext.other_card:set_ability(G.P_CENTERS.c_base, nil, true)\n\t\t\t\t\tcontext.other_card.ability.perma_bonus = context.other_card.ability.perma_bonus or 0 --initialises a permanent chips value\n\t\t\t\t\tcontext.other_card.ability.perma_bonus = context.other_card.ability.perma_bonus + card.ability.extra.big_bonus --add permanent chips to playing card\n\t\t\t\t\treturn {\n\tmessage = localize(\"k_picubeds_chisel\"),\n\tcolour = G.C.CHIPS\n\t\t\t\t\t}\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend",
      "config": {
        "extra": {
          "big_bonus": 50
        }
      },
      "ability": {
        "extra": {
          "big_bonus": 50
        }
      },
      "vars": [
        50,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "currencyexchange",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 7,
        "y": 4
      },
      "raw": "--Currency Exchange\n\tkey = 'currencyexchange',\n\tloc_txt = {\n\t\tname = 'Currency Exchange',\n\t\ttext = {\n\t\t\t\"Cards held in hand\",\n\t\t\t\"give {C:mult}+#1#{} Mult\"\n\t\t}\n\t},\n\tpronouns = 'it_its',\n\trarity = 1,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 7, y = 4 },\n\tcost = 5,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tperishable_compat = true,\n\teternal_compat = true,\n\tconfig = { extra = { mult = 2 } },\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.mult } }\n\tend,\n\tcalculate = function(self, card, context)\n\t\tif context.cardarea == G.hand and context.individual and not context.end_of_round then\n\t\t\tif not context.other_card.debuff then\n\t\t\t\treturn {\n                    mult = card.ability.extra.mult,\n                    card = context.other_card\n                }\n\t\t\tend\n\t\tend\n\tend",
      "config": {
        "extra": {
          "mult": 2
        }
      },
      "ability": {
        "extra": {
          "mult": 2
        }
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "cyclone",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 0,
        "y": 8
      },
      "raw": "--Cyclone\n\tkey = 'cyclone',\n\tloc_txt = {\n\t\tname = 'Cyclone',\n\t\ttext = {\n\t\t\t\"Scored cards with a {C:attention}Seal{}\",\n\t\t\t\"create the {C:planet}Planet{} card of\",\n\t\t\t\"played {C:attention}poker hand{}\",\n\t\t}\n\t},\n\tpronouns = 'he_him',\n\trarity = 3,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 0, y = 8 },\n\tcost = 7,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tperishable_compat = true,\n\teternal_compat = false,\n\tcalculate = function(self, card, context)\n\t\tif context.cardarea == G.play then\n\t\t\tif context.individual then\n\t\t\t\tif context.other_card.ability.seal then\n\t\t\t\t\tif #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then\n\t\t\t\t\t\tG.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1\n\t\t\t\t\t\tlocal _planet = nil\n\t\t\t\t\t\tfor k, v in pairs(G.P_CENTER_POOLS.Planet) do\n                            if v.config.hand_type == G.GAME.last_hand_played then\n                                _planet = v.key\n                            end\n\t\t\t\t\t\tend\n\t\t\t\t\t\tG.E_MANAGER:add_event(Event({\n\t\t\t\t\t\t\ttrigger = 'before',\n\t\t\t\t\t\t\tdelay = 0.0,\n\t\t\t\t\t\t\tfunc = (function()\n\t\t\t\t\t\t\t\tSMODS.add_card({ key = _planet or 'c_pluto' })\n\t\t\t\t\t\t\t\tG.GAME.consumeable_buffer = 0\n\t\t\t\t\t\t\t\t--card:juice_up(0.5, 0.5)\n\t\t\t\t\t\t\t\treturn true\n\t\t\t\t\t\t\tend)}))\n\t\t\t\t\t\tcard_eval_status_text(card, 'extra', nil, nil, nil, {message = localize('k_plus_planet'), colour = G.C.SECONDARY_SET.Planet})\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "d2",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "--D2\n\tkey = 'd2',\n\tloc_txt = {\n\t\tname = 'D2',\n\t\ttext = {\n\t\t\t\"{C:green}#2# in #3#{} chance\", \n\t\t\t\"to give {C:mult}+#1#{} Mult\"\n\t\t}\n\t},\n\tpronouns = 'she_they',\n\tconfig = { extra = { mult = 20, odds = 2 } },\n\trarity = 1,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 1, y = 0 },\n\tcost = 4,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tloc_vars = function(self, info_queue, card)\n\t\tlocal numerator, denominator = SMODS.get_probability_vars(card, 1, card.ability.extra.odds, 'picubed_d2')\n\t\treturn { vars = { card.ability.extra.mult, \n\t\t\tnumerator, denominator } \n\t\t}\n\tend,\n\tcalculate = function(self, card, context)\n\t\tif context.joker_main then\n\t\t\tif SMODS.pseudorandom_probability(card, 'picubed_d2', 1, card.ability.extra.odds) then\n\t\t\t\treturn {\n\t\t\t\t\tmult_mod = card.ability.extra.mult,\n\t\t\t\t\tmessage = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }\n\t\t\t\t}\n\t\t\tend\n\t\tend\n\tend",
      "config": {
        "extra": {
          "mult": 20,
          "odds": 2
        }
      },
      "ability": {
        "extra": {
          "mult": 20,
          "odds": 2
        }
      },
      "vars": [
        20,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "echolocation",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 9,
        "y": 1
      },
      "raw": "--Echolocation\n    key = 'echolocation',\n    loc_txt = {\n        name = 'Echolocation',\n        text = {\n            \"{C:attention}+#3#{} hand size,\",\n            \"{C:green}#1# in #2#{} playing cards\",\n            \"are drawn {C:attention}face down\"\n        }\n    },\n    pronouns = 'she_her',\n    rarity = 1,\n    atlas = 'PiCubedsJokers',\n    pos = { x = 9, y = 1 },\n    cost = 3,\n    discovered = true,\n    blueprint_compat = false,\n    perishable_compat = true,\n    eternal_compat = true,\n    config = { extra = { odds = 5, hand_increase = 2 } },\n    loc_vars = function(self, info_queue, card)\n        local numerator, denominator = SMODS.get_probability_vars(card, 1, card.ability.extra.odds, 'picubed_echolocation')\n        return { vars = { numerator, denominator, card.ability.extra.hand_increase} }\n    end,\n    \n    add_to_deck = function(self, card, from_debuff)\n\t\tG.hand:change_size(card.ability.extra.hand_increase)\n\tend,\n\n\tremove_from_deck = function(self, card, from_debuff)\n\t\tG.hand:change_size(-card.ability.extra.hand_increase)\n\tend,\n    \n    calculate = function(self, card, context)\n        if not context.blueprint then\n            if context.stay_flipped then\n                if SMODS.pseudorandom_probability(card, 'picubed_echolocation', 1, card.ability.extra.odds) then\n                    return { stay_flipped = true }\n                end\n                -- else return { stay_flipped = false }\n            end\n        end\n        if context.cardarea == G.jokers and context.before then\n            for k, v in ipairs(context.full_hand) do\n                if v.facing == 'back' then\n                    v:flip()\n                end\n            end\n        end\n    end",
      "config": {
        "extra": {
          "odds": 5,
          "hand_increase": 2
        }
      },
      "ability": {
        "extra": {
          "odds": 5,
          "hand_increase": 2
        }
      },
      "vars": [
        null,
        null,
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "encore",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 3,
        "y": 11
      },
      "raw": "--Encore\n\tkey = 'encore',\n\tloc_txt = {\n\t\tname = 'Encore',\n\t\ttext = {\n\t\t\t\"On {C:attention}final hand{} of\", \n\t\t\t\"{C:attention}Boss Blind{}, played\",\n            \"cards earn {C:money}$#1#{}\",\n            \"when scored\",\n\t\t}\n\t},\n\tpronouns = 'they_them',\n\trarity = 2,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 3, y = 11 },\n\tcost = 6,\n\tdiscovered = true,\n\tblueprint_compat = true,\n    perishable_compat = true,\n\teternal_compat = true,\n\tconfig = { extra = { money = 3 } },\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.money } }\n\tend,\n\tcalculate = function(self, card, context)\n        if context.individual and context.cardarea == G.play and G.GAME.current_round.hands_left == 0 and G.GAME.blind and G.GAME.blind.boss then\n\t\t\tG.GAME.dollar_buffer = (G.GAME.dollar_buffer or 0) + card.ability.extra.money\n            return {\n                dollars = card.ability.extra.money,\n                func = function()\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            G.GAME.dollar_buffer = 0\n                            return true\n                        end\n                    }))\n                end\n            }\n\t\tend\n\tend",
      "config": {
        "extra": {
          "money": 3
        }
      },
      "ability": {
        "extra": {
          "money": 3
        }
      },
      "vars": [
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "explo1",
      "atlas": null,
      "pos": null,
      "raw": "key = \"explo1\",\n\tpath = \"explo1.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "explo2",
      "atlas": null,
      "pos": null,
      "raw": "key = \"explo2\",\n\tpath = \"explo2.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "explo3",
      "atlas": null,
      "pos": null,
      "raw": "key = \"explo3\",\n\tpath = \"explo3.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "explosher",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 2,
        "y": 4
      },
      "raw": "--Explosher\n    key = 'explosher',\n    loc_txt = {\n        name = 'Explosher',\n        text = {\n            \"After scoring is complete,\",\n            \"give {C:attention}#1# {}random cards\", \n            \"held in hand a {C:attention}random suit\"\n        }\n    },\n    pronouns = 'she_her',\n    rarity = 1,\n    atlas = 'PiCubedsJokers',\n    pos = { x = 2, y = 4 },\n    cost = 5,\n    discovered = true,\n    blueprint_compat = true,\n    perishable_compat = true,\n    eternal_compat = true,\n    config = { extra = { num = 5 } },\n loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.num } }\n    end,\n    calculate = function(self, card, context)\n        if context.cardarea == G.jokers and context.after then\n            local suit_list = {'Hearts', 'Diamonds', 'Spades', 'Clubs'}\n            if #G.hand.cards > 0 and #G.hand.cards <= card.ability.extra.num then\n                for k,v in ipairs(G.hand.cards) do\n                    for i=#suit_list,1,-1 do\n                        if v.base.suit == suit_list[i] then\n                            table.remove(suit_list, i)\n                        end\n                    end\n                end\n                if #suit_list == 0 then\n                    suit_list = {'Hearts', 'Diamonds', 'Spades', 'Clubs'}\n                end\n                local chosen_suit = pseudorandom_element(suit_list, pseudoseed('Explosher'..G.GAME.round_resets.ante))\n                for k,v in ipairs(G.hand.cards) do\n                    G.E_MANAGER:add_event(Event({func = function()\n                        v:change_suit(chosen_suit)\n                        v:juice_up()\n                        card:juice_up()\n                    return true end }))\n                end\n                if picubed_config.custom_sound_effects then\n                    return {\n                        message = localize(\"k_picubeds_slosh\"),\n                        volume = 0.5,\n                        sound = \"picubed_explo\"..pseudorandom_element({'1', '2', '3'}, pseudoseed('Explosher1'..G.GAME.round_resets.ante))\n                    }\n                else\n                    return {\n                        message = localize(\"k_picubeds_slosh\"),\n                    }\n                end\n            elseif #G.hand.cards > 0 then\n                local card_list = {}\n                local hit_list = {}\n                for k,v in ipairs(G.hand.cards) do\n                    for i=#suit_list,1,-1 do\n                        if v.base.suit == suit_list[i] then\n                            table.remove(suit_list, i)\n                        end\n                    end\n                end\n                if #suit_list == 0 then\n                    suit_list = {'Hearts', 'Diamonds', 'Spades', 'Clubs'}\n                end\n                local chosen_suit = pseudorandom_element(suit_list, pseudoseed('Explosher'..G.GAME.round_resets.ante))\n                for i=1,#G.hand.cards do\n                    card_list[i] = G.hand.cards[i]\n                end\n                for i=1,card.ability.extra.num do\n                    hit_list[i] = pseudorandom_element(card_list, pseudoseed('Explosher'..i..G.GAME.round_resets.ante))\n                    for j=1,#card_list do\n                        if hit_list[i] == card_list[j] then\n                            table.remove(card_list, j)\n                        end\n                    end\n                end\n                for k,v in ipairs(hit_list) do\n                    G.E_MANAGER:add_event(Event({func = function()\n                        v:change_suit(chosen_suit)\n                        v:juice_up()\n                        card:juice_up()\n                    return true end }))\n                end\n                if picubed_config.custom_sound_effects then\n                    return {\n                        message = localize(\"k_picubeds_slosh\"),\n                        volume = 0.5,\n                        sound = \"picubed_explo\"..pseudorandom_element({'1', '2', '3'}, pseudoseed('Explosher1'..G.GAME.round_resets.ante))\n                    }\n                else\n                    return {\n                        message = localize(\"k_picubeds_slosh\"),\n                    }\n                end\n            end\n        end\n    end",
      "config": {
        "extra": {
          "num": 5
        }
      },
      "ability": {
        "extra": {
          "num": 5
        }
      },
      "vars": [
        5
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "extralimb",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 0,
        "y": 4
      },
      "raw": "--Extra Limb\n    key = 'extralimb',\n    loc_txt = {\n        name = 'Extra Limb',\n        text = {\n            {\n                \"{C:attention}+#1#{} Consumable Slots\",\n            },\n            {\n                \"{C:mult}+#2#{} Mult per held\",\n                \"Consumable\",\n                \"{C:inactive}(Currently {C:mult}+#3# {C:inactive}Mult)\"\n            }\n        }\n    },\n    pronouns = 'she_they',\n    rarity = 1,\n    atlas = 'PiCubedsJokers',\n    pos = { x = 0, y = 4 },\n    cost = 5,\n    discovered = true,\n    blueprint_compat = true,\n    perishable_compat = true,\n    eternal_compat = true,\n    config = { extra = { card_limit = 1, mult_mod = 6 } },\n    loc_vars = function(self, info_queue, card)\n        if G.OVERLAY_MENU then\n            return { vars = { card.ability.extra.card_limit, card.ability.extra.mult_mod, 0 } }\n        else\n            return { vars = { card.ability.extra.card_limit, card.ability.extra.mult_mod, card.ability.extra.mult_mod * #G.consumeables.cards } }\n        end\n    end,\n    --add & remove taken from Extra Credit's Forklift\n    add_to_deck = function(self, card, from_debuff)\n        G.E_MANAGER:add_event(Event({func = function()\n            G.consumeables.config.card_limit = G.consumeables.config.card_limit + card.ability.extra.card_limit\n            return true end }))\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        G.E_MANAGER:add_event(Event({func = function()\n            G.consumeables.config.card_limit = G.consumeables.config.card_limit - card.ability.extra.card_limit\n            return true end }))\n    end,\n    calculate = function(self, card, context)\n        if context.joker_main and #G.consumeables.cards ~= 0 then\n            return {\n                mult_mod = card.ability.extra.mult_mod * #G.consumeables.cards,\n                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult_mod * #G.consumeables.cards } }\n            }\n        end\n    end",
      "config": {
        "extra": {
          "card_limit": 1,
          "mult_mod": 6
        }
      },
      "ability": {
        "extra": {
          "card_limit": 1,
          "mult_mod": 6
        }
      },
      "vars": [
        1,
        6,
        0
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "extrapockets",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "--Extra Pockets\n    key = 'extrapockets',\n    loc_txt = {\n        name = 'Extra Pockets',\n        text = {\n            \"{C:attention}+#1#{} hand size for\",\n            \"each held {C:attention}Consumable\",\n        }\n    },\n    pronouns = 'she_they',\n    rarity = 2,\n    atlas = 'PiCubedsJokers',\n    pos = { x = 1, y = 2 },\n    cost = 6,\n    discovered = true,\n    blueprint_compat = false,\n    perishable_compat = true,\n    eternal_compat = true,\n    config = { extra = {hand_increase_mod = 1, hand_increase = 0, hand_diff = 0} },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.hand_increase_mod } }\n    end,\n    \n    remove_from_deck = function(self, card, from_debuff)\n        G.hand:change_size(-card.ability.extra.hand_increase)\n    end,\n    \n    calculate = function(self, card, context)\n        --card.ability.extra.hand_increase_mod = math.ceil(card.ability.extra.hand_increase_mod)\n        card.ability.extra.hand_increase = #G.consumeables.cards * card.ability.extra.hand_increase_mod\n        while math.ceil(card.ability.extra.hand_increase) > math.ceil(card.ability.extra.hand_diff) do\n            card.ability.extra.hand_diff = card.ability.extra.hand_diff + 1\n            G.hand:change_size(1)\n        end\n        while math.ceil(card.ability.extra.hand_increase) < math.ceil(card.ability.extra.hand_diff) do\n            card.ability.extra.hand_diff = card.ability.extra.hand_diff - 1\n            G.hand:change_size(-1)\n        end\n    end",
      "config": {
        "extra": {
          "hand_increase_mod": 1,
          "hand_increase": 0,
          "hand_diff": 0
        }
      },
      "ability": {
        "extra": {
          "hand_increase_mod": 1,
          "hand_increase": 0,
          "hand_diff": 0
        }
      },
      "vars": [
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "eyepatch",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 2,
        "y": 6
      },
      "raw": "--Eye Patch\n\tkey = 'eyepatch',\n\tloc_txt = {\n\t\tname = 'Eye Patch',\n\t\ttext = {\n\t\t\t\"This Joker gains {X:mult,C:white}X#2#{} Mult\",\n\t\t\t\"if {C:attention}poker hand{} has {C:attention}not{}\",\n\t\t\t\"been played this {C:attention}Ante{}, resets\",\n\t\t\t\"when {C:attention}Boss Blind{} is defeated\",\n\t\t\t\"{C:inactive}(Currently {X:mult,C:white}X#1#{} {C:inactive}Mult){}\",\n\t\t}\n\t},\n\tpronouns = 'he_him',\n\trarity = 2,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 2, y = 6 },\n\tcost = 7,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tperishable_compat = true,\n\teternal_compat = true,\n\tconfig = { extra = { Xmult = 1, Xmult_mod = 1/3, hand_list = {}, displ_list = {} } },\n\tloc_vars = function(self, info_queue, card)\n\t\tif #card.ability.extra.displ_list > 0 then\n            main_end = {\n                {n=G.UIT.C, config={align = \"bm\", padding = 0.02}, nodes={\n                    {n=G.UIT.C, config={align = \"m\", colour = G.C.CHIPS, r = 0.05, padding = 0.05}, nodes={\n                        {n=G.UIT.T, config={text = table.concat(card.ability.extra.displ_list or {}, \", \"), colour = G.C.UI.TEXT_LIGHT, scale = 0.3, shadow = true}},\n                    }}\n                }}\n            }\n\t\telse\n            main_end = nil\n\t\tend\n\t\treturn { vars = { \n\t\t\t\tcard.ability.extra.Xmult, \n\t\t\t\tcard.ability.extra.Xmult_mod,\n\t\t\t}, main_end = main_end \n\t\t}\n\tend,\n\tadd_to_deck = function(self, card, from_debuff)\n\t\tfor k, v in pairs(G.handlist) do\n\t\t\tcard.ability.extra.hand_list[v] = false\n\t\tend\n\tend,\n\tcalculate = function(self, card, context)\n\t\tcard.ability.extra.displ_list = {}\n\t\tfor k, v in pairs(G.handlist) do\n\t\t\tif card.ability.extra.hand_list[v] == true then\n\t\t\t\ttable.insert(card.ability.extra.displ_list, tostring(localize(v, 'poker_hands')))\n\t\t\tend\n\t\tend\n\t\t--[[local eval = function() return card.ability.extra.hand_list[context.scoring_name or nil] == false and #G.hand.highlighted > 0 and not G.RESET_JIGGLES end \n\t\tjuice_card_until(card, eval, true)]]\n\t\t\n\t\tif card.ability.extra.hand_list[context.scoring_name or nil] == false and #G.hand.highlighted > 0 and not G.RESET_JIGGLES then\n\t\t\tG.E_MANAGER:add_event(Event({\n\t\t\t\ttrigger = 'after', blocking = false, blockable = false, timer = 'REAL',\n\t\t\t\tfunc = (function() card:juice_up(0.1, 0.1) return true end)\n\t\t\t}))\n\t\tend\n\t\t\n\t\tif context.before and context.main_eval and not context.blueprint and not context.retrigger_joker then\n            if card.ability.extra.hand_list[context.scoring_name] == false then\n                card.ability.extra.hand_list[context.scoring_name] = true\n                card.ability.extra.Xmult = card.ability.extra.Xmult + card.ability.extra.Xmult_mod\n                return {\n                    message = localize('k_upgrade_ex'),\n                    card = card\n                }\n            end\n\t\tend\n\t\tif context.joker_main then\n            return {\n                xmult = card.ability.extra.Xmult\n            }\n\t\tend\n\t\tif context.end_of_round and not context.blueprint and G.GAME.blind.boss and card.ability.extra.Xmult > 1 then\n\t\t\tcard.ability.extra.displ_list = {}\n\t\t\tfor k, v in pairs(G.handlist) do\n\t\t\t\tcard.ability.extra.hand_list[v] = false\n\t\t\tend\n\n\t\t\tcard.ability.extra.Xmult = 1\n\t\t\treturn {\n                card = card,\n                message = localize('k_reset'),\n                colour = G.C.RED\n\t\t\t}\n\t\tend\n\tend",
      "config": {
        "extra": {
          "Xmult": 1,
          "Xmult_mod": 0.3333333333333333,
          "hand_list": {},
          "displ_list": {}
        }
      },
      "ability": {
        "extra": {
          "Xmult": 1,
          "Xmult_mod": 0.3333333333333333,
          "hand_list": {},
          "displ_list": {}
        }
      },
      "vars": [
        1,
        0.3333333333333333
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "forgery",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 6,
        "y": 5
      },
      "raw": "--Forgery\n\tkey = 'forgery',\n\tloc_txt = {\n\t\tname = 'Forgery',\n\t\ttext = {\n\t\t\t\"When {C:attention}Blind{} is selected,\",\n\t\t\t\"{C:attention}destroy{} 1 random card in\",\n\t\t\t\"{C:attention}deck{}, and add half its\",\n\t\t\t\"{C:chips}Chips{} to this Joker as {C:mult}Mult\",\n\t\t\t\"{C:inactive}(Currently {C:mult}+#1#{C:inactive} Mult)\"\n\t\t}\n\t},\n\tpronouns = 'he_they',\n\trarity = 2,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 6, y = 5 },\n\tcost = 6,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tperishable_compat = false,\n\teternal_compat = true,\n\tconfig = { extra = { mult = 0 } },\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.mult } }\n\tend,\n\tcalculate = function(self, card, context)\n\t\tif context.setting_blind and not context.blueprint and not context.retrigger_joker and #G.playing_cards > 0 then\n\t\t\tlocal card_list = {}\n\t\t\tfor k,v in ipairs(G.playing_cards) do\n\t\t\t\tif not v.getting_sliced then\n\t\t\t\t\ttable.insert(card_list, v)\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tif #card_list > 0 then\n\t\t\t\tlocal card_is_kil = pseudorandom_element(card_list, pseudoseed('forgery'..G.GAME.round_resets.ante))\n\t\t\t\tcard_is_kil.getting_sliced = true\n\t\t\t\tlocal card_mult = 0\n\t\t\t\tif SMODS.has_no_rank(card_is_kil) then -- rankless cards\n\t\t\t\t\tcard_mult = card_mult + 0\n\t\t\t\telse\n\t\t\t\t\tcard_mult = card_is_kil.base.nominal or 0\n\t\t\t\tend\n\t\t\t\tcard_mult = card_mult + (card_is_kil.ability.perma_bonus or 0) + (card_is_kil.ability.perma_h_chips or 0)\n\t\t\t\tif SMODS.has_enhancement(card_is_kil, 'm_bonus') then -- bonus card (vanilla)\n\t\t\t\t\tcard_mult = card_mult + 30\n\t\t\t\telseif SMODS.has_enhancement(card_is_kil, 'm_stone') then -- stone card (vanilla)\n\t\t\t\t\tcard_mult = card_mult + 50\n\t\t\t\telseif SMODS.has_enhancement(card_is_kil, 'm_akyrs_ash_card') then -- ash card (aikoyori's shenanigans)\n\t\t\t\t\tcard_mult = card_mult + 30\n\t\t\t\tend\n\t\t\t\tif card_is_kil.edition then\n\t\t\t\t\tif card_is_kil.edition.key == 'e_foil' then -- foil (vanilla)\n\t\t\t\t\t\t\tcard_mult = card_mult + 50\n\t\t\t\t\telseif card_is_kil.edition.key == 'e_cry_noisy' then -- noisy (cryptid)\n\t\t\t\t\t\t\tcard_mult = card_mult + pseudorandom('noisy') * 150\n\t\t\t\t\telseif card_is_kil.edition.key == 'e_ortalab_anaglyphic' then -- anaglyphic (ortalab)\n\t\t\t\t\t\t\tcard_mult = card_mult + 20\n\t\t\t\t\telseif card_is_kil.edition.key == 'e_cry_mosaic' then -- mosaic (cryptid)\n\t\t\t\t\t\t\tcard_mult = 2.5 * card_mult\n\t\t\t\t\telseif card_is_kil.edition.key == 'e_akyrs_texelated' then -- texelated (aikoyori's shenanigans)\n\t\t\t\t\t\t\tcard_mult = 0.8 * card_mult\n\t\t\t\t\telseif card_is_kil.edition.key == 'e_bunc_glitter' then -- glitter (bunco)\n\t\t\t\t\t\t\tcard_mult = 1.3 * card_mult\n\t\t\t\t\telseif card_is_kil.edition.key == 'e_yahimod_evil' then -- evil (yahimod)\n\t\t\t\t\t\t\tcard_mult = 1.5 * card_mult\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tif card_is_kil.ability.perma_x_chips and card_is_kil.ability.perma_x_chips > 1 then\n\t\t\t\t\tcard_mult = card_mult * card_is_kil.ability.perma_x_chips\n\t\t\t\tend\n\t\t\t\tif card_is_kil.ability.perma_h_x_chips and card_is_kil.ability.perma_h_x_chips > 1 then\n\t\t\t\t\tcard_mult = card_mult * card_is_kil.ability.perma_h_x_chips\n\t\t\t\tend\t\t\t \n\t\t\t\tG.E_MANAGER:add_event(Event({\n\t\t\t\t\ttrigger = 'before',\n\t\t\t\t\tdelay = 0.1,\n\t\t\t\t\tfunc = function()\n\t\t\t\t\t\tdraw_card(G.deck, G.play, 90, 'up', nil, card_is_kil)\n\t\t\t\t\t\tdelay(1)\n\t\t\t\t\t\treturn true\n\t\t\t\t\tend\n\t\t\t\t}))\n\t\t\t\tG.E_MANAGER:add_event(Event({\n\t\t\t\t\ttrigger = 'before',\n\t\t\t\t\tdelay = 0.1,\n\t\t\t\t\tfunc = function()\n\t\t\t\t\t\tSMODS.destroy_cards(card_is_kil)\n\t\t\t\t\t\tSMODS.calculate_effect({ message = localize { type = 'variable', key = 'a_mult', vars = { card_mult * 0.5 } }, colour = G.C.MULT, sound = 'slice1', pitch = 0.96 + math.random() * 0.08 }, card )\n\t\t\t\t\t\treturn true \n\t\t\t\t\tend\n\t\t\t\t}))\n\t\t\t\tif card_mult * 0.5 >= 40 then\n\t\t\t\t\tcheck_for_unlock({type = 'picubed_forgery_criticalhit'})\n\t\t\t\tend\n\t\t\t\tcard.ability.extra.mult = card.ability.extra.mult + card_mult * 0.5\n\t\t\tend\n\n\t\tend\n\t\tif context.joker_main then\n\t\t\treturn {\n                mult = card.ability.extra.mult,\n                card = card\n\t\t\t}\n\t\tend\n\tend",
      "config": {
        "extra": {
          "mult": 0
        }
      },
      "ability": {
        "extra": {
          "mult": 0
        }
      },
      "vars": [
        0
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "fusionmagic",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 9,
        "y": 4
      },
      "raw": "--Fusion Magic\n\tkey = 'fusionmagic',\n\tloc_txt = {\n\t\tname = 'Fusion Magic',\n\t\ttext = {\n\t\t\t\"After {C:attention}selling #1#{} {C:inactive}[#2#]{} {C:tarot}Tarot{} cards,\",\n\t\t\t\"create a {C:spectral}Spectral {}card\",\n\t\t\t\"{C:inactive}(Must have room)\"\n\t\t}\n\t},\n\tpronouns = 'she_they',\n\trarity = 3,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 9, y = 4 },\n\tcost = 8,\n\tdiscovered = true,\n\tblueprint_compat = false,\n\tperishable_compat = true,\n\teternal_compat = true,\n\tconfig = { extra = { num = 4, num_remaining = 4 } },\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.num, card.ability.extra.num_remaining } }\n\tend,\n\tcalculate = function(self, card, context)\n\t\tif context.selling_card and context.card.ability.set == 'Tarot' and not context.blueprint then\n\t\t\tcard.ability.extra.num_remaining = card.ability.extra.num_remaining - 1\n\t\t\tif card.ability.extra.num_remaining > 0 then\n\t\t\t\treturn {\n\t\t\t\t\tmessage = tostring(card.ability.extra.num_remaining)\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tif (#G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit) --negative tarots \n\t\t\t\tor ((#G.consumeables.cards + G.GAME.consumeable_buffer - 1 < G.consumeables.config.card_limit) and (not context.card.edition or (context.card.edition and context.card.edition.key ~= 'e_negative'))) then --non-negative tarots\n\t\t\t\t\tG.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1\n\t\t\t\t\tcard.ability.extra.num_remaining = card.ability.extra.num\n\t\t\t\t\tG.E_MANAGER:add_event(Event({\n                        trigger = 'before',\n                        delay = 0.0,\n                        func = (function()\n                            local card = create_card('Spectral',G.consumeables, nil, nil, nil, nil, nil, 'sixth')\n                            card:add_to_deck()\n                            G.consumeables:emplace(card)\n                            G.GAME.consumeable_buffer = 0\n                        return true\n\t\t\t\t\tend)}))\n\t\t\t\t\treturn {\n\t\t\t\t\t\tmessage = localize('k_plus_spectral'),\n\t\t\t\t\t\tcolour = G.C.SECONDARY_SET.Spectral,\n\t\t\t\t\t\tcard = card\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tcard.ability.extra.num_remaining = 1\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend",
      "config": {
        "extra": {
          "num": 4,
          "num_remaining": 4
        }
      },
      "ability": {
        "extra": {
          "num": 4,
          "num_remaining": 4
        }
      },
      "vars": [
        4,
        4
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "goldenpancakes",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 4,
        "y": 4
      },
      "raw": "--Golden Pancakes\n\tkey = 'goldenpancakes',\n\tloc_txt = {\n\t\tname = 'Golden Pancakes',\n\t\ttext = {\n\t\t\t\"Scoring cards earn {C:money}$#1#{}\",\n\t\t\t\"{C:green}#2# in #3#{} chance this\",\n\t\t\t\"card is {C:attention}destroyed\",\n\t\t\t\"at end of round\"\n\t\t}\n\t},\n\tpronouns = 'she_they',\n\trarity = 2,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 4, y = 4 },\n\tcost = 5,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tperishable_compat = true,\n\teternal_compat = false,\n\tconfig = { extra = { money = 1, odds = 6 } },\n\tloc_vars = function(self, info_queue, card)\n\t\tlocal numerator, denominator = SMODS.get_probability_vars(card, 1, card.ability.extra.odds, 'picubed_goldenpancakes')\n\t\treturn { vars = { card.ability.extra.money, numerator, denominator } }\n\tend,\n\tpools = { [\"Food\"] = true },\n\tcalculate = function(self, card, context)\n\t\tif context.individual and context.cardarea == G.play then\n            G.GAME.dollar_buffer = (G.GAME.dollar_buffer or 0) + card.ability.extra.money\n            return {\n                dollars = card.ability.extra.money,\n                func = function()\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            G.GAME.dollar_buffer = 0\n                            return true\n                        end\n                    }))\n                end\n            }\n        end\n\t\tif context.end_of_round and not context.repetition and context.game_over == false and not context.blueprint then\n\t\t\tif SMODS.pseudorandom_probability(card, 'picubed_goldenpancakes', 1, card.ability.extra.odds) then\n\t\t\t\tG.E_MANAGER:add_event(Event({\n\t\t\t\t\tfunc = function()\n\t\t\t\t\t\tplay_sound('tarot1')\n\t\t\t\t\t\tcard.T.r = -0.2\n\t\t\t\t\t\tcard:juice_up(0.3, 0.4)\n\t\t\t\t\t\tcard.states.drag.is = true\n\t\t\t\t\t\tcard.children.center.pinch.x = true\n\t\t\t\t\t\tG.E_MANAGER:add_event(Event({\n\t\t\t\t\t\t\ttrigger = 'after',\n\t\t\t\t\t\t\tdelay = 0.3,\n\t\t\t\t\t\t\tblockable = false,\n\t\t\t\t\t\t\tfunc = function()\n\t\t\t\t\t\t\t\tG.jokers:remove_card(card)\n\t\t\t\t\t\t\t\tcard:remove()\n\t\t\t\t\t\t\t\tcard = nil\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t}))\n\t\t\t\t\t\treturn true\n\t\t\t\t\tend\n\t\t\t\t}))\n\t\t\t\treturn {\n\t\t\t\t\tmessage = localize(\"k_eaten_ex\")\n\t\t\t\t}\n\t\t\telse\n\t\t\t\treturn {\n\t\t\t\t\tmessage = localize(\"k_safe_ex\")\n\t\t\t\t}\n\t\t\tend\n\t\tend\n\tend",
      "config": {
        "extra": {
          "money": 1,
          "odds": 6
        }
      },
      "ability": {
        "extra": {
          "money": 1,
          "odds": 6
        }
      },
      "vars": [
        1,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "gottheworm",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 2,
        "y": 3
      },
      "raw": "--Got the Worm\n    key = 'gottheworm',\n    loc_txt = {\n        name = 'Got the Worm',\n        text = {\n            \"{C:attention}Skipping{} a blind\",\n            \"also gives {C:money}$#1#{}\"\n        }\n    },\n    pronouns = 'she_her',\n    rarity = 1,\n    atlas = 'PiCubedsJokers',\n    pos = { x = 2, y = 3 },\n    cost = 4,\n    discovered = true,\n    blueprint_compat = true,\n    perishable_compat = true,\n    eternal_compat = true,\n    config = { extra = { money = 15 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.money } }\n    end,\n    calculate = function(self, card, context)\n        if context.skip_blind then\n            return {\n                dollars = card.ability.extra.money,\n                card = card\n            }\n        end\n    end",
      "config": {
        "extra": {
          "money": 15
        }
      },
      "ability": {
        "extra": {
          "money": 15
        }
      },
      "vars": [
        15
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "hiddengem",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 4,
        "y": 1
      },
      "raw": "--Hidden Gem\n    key = 'hiddengem',\n    loc_txt = {\n        name = 'Hidden Gem',\n        text = {\n            \"{C:attention}Discarded{} cards have a {C:green}#1# in #2#{}\",\n            \"chance to be {C:attention}destroyed{} and\",\n            \"create a {C:spectral}Spectral{} card\",\n            \"{C:inactive}(Must have room)\"\n        }\n    },\n    pronouns = 'they_them',\n    rarity = 3,\n    atlas = 'PiCubedsJokers',\n    pos = { x = 4, y = 1 },\n    cost = 9,\n    config = { extra = { odds = 15 } },\n    discovered = true,\n    blueprint_compat = false,\n    perishable_compat = true,\n    eternal_compat = true,\n    loc_vars = function(self, info_queue, card)\n        local numerator, denominator = SMODS.get_probability_vars(card, 1, card.ability.extra.odds, 'picubed_hiddengem')\n        return { vars = { numerator, denominator } }\n    end,\n    calculate = function(self, card, context)\n        if context.discard then\n            if not context.other_card.debuff and not context.blueprint then\n                if SMODS.pseudorandom_probability(card, 'picubed_hiddengem', 1, card.ability.extra.odds) then\n                    if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then\n                        G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1\n                        G.E_MANAGER:add_event(Event({\n                            trigger = 'before',\n                            delay = 0.0,\n                            func = (function()\n                                local card = create_card('Spectral',G.consumeables, nil, nil, nil, nil, nil, 'sixth')\n                                card:add_to_deck()\n                                G.consumeables:emplace(card)\n                                G.GAME.consumeable_buffer = 0\n                                return true\n                            end)}))\n                        return {\n                            message = localize('k_plus_spectral'),\n                            colour = G.C.SECONDARY_SET.Spectral,\n                            card = card,\n                            remove = true\n                        }\n                    else\n                        return {\n                            remove = true\n                        }\n                    end\n                end\n            end\n        end\n    end",
      "config": {
        "extra": {
          "odds": 15
        }
      },
      "ability": {
        "extra": {
          "odds": 15
        }
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "hierarchy",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 0,
        "y": 10
      },
      "raw": "--Hierarchy\n\tkey = 'hierarchy',\n\tloc_txt = {\n\t\tname = 'Hierarchy',\n\t\ttext = {\n\t\t\t\"If scoring hand contains a {C:attention}King{},\", \n\t\t\t\"the {C:attention}first{} scoring card of\",\n            \"each {C:attention}rank{} gives {X:mult,C:white}X#1#{} Mult\",\n\t\t}\n\t},\n\tpronouns = 'he_they',\n\trarity = 3,\n    config = { extra = { Xmult = 2, has_king = false } },\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 0, y = 10 },\n\tcost = 8,\n\tdiscovered = true,\n\tblueprint_compat = true,\n    perishable_compat = true,\n\teternal_compat = true,\n\tloc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.Xmult } }\n\tend,\n\tcalculate = function(self, card, context)\n        if context.before then\n\t\t\tfor k,v in ipairs(context.scoring_hand) do\n\t\t\t\tif v:get_id() == 13 then\n\t\t\t\t\tcard.ability.extra.has_king = true\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tif card.ability.extra.has_king and context.individual and context.cardarea == G.play and not SMODS.has_no_rank(context.other_card) then\n\t\t\tlocal is_first = false\n\t\t\tfor k,v in ipairs(context.scoring_hand) do\n\t\t\t\tif v:get_id() == context.other_card:get_id() then\n\t\t\t\t\tif v == context.other_card then\n\t\t\t\t\t\tis_first = true\n\t\t\t\t\tend\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n\t\t\tif is_first then\n\t\t\t\treturn {\n\t\t\t\t\txmult = card.ability.extra.Xmult\n\t\t\t\t}\n\t\t\tend\n        end\n\t\tif context.after then\n\t\t\tcard.ability.extra.has_king = false\n\t\tend\n\tend",
      "config": {
        "extra": {
          "Xmult": 2,
          "has_king": false
        }
      },
      "ability": {
        "extra": {
          "Xmult": 2,
          "has_king": false
        }
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "hypemoments",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 6,
        "y": 8
      },
      "raw": "--Hype Moments\n\tkey = 'hypemoments',\n\tloc_txt = {\n\t\tname = 'Hype Moments',\n\t\ttext = {\n\t\t\t\"When {C:attention}Boss Blind{} is selected,\",\n\t\t\t\"create an {C:attention}Aura{}\",\n\t\t\t\"{C:inactive}(Must have room){}\",\n\t\t}\n\t},\n\tpronouns = 'it_its',\n\trarity = 2,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 6, y = 8 },\n\tcost = 7,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tperishable_compat = true,\n\teternal_compat = true,\n\tloc_vars = function(self, info_queue, card)\n\t\tinfo_queue[#info_queue+1] = G.P_CENTERS.c_aura\n\t\treturn { vars = { card.ability.max_highlighted } }\n\tend,\n\tcalculate = function(self, card, context)\n\t\tif context.setting_blind and not context.individual and context.blind.boss then\n\t\t\tif #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then\n\t\t\t\tG.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1\n\t\t\t\tG.E_MANAGER:add_event(Event({\n\t\t\t\t\ttrigger = 'before',\n\t\t\t\t\tdelay = 0.0,\n\t\t\t\t\tfunc = (function()\n\t\t\t\t\t\tlocal card = create_card('Spectral', G.consumeables, nil, nil, nil, nil, 'c_aura')\n\t\t\t\t\t\tcard:add_to_deck()\n\t\t\t\t\t\tG.consumeables:emplace(card)\n\t\t\t\t\t\tG.GAME.consumeable_buffer = 0\n\t\t\t\t\t\tcard:juice_up(0.5, 0.5)\n\t\t\t\t\t\treturn true\n\t\t\t\t\tend)}))\n\t\t\t\tcard_eval_status_text(card, 'extra', nil, nil, nil, {message = localize('k_plus_spectral'),\n\t\t\t\t\t\t\tcolour = G.C.SECONDARY_SET.Spectral })\n\t\t\tend\n\t\tend\n\tend",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "incompletesurvey",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 0,
        "y": 3
      },
      "raw": "--Incomplete Survey\n    key = 'incompletesurvey',\n    loc_txt = {\n        name = 'Incomplete Survey',\n        text = {\n            {\n                \"Earn {C:money}$#1#{} at start of round\",\n            },\n            {\n                \"When drawing cards to\",\n                \"hand, {C:attention}last card{} drawn is\",\n                \"always drawn {C:attention}face down{}\",\n            }\n        }\n    },\n    pronouns = 'she_they',\n    rarity = 1,\n    atlas = 'PiCubedsJokers',\n    pos = { x = 0, y = 3 },\n    cost = 5,\n    discovered = true,\n    blueprint_compat = false,\n    perishable_compat = true,\n    eternal_compat = true,\n    config = { extra = { money = 5 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.money } }\n    end,\n    calculate = function(self, card, context)\n        if context.first_hand_drawn == true and not context.blueprint then\n            return {\n                    dollars = card.ability.extra.money,\n                    card = card\n            }\n        end\n        if context.stay_flipped and not (context.cardarea == G.play and context.before) then        \n            if G.hand.config.card_limit - 1 <= (#G.hand.cards) then\n                return { stay_flipped = true }\n            end\n        end\n        if context.cardarea == G.jokers and context.before then\n            for k, v in ipairs(context.full_hand) do\n                if v.facing == 'back' then\n                    v:flip()\n                end\n            end\n        end\n    end",
      "config": {
        "extra": {
          "money": 5
        }
      },
      "ability": {
        "extra": {
          "money": 5
        }
      },
      "vars": [
        5
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "inkjetprinter",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 5,
        "y": 2
      },
      "raw": "--Inkjet Printer\n     key = 'inkjetprinter',\n    loc_txt = {\n        name = 'Inkjet Printer',\n        text = {\n            \"{C:attention}Consumables{} have a {C:green}#1# in #2#\",\n            \"chance to be {C:attention}recreated{} on use,\",\n            \"this card has a {C:green}#3# in #4#{} chance to\",\n            \"be {C:attention}destroyed{} after activating\",\n            \"{C:inactive}(Must have room){}\"\n        }\n    },\n    pronouns = 'it_its',\n    rarity = 2,\n    atlas = 'PiCubedsJokers',\n    pos = { x = 5, y = 2 },\n    cost = 6,\n    discovered = true,\n    blueprint_compat = false,\n    perishable_compat = true,\n    eternal_compat = false,\n    config = { extra = { copy_odds = 2, destroy_odds = 4, copied = {} } },\n    loc_vars = function(self, info_queue, card)\n        local numerator_copy, denominator_copy = SMODS.get_probability_vars(card, 1, card.ability.extra.copy_odds, 'picubed_inkjetprinter_copy')\n        local numerator_destroy, denominator_destroy = SMODS.get_probability_vars(card, 1, card.ability.extra.destroy_odds, 'picubed_inkjetprinter_destroy')\n        return { vars = { numerator_copy, denominator_copy, numerator_destroy, denominator_destroy } }\n    end,\n    in_pool = function(self, args)\n            return #SMODS.find_card('j_picubed_laserprinter') < 1\n    end,\n    calculate = function(self, card, context)\n        if context.using_consumeable and not context.blueprint then\n            if SMODS.pseudorandom_probability(card, 'picubed_inkjetprinter_copy', 1, card.ability.extra.copy_odds) then\n                local has_activated = false\n                local has_destroyed = false\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        if #G.consumeables.cards < G.consumeables.config.card_limit then\n                            local copied_card = copy_card(context.consumeable, nil)\n                            copied_card:add_to_deck()\n                            G.consumeables:emplace(copied_card)\n                            has_activated = true\n                            card_eval_status_text(card, 'extra', nil, nil, nil,\n                                { message = localize(\"k_picubeds_print\") })\n                        end\n                        return true\n                    end\n                }))\n\n                if SMODS.pseudorandom_probability(card, 'picubed_inkjetprinter_destroy', 1, card.ability.extra.destroy_odds) then\n                    card_eval_status_text(card, 'extra', nil, nil, nil,\n                        { message = localize(\"k_picubeds_error\"), sound = 'tarot1', colour = G.C.RED })\n                    G.E_MANAGER:add_event(Event({\n\t\t\t\t\tfunc = function()\n\t\t\t\t\t\tif has_activated then\n                            has_destroyed = true\n                            play_sound('tarot1')\n                                card.T.r = -0.2\n                                card:juice_up(0.3, 0.4)\n                                card.states.drag.is = true\n                                card.children.center.pinch.x = true\n                                -- This part destroys the card.\n                                G.E_MANAGER:add_event(Event({\n                                    trigger = 'after',\n                                    delay = 0.3,\n                                    blockable = false,\n                                    func = function()\n                                        check_for_unlock({type = 'picubed_printer_error'})\n                                        local mpcard = create_card('Joker', G.jokers, nil, 0, nil, nil, 'j_misprint', 'pri')\n                                        mpcard:set_edition(card.edition, false, true)\n                                        mpcard:add_to_deck()\n                                        G.jokers:emplace(mpcard)\n                                        mpcard:start_materialize()\n                                        G.GAME.pool_flags.picubed_printer_error = true\n                                        G.jokers:remove_card(card)\n                                        card:remove()\n                                        card = nil\n                                        return true;\n                                    end\n                                }))\n                            end\n                    return true\n                    end\n                    }))\n                end\n            end\n        end\n    end",
      "config": {
        "extra": {
          "copy_odds": 2,
          "destroy_odds": 4,
          "copied": {}
        }
      },
      "ability": {
        "extra": {
          "copy_odds": 2,
          "destroy_odds": 4,
          "copied": {}
        }
      },
      "vars": [
        null,
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "itsaysjokerontheceiling",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "--It Says \"Joker\" on the Ceiling\n\t\tkey = 'itsaysjokerontheceiling',\n\t\tloc_txt = {\n\t\t\t\tname = 'It Says \"Joker\" on the Ceiling',\n\t\t\t\ttext = {\n\t\t\t\t\t\t\"Round {C:chips}Chips{} to the next #1#,\", \n\t\t\t\t\t\t\"Round {C:mult}Mult{} to the next #2#\"\n\t\t\t\t}\n\t\t},\n\t\tpronouns = 'he_him',\n\t\trarity = 1,\n\t\tatlas = 'PiCubedsJokers',\n\t\tpos = { x = 0, y = 0 },\n\t\tcost = 5,\n\t\tdiscovered = true,\n\t\tblueprint_compat = true,\n\t\tloc_vars = function(self, info_queue, card)\n\t\t\t\treturn { vars = { card.ability.extra.chips_ceil, card.ability.extra.mult_ceil } }\n\t\tend,\n\t\tconfig = { extra = { chips = 0, mult = 0, chips_ceil = 100, mult_ceil = 10 } },\n\t\tcalculate = function(self, card, context)\n\t\t\t\tlocal mult_ceil = 0\n\t\t\t\tlocal chips_ceil = 0\n\t\t\t\tif context.joker_main then\n\t\t\t\t\t\tif mult < to_big(1e+308) then\n\t\t\t\t\t\t\t\tmult_ceil = math.ceil(to_number(mult) / card.ability.extra.mult_ceil) * card.ability.extra.mult_ceil\n\t\t\t\t\t\t\t\tcard.ability.extra.mult = mult_ceil - to_number(mult)\n\t\t\t\t\t\tend \n\t\t\t\t\t\tif hand_chips < to_big(1e+308) then\n\t\t\t\t\t\t\t\tchips_ceil = math.ceil(to_number(hand_chips) / card.ability.extra.chips_ceil) * card.ability.extra.chips_ceil\n\t\t\t\t\t\t\t\tcard.ability.extra.chips = chips_ceil - to_number(hand_chips)\n\t\t\t\t\t\tend\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tcolour = G.C.PURPLE,\n\t\t\t\t\t\t\t\tmessage = localize(\"k_picubeds_gullible\"),\n\t\t\t\t\t\t\t\tremove_default_message = true,\n\t\t\t\t\t\t\t\tchips = card.ability.extra.chips,\n\t\t\t\t\t\t\t\tmult = card.ability.extra.mult\n\t\t\t\t\t\t}\n\t\t\t\tend\n\t\tend",
      "config": {
        "extra": {
          "chips": 0,
          "mult": 0,
          "chips_ceil": 100,
          "mult_ceil": 10
        }
      },
      "ability": {
        "extra": {
          "chips": 0,
          "mult": 0,
          "chips_ceil": 100,
          "mult_ceil": 10
        }
      },
      "vars": [
        100,
        10
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "jokercircuit",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 7,
        "y": 9
      },
      "raw": "--Joker Circuit\n\tkey = 'jokercircuit',\n\tloc_txt = {\n\t\tname = 'Joker Circuit',\n\t\ttext = {\n\t\t\t\"Every {C:attention}#1#{} {C:inactive}[#2#]{} hands\", \n\t\t\t\"containing a {C:attention}Straight{},\",\n            \"create a free {C:attention}Speed Tag{}\",\n\t\t}\n\t},\n\tpronouns = 'he_they',\n\trarity = 2,\n    config = { extra = { count_max = 3, count_current = 3 } },\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 7, y = 9 },\n\tcost = 4,\n\tdiscovered = true,\n\tblueprint_compat = true,\n    perishable_compat = true,\n\teternal_compat = true,\n\tloc_vars = function(self, info_queue, card)\n\t    info_queue[#info_queue + 1] = { key = \"speedtag_tooltip\", set = \"Other\", vars = { G.GAME.skips*5 or 0 } }\n        return { vars = { card.ability.extra.count_max, card.ability.extra.count_current } }\n\tend,\n\tcalculate = function(self, card, context)\n        if context.before and context.main_eval and not context.blueprint and next(context.poker_hands['Straight']) then\n\t\t\tcard.ability.extra.count_current = card.ability.extra.count_current - 1\n\t\t\tif card.ability.extra.count_current > 0 then\n\t\t\t\treturn {\n\t\t\t\t\tcard = card,\n\t\t\t\t\tmessage = tostring(card.ability.extra.count_current),\n\t\t\t\t\tcolour = G.C.MONEY\n\t\t\t\t}\n\t\t\tend\n\t\tend\n\t\tif context.before and context.main_eval and not context.blueprint and next(context.poker_hands['Straight']) and card.ability.extra.count_current <= 0 and not context.retrigger_joker then\n\t\t\tcard.ability.extra.count_current = card.ability.extra.count_max\n\t\t\tcard_eval_status_text(card, 'extra', nil, nil, nil, {message = \"+1 Tag\", colour = G.C.MONEY})\n\t\t\tG.E_MANAGER:add_event(Event({\n                func = (function()\n                    card:juice_up()\n\t\t\t\t\tadd_tag(Tag('tag_picubed_jokercircuitskip'))\n                    play_sound('generic1', 0.9 + math.random() * 0.1, 0.8)\n                    play_sound('holo1', 1.2 + math.random() * 0.1, 0.4)\n                    return true\n                end)\n            }))\n\t\tend\n\tend",
      "config": {
        "extra": {
          "count_max": 3,
          "count_current": 3
        }
      },
      "ability": {
        "extra": {
          "count_max": 3,
          "count_current": 3
        }
      },
      "vars": [
        3,
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Tag",
      "key": "jokercircuitskip",
      "atlas": null,
      "pos": {
        "x": 0,
        "y": 3
      },
      "raw": "-- Speed Tag (special version for Joker Circuit - waits to activate if G.GAME.skips == 0, and otherwise activates *immediately* and )\n    key = \"jokercircuitskip\",\n    pos = { x = 0, y = 3 },\n    config = { skip_bonus = 5 },\n    in_pool = function(self, args) return false end,\n\tno_collection = true,\n\tdiscovered = true,\n\tloc_vars = function(self, info_queue, tag)\n        return { vars = { tag.config.skip_bonus, tag.config.skip_bonus * ((G.GAME.skips or 0)) } }\n    end,\n    apply = function(self, tag, context)\n        if G.GAME.skips and G.GAME.skips > 0 then\n            local lock = tag.ID\n            G.CONTROLLER.locks[lock] = true\n            tag:yep('+', G.C.MONEY, function()\n                G.CONTROLLER.locks[lock] = nil\n                return true\n            end)\n            ease_dollars((G.GAME.skips or 0) * tag.config.skip_bonus)\n            tag.triggered = true\n            return true\n        end\n    end",
      "config": {
        "skip_bonus": 5
      },
      "ability": {
        "skip_bonus": 5
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "jokerinanutshell",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 3,
        "y": 10
      },
      "raw": "--Joker in a Nutshell\n\tkey = 'jokerinanutshell',\n\tloc_txt = {\n\t\tname = 'Joker in a Nutshell',\n\t\ttext = {\n\t\t\t\"When {C:attention}Blind{} is selected, destroy\",\n            \"Joker to the right, and for\",\n            \"each {C:attention}line of description text{}\",\n            \"it had add {X:mult,C:white}X#2#{} Mult to this Joker\",\n            \"{C:inactive}(Currently {X:mult,C:white}X#1#{C:inactive} Mult)\",\n\t\t}\n\t},\n    pronouns = 'they_them',\n\trarity = 3,\n    config = { extra = { Xmult = 1, Xmult_mod = 0.1 } },\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 3, y = 10 },\n\tcost = 7,\n\tdiscovered = true,\n\tblueprint_compat = true,\n    perishable_compat = false,\n\teternal_compat = true,\n\tloc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.Xmult, card.ability.extra.Xmult_mod } }\n\tend,\n\n\t\n\tcalculate = function(self, card, context)\n        if context.setting_blind and not context.blueprint and not context.retrigger_joker then\n            local my_pos = nil\n            for i = 1, #G.jokers.cards do\n                if G.jokers.cards[i] == card then\n                    my_pos = i\n                    break\n                end\n            end\n            if my_pos and G.jokers.cards[my_pos + 1] and not SMODS.is_eternal(G.jokers.cards[my_pos + 1], card) and not G.jokers.cards[my_pos + 1].getting_sliced then\n                local sliced_card = G.jokers.cards[my_pos + 1]\n                sliced_card.getting_sliced = true\n                G.GAME.joker_buffer = G.GAME.joker_buffer - 1\n\t\t\t\tlocal card_desc = G.localization.descriptions.Joker[sliced_card.config.center.key].text\n\t\t\t\tlocal num_lines = 0\n                if type(card_desc[1]) == 'table' then\n                    for i=1,#card_desc do\n                        num_lines = num_lines + #card_desc[i]\n                    end\n                elseif type(card_desc[1]) == 'string' then\n                    num_lines = #card_desc\n                end\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        G.GAME.joker_buffer = 0\n                        card.ability.extra.Xmult = card.ability.extra.Xmult + num_lines * card.ability.extra.Xmult_mod\n                        card:juice_up(0.8, 0.8)\n                        sliced_card:start_dissolve({ HEX(\"57ecab\") }, nil, 1.6)\n                        play_sound('tarot1', 0.96 + math.random() * 0.08)\n                        return true\n                    end\n                }))\n                return {\n                    message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.Xmult + num_lines * card.ability.extra.Xmult_mod } },\n                    colour = G.C.RED,\n                    no_juice = true,\n                }\n            end\n        end\n        if context.joker_main then\n            return {\n                xmult = card.ability.extra.Xmult\n            }\n        end\n\tend",
      "config": {
        "extra": {
          "Xmult": 1,
          "Xmult_mod": 0.1
        }
      },
      "ability": {
        "extra": {
          "Xmult": 1,
          "Xmult_mod": 0.1
        }
      },
      "vars": [
        1,
        0.1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "jokinhood",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 6,
        "y": 0
      },
      "raw": "--Jokin' Hood\n    key = 'jokinhood',\n    loc_txt = {\n        name = \"Jokin' Hood\",\n        text = {\n            \"{C:attention}Non-face cards{} earn {C:money}$#1#{}\",\n            \"when scored, {C:attention}face cards{}\",\n            \"earn {C:mult}-$#2#{} when scored\"\n        }\n    },\n    pronouns = 'he_they',\n    config = { extra = { num_money = 1, face_money = 2 } },\n    rarity = 2,\n    atlas = 'PiCubedsJokers',\n    pos = { x = 6, y = 0 },\n    cost = 6,\n    discovered = true,\n    blueprint_compat = true,\n    perishable_compat = true,\n    eternal_compat = true,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.num_money, card.ability.extra.face_money } }\n    end,\n    calculate = function(self, card, context)\n        if context.individual and context.cardarea == G.play then\n            if not context.other_card:is_face() and not context.other_card.debuff then\n                return {\n                    dollars = card.ability.extra.num_money,\n                    card = card,\n                    func = function()\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            G.GAME.dollar_buffer = 0\n                            return true\n                        end\n                    }))\n                    end\n                }\n            else\n                return {\n                    dollars = -card.ability.extra.face_money,\n                    card = card,\n                    func = function()\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            G.GAME.dollar_buffer = 0\n                            return true\n                        end\n                    }))\n                    end\n                }\n            end\n        end\n    end",
      "config": {
        "extra": {
          "num_money": 1,
          "face_money": 2
        }
      },
      "ability": {
        "extra": {
          "num_money": 1,
          "face_money": 2
        }
      },
      "vars": [
        1,
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "landslide",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 8,
        "y": 0
      },
      "raw": "--Landslide\n    key = 'landslide',\n    loc_txt = {\n        name = 'Landslide',\n        text = {\n            \"A random card held in hand\",\n            \"becomes a {C:attention}Stone Card{}\",\n            \"if {C:chips}Chips{} exceeds {C:mult}Mult\",\n            \"after scoring\"\n        }\n    },\n    pronouns = 'he_they',\n    atlas = 'PiCubedsJokers',\n    pos = { x = 8, y = 0 },\n    cost = 5,\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = true,\n    perishable_compat = true,\n    eternal_compat = true,\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue+1] = G.P_CENTERS.m_stone\n        return {\n            vars = { card.ability.max_highlighted }\n        }\n    end,\n    \n    calculate = function(self, card, context)\n        if context.cardarea == G.jokers and context.after then \n            if to_big(hand_chips) > to_big(mult) and #G.hand.cards >= 1 then\n                local rndcard = pseudorandom_element(G.hand.cards, pseudoseed('Landslide'..G.GAME.round_resets.ante))\n                if not SMODS.has_enhancement(rndcard, 'm_stone') then\n                    G.E_MANAGER:add_event(Event({\n                        trigger = 'before',\n                        delay = 0.15,\n                        func = function() \n                            rndcard:flip()\n                            rndcard:juice_up()\n                            play_sound('tarot2', 0.9 + math.random()*0.05 )\n                            return true\n                        end\n                    }))\n                    card_eval_status_text(card, 'extra', nil, nil, nil, {message = localize(\"k_picubeds_tumble\"), colour = G.C.ORANGE})\n                    G.E_MANAGER:add_event(Event({\n                        trigger = 'after',\n                        func = function() \n                            rndcard:set_ability('m_stone', nil, true)\n                            return true\n                        end\n                    }))\n                    G.E_MANAGER:add_event(Event({\n                        trigger = 'after',\n                        delay = 0.15,\n                        func = function() \n                            rndcard:flip()\n                            rndcard:juice_up()\n                            play_sound('tarot2', 1.05 + math.random()*0.05 )\n                            return true\n                        end\n                    }))\n                else\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            rndcard:juice_up()\n                            return true\n                        end\n                    }))\n                end\n            end\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "laserprinter",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 1,
        "y": 8
      },
      "raw": "--Laser Printer\n\t key = 'laserprinter',\n\tloc_txt = {\n\t\tname = 'Laser Printer',\n\t\ttext = {\n\t\t\t\"{C:attention}Consumables{} have a {C:green}#1# in #2#{} chance\",\n\t\t\t\"to be {C:attention}recreated{} on use and a\",\n\t\t\t\"{C:green}#5# in #6#{} chance to be made {C:dark_edition}Negative{},\",\n\t\t\t\"this card has a {C:green}#3# in #4#{} \",\n\t\t\t\"chance to be {C:attention}disabled{} for\",\n\t\t\t\"this Ante after activating\",\n\t\t\t\"{C:inactive}(Must have room){}\"\n\t\t}\n\t},\n\tpronouns = 'it_its',\n\trarity = 2,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 1, y = 8 },\n\t--soul_pos = { x = 1, y = 7 },\n\tsoul_pos = { x = 10, y = 7 }, --no soul\n\tcost = 6,\n\tunlocked = false,\n\tblueprint_compat = false,\n\tperishable_compat = true,\n\teternal_compat = false,\n\tconfig = { extra = { copy_odds = 2, destroy_odds = 4, copied = {}, negative_odds = 2, is_disabled = false } },\n\tloc_vars = function(self, info_queue, card)\n\t\tlocal numerator_copy, denominator_copy = SMODS.get_probability_vars(card, 1, card.ability.extra.copy_odds, 'picubed_laserprinter_copy')\n\t\tlocal numerator_destroy, denominator_destroy = SMODS.get_probability_vars(card, 1, card.ability.extra.destroy_odds, 'picubed_laserprinter_destroy')\n\t\tlocal numerator_neg, denominator_neg = SMODS.get_probability_vars(card, 1, card.ability.extra.negative_odds, 'picubed_laserprinter_neg')\n\t\treturn { vars = { numerator_copy, denominator_copy, numerator_destroy, denominator_destroy, numerator_neg, denominator_neg } }\n\tend,\n\tin_pool = function(self, args)\n\t\t\treturn G.GAME.pool_flags.picubed_printer_error and #SMODS.find_card('j_picubed_inkjetprinter') < 1\n\tend,\n\tlocked_loc_vars = function(self, info_queue, card)\n\t\tinfo_queue[#info_queue+1] = G.P_CENTERS.j_picubed_inkjetprinter\n\t\treturn { vars = { card.ability.max_highlighted } }\n\tend,\n\tcheck_for_unlock = function(self, args)\n\t\t\tif G.GAME.pool_flags.picubed_printer_error then return true end\n\t\t\treturn false\n\tend,\n\tupdate = function(self, card, dt)\n\t\tif not card.ability.extra.is_disabled then\n\t\t\tcard.children.floating_sprite:set_sprite_pos({ x = 10, y = 7 }) -- no soul\n\t\telse\n\t\t\tcard.children.floating_sprite:set_sprite_pos({ x = 1, y = 7 })\n\t\tend\n\tend,\n\tcalculate = function(self, card, context)\n\t\tif context.end_of_round and G.GAME.blind.boss and context.cardarea == G.jokers and card.ability.extra.is_disabled then\n\t\t\tcard.ability.extra.is_disabled = false\n\t\t\tcard.children.floating_sprite:set_sprite_pos({ x = 10, y = 7 })\n\t\t\tcard_eval_status_text(card, 'extra', nil, nil, nil, { message = localize(\"k_picubeds_fixed\") })\n\t\tend\n\t\tif context.using_consumeable and not context.blueprint and not card.ability.extra.is_disabled then\n\t\t\tif SMODS.pseudorandom_probability(card, 'picubed_laserprinter_copy', 1, card.ability.extra.copy_odds) then\n\t\t\t\tlocal has_activated = false\n\t\t\t\tlocal has_destroyed = false\n\t\t\t\tlocal is_negative = false\n\t\t\tif SMODS.pseudorandom_probability(card, 'picubed_laserprinter_neg', 1, card.ability.extra.negative_odds) then\n\t\t\t\tis_negative = true\n\t\t\tend\n\t\t\t\tG.E_MANAGER:add_event(Event({\n\t\t\t\t\tfunc = function()\n\t\t\t\t\t\tif is_negative then\n\t\t\t\t\t\t\tlocal copied_card = copy_card(context.consumeable, nil)\n\t\t\t\t\t\t\tcopied_card:add_to_deck()\n\t\t\t\t\t\t\tif context.consumeable.edition then\n\t\t\t\t\t\t\t\tif not copied_card.edition == 'e_negative' then\n\t\t\t\t\t\t\t\t\tcopied_card:set_edition(\"e_negative\", false, true)\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tcopied_card:set_edition(\"e_negative\", false, true)\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tG.consumeables:emplace(copied_card)\n\t\t\t\t\t\t\thas_activated = true\n\t\t\t\t\t\t\tcard_eval_status_text(card, 'extra', nil, nil, nil,\n\t\t\t\t\t\t\t\t{ message = localize(\"k_picubeds_print\") })\n\t\t\t\t\t\telseif #G.consumeables.cards < G.consumeables.config.card_limit then\n\t\t\t\t\t\t\tlocal copied_card = copy_card(context.consumeable, nil)\n\t\t\t\t\t\t\tcopied_card:add_to_deck()\n\t\t\t\t\t\t\tG.consumeables:emplace(copied_card)\n\t\t\t\t\t\t\thas_activated = true\n\t\t\t\t\t\t\tcard_eval_status_text(card, 'extra', nil, nil, nil,\n\t\t\t\t\t\t\t\t{ message = localize(\"k_picubeds_print\") })\n\t\t\t\t\t\tend\n\t\t\t\t\t\treturn true\n\t\t\t\t\tend\n\t\t\t\t}))\n\n\t\t\t\tif SMODS.pseudorandom_probability(card, 'picubed_laserprinter_destroy', 1, card.ability.extra.destroy_odds) then\n\t\t\t\t\tcard_eval_status_text(card, 'extra', nil, nil, nil,\n\t\t\t\t\t\t\t\t\t\t\t{ message = localize(\"k_picubeds_error\"), sound = 'tarot1', colour = G.C.RED })\n\t\t\t\t\tG.E_MANAGER:add_event(Event({\n\t\t\t\t\tfunc = function()\n\t\t\t\t\t\tif has_activated then\n\t\t\t\t\t\t\thas_destroyed = true\n                            G.E_MANAGER:add_event(Event({\n                                trigger = 'after',\n                                delay = 0.3,\n                                blockable = false,\n                                func = function()\n                                    card.ability.extra.is_disabled = true\n                                    card.children.floating_sprite:set_sprite_pos({ x = 1, y = 7 })\n                                    return true;\n                                end\n                            }))\n                        end\n\t\t\t\t\treturn true\n\t\t\t\t\tend\n\t\t\t\t\t}))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend",
      "config": {
        "extra": {
          "copy_odds": 2,
          "destroy_odds": 4,
          "copied": {},
          "negative_odds": 2,
          "is_disabled": false
        }
      },
      "ability": {
        "extra": {
          "copy_odds": 2,
          "destroy_odds": 4,
          "copied": {},
          "negative_odds": 2,
          "is_disabled": false
        }
      },
      "vars": [
        null,
        null,
        null,
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "leeroooooy",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 5,
        "y": 11
      },
      "raw": "--LEEROOOOOY\n\tkey = 'leeroooooy',\n\tloc_txt = {\n\t\tname = 'LEEROOOOOY!!',\n\t\ttext = {\n\t\t\t\"{C:attention}Retrigger{} all played cards\", \n\t\t\t\"per {C:attention}Blind skipped{} this {C:attention}Ante\",\n            \"{C:inactive}(Currently {C:attention}#1#{} {C:inactive}retriggers)\"\n\t\t}\n\t},\n\tpronouns = 'he_him',\n\trarity = 2,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 5, y = 11 },\n\tcost = 5,\n\tdiscovered = true,\n\tblueprint_compat = true,\n    perishable_compat = true,\n\teternal_compat = true,\n\tpools = { [\"Meme\"] = true },\n\tconfig = { extra = { retriggers = 0 } },\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.retriggers } }\n\tend,\n\tcalculate = function(self, card, context)\n        if context.skip_blind and not context.blueprint and not context.retrigger_joker then\n\t\t\tcard.ability.extra.retriggers = card.ability.extra.retriggers + 1\n            return {\n                message = localize('k_upgrade_ex')\n            }\n\t\tend\n\t\tif context.end_of_round and context.game_over == false and context.main_eval and not context.blueprint and not context.retrigger_joker then\n            if context.beat_boss and card.ability.extra.retriggers ~= 0 then\n                card.ability.extra.retriggers = 0\n                return {\n                    message = localize('k_reset'),\n                    colour = G.C.RED\n                }\n            end\n        end\n\t\tif context.repetition and context.cardarea == G.play and card.ability.extra.retriggers >= 1 then\n            return {\n                repetitions = card.ability.extra.retriggers\n            }\n        end\n\tend",
      "config": {
        "extra": {
          "retriggers": 0
        }
      },
      "ability": {
        "extra": {
          "retriggers": 0
        }
      },
      "vars": [
        0
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "lowballdraw",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 9,
        "y": 7
      },
      "raw": "--Lowball Draw\n\tkey = 'lowballdraw',\n\tloc_txt = {\n\t\tname = 'Lowball Draw',\n\t\ttext = {\n\t\t\t\"Earn {C:money}$#1#{} when a\",\n\t\t\t\"{C:attention}2{} or {C:attention}7{} is drawn\",\n\t\t\t\"to hand during Blind\",\n\t\t}\n\t},\n\tpronouns = 'they_them',\n\trarity = 1,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 9, y = 7 },\n\tcost = 6,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tperishable_compat = true,\n\teternal_compat = true,\n\tconfig = { extra = { money = 1 } },\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.money } }\n\tend,\n\tcalculate = function(self, card, context)\n\t\tlocal low_count = 0\n\t\tif (context.first_hand_drawn or context.hand_drawn) and G.GAME.blind.in_blind then\n\t\t\tfor k,v in ipairs(context.hand_drawn) do\n\t\t\t\tif v:get_id() == 2 or v:get_id() == 7 then\n\t\t\t\t\tlow_count = low_count + 1\n\t\t\t\tend\n\t\t\tend\n\t\t\tif low_count > 0 then\n\t\t\t\tlocal low_low_count = low_count\n\t\t\t\tlow_count = 0\n\t\t\t\treturn {\n                    dollars = card.ability.extra.money * low_low_count,\n                    card = card\n\t\t\t\t}\n\t\t\tend\n\t\tend\n\tend",
      "config": {
        "extra": {
          "money": 1
        }
      },
      "ability": {
        "extra": {
          "money": 1
        }
      },
      "vars": [
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "missingfinger",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 6,
        "y": 7
      },
      "raw": "--Missing Finger\n\tkey = 'missingfinger',\n\tloc_txt = {\n\t\tname = 'Missing Finger',\n\t\ttext = {\n\t\t\t\"{X:mult,C:white}X#1#{} Mult, {C:attention}#2#{} playing\",\n\t\t\t\"card {C:attention}selection limit{}\",\n\t\t\t--\"for {C:blue}playing{} and {C:red}discarding{}\",\n\t\t}\n\t},\n\tpronouns = 'they_them',\n\trarity = 3,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 6, y = 7 },\n\tcost = 7,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tperishable_compat = true,\n\teternal_compat = true,\n\tconfig = { extra = { Xmult = 4, select_mod = -1 } },\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.Xmult, card.ability.extra.select_mod } }\n\tend,\n\tadd_to_deck = function(self, card, from_debuff)\n\t\tG.hand.config.highlighted_limit = G.hand.config.highlighted_limit + card.ability.extra.select_mod\n\t\tif #G.hand.highlighted > G.hand.config.highlighted_limit then\n\t\t\tG.hand:unhighlight_all()\n\t\tend\n\tend,\n\tremove_from_deck = function(self, card, from_debuff)\n\t\tG.hand.config.highlighted_limit = G.hand.config.highlighted_limit - card.ability.extra.select_mod \n\tend,\n\tcalculate = function(self, card, context)\n\t\tif context.joker_main then\n\t\t\treturn {\n                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.Xmult } },\n                Xmult_mod = card.ability.extra.Xmult\n\t\t\t}\n\t\tend\n\tend",
      "config": {
        "extra": {
          "Xmult": 4,
          "select_mod": -1
        }
      },
      "ability": {
        "extra": {
          "Xmult": 4,
          "select_mod": -1
        }
      },
      "vars": [
        4,
        -1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "moltenjoker",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "--Molten Joker\n\t\tkey = 'moltenjoker',\n\t\tloc_txt = {\n\t\t\t\tname = 'Molten Joker',\n\t\t\t\ttext = {\n\t\t\t\t\t\t\"Retrigger {C:attention}Gold{}, {C:attention}Steel{},\", \n\t\t\t\t\t\t\"and {C:attention}Stone{} cards\"\n\t\t\t\t}\n\t\t},\n\t\tpronouns = 'they_them',\n\t\tconfig = { extra = { repetitions = 1 } },\n\t\trarity = 2,\n\t\tatlas = 'PiCubedsJokers',\n\t\tpos = { x = 3, y = 0 },\n\t\tcost = 5,\n\t\tdiscovered = true,\n\t\tblueprint_compat = true,\n\t\tin_pool = function(self, args)\n\t\t\tfor kk, vv in pairs(G.playing_cards or {}) do\n\t\t\t\tif SMODS.has_enhancement(vv, 'm_stone') or SMODS.has_enhancement(vv, 'm_gold') or SMODS.has_enhancement(vv, 'm_steel') then\n\t\t\t\t\treturn true\n\t\t\t\tend\n\t\t\tend\n\t\t\treturn false\n\t\tend,\n\t\tloc_vars = function(self, info_queue, card)\n\t\t\t\tinfo_queue[#info_queue+1] = G.P_CENTERS.m_gold\n\t\t\t\tinfo_queue[#info_queue+1] = G.P_CENTERS.m_steel\n\t\t\t\tinfo_queue[#info_queue+1] = G.P_CENTERS.m_stone\n\t\t\t\treturn {\n\t\t\t\t\t\tvars = { card.ability.max_highlighted}\n\t\t\t\t}\n\t\tend,\n\t\t\n\t\tcalculate = function(self, card, context)\n\t\t\t\tif context.cardarea == G.play and context.repetition and not context.repetition_only then\n\t\t\t\t\t\tif SMODS.has_enhancement(context.other_card, 'm_stone') or SMODS.has_enhancement(context.other_card, 'm_gold')\n\t\t\t\t\t\tor SMODS.has_enhancement(context.other_card, 'm_steel') then\n\t\t\t\treturn {\n\t\t\t\t\tmessage = localize('k_again_ex'),\n                repetitions = card.ability.extra.repetitions,\n                card = card\n\t\t\t\t}\n\t\t\tend\n\t\tend\n\t\t\t\tif context.cardarea == G.hand and context.repetition and not context.repetition_only then\n\t\t\t\t\t\tif SMODS.has_enhancement(context.other_card, 'm_stone') or SMODS.has_enhancement(context.other_card, 'm_gold')\n\t\t\t\t\t\tor SMODS.has_enhancement(context.other_card, 'm_steel') then\n\t\t\t\treturn {\n\t\t\t\t\tmessage = localize('k_again_ex'),\n                repetitions = card.ability.extra.repetitions,\n                card = card\n\t\t\t\t}\n\t\t\t\t\t\tend\n\t\t\t\tend\n\tend",
      "config": {
        "extra": {
          "repetitions": 1
        }
      },
      "ability": {
        "extra": {
          "repetitions": 1
        }
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "monkey1",
      "atlas": null,
      "pos": null,
      "raw": "key = \"monkey1\",\n\tpath = \"monkey1.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "monkey2",
      "atlas": null,
      "pos": null,
      "raw": "key = \"monkey2\",\n\tpath = \"monkey2.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "monkeyseemonkeydo",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 4,
        "y": 9
      },
      "raw": "--Monkey See, Monkey Do\n\tkey = 'monkeyseemonkeydo',\n\tloc_txt = {\n\t\tname = 'Monkey See, Monkey Do',\n\t\ttext = {\n\t\t\t\"Each played {C:attention}#1#{} and {C:attention}#2#{}\", \n\t\t\t\"gives {C:mult}+#3#{} Mult when scored\",\n            \"{s:0.8}Ranks change every {}{s:0.8,C:attention}hand{}\",\n\t\t}\n\t},\n\tpronouns = 'he_him',\n\tconfig = { extra = { mult = 8 } },\n\trarity = 1,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 4, y = 9 },\n\tcost = 4,\n\tdiscovered = true,\n\tblueprint_compat = true,\n    perishable_compat = true,\n\teternal_compat = true,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { localize((G.GAME.current_round.picubed_monkeysee or {}).rank or 'King', 'ranks'), localize((G.GAME.current_round.picubed_monkeydo or {}).rank or 'Ace', 'ranks'), card.ability.extra.mult } }\n    end,\n\tcalculate = function(self, card, context)\n        if not G.GAME.current_round.picubed_monkeysee then -- initialise on first play\n\t\t\tG.GAME.current_round.picubed_monkeysee = { rank = 'King', id = 13 }\n\t\t\tG.GAME.current_round.picubed_monkeydo = { rank = 'Ace', id = 14 }\n\t\tend\n\t\tif context.individual and context.cardarea == G.play then\n\t\t\tif not picubed_config.custom_sound_effects then\n\t\t\t\tif context.other_card:get_id() == G.GAME.current_round.picubed_monkeysee or context.other_card:get_id() == G.GAME.current_round.picubed_monkeydo then\n\t\t\t\t\treturn {\n\t\t\t\t\t\tmult = card.ability.extra.mult\n\t\t\t\t\t}\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tif context.other_card:get_id() == G.GAME.current_round.picubed_monkeysee.id then\n\t\t\t\t\tG.E_MANAGER:add_event(Event({func = function()\n\t\t\t\t\tplay_sound(\"picubed_monkey1\")\n\t\t\t\t\treturn true end}))\n\t\t\t\t\treturn {\n\t\t\t\t\t\tmult = card.ability.extra.mult,\n\t\t\t\t\t}\n\t\t\t\tend\n\t\t\t\tif context.other_card:get_id() == G.GAME.current_round.picubed_monkeydo.id then\n\t\t\t\t\tG.E_MANAGER:add_event(Event({func = function()\n\t\t\t\t\tplay_sound(\"picubed_monkey2\")\n\t\t\t\t\treturn true end}))\n\t\t\t\t\treturn {\n\t\t\t\t\t\tmult = card.ability.extra.mult,\n\t\t\t\t\t}\n\t\t\t\tend\n\t\t\tend\n        end\n\t\tif context.after and not context.blueprint then\n\t\t\tG.E_MANAGER:add_event(Event({\n\t\t\t\tfunc = (function()\n\t\t\t\t\treset_monkey_ranks()\n\t\t\t\t\treturn true\n\t\t\t\tend)\n\t\t\t}))\n\t\tend\n\tend",
      "config": {
        "extra": {
          "mult": 8
        }
      },
      "ability": {
        "extra": {
          "mult": 8
        }
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "mountjoker",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 7,
        "y": 5
      },
      "raw": "--Mount Joker\n\tkey = 'mountjoker',\n\tloc_txt = {\n\t\tname = 'Mount Joker',\n\t\ttext = {\n\t\t\t\"If played hand has at\",\n\t\t\t\"least 4 {C:attention}Stone{} cards,\",\n\t\t\t\"poker hand is your\",\n\t\t\t\"{C:attention}highest level poker hand{}\"\n\t\t}\n\t},\n\tpronouns = 'he_they',\n\trarity = 2,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 7, y = 5 },\n\tcost = 4,\n\tdiscovered = true,\n\tblueprint_compat = false,\n\tperishable_compat = true,\n\teternal_compat = true,\n\tin_pool = function(self, args)\n\t\tfor kk, vv in pairs(G.playing_cards or {}) do\n\t\t\tif SMODS.has_enhancement(vv, 'm_stone') then\n\t\t\t\treturn can_do_pokerhand_changer_jokers()\n\t\t\tend\n\t\tend\n\t\treturn false\n\tend,\n\tloc_vars = function(self, info_queue, card)\n\t\tinfo_queue[#info_queue+1] = G.P_CENTERS.m_stone\n\t\treturn {\n\t\t\tvars = { card.ability.max_highlighted}\n\t\t}\n\tend,\n\tcalculate = function(self, card, context) --this joker is all patch, in evaluate_poker_hand(hand)\n\t\tif not can_do_pokerhand_changer_jokers() then\n\t\t\tprint(\"Mount Joker has limited functionality due to a mod conflict, or the 'Hand type-affecting Jokers' config option being disabled.\")\n\t\tend\n\t\tlocal stone_count = 0\n\t\tfor k,v in ipairs(G.hand.highlighted) do\n\t\t\t\tif SMODS.has_enhancement(v, 'm_stone') then \n\t\t\t\t\t\tstone_count = stone_count + 1\n\t\t\t\tend\n\t\tend\n\t\tfor k,v in ipairs(G.play.cards) do\n\t\t\t\tif SMODS.has_enhancement(v, 'm_stone') then \n\t\t\t\t\t\tstone_count = stone_count + 1\n\t\t\t\tend\n\t\tend\n\t\tif context.joker_main and next(context.poker_hands['Straight Flush']) then\n\t\t\tcheck_for_unlock({type = 'picubed_straightflush_agrandmemorial'})\n\t\tend\n\t\tif context.modify_scoring_hand and not context.blueprint and stone_count >= 4 then\n\t\t\treturn {\n\t\t\t\t\tadd_to_hand = true\n\t\t\t}\n\t\tend\n\tend",
      "config": {
        "type": "picubed_straightflush_agrandmemorial"
      },
      "ability": {
        "type": "picubed_straightflush_agrandmemorial"
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "nightvision",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 7,
        "y": 7
      },
      "raw": "--Night Vision\n\tkey = 'nightvision',\n\tloc_txt = {\n\t\tname = 'Night Vision',\n\t\ttext = {\n\t\t\t\"After Play, {C:attention}flip{} all cards in hand,\",\n\t\t\t\"earn {C:money}$#1#{} per card flipped\",\n\t\t\t\"{C:attention}face up{} by this Joker\",\n\t\t}\n\t},\n\tpronouns = 'he_him',\n\trarity = 2,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 7, y = 7 },\n\tcost = 7,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tperishable_compat = true,\n\teternal_compat = true,\n\tconfig = { extra = { money = 1 } },\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.money } }\n\tend,\n\tcalculate = function(self, card, context)\n\t\tif context.before and not context.blueprint then\n\t\t\tlocal flip_count = 0\n\t\t\tfor k, v in ipairs(G.hand.cards) do\n\t\t\t\tif v.facing ~= 'front' then\n\t\t\t\t\tflip_count = flip_count + 1\n\t\t\t\tend\n\t\t\t\tv:flip()\n\t\t\tend\n\t\t\tif flip_count > 0 then\n\t\t\t\treturn {\n                    dollars = card.ability.extra.money * flip_count,\n                    card = card\n\t\t\t\t}\n\t\t\tend\n\t\tend\n\tend",
      "config": {
        "extra": {
          "money": 1
        }
      },
      "ability": {
        "extra": {
          "money": 1
        }
      },
      "vars": [
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "nobelprize",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 2,
        "y": 10
      },
      "raw": "--Nobel Prize\n\tkey = 'nobelprize',\n\tloc_txt = {\n\t\tname = 'Nobel Prize',\n\t\ttext = {\n\t\t\t\"Create a {C:spectral}Spectral {}card\", \n\t\t\t\"after playing a poker hand\",\n            \"for the {C:attention}first time{} this run\",\n            \"{C:inactive}(Must have room)\",\n            \"{S:1.1,C:red,E:2}self destructs{}\",\n\t\t}\n\t},\n    pronouns = 'he_him',\n\trarity = 1,\n    config = { extra = { count_max = 3, count_current = 3 } },\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 2, y = 10 },\n\tcost = 3,\n\tdiscovered = true,\n\tblueprint_compat = false,\n    perishable_compat = true,\n\teternal_compat = false,\n    in_pool = function(self, args) --only shows up if there is a remaining poker hand with no plays\n\t\tfor kk, vv in pairs(G.GAME.hands) do\n            if G.GAME.hands[kk].played <= 0 then\n\t\t\t\treturn true\n\t\t\tend\n\t\tend\n\t\treturn false\n\tend,\n\tcalculate = function(self, card, context)\n        if context.before and context.main_eval and not context.blueprint then\n            if G.GAME.hands[context.scoring_name].played <= 1 then\n                if #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then\n                    G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1\n                    G.E_MANAGER:add_event(Event({\n                        func = (function()\n                            SMODS.add_card {\n                                set = 'Spectral',\n                                key_append = 'picubed_nobel_prize'\n                            }\n                            G.GAME.consumeable_buffer = 0\n                            return true\n                        end)\n                    }))\n                    card_eval_status_text(card, 'extra', nil, nil, nil, {message = localize(\"k_plus_spectral\"), colour = G.C.SECONDARY_SET.Spectral})\n\t\t\t\t\tG.E_MANAGER:add_event(Event({\n                    func = function()\n                        play_sound('tarot1')\n                        card.T.r = -0.2\n                        card:juice_up(0.3, 0.4)\n                        card.states.drag.is = true\n                        card.children.center.pinch.x = true\n                        G.E_MANAGER:add_event(Event({\n                            trigger = 'after',\n                            delay = 0.3,\n                            blockable = false,\n                            func = function()\n                                card:remove()\n                                return true\n                            end\n                        }))\n                        return true\n                    end\n                }))\n                end\n            end\n        end\n\tend",
      "config": {
        "extra": {
          "count_max": 3,
          "count_current": 3
        }
      },
      "ability": {
        "extra": {
          "count_max": 3,
          "count_current": 3
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "onbeat2",
      "atlas": null,
      "pos": null,
      "raw": "key = \"onbeat2\",\n\tpath = \"onbeat2.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "offbeat",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 1,
        "y": 5
      },
      "raw": "--Off-beat\n\tkey = 'offbeat',\n\tloc_txt = {\n\t\tname = 'Off-beat',\n\t\ttext = {\n\t\t\t\"Retrigger the {C:attention}2nd{}\",\n\t\t\t\"and {C:attention}4th{} scoring card\",\n\t\t\t\"{s:0.8}After hand is played,\",\n\t\t\t\"{s:0.8}becomes {s:0.8,C:attention}On-beat{}\"\n\t\t}\n\t},\n\tpronouns = 'he_him',\n\trarity = 1,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 1, y = 5 },\n\tcost = 6,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tperishable_compat = true,\n\teternal_compat = true,\n\tin_pool = function(self, args) return false end,\n\tconfig = { extra = { repetitions = 1, odds = 50, secret_art = false } },\n\tloc_vars = function(self, info_queue, card)\n\t\tinfo_queue[#info_queue+1] = {key = \"onbeat_tooltip\", set = 'Other'}\n\t\treturn { vars = { card.ability.max_highlighted } }\n\tend,\n\tupdate = function(self, card, dt)\n\t\tif card.ability.extra.secret_art then\n\t\t\tcard.children.center:set_sprite_pos({ x = 1, y = 6 })\n\t\telse\n\t\t\tcard.children.center:set_sprite_pos({ x = 1, y = 5 })\n\t\tend\n\tend,\n\tcalculate = function(self, card, context)\n\t\tif context.cardarea == G.play and context.repetition and not context.repetition_only then \n\t\t\tlocal card_pos = 1\n\t\t\tfor i = 1, #context.scoring_hand do\n\t\t\t\tif context.scoring_hand[i] == context.other_card then\n\t\t\t\t\tcard_pos = i\n\t\t\t\tend\n\t\t\tend\n\t\t\tif card_pos % 2 ~= 1 then\n\t\t\t\treturn {\n\t\t\t\t\tmessage = localize('k_again_ex'),\n\t\t\t\t\trepetitions = card.ability.extra.repetitions,\n\t\t\t\t\tcard = card\n\t\t\t\t}\n\t\t\tend\n\t\tend\n\t\tif context.after and context.main_eval and not context.blueprint then\n\t\t\t\t\n\t\t\tG.E_MANAGER:add_event(Event({\n\t\t\t\tfunc = function()\n\t\t\t\t\t\tlocal da_odds = card.ability.extra.odds\n\t\t\t\t\t\tcard:set_ability(G.P_CENTERS[\"j_picubed_onbeat\"])\n\t\t\t\t\t\tcard:juice_up()\n\t\t\t\t\t\tcard.ability.extra.odds = da_odds\n\t\t\t\t\t\tif pseudorandom('offbeat'..G.GAME.round_resets.ante) < (G.GAME.probabilities.normal / card.ability.extra.odds) then\n\t\t\t\t\t\t\t\tcard.ability.extra.secret_art = true\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tcard.ability.extra.secret_art = false\n\t\t\t\t\t\tend\n\t\t\t\t\t\treturn true\n\t\t\t\tend\n\t\t\t}))\n\t\t\tif picubed_config.custom_sound_effects then\n\t\t\t\treturn {\n\t\t\t\t\tcard = card,\n\t\t\t\t\tmessage = localize(\"k_picubeds_swap\"),\n\t\t\t\t\tvolume = 0.5,\n\t\t\t\t\tpitch = 1,\n\t\t\t\t\tsound = \"picubed_onbeat2\"\n\t\t\t\t}\n\t\t\telse\n\t\t\t\treturn {\n\t\t\t\t\tcard = card,\n\t\t\t\t\tmessage = localize('k_picubeds_swap')\n\t\t\t\t}\n\t\t\tend\n\t\tend\n\tend",
      "config": {
        "extra": {
          "repetitions": 1,
          "odds": 50,
          "secret_art": false
        }
      },
      "ability": {
        "extra": {
          "repetitions": 1,
          "odds": 50,
          "secret_art": false
        }
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "offthehook",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 9,
        "y": 5
      },
      "raw": "--Off the Hook\n\tkey = 'offthehook',\n\tloc_txt = {\n\t\tname = 'Off the Hook',\n\t\ttext = {\n\t\t\t{\n\t\t\t\t\"After play, all {C:attention}unenhanced{}\",\n\t\t\t\t\"cards held in hand\",\n\t\t\t\t\"are {C:attention}discarded{}\",\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"Gain {C:chips}+#1#{} Hands\",\n\t\t\t\t\"when {C:attention}Blind{} is selected\"\n\t\t\t}\n\t\t}\n\t},\n\tpronouns = 'she_her',\n\trarity = 2,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 9, y = 5 },\n\tcost = 5,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tperishable_compat = true,\n\teternal_compat = true,\n\tconfig = { extra = { h_plays = 2 } },\n\tloc_vars = function(self, info_queue, card)\n\t\t\treturn { vars = { card.ability.extra.h_plays } }\n\tend,\n\tcalculate = function(self, card, context)\n\t\tif context.setting_blind then\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    ease_hands_played(card.ability.extra.h_plays)\n                    SMODS.calculate_effect(\n                        { message = localize { type = 'variable', key = 'a_hands', vars = { card.ability.extra.h_plays } } },\n                        context.blueprint_card or card)\n                    return true\n                end\n            }))\n            return nil, true\n        end\n\t\tif context.press_play and not context.blueprint and not (G.GAME.blind.config.blind.key == (\"bl_hook\" or \"bl_cry_obsidian_orb\" or \"b_bunc_bulwark\")) then\n\t\t\tlocal saved_highlight = G.hand.config.highlighted_limit\n\t\t\tG.hand.config.highlighted_limit = 31415\n\t\t\tG.E_MANAGER:add_event(Event({ func = function()\n                local num_discard_cards = 0\n\t\t\t\tfor k, v in ipairs(G.hand.cards) do\n                    if v.config.center == G.P_CENTERS.c_base then\n                        G.hand:add_to_highlighted(v, true)\n                        any_selected = true\n\t\t\t\t\t\tnum_discard_cards = num_discard_cards + 1\n                    end\n                end\n\t\t\t\tif num_discard_cards >= 12 then\n\t\t\t\t\tcheck_for_unlock({type = 'picubed_discard12_dontgetcookedstay'})\n\t\t\t\tend\n                if any_selected then G.FUNCS.discard_cards_from_highlighted(nil, true) end\n\t\t\treturn true end }))\n\t\t\tG.E_MANAGER:add_event(Event({ func = function() \n                G.hand.config.highlighted_limit = saved_highlight \n                play_sound('card1', 1)\n\t\t\treturn true end }))\n\t\t\treturn {\n                message = localize(\"k_picubeds_offthehook\"),\n                card = card,\n\t\t\t}\n\t\telseif context.before and not context.blueprint and (G.GAME.blind.config.blind.key == (\"bl_hook\" or \"b_cry_obsidian_orb\" or \"b_bunc_bulwark\")) then\n\t\t\tlocal saved_highlight = G.hand.config.highlighted_limit\n\t\t\tG.hand.config.highlighted_limit = 31415\n\t\t\tG.E_MANAGER:add_event(Event({ func = function()\n                for k, v in ipairs(G.hand.cards) do\n                    if v.config.center == G.P_CENTERS.c_base then\n                        G.hand:add_to_highlighted(v, true)\n                        any_selected = true\n                    end\n                end\n                if any_selected then G.FUNCS.discard_cards_from_highlighted(nil, true) end\n\t\t\treturn true end }))\n\t\t\tG.E_MANAGER:add_event(Event({ func = function() \n                G.hand.config.highlighted_limit = saved_highlight \n                play_sound('card1', 1)\n\t\t\treturn true end }))\n\t\t\treturn {\n                message = localize(\"k_picubeds_offthehook\"),\n                card = card,\n\t\t\t}\n\t\tend\n\tend",
      "config": {
        "extra": {
          "h_plays": 2
        }
      },
      "ability": {
        "extra": {
          "h_plays": 2
        }
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "onbeat1",
      "atlas": null,
      "pos": null,
      "raw": "key = \"onbeat1\",\n\tpath = \"onbeat1.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "onbeat",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 0,
        "y": 5
      },
      "raw": "--On-beat\n\tkey = 'onbeat',\n\tloc_txt = {\n\t\tname = 'On-beat',\n\t\ttext = {\n\t\t\t\"Retrigger the {C:attention}1st{}, {C:attention}3rd{},\",\n\t\t\t\"and {C:attention}5th{} scoring card\",\n\t\t\t\"{s:0.8}After hand is played,\",\n\t\t\t\"{s:0.8}becomes {s:0.8,C:attention}Off-beat{}\"\n\t\t}\n\t},\n\tpronouns = 'he_him',\n\trarity = 1,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 0, y = 5 },\n\tcost = 6,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tperishable_compat = true,\n\teternal_compat = true,\n\tconfig = { extra = { repetitions = 1, odds = 50, secret_art = false } },\n\tloc_vars = function(self, info_queue, card)\n\t\tinfo_queue[#info_queue+1] = {key = \"offbeat_tooltip\", set = 'Other'}\n\t\treturn { vars = { card.ability.max_highlighted } }\n\tend,\n\tupdate = function(self, card, dt)\n\t\tif card.ability.extra.secret_art then\n\t\t\tcard.children.center:set_sprite_pos({ x = 0, y = 6 })\n\t\telse\n\t\t\tcard.children.center:set_sprite_pos({ x = 0, y = 5 })\n\t\tend\n\tend,\n\tcalculate = function(self, card, context)\n\t\tif context.cardarea == G.play and context.repetition and not context.repetition_only then \n\t\t\tlocal card_pos = 1\n\t\t\tfor i = 1, #context.scoring_hand do\n\t\t\t\tif context.scoring_hand[i] == context.other_card then\n\t\t\t\t\tcard_pos = i\n\t\t\t\tend\n\t\t\tend\n\t\t\tif card_pos % 2 == 1 then\n\t\t\t\treturn {\n\t\t\t\t\tmessage = localize('k_again_ex'),\n\t\t\t\t\trepetitions = card.ability.extra.repetitions,\n\t\t\t\t\tcard = card\n\t\t\t\t}\n\t\t\tend\n\t\tend\n\t\tif context.after and context.main_eval and not context.blueprint then\n\t\t\tG.E_MANAGER:add_event(Event({\n\t\t\t\tfunc = function()\n\t\t\t\t\t\tlocal da_odds = card.ability.extra.odds\n\t\t\t\t\t\tcard:set_ability(G.P_CENTERS[\"j_picubed_offbeat\"])\n\t\t\t\t\t\tcard:juice_up()\n\t\t\t\t\t\tcard.ability.extra.odds = da_odds\n\t\t\t\t\t\tif pseudorandom('offbeat'..G.GAME.round_resets.ante) < (G.GAME.probabilities.normal / card.ability.extra.odds) then\n\t\t\t\t\t\t\t\tcard.ability.extra.secret_art = true\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tcard.ability.extra.secret_art = false\n\t\t\t\t\t\tend\n\t\t\t\t\t\treturn true\n\t\t\t\tend\n\t\t\t}))\n\t\t\tif picubed_config.custom_sound_effects then\n\t\t\t\treturn {\n\t\t\t\t\tcard = card,\n\t\t\t\t\tmessage = localize(\"k_picubeds_swap\"),\n\t\t\t\t\tvolume = 0.5,\n\t\t\t\t\tpitch = 1,\n\t\t\t\t\tsound = \"picubed_onbeat1\"\n\t\t\t\t}\n\t\t\telse\n\t\t\t\treturn {\n\t\t\t\t\tcard = card,\n\t\t\t\t\tmessage = localize('k_picubeds_swap')\n\t\t\t\t}\n\t\t\tend\n\t\tend\n\tend",
      "config": {
        "extra": {
          "repetitions": 1,
          "odds": 50,
          "secret_art": false
        }
      },
      "ability": {
        "extra": {
          "repetitions": 1,
          "odds": 50,
          "secret_art": false
        }
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "oooshiny",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "--Ooo! Shiny!\n    key = 'oooshiny',\n    loc_txt = {\n        name = 'Ooo! Shiny!',\n        text = {\n            \"{C:dark_edition}Polychrome{} cards\",\n            \"give {C:money}$#1#{} when scored\"\n        }\n    },\n    pronouns = 'they_them',\n    config = { extra = { money = 7 } },\n    atlas = 'PiCubedsJokers',\n    pos = { x = 0, y = 1 },\n    cost = 7,\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = true,\n    perishable_compat = true,\n    eternal_compat = true,\n    in_pool = function(self, args)\n        for kk, vv in pairs(G.playing_cards or {}) do\n            if vv.edition then\n                if vv.edition.key == 'e_polychrome' then\n                    return true\n                end\n            end\n        end \n        for kk, vv in pairs(G.jokers.cards or {}) do\n            if vv.edition then\n                if vv.edition.key == 'e_polychrome' then\n                    return true\n                end\n            end\n        end\n        return false\n    end,\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue+1] = G.P_CENTERS.e_polychrome\n        return {\n            vars = { card.ability.extra.money, card.ability.max_highlighted }\n        }\n    end,\n    calculate = function(self, card, context)\n        if context.individual and context.cardarea == G.play then\n            if context.other_card.edition and context.other_card.edition.key == 'e_polychrome' \n            and (not context.other_card.debuff) then\n                return {\n                    dollars = card.ability.extra.money,\n                    card = card\n                }\n            end\n        end\n        if context.other_joker and context.other_joker.edition then\n            if context.other_joker.edition.key == 'e_polychrome'\n            and (not context.other_joker.debuff) then\n                return {\n                    dollars = card.ability.extra.money,\n                    card = card\n                }\n            end\n        end\n    end",
      "config": {
        "extra": {
          "money": 7
        }
      },
      "ability": {
        "extra": {
          "money": 7
        }
      },
      "vars": [
        7,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "otamatone",
      "atlas": null,
      "pos": null,
      "raw": "key = \"otamatone\",\n\tpath = \"otamatone.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "otamatone",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 4,
        "y": 11
      },
      "raw": "--Otamatone\n\tkey = 'otamatone',\n\tloc_txt = {\n\t\tname = 'Otamatone',\n\t\ttext = {\n\t\t\t\"\",\n\t\t}\n\t},\n    pronouns = 'they_them',\n\trarity = 1,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 4, y = 11 },\n\tcost = 4,\n\tdiscovered = true,\n\tblueprint_compat = true,\n    perishable_compat = true,\n\teternal_compat = true,\n\tconfig = { extra = { chips_min = 0, chips_max = 153 } },\n\tloc_vars = function(self, info_queue, card)\n        local r_chips = {}\n        for i = card.ability.extra.chips_min, card.ability.extra.chips_max do\n            r_chips[#r_chips + 1] = tostring(i)\n        end\n        local loc_chips = ' ' .. (localize('k_picubeds_chips')) .. ' '\n        main_start = {\n            { n = G.UIT.T, config = { text = '  +', colour = G.C.CHIPS, scale = 0.32 } },\n            { n = G.UIT.O, config = { object = DynaText({ string = r_chips, colours = { G.C.BLUE }, pop_in_rate = 9999999, silent = true, random_element = true, pop_delay = 0.5, scale = 0.32, min_cycle_time = 0 }) } },\n            {\n                n = G.UIT.O,\n                config = {\n                    object = DynaText({\n                        string = {\n                            { string = 'rand()', colour = G.C.JOKER_GREY }, { string = \"#@\" .. (G.deck and G.deck.cards[1] and G.deck.cards[#G.deck.cards].base.id or 11) .. (G.deck and G.deck.cards[1] and G.deck.cards[#G.deck.cards].base.suit:sub(1, 1) or 'D'), colour = G.C.BLUE },\n                            loc_chips, loc_chips, loc_chips, loc_chips, loc_chips, loc_chips, loc_chips, loc_chips, loc_chips,\n                            loc_chips, loc_chips, loc_chips, loc_chips },\n                        colours = { G.C.UI.TEXT_DARK },\n                        pop_in_rate = 9999999,\n                        silent = true,\n                        random_element = true,\n                        pop_delay = 0.2011,\n                        scale = 0.32,\n                        min_cycle_time = 0\n                    })\n                }\n            },\n        }\n        return { main_start = main_start }\n    end,\n\tcalculate = function(self, card, context)\n        if context.joker_main then\n            local rand_num = pseudorandom('picubed_otamatone', card.ability.extra.chips_min, card.ability.extra.chips_max)\n\t\t\trand_num = rand_num / card.ability.extra.chips_max\n            if picubed_config.custom_sound_effects then\n                return {\n                    chip_mod = rand_num * card.ability.extra.chips_max,\n                    sound = 'picubed_otamatone',\n                    volume = 0.75,\n                    pitch = 3 * rand_num,\n                    message = localize { type = 'variable', key = 'a_chips', vars = { rand_num * card.ability.extra.chips_max } },\n                }\n            else\n                return {\n                    chip_mod = rand_num * card.ability.extra.chips_max,\n                    message = localize { type = 'variable', key = 'a_chips', vars = { rand_num * card.ability.extra.chips_max } },\n                }\n            end\n        end\n\tend",
      "config": {
        "extra": {
          "chips_min": 0,
          "chips_max": 153
        }
      },
      "ability": {
        "extra": {
          "chips_min": 0,
          "chips_max": 153
        }
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "oxplow",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 8,
        "y": 5
      },
      "raw": "--Ox Plow\n\tkey = 'oxplow',\n\tloc_txt = {\n\t\tname = 'Ox Plow',\n\t\ttext = {\n\t\t\t\"Earn {C:money}$#1#{} if {C:attention}most played{}\",\n\t\t\t\"{C:attention}poker hand{} wasn't played\",\n\t\t\t\"by end of round\",\n\t\t\t\"{C:inactive}(Currently #2#){}\",\n\t\t}\n\t},\n\tpronouns = 'it_its',\n\trarity = 1,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 8, y = 5 },\n\tcost = 4,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tperishable_compat = true,\n\teternal_compat = true,\n\tconfig = { extra = { money = 7, most_played = false } },\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.money,\n\t\t\t\t\t\tlocalize { type = 'variable', key = ((card.ability.extra.most_played and 'k_picubeds_pot_inactive') or 'k_picubeds_pot_active'), vars = { card.ability.extra.most_played } },\n\t} }\n\tend,\n\tcalculate = function(self, card, context)\n\t\tif context.setting_blind then\n\t\t\tcard.ability.extra.most_played = false\n\t\tend\n\t\tif context.after then\n\t\t\tlocal is_most = true\n\t\t\tlocal play_more_than = (G.GAME.hands[context.scoring_name].played or 0)\n\t\t\tfor k, v in pairs(G.GAME.hands) do\n\t\t\t\tif k ~= context.scoring_name and v.played >= play_more_than and v.visible then\n\t\t\t\t\tis_most = false\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n\t\t\tif is_most then\n\t\t\t\tcard.ability.extra.most_played = true\n\t\t\tend\n\t\tend\n\tend,\n\tcalc_dollar_bonus = function(self, card)\n        return (not card.ability.extra.most_played) and card.ability.extra.money or nil\n    end",
      "config": {
        "extra": {
          "money": 7,
          "most_played": false
        }
      },
      "ability": {
        "extra": {
          "money": 7,
          "most_played": false
        }
      },
      "vars": [
        7,
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "panicfire",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 3,
        "y": 8
      },
      "raw": "--Panic Fire\n\tkey = 'panicfire',\n\tloc_txt = {\n\t\tname = 'Panic Fire',\n\t\ttext = {\n\t\t\t\"{X:mult,C:white}X#1#{} Mult for {C:attention}this round{}\",\n\t\t\t\"after #3# {C:inactive}[#4#]{} cards have\",\n\t\t\t\"been {C:attention}sold{} during {C:attention}Blind{}\",\n\t\t\t\"{C:inactive}(Currently #2#){}\",\n\t\t}\n\t},\n\tpronouns = 'she_they',\n\trarity = 2,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 3, y = 8 },\n\tsoul_pos = { x = 4, y = 8 },\n\tcost = 6,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tperishable_compat = true,\n\teternal_compat = true,\n\tconfig = { extra = { Xmult = 3, is_active = false, count_max = 3, count_current = 3 } },\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { \n            card.ability.extra.Xmult, \n            localize { type = 'variable', key = ((card.ability.extra.is_active and 'k_picubeds_pot_active') or 'k_picubeds_pot_inactive'), vars = { card.ability.extra.is_active } },\n\t\t\tcard.ability.extra.count_max,\n\t\t\tcard.ability.extra.count_current,\n\t\t} }\n\tend,\n\tcalculate = function(self, card, context)\n\t\tif context.setting_blind and card.ability.extra.count_current ~= card.ability.extra.count_max then \n\t\t\tcard.ability.extra.is_active = false\n\t\t\tcard.ability.extra.count_current = card.ability.extra.count_max\n\t\t\treturn {\n\t\t\t\tmessage = localize('k_reset'),\n\t\t\t\tcolour = G.C.RED\n\t\t\t}\n\t\tend\n\t\tif context.selling_card and not card.ability.extra.is_active and not context.blueprint and G.GAME.blind.in_blind and not context.retrigger_joker then\n\t\t\tcard.ability.extra.count_current = card.ability.extra.count_current - 1\n\t\t\tif card.ability.extra.count_current <= 0 then\n\t\t\t\tcard.ability.extra.is_active = true\n\t\t\t\treturn {\n\t\t\t\t\tcard = card,\n\t\t\t\t\tmessage = localize('k_picubeds_panicfire_ready')\n\t\t\t\t} \n\t\t\telse\n\t\t\t\treturn {\n\t\t\t\t\tcard = card,\n\t\t\t\t\tmessage = tostring(card.ability.extra.count_current)\n\t\t\t\t} \n\t\t\tend\n\t\tend\n\t\tif context.joker_main and card.ability.extra.is_active then\n\t\t\treturn {\n                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.Xmult } },\n                Xmult_mod = card.ability.extra.Xmult\n\t\t\t}\n\t\tend\n\tend",
      "config": {
        "extra": {
          "Xmult": 3,
          "is_active": false,
          "count_max": 3,
          "count_current": 3
        }
      },
      "ability": {
        "extra": {
          "Xmult": 3,
          "is_active": false,
          "count_max": 3,
          "count_current": 3
        }
      },
      "vars": [
        3,
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "peartree",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "--Pear Tree\n    key = 'peartree',\n    loc_txt = {\n        name = 'Pear Tree',\n        text = {\n            \"{C:mult}+#1#{} Mult if cards\",\n            \"{C:attention}held in hand{}\",\n            \"contain a {C:attention}Pair\"\n        }\n    },\n    pronouns = 'they_them',\n    rarity = 1,\n    atlas = 'PiCubedsJokers',\n    pos = { x = 2, y = 2 },\n    cost = 5,\n    discovered = true,\n    blueprint_compat = true,\n    perishable_compat = true,\n    eternal_compat = true,\n    config = { extra = { mult = 15 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.mult } }\n    end,\n    calculate = function(self, card, context)\n        if context.joker_main then\n            local rank_list = {0}\n            for i=1, #G.hand.cards do\n                for j=1, #rank_list do\n                    if i == 1 and not SMODS.has_no_rank(G.hand.cards[i]) then\n                        rank_list[i] = G.hand.cards[i]:get_id()\n                    elseif rank_list[1] ~= \"PAIR!\" and not SMODS.has_no_rank(G.hand.cards[i]) then\n                        --print(tostring(G.hand.cards[i].base.value)..\" \"..tostring(rank_list[j]))\n                        if tostring(G.hand.cards[i]:get_id()) == tostring(rank_list[j]) then\n                            rank_list[1] = \"PAIR!\"\n                            return {\n                                mult_mod = card.ability.extra.mult,\n                                message = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } }\n                            }\n                        else \n                            rank_list[i] = G.hand.cards[i]:get_id()\n                        end\n                    end\n                end\n            end\n        end        \n    end",
      "config": {
        "extra": {
          "mult": 15
        }
      },
      "ability": {
        "extra": {
          "mult": 15
        }
      },
      "vars": [
        15
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "perfectscore",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 1,
        "y": 4
      },
      "raw": "--Perfect Score\n    key = 'perfectscore',\n    loc_txt = {\n        name = 'Perfect Score',\n        text = {\n            \"{C:chips}+#1# {}Chips if scoring\",\n            \"hand contains a {C:attention}10{}\"\n        }\n    },\n    pronouns = 'they_them',\n    rarity = 1,\n    atlas = 'PiCubedsJokers',\n    pos = { x = 1, y = 4 },\n    cost = 5,\n    discovered = true,\n    blueprint_compat = true,\n    perishable_compat = true,\n    eternal_compat = true,\n    config = { extra = { chips = 100 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.chips } }\n    end,\n    calculate = function(self, card, context)\n        if context.joker_main then\n            local has_10 = false\n            for k, v in ipairs(context.scoring_hand) do\n                if v.base.value == '10' then\n                    has_10 = true\n                end\n            end\n            if has_10 then\n                return {\n                chip_mod = card.ability.extra.chips,\n                message = localize { type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }\n                }\n            end\n        end\n    end",
      "config": {
        "extra": {
          "chips": 100
        }
      },
      "ability": {
        "extra": {
          "chips": 100
        }
      },
      "vars": [
        100
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "pi",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 4,
        "y": 3
      },
      "raw": "--Pi\n\tkey = 'pi',\n\tloc_txt = {\n\t\tname = 'Pi',\n\t\ttext = {\n\t\t\t\"Cards with an {C:attention}edition{}\",\n\t\t\t\"have a {C:green}#2# in #3#{} chance to\",\n\t\t\t\"give {X:mult,C:white}X#1#{} Mult\",\n\t\t}\n\t},\n\tpronouns = 'it_its',\n\trarity = 4,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 4, y = 3 },\n\tsoul_pos = { x = 5, y = 3 },\n\tcost = 20,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tperishable_compat = true,\n\teternal_compat = true,\n\tconfig = { extra = { Xmult = 3.14, odds = 3 } },\n\tloc_vars = function(self, info_queue, card)\n\t\tlocal numerator, denominator = SMODS.get_probability_vars(card, 1, card.ability.extra.odds, 'picubed_pi')\n\t\treturn { vars = { \n\t\t\t\tlocalize { type = 'variable', key = ((card.ability.extra.Xmult == 3.14 and 'k_picubeds_pi') or card.ability.extra.Xmult), vars = { card.ability.extra.Xmult } },\n\t\t\t\tnumerator, denominator\n\t\t} }\n\tend,\n\tcalculate = function(self, card, context)\n\t\t\n\t\tif context.other_joker then\n\t\t\tif context.other_joker.edition and SMODS.pseudorandom_probability(card, 'picubed_pi', 1, card.ability.extra.odds) then\n\t\t\t\treturn {\n\t\t\t\t\tmessage = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.Xmult } },\n\t\t\t\t\tXmult_mod = card.ability.extra.Xmult,\n\t\t\t\t\tcard = context.other_joker,\n\t\t\t\t}\n\t\t\tend\n\t\t\n\t\telseif context.other_consumeable then\n\t\t\tif context.other_consumeable.edition and SMODS.pseudorandom_probability(card, 'picubed_pi', 1, card.ability.extra.odds) then\n\t\t\t\treturn {\n\t\t\t\t\tmessage = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.Xmult } },\n\t\t\t\t\tXmult_mod = card.ability.extra.Xmult,\n\t\t\t\t\tcard = context.other_consumeable, --does jack :(\n\t\t\t\t}\n\t\t\tend\n\t\t\n\t\telseif context.individual and context.cardarea == G.play then\n\t\t\tif context.other_card.edition and SMODS.pseudorandom_probability(card, 'picubed_pi', 1, card.ability.extra.odds) then\n\t\t\t\treturn {\n\t\t\t\t\tmessage = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.Xmult } },\n\t\t\t\t\tXmult_mod = card.ability.extra.Xmult,\n\t\t\t\t\tcard = context.other_card,\n\t\t\t\t}\n\t\t\tend\n\t\t\n\t\telseif context.individual and context.cardarea == G.hand and not context.end_of_round then\n\t\t\tif context.other_card.edition and SMODS.pseudorandom_probability(card, 'picubed_pi', 1, card.ability.extra.odds) then\n\t\t\t\treturn {\n\t\t\t\t\tmessage = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.Xmult } },\n\t\t\t\t\tXmult_mod = card.ability.extra.Xmult,\n\t\t\t\t\tcard = context.other_card,\n\t\t\t\t}\n\t\t\tend\n\t\tend\n\t\t\n\tend",
      "config": {
        "extra": {
          "Xmult": 3.14,
          "odds": 3
        }
      },
      "ability": {
        "extra": {
          "Xmult": 3.14,
          "odds": 3
        }
      },
      "vars": [
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "polyrhythm",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 2,
        "y": 5
      },
      "raw": "--Polyrhythm\n\tkey = 'polyrhythm',\n\tloc_txt = {\n\t\tname = 'Polyrhythm',\n\t\ttext = {\n\t\t\t{\n\t\t\t\t\"Receive {C:money}$#1#{} every\",\n\t\t\t\t\"{C:attention}#2#{} {C:inactive}[#4#]{} hands played\",\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"Create a {C:tarot}Tarot{} card\",\n\t\t\t\t\"every {C:attention}#3#{} {C:inactive}[#5#]{} discards\",\n\t\t\t\t\"{C:inactive}(Must have room){}\"\n\t\t\t}\n\t\t}\n\t},\n\tpronouns = 'she_they',\n\trarity = 1,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 2, y = 5 },\n\tcost = 5,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tperishable_compat = true,\n\teternal_compat = true,\n\tconfig = { extra = { money = 3, money_req = 3, tarot_req = 4, money_count = 3, tarot_count = 4 } },\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.money, card.ability.extra.money_req, card.ability.extra.tarot_req,card.ability.extra.money_count, card.ability.extra.tarot_count } }\n\tend,\n\tcalculate = function(self, card, context)\n\t\tif context.joker_main and not context.blueprint and not context.retrigger_joker then\n\t\t\tcard.ability.extra.money_count = card.ability.extra.money_count - 1\n\t\t\tif card.ability.extra.money_count > 0 then\n\t\t\t\treturn {\n\t\t\t\t\tcard = card,\n\t\t\t\t\tmessage = tostring(card.ability.extra.money_count),\n\t\t\t\t\tcolour = G.C.MONEY\n\t\t\t\t}\n\t\t\tend\n\t\tend\n\t\tif context.joker_main and card.ability.extra.money_count <= 0 then\n\t\t\tcard.ability.extra.money_count = card.ability.extra.money_req\n\t\t\treturn {\n                colour = G.C.MONEY,\n                dollars = card.ability.extra.money,\n                card = card\n\t\t\t}\n\t\tend\n\t\tif context.pre_discard and not context.blueprint and not context.retrigger_joker then\n\t\t\tcard.ability.extra.tarot_count = card.ability.extra.tarot_count - 1\n\t\t\tif card.ability.extra.tarot_count > 0 then\n\t\t\t\treturn {\n\t\t\t\t\tcolour = G.C.PURPLE,\n\t\t\t\t\tcard = card,\n\t\t\t\t\tmessage = tostring(card.ability.extra.tarot_count)\n\t\t\t\t}\n\t\t\tend\n\t\tend\n\t\tif context.pre_discard and card.ability.extra.tarot_count <= 0 then\n\t\t\tcard.ability.extra.tarot_count = card.ability.extra.tarot_req\n\t\t\tif #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then\n\t\t\t\tG.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1\n\t\t\t\tG.E_MANAGER:add_event(Event({\n                    func = (function()\n                        G.E_MANAGER:add_event(Event({\n                            func = function()\n                                    SMODS.add_card {\n                                            set = 'Tarot',\n                                    }\n                                    G.GAME.consumeable_buffer = 0\n                                    return true\n                            end\n                        }))\n                        SMODS.calculate_effect({ message = localize('k_plus_tarot'), colour = G.C.PURPLE },\n                            context.blueprint_card or card)\n                        return true\n                    end)\n\t\t\t\t}))\n\t\t\tend\n\t\tend\n\tend",
      "config": {
        "extra": {
          "money": 3,
          "money_req": 3,
          "tarot_req": 4,
          "money_count": 3,
          "tarot_count": 4
        }
      },
      "ability": {
        "extra": {
          "money": 3,
          "money_req": 3,
          "tarot_req": 4,
          "money_count": 3,
          "tarot_count": 4
        }
      },
      "vars": [
        3,
        3,
        4,
        3,
        4
      ],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "pot1",
      "atlas": null,
      "pos": null,
      "raw": "key = \"pot1\",\n\tpath = \"pot1.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "pot2",
      "atlas": null,
      "pos": null,
      "raw": "key = \"pot2\",\n\tpath = \"pot2.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "pot",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 3,
        "y": 5
      },
      "raw": "--Pot\n\tkey = 'pot',\n\tloc_txt = {\n\t\tname = 'Pot',\n\t\ttext = {\n\t\t\t\"{C:green}#1# in #2#{} chance for {X:mult,C:white}X#3#{} Mult,\",\n\t\t\t\"gives a {C:attention}cue{} if this Joker\",\n\t\t\t\"will activate for played hand\",\n\t\t\t\"{C:inactive}Currently #4#{}\"\n\t\t}\n\t},\n\tpronouns = 'he_him',\n\trarity = 3,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 3, y = 5 },\n\tsoul_pos = { x = 7, y = 6 },\n\tcost = 8,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tperishable_compat = true,\n\teternal_compat = true,\n\tconfig = { extra = { odds = 3, Xmult = 4, is_active = false } },\n\tloc_vars = function(self, info_queue, card)\n\t\tlocal numerator, denominator = SMODS.get_probability_vars(card, 1, card.ability.extra.odds, 'picubed_pot')\n\t\treturn { \n\t\t\tvars = { \n\t\t\t\tnumerator, \n\t\t\t\tdenominator, \n\t\t\t\tcard.ability.extra.Xmult, \n\t\t\t\tlocalize { type = 'variable', key = ((card.ability.extra.is_active and 'k_picubeds_pot_active') or 'k_picubeds_pot_inactive'), vars = { card.ability.extra.is_active } } \n\t\t\t} \n\t\t}\n\tend,\n\tcalculate = function(self, card, context)\n\t\tif (context.first_hand_drawn or context.hand_drawn) and not context.blueprint and not context.retrigger_joker then\n\t\t\tif SMODS.pseudorandom_probability(card, 'picubed_pot', 1, card.ability.extra.odds) then\n\t\t\t\tcard.ability.extra.is_active = true\n\t\t\t\tlocal eval = function() return card.ability.extra.is_active and not G.RESET_JIGGLES end\n\t\t\t\tjuice_card_until(card, eval, true)\n\t\t\t\tif picubed_config.custom_sound_effects then\n\t\t\t\t\treturn {\n\t\t\t\t\t\tcard = card,\n\t\t\t\t\t\tmessage = localize('k_picubeds_pot_ready'),\n\t\t\t\t\t\tvolume = 0.5,\n\t\t\t\t\t\tpitch = 1,\n\t\t\t\t\t\tsound = \"picubed_pot1\"\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\treturn {\n\t\t\t\t\t\tcard = card,\n\t\t\t\t\t\tmessage = localize('k_picubeds_pot_active')\n\t\t\t\t\t}\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tif context.joker_main and card.ability.extra.is_active then\n\t\t\tif picubed_config.custom_sound_effects then\n\t\t\t\treturn {\n\t\t\t\t\tvolume = 0.4,\n\t\t\t\t\tsound = \"picubed_rhythm2\",\n\t\t\t\t\tmessage = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.Xmult } },\n\t\t\t\t\tXmult_mod = card.ability.extra.Xmult\n\t\t\t\t}\n\t\t\telse\n\t\t\t\treturn {\n\t\t\t\t\tmessage = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.Xmult } },\n\t\t\t\t\tXmult_mod = card.ability.extra.Xmult\n\t\t\t\t}\n\t\t\tend\n\t\tend\n\t\tif context.pre_discard and not context.blueprint and not context.hook and not context.retrigger_joker then\n\t\t\tif card.ability.extra.is_active then\n\t\t\t\tcard.ability.extra.is_active = false\n\t\t\t\tif picubed_config.custom_sound_effects then\n\t\t\t\t\treturn {\n\t\t\t\t\t\tvolume = 0.5,\n\t\t\t\t\t\tpitch = 1,\n\t\t\t\t\t\tsound = \"picubed_pot2\",\n\t\t\t\t\t\tmessage = localize(\"k_picubeds_pot_miss\"),\n\t\t\t\t\t\tcard = card\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\treturn {\n\t\t\t\t\t\tmessage = localize(\"k_picubeds_pot_miss\"),\n\t\t\t\t\t\tcard = card\n\t\t\t\t\t}\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tif context.after then\n\t\t\tcard.ability.extra.is_active = false\n\t\tend\n\tend",
      "config": {
        "extra": {
          "odds": 3,
          "Xmult": 4,
          "is_active": false
        }
      },
      "ability": {
        "extra": {
          "odds": 3,
          "Xmult": 4,
          "is_active": false
        }
      },
      "vars": [
        null,
        null,
        4,
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "preorderbonus",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 5,
        "y": 4
      },
      "raw": "--Preorder Bonus\n\tkey = 'preorderbonus',\n\tloc_txt = {\n\t\tname = 'Preorder Bonus',\n\t\ttext = {\n\t\t\t\"Booster Packs\",\n\t\t\t\"cost {C:attention}#1#% less{}\"\n\t\t}\n\t},\n\tpronouns = 'it_its',\n\trarity = 1,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 5, y = 4 },\n\tcost = 3,\n\tdiscovered = true,\n\tblueprint_compat = false,\n\tperishable_compat = true,\n\teternal_compat = true,\n\tconfig = { extra = { discount = 0.5 } },\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.discount * 100 } }\n\tend,\n\t--[[in_pool = function(self, args)\n\t\tif not G.GAME.challenge == 'ch_c_picubed_balalajokerpoker' then return true end\n\tend,]]\n\tadd_to_deck = function(self, card, from_debuff)\n\t\tG.E_MANAGER:add_event(Event({func = function()\n\t\t\tfor k, v in pairs(G.I.CARD) do\n\t\t\t\t\tif v.set_cost then v:set_cost() end\n\t\t\tend\n\t\treturn true end }))\n\tend,\n\tremove_from_deck = function(self, card, from_debuff)\n\t\tG.E_MANAGER:add_event(Event({func = function()\n\t\t\tfor k, v in pairs(G.I.CARD) do\n\t\t\t\t\tif v.set_cost then v:set_cost() end\n\t\t\tend\n\t\treturn true end }))\n\tend",
      "config": {
        "extra": {
          "discount": 0.5
        }
      },
      "ability": {
        "extra": {
          "discount": 0.5
        }
      },
      "vars": [
        50
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "prime7",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 7,
        "y": 0
      },
      "raw": "--Prime 7\n    key = 'prime7',\n    loc_txt = {\n        name = \"Prime 7\",\n        text = {\n            \"If hand is a single {C:attention}7{},\",\n            \"it becomes {C:dark_edition}Negative{}\"\n        }\n    },\n    pronouns = 'she_her',\n    rarity = 3,\n    atlas = 'PiCubedsJokers',\n    pos = { x = 7, y = 0 },\n    soul_pos = { x = 3, y = 3},\n    cost = 7,\n    discovered = true,\n    blueprint_compat = false,\n    perishable_compat = true,\n    eternal_compat = true,\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue+1] = {key = 'e_negative_playing_card', set = 'Edition', config = {extra = G.P_CENTERS['e_negative'].config.card_limit} }\n        return {\n            vars = { card.ability.max_highlighted }\n        }\n    end,\n    \n    calculate = function(self, card, context)\n        if not context.blueprint and context.before then \n            if #context.full_hand == 1 then\n                for k, v in ipairs(context.scoring_hand) do\n                    if not v.debuff and v.base.value == '7' then \n                        v:set_edition('e_negative', false, true)\n                        G.E_MANAGER:add_event(Event({\n                            func = function()\n                                v:juice_up()\n                                return true\n                            end\n                        }))\n                        return {\n                            colour = G.C.PURPLE,\n                            message = localize(\"k_picubeds_prime\"),\n                            card = card\n                        }\n                    end\n                end\n            end\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "psychicspirit",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 2,
        "y": 9
      },
      "raw": "--Psychic Spirit\n\tkey = 'psychicspirit',\n\tloc_txt = {\n\t\tname = 'Psychic Spirit',\n\t\ttext = {\n\t\t\t\"{C:chips}+#1#{} Hands after Blind is selected,\",\n            \"decreases by {C:mult}#2#{} if played hand\",\n            \"does not contain {C:attention}#3#{} cards\",\n\t\t}\n\t},\n    pronouns = 'it_its',\n\tconfig = { extra = { hands = 2, hands_mod = 1, req_cards = 5 } },\n\trarity = 1,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 2, y = 9 },\n\tcost = 4,\n\tdiscovered = true,\n\tblueprint_compat = true,\n    perishable_compat = true,\n\teternal_compat = false,\n    pools = { [\"Food\"] = true },\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.hands, card.ability.extra.hands_mod, card.ability.extra.req_cards } \n\t\t}\n\tend,\n\tcalculate = function(self, card, context)\n        if context.before and context.main_eval and #context.full_hand < card.ability.extra.req_cards and not context.blueprint and not context.retrigger_joker then\n            card.ability.extra.hands = card.ability.extra.hands - card.ability.extra.hands_mod\n            if card.ability.extra.hands <= 0 then\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        play_sound('tarot1')\n                        card.T.r = -0.2\n                        card:juice_up(0.3, 0.4)\n                        card.states.drag.is = true\n                        card.children.center.pinch.x = true\n                        G.E_MANAGER:add_event(Event({\n                            trigger = 'after',\n                            delay = 0.3,\n                            blockable = false,\n                            func = function()\n                                card:remove()\n                                return true\n                            end\n                        }))\n                        return true\n                    end\n                }))\n                return {\n                    message = localize('k_drank_ex'),\n                    colour = G.C.FILTER\n                }\n            else\n                return {\n                    message = card.ability.extra.hands..\"\",\n                    colour = G.C.FILTER\n                }\n            end \n        end\n        if context.setting_blind then\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    ease_hands_played(card.ability.extra.hands)\n                    SMODS.calculate_effect(\n                        { message = localize { type = 'variable', key = 'a_hands', vars = { card.ability.extra.hands } } },\n                        context.blueprint_card or card)\n                    return true\n                end\n            }))\n            return true\n        end\n        \n\tend",
      "config": {
        "extra": {
          "hands": 2,
          "hands_mod": 1,
          "req_cards": 5
        }
      },
      "ability": {
        "extra": {
          "hands": 2,
          "hands_mod": 1,
          "req_cards": 5
        }
      },
      "vars": [
        2,
        1,
        5
      ],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "rhythm1",
      "atlas": null,
      "pos": null,
      "raw": "key = \"rhythm1\",\n\tpath = \"rhythm1.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "rhythmicjoker",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 3,
        "y": 4
      },
      "raw": "--Rhythmic Joker\n    key = 'rhythmicjoker',\n    loc_txt = {\n        name = 'Rhythmic Joker',\n        text = {\n            \"{C:mult}+#1#{} Mult if Hands\",\n            \"remaining is {C:attention}even\"\n        }\n    },\n    pronouns = 'he_him',\n    rarity = 1,\n    atlas = 'PiCubedsJokers',\n    pos = { x = 3, y = 4 },\n    cost = 5,\n    discovered = true,\n    blueprint_compat = true,\n    perishable_compat = true,\n    eternal_compat = true,\n    config = { extra = { mult = 12 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.mult } }\n    end,\n    calculate = function(self, card, context)\n        if context.joker_main and G.GAME.current_round.hands_left % 2 == 0 then\n            if picubed_config.custom_sound_effects then\n                return {\n                    message = localize{type='variable',key='a_mult',vars={card.ability.extra.mult}},\n                    mult_mod = card.ability.extra.mult, \n                    colour = G.C.MULT,\n                    volume = 0.4,\n                    sound = \"picubed_rhythm2\"\n                }\n            elseif not context.retrigger_joker then\n                return {\n                    message = localize{type='variable',key='a_mult',vars={card.ability.extra.mult}},\n                    mult_mod = card.ability.extra.mult, \n                    colour = G.C.MULT,\n                }\n            end\n        end\n        if context.hand_drawn and G.GAME.current_round.hands_left % 2 ~= 0 and not context.retrigger_joker then\n            if picubed_config.custom_sound_effects then play_sound('picubed_rhythm1', 0.7, 0.7) end\n            card:juice_up()\n        end\n    end",
      "config": {
        "extra": {
          "mult": 12
        }
      },
      "ability": {
        "extra": {
          "mult": 12
        }
      },
      "vars": [
        12
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "roundabout",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 5,
        "y": 8
      },
      "raw": "--Round-a-bout\n\tkey = 'roundabout',\n\tloc_txt = {\n\t\tname = 'Round-a-bout',\n\t\ttext = {\n\t\t\t{\n\t\t\t\t\"Allows {C:attention}Straights{} to be made\",\n\t\t\t\t\"using {C:attention}Wrap-around Straights{}\",\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"This Joker gains {X:mult,C:white}X#1#{} Mult per\",\n\t\t\t\t\"played {C:attention}Wrap-around Straight{}\",\n\t\t\t\t\"{C:inactive}(Currently {X:mult,C:white}X#2#{C:inactive} Mult)\"\n\t\t\t}\n\t\t}\n\t},\n\tpronouns = 'she_her',\n\trarity = 2,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 5, y = 8 },\n\tcost = 6,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tperishable_compat = true,\n\teternal_compat = true,\n\tconfig = { extra = { mult = 1, mult_mod = 0.25 }},\n\tin_pool = function(self, args)\n\t\treturn can_do_pokerhand_changer_jokers()\n\tend,\n\tloc_vars = function(self, info_queue, card)\n\t\tinfo_queue[#info_queue + 1] = { key = \"wraparound\", set = \"Other\" }\n\t\treturn { \n\t\t\tvars = { card.ability.extra.mult_mod, card.ability.extra.mult } \n\t\t}\n\tend,\n\tcalculate = function(self, card, context)\n\t\tif not can_do_pokerhand_changer_jokers() then\n\t\t\tprint(\"Round-a-bout has limited functionality due to a mod conflict, or the 'Hand type-affecting Jokers' config option being disabled.\")\n\t\tend\n\t\tif context.evaluate_poker_hand and next(context.poker_hands['Straight']) then\n\t\t\tlocal has_low = false\n\t\t\tlocal has_high = false\n\t\t\tlocal has_flush = false\n\t\t\tif next(context.poker_hands['Straight Flush']) or next(context.poker_hands['Flush']) then\n\t\t\t\thas_flush = true\n\t\t\tend\n\t\t\tfor k, v in ipairs(context.scoring_hand) do\n\t\t\t\tif v:get_id() == 2 or v:get_id() == 3 then\n\t\t\t\t\thas_low = true\n\t\t\t\telseif v:get_id() == 12 or v:get_id() == 13 then\n\t\t\t\t\thas_high = true\n\t\t\t\tend\n\t\t\tend\n\t\t\tif has_low and has_high then\n\t\t\t\tif has_flush then\n\t\t\t\t\treturn {\n\t\t\t\t\t\t\treplace_display_name = \"Wrap-a-Straight Flush\",\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\treturn {\n\t\t\t\t\t\t\treplace_display_name = \"Wrap-around Straight\",\n\t\t\t\t\t}\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tif context.before and context.main_eval and not context.blueprint and next(context.poker_hands['Straight']) and not context.retrigger_joker then\n\t\t\tlocal has_low = false\n\t\t\tlocal has_high = false\n\t\t\tfor k, v in ipairs(context.scoring_hand) do\n\t\t\t\tif v:get_id() == 2 or v:get_id() == 3 then\n\t\t\t\t\thas_low = true\n\t\t\t\telseif v:get_id() == 12 or v:get_id() == 13 then\n\t\t\t\t\thas_high = true\n\t\t\t\tend\n\t\t\tend\n\t\t\tif has_low and has_high then\n\t\t\t\tcard.ability.extra.mult = card.ability.extra.mult + card.ability.extra.mult_mod\n\t\t\t\treturn {\n\t\t\t\t\tmessage = localize('k_upgrade_ex'),\n\t\t\t\t\tcolour = G.C.MULT,\n\t\t\t\t\tcard = card\n\t\t\t\t}\n\t\t\tend\n\t\tend\n\t\tif context.joker_main and next(context.poker_hands['Straight Flush']) then \n\t\t\tcheck_for_unlock({type = 'picubed_roundabout_wrapastraightflush'})\n\t\tend\n\t\tif context.joker_main and card.ability.extra.mult > 0 then\n\t\t\treturn {\n\t\t\t\t--message = localize{type='variable', key='a_mult', vars = {card.ability.extra.xmult} },\n\t\t\t\txmult = card.ability.extra.mult, \n\t\t\t\tcolour = G.C.MULT\n\t\t\t}\n\t\tend\n\tend",
      "config": {
        "extra": {
          "mult": 1,
          "mult_mod": 0.25
        }
      },
      "ability": {
        "extra": {
          "mult": 1,
          "mult_mod": 0.25
        }
      },
      "vars": [
        0.25,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "runnerup",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 9,
        "y": 0
      },
      "raw": "--Runner-up\n    key = 'runnerup',\n    loc_txt = {\n        name = 'Runner-up',\n        text = {\n            \"{X:mult,C:white}X#1#{} Mult on {C:attention}second{}\",\n            \"hand of round\"\n        }\n    },\n    pronouns = 'he_they',\n    config = { extra = { Xmult = 2 } },\n    atlas = 'PiCubedsJokers',\n    pos = { x = 9, y = 0 },\n    cost = 6,\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = true,\n    perishable_compat = true,\n    eternal_compat = true,\n    loc_vars = function(self, info_queue, card)\n        return {\n            vars = { card.ability.extra.Xmult }\n        }\n    end,\n    calculate = function(self, card, context)\n        if context.joker_main and G.GAME.current_round.hands_played == 1 then\n            return {\n                message = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.Xmult } },\n                Xmult_mod = card.ability.extra.Xmult\n            }\n        end\n    end",
      "config": {
        "extra": {
          "Xmult": 2
        }
      },
      "ability": {
        "extra": {
          "Xmult": 2
        }
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "rushedjoker",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 5,
        "y": 5
      },
      "raw": "--Rushed Joker\n\tkey = 'rushedjoker',\n\tloc_txt = {\n\t\tname = 'Rushed Joker',\n\t\ttext = {\n\t\t\t\"{C:attention}First{} card played\",\n\t\t\t\"gives {C:mult}+#1#{} Mult\",\n\t\t\t\"when scored\"\n\t\t}\n\t},\n\tpronouns = 'she_they',\n\trarity = 1,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 5, y = 5 },\n\tcost = 3,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tperishable_compat = true,\n\teternal_compat = true,\n\tconfig = { extra = { mult = 5 } },\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.mult } }\n\tend,\n\tcalculate = function(self, card, context)\n\t\tif context.individual and context.cardarea == G.play then\n\t\t\tif context.other_card == context.scoring_hand[1] and not context.other_card.debuff then\n\t\t\t\treturn {\n\t\t\t\t\tmult = card.ability.extra.mult,\n\t\t\t\t\tcard = card\n\t\t\t\t}\n\t\t\tend\n\t\tend\n\tend",
      "config": {
        "extra": {
          "mult": 5
        }
      },
      "ability": {
        "extra": {
          "mult": 5
        }
      },
      "vars": [
        5
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "satanist",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 8,
        "y": 9
      },
      "raw": "--Satanist\n\tkey = 'satanist',\n\tloc_txt = {\n\t\tname = 'Satanist',\n\t\ttext = {\n\t\t\t\"If played hand contains a {C:attention}6{}\", \n\t\t\t\"and a {C:attention}Three of a Kind{},\",\n            \"create a {C:attention}The Devil{} card\",\n            \"and a random {C:purple}Tarot{} card\",\n            \"{C:inactive}(Must have room)\"\n\t\t}\n\t},\n\tpronouns = 'she_they',\n\trarity = 1,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 8, y = 9 },\n\tcost = 5,\n\tdiscovered = true,\n\tblueprint_compat = true,\n    perishable_compat = true,\n\teternal_compat = true,\n\tloc_vars = function(self, info_queue, card)\n\t    info_queue[#info_queue + 1] = G.P_CENTERS.c_devil\n\t\treturn { vars = { card.ability.max_highlighted } }\n\tend,\n\tcalculate = function(self, card, context)\n        if context.joker_main and next(context.poker_hands[\"Three of a Kind\"]) and\n            #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then\n            local six_check = false\n            for i = 1, #context.full_hand do\n                if context.full_hand[i]:get_id() == 6 then\n                    six_check = true\n                    break\n                end\n            end\n            if six_check then\n                G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1\n                G.E_MANAGER:add_event(Event({\n                    func = (function()\n                        SMODS.add_card {\n                            key = 'c_devil',\n\t\t\t\t\t\t\tset = 'Tarot',\n                            key_append = 'picubed_satanist'\n                        }\n                        G.GAME.consumeable_buffer = 0\n                        return true\n                    end)\n                }))\n                card_eval_status_text(card, 'extra', nil, nil, nil, {message = localize(\"k_plus_tarot\"), colour = G.C.PURPLE})\n\t\t\t\tif #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then\n\t\t\t\t\tG.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1\n\t\t\t\t\tG.E_MANAGER:add_event(Event({\n\t\t\t\t\t\tfunc = (function()\n\t\t\t\t\t\t\tSMODS.add_card {\n\t\t\t\t\t\t\t\tset = 'Tarot',\n\t\t\t\t\t\t\t\tkey_append = 'picubed_satanist'\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tG.GAME.consumeable_buffer = 0\n\t\t\t\t\t\t\treturn true\n\t\t\t\t\t\tend)\n\t\t\t\t\t}))\n\t\t\t\t\tcard_eval_status_text(card, 'extra', nil, nil, nil, {message = localize(\"k_plus_tarot\"), colour = G.C.PURPLE})\n\t\t\t\tend\n            end\n        end\n\tend",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "shoppingtrolley",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "--Shopping Trolley\n    key = 'shoppingtrolley',\n    loc_txt = {\n        name = 'Shopping Trolley',\n        text = {\n            \"{C:green}#1# in #2#{} chance for\",\n            \"{C:attention}+#3#{} hand size\",\n            \"in {C:attention}Booster Packs\"\n        }\n    },\n    pronouns = 'she_they',\n    rarity = 2,\n    atlas = 'PiCubedsJokers',\n    pos = { x = 0, y = 2 },\n    cost = 4,\n    discovered = true,\n    blueprint_compat = false,\n    perishable_compat = true,\n    eternal_compat = true,\n    config = { extra = { odds = 4, hand_increase = 10, trolley_success = 0 } },\n    pools = { [\"Meme\"] = true },\n    loc_vars = function(self, info_queue, card)\n        local numerator, denominator = SMODS.get_probability_vars(card, 3, card.ability.extra.odds, 'picubed_shoppingtrolley')\n        return { vars = { numerator, denominator, card.ability.extra.hand_increase} }\n    end,\n    \n    calculate = function(self, card, context)\n        if context.open_booster and not context.blueprint then\n            if card.ability.extra.trolley_success == 1 then\n                card.ability.extra.trolley_success = 0\n                G.hand:change_size(-card.ability.extra.hand_increase)\n            end\n            if SMODS.pseudorandom_probability(card, 'picubed_shoppingtrolley', 3, card.ability.extra.odds) then\n                card.ability.extra.trolley_success = 1\n                G.hand:change_size(card.ability.extra.hand_increase)\n                card:juice_up()\n            end\n        elseif context.ending_shop or context.setting_blind then\n            if card.ability.extra.trolley_success == 1 then\n                card.ability.extra.trolley_success = 0\n                G.hand:change_size(-card.ability.extra.hand_increase)\n            end\n        end\n    end,\n\n\tremove_from_deck = function(self, card, from_debuff)\n        if card.ability.extra.trolley_success == 1 then\n            G.hand:change_size(-card.ability.extra.hand_increase)\n        end\n    end",
      "config": {
        "extra": {
          "odds": 4,
          "hand_increase": 10,
          "trolley_success": 0
        }
      },
      "ability": {
        "extra": {
          "odds": 4,
          "hand_increase": 10,
          "trolley_success": 0
        }
      },
      "vars": [
        null,
        null,
        10
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "shrapnel",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 4,
        "y": 7
      },
      "raw": "--Shrapnel\n\tkey = 'shrapnel',\n\tloc_txt = {\n\t\tname = 'Shrapnel',\n\t\ttext = {\n\t\t\t\"When a {C:attention}Consumable card{} is\",\n\t\t\t\"used, all playing cards in hand\",\n\t\t\t\"receive a {C:attention}permanent{} {C:mult}+#1#{} Mult\",\n\t\t}\n\t},\n\tpronouns = 'it_its',\n\trarity = 2,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 4, y = 7 },\n\tcost = 6,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tperishable_compat = true,\n\teternal_compat = true,\n\tconfig = { extra = { mult = 2 } },\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.mult } }\n\tend,\n\tcalculate = function(self, card, context)\n\t\tif context.using_consumeable and G.hand.cards then\n\t\t\tfor k, v in ipairs(G.hand.cards) do\n\t\t\t\tv.ability.perma_mult = v.ability.perma_mult or 0 \n\t\t\t\tv.ability.perma_mult = v.ability.perma_mult + card.ability.extra.mult\n\t\t\t\tG.E_MANAGER:add_event(Event({\n\t\t\t\ttrigger = 'before',\n\t\t\t\tdelay = 0,\n\t\t\t\tfunc = (function()\n\t\t\t\t\tv:juice_up()\n\t\t\t\t\treturn true\n\t\t\t\tend)}))\n\t\t\tend\n\t\tend\n\tend",
      "config": {
        "extra": {
          "mult": 2
        }
      },
      "ability": {
        "extra": {
          "mult": 2
        }
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "siphon",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 4,
        "y": 2
      },
      "raw": "--Siphon\n    key = 'siphon',\n    loc_txt = {\n        name = 'Siphon',\n        text = {\n            \"This Joker gains {C:chips}+#1#{} Chips\",\n            \"when another Joker is {C:attention}sold\",\n            \"or {C:attention}destroyed{}\",\n            \"{C:inactive}(Currently {C:chips}+#2#{C:inactive} Chips)\"\n        }\n    },\n    pronouns = 'he_him',\n    rarity = 1,\n    atlas = 'PiCubedsJokers',\n    pos = { x = 4, y = 2 },\n    cost = 5,\n    discovered = true,\n    blueprint_compat = true,\n    perishable_compat = false,\n    eternal_compat = true,\n    config = { extra = { chips_mod = 8, chips = 0 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.chips_mod, card.ability.extra.chips } }\n    end,\n    calculate = function(self, card, context)\n        --[[if context.joker_type_destroyed and context.card.ability.set == 'Joker' and not context.blueprint then\n            print(\"hi\")\n            local num_destroy = 0\n            for k,v in ipairs(context.card) do\n                num_destroy = num_destroy + 1\n            end\n            if num_destroy > 0 then\n                card.ability.extra.chips = card.ability.extra.chips + card.ability.extra.chips_mod * num_destroy\n                return {\n                        selling_self = false,\n                        message = localize('k_upgrade_ex'),\n                        colour = G.C.CHIPS,\n                        card = card\n                    }\n            end\n        end]]\n        if not context.selling_self then\n            if context.selling_card and context.card.ability.set == 'Joker' and not context.blueprint and not context.retrigger_joker then\n                card.ability.extra.chips = card.ability.extra.chips + card.ability.extra.chips_mod\n                return {\n                    selling_self = false,\n                    message = localize('k_upgrade_ex'),\n                    colour = G.C.CHIPS,\n                    card = card\n                }\n            end\n        end\n        if context.joker_main then\n            return {\n                    chip_mod = card.ability.extra.chips,\n                    message = localize { type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }\n            }\n        end\n    end",
      "config": {
        "extra": {
          "chips_mod": 8,
          "chips": 0
        }
      },
      "ability": {
        "extra": {
          "chips_mod": 8,
          "chips": 0
        }
      },
      "vars": [
        8,
        0
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "snakeeyes",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "--Snake Eyes\n    key = 'snakeeyes',\n    loc_txt = {\n        name = 'Snake Eyes',\n        text = {\n            \"When this card is {C:attention}sold{}, Joker\",\n            \"to the {C:attention}left{} has its listed \",\n            \"{E:1,C:green}probabilities {C:attention}guaranteed\",\n            \"{C:inactive}(ex: {C:green}1 in 6 {C:inactive}-> {C:green}1 in 1{C:inactive})\"\n            \n        }\n    },\n    pronouns = 'he_him',\n    rarity = 2,\n    atlas = 'PiCubedsJokers',\n    pos = { x = 2, y = 1 },\n    cost = 6,\n    discovered = true,\n    blueprint_compat = false,\n    perishable_compat = true,\n    eternal_compat = false,\n    pools = { [\"Meme\"] = true },\n    calculate = function(self, card, context)\n        if #G.jokers.cards ~= 1 and not context.blueprint and context.selling_self then\n            local joker_left = joker_left or 0\n            for i=1, #G.jokers.cards do -- determining which joker is left of card\n                if G.jokers.cards[i] == card and i ~= 1 then\n                    joker_left = G.jokers.cards[i - 1]\n                end\n            end\n            \n            if joker_left ~= 0 and type(joker_left.ability.extra) == 'table' then\n                local odds_count = 0\n                if joker_left.config.center.key == 'j_cavendish' then\n                    check_for_unlock({type = 'picubed_snakeeyes_bananabreaker'})\n                end\n                for k, v in pairs(joker_left.ability.extra) do\n                    if string.match(k, \"odds\") then\n                        joker_left.ability.extra[k] = 1\n                        odds_count = 1\n                    end\n                end\n                if odds_count > 0 then\n                    return {\n                        message = localize(\"k_picubeds_snakeeyes\"),\n                        card = card\n                    }\n                end\n            elseif joker_left ~= 0 and type(joker_left.ability.extra) == 'number' then --this may cause funny shit to happen\n                joker_left.ability.extra = 1\n                return {\n                    message = localize(\"k_picubeds_snakeeyes\"),\n                    card = card\n                }\n            end\n        end\n    end",
      "config": {
        "type": "picubed_snakeeyes_bananabreaker"
      },
      "ability": {
        "type": "picubed_snakeeyes_bananabreaker"
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "spectraljoker",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 3,
        "y": 2
      },
      "raw": "--Spectral Joker\n    key = 'spectraljoker',\n    loc_txt = {\n        name = 'Spectral Joker',\n        text = {\n            \"After {C:attention}Boss Blind{} is\",\n            \"defeated, create a\",\n            \"free {C:attention}Ethereal Tag{}\"\n        }\n    },\n    pronouns = 'he_they',\n    rarity = 3,\n    atlas = 'PiCubedsJokers',\n    pos = { x = 3, y = 2 },\n    cost = 8,\n    discovered = true,\n    blueprint_compat = true,\n    perishable_compat = true,\n    eternal_compat = true,\n    loc_vars = function(self, info_queue, card)\n            info_queue[#info_queue+1] = G.P_TAGS['tag_ethereal']\n        return {\n            vars = { card.ability.max_highlighted }\n        }\n    end,\n    \n    calculate = function(self, card, context)\n        if context.end_of_round and G.GAME.blind.boss and context.cardarea == G.jokers then\n            G.E_MANAGER:add_event(Event({\n                func = function()\n                    add_tag(Tag('tag_ethereal'))\n                    return true\n                end\n            }))\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "splatzone",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 6,
        "y": 9
      },
      "raw": "--Splat Zone\n\tkey = 'splatzone',\n\tloc_txt = {\n\t\tname = 'Splat Zone',\n\t\ttext = {\n\t\t\t\"{C:mult}+#1#{} Mult if all cards\", \n\t\t\t\"{C:attention}held in hand{} share\",\n            \"the {C:attention}same suit{}\",\n\t\t}\n\t},\n\tpronouns = 'they_them',\n\trarity = 1,\n    config = { extra = { mult = 20 } },\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 6, y = 9 },\n\tcost = 5,\n\tdiscovered = true,\n\tblueprint_compat = true,\n    perishable_compat = true,\n\teternal_compat = true,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.mult } }\n\tend,\n\tcalculate = function(self, card, context)\n \t\tif context.joker_main and #G.hand.cards > 0 then\n\t\t\tlocal all_same_suit = false\n\t\t\tlocal suit_list = {}\n            for k, v in pairs(SMODS.Suits) do\n                suit_list[k] = 0\n            end\n\t\t\tfor k, v in ipairs(G.hand.cards) do\n\t\t\t\tfor kk, vv in pairs(suit_list) do\n\t\t\t\t\tif v:is_suit(kk, true) then \n\t\t\t\t\t\tsuit_list[kk] = suit_list[kk] + 1\n\t\t\t\t\tend \n\t\t\t\tend\n            end\n\t\t\tfor kk, vv in pairs(suit_list) do\n                if suit_list[kk] == #G.hand.cards then \n                    all_same_suit = true\n\t\t\t\t\tbreak\n                end \n            end \n            if all_same_suit then\n                return {\n                    mult = card.ability.extra.mult\n                }\n            end\n        end\n\tend",
      "config": {
        "extra": {
          "mult": 20
        }
      },
      "ability": {
        "extra": {
          "mult": 20
        }
      },
      "vars": [
        20
      ],
      "infoQueue": []
    },
    {
      "type": "Suits",
      "key": "sprinkler",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 3,
        "y": 9
      },
      "raw": "--Sprinkler\n\tkey = 'sprinkler',\n\tloc_txt = {\n\t\tname = 'Sprinkler',\n\t\ttext = {\n\t\t\t\"On {C:attention}Discard{}, give #1# held\", \n            \"card your full deck's\",\n            \"{C:attention}most common suit{}\",\n            \"{C:inactive}(Currently {V:1}#2#{}{C:inactive}){}\",\n\t\t}\n\t},\n    pronouns = 'she_they',\n\tconfig = { extra = { num_card = 1 } },\n\trarity = 1,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 3, y = 9 },\n\tcost = 4,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tloc_vars = function(self, info_queue, card)\n        reset_sprinker_card()\n        local suit = G.GAME.current_round.sprinkler_card or 'Clubs'\n\t\treturn { vars = { card.ability.extra.num_card, localize(suit, 'suits_plural'), colours = { G.C.SUITS[suit] } } \n\t\t}\n\tend,\n\tcalculate = function(self, card, context)\n        if not context.blueprint then\n            reset_sprinker_card()\n        end\n        if context.pre_discard then\n            local highest_suit = G.GAME.current_round.sprinkler_card\n            if #G.hand.cards > 0 then\n                local card_list = {}\n                local card_hit = nil\n                for i=1, #G.hand.cards do\n                    if not SMODS.has_no_suit(G.hand.cards[i]) then\n                        card_list[i] = G.hand.cards[i]\n                    end\n                end\n                card_hit = pseudorandom_element(card_list, pseudoseed('Sprinkler'..G.GAME.round_resets.ante))\n                if card_hit then\n                    G.E_MANAGER:add_event(Event({func = function()\n                        card_hit:change_suit(highest_suit)\n                        card_hit:juice_up()\n                        card:juice_up()\n                        card_hit:juice_up()\n                        return true \n                    end }))\n                    return {\n                        message = localize('k_picubeds_splat'),\n                        colour = G.C.SUITS[highest_suit]\n                    }\n                end\n            end\n        end\n\tend",
      "config": {
        "extra": {
          "num_card": 1
        }
      },
      "ability": {
        "extra": {
          "num_card": 1
        }
      },
      "vars": [
        1,
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "stonemason",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "--Stonemason\n    key = 'stonemason',     \n    loc_txt = {\n        name = 'Stonemason',\n        text = {\n            {\n                \"{C:attention}Stone{} cards permanently\",\n                \"gain {X:mult,C:white}X#1#{} Mult when scored\",\n            },\n            {\n                \"Stone cards have a {C:green}#2# in #3#{} chance\",\n                \"to be {C:attention}destroyed{} after scoring\"\n            }\n        }\n    },\n    pronouns = 'she_they',\n    config = { extra = { Xmult_bonus = 0.25, odds = 6 } },\n    rarity = 2,\n    atlas = 'PiCubedsJokers',\n    pos = { x = 1, y = 1 },\n    cost = 8,\n    discovered = true,\n    blueprint_compat = true,\n    perishable_compat = true,\n    eternal_compat = true,\n    enhancement_gate = 'm_stone',\n    loc_vars = function(self, info_queue, card)\n        local numerator, denominator = SMODS.get_probability_vars(card, 1, card.ability.extra.odds, 'picubed_stonemason')\n        info_queue[#info_queue+1] = G.P_CENTERS.m_stone\n        return {\n            vars = { card.ability.extra.Xmult_bonus, numerator, denominator, card.ability.max_highlighted }\n        }\n    end,\n    calculate = function(self, card, context)\n        if context.individual and context.cardarea == G.play then\n            if SMODS.has_enhancement(context.other_card, 'm_stone') then\n                context.other_card.ability.perma_x_mult = context.other_card.ability.perma_x_mult or 1 \n                context.other_card.ability.perma_x_mult = context.other_card.ability.perma_x_mult +         card.ability.extra.Xmult_bonus\n                return {\n                    message = localize(\"k_upgrade_ex\"),\n                    colour = G.C.MULT,\n                    card = card\n                }\n            end\n        end\n        if context.destroying_card and context.cardarea == G.play and not context.blueprint and not context.retrigger_joker then\n            if SMODS.has_enhancement(context.destroying_card, 'm_stone') then\n                if SMODS.pseudorandom_probability(card, 'picubed_stonemason', 1, card.ability.extra.odds) then\n                    return {\n                        remove = true\n                    }\n                end\n            end\n        end\n    end",
      "config": {
        "extra": {
          "Xmult_bonus": 0.25,
          "odds": 6
        }
      },
      "ability": {
        "extra": {
          "Xmult_bonus": 0.25,
          "odds": 6
        }
      },
      "vars": [
        0.25,
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "supergluttonousjoker",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 4,
        "y": 5
      },
      "raw": "--Super Gluttonous Joker\n\tkey = 'supergluttonousjoker',\n\tloc_txt = {\n\t\tname = 'Super Gluttonous Joker',\n\t\ttext = {\n\t\t\t\"When a {C:clubs}Club{} card is\",\n\t\t\t\"drawn to hand, draw an\",\n\t\t\t\"{C:attention}additional{} card to hand\"\n\t\t}\n\t},\n\tpronouns = 'he_they',\n\trarity = 3,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 4, y = 5 },\n\tcost = 9,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tperishable_compat = true,\n\teternal_compat = true,\n\tcalculate = function(self, card, context)\n\t\tif (context.first_hand_drawn or context.hand_drawn) then\n\t\t\tlocal club_count = 0\n\t\t\tfor k,v in ipairs(context.hand_drawn) do\n\t\t\t\tif v:is_suit(\"Clubs\") then\n\t\t\t\t\tclub_count = club_count + 1\n\t\t\t\tend\n\t\t\tend\n\t\t\tif club_count > 0 and #G.deck.cards > 0 then\n\t\t\t\tG.E_MANAGER:add_event(Event({\n\t\t\t\t\tfunc = function()\n\t\t\t\t\t\tG.FUNCS.draw_from_deck_to_hand(club_count)\n\t\t\t\treturn true end \n\t\t\t\t}))\t\n\t\t\t\treturn {\n\t\t\t\t\tmessage = localize(\"k_picubeds_club\"),\n\t\t\t\t\tcard = card,\n\t\t\t\t\tcolour = G.C.SUITS[\"Clubs\"]\n\t\t\t\t}\n\t\t\tend\n\t\tend\n\tend",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "supergreedyjoker",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 6,
        "y": 3
      },
      "raw": "--Super Greedy Joker\n\tkey = 'supergreedyjoker',\n\tloc_txt = {\n\t\tname = 'Super Greedy Joker',\n\t\ttext = {\n\t\t\t\"Create a random {C:attention}Editioned {}Joker\",\n\t\t\t\"when a {C:diamonds}Diamond {}card scores\",\n\t\t\t\"{C:inactive}(Must have room?)\"\n\t\t}\n\t},\n\tpronouns = 'they_them',\n\trarity = 3,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 6, y = 3 },\n\tcost = 9,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tperishable_compat = true,\n\teternal_compat = true,\n\tconfig = { extra = { num = 4, num_remaining = 4 } },\n\tcalculate = function(self, card, context)\n\t\tif context.end_of_round or context.before then\n\t\t\tpicubeds_supergreedyjoker_emptyslots = G.jokers.config.card_limit - #G.jokers.cards\n\t\tend\n\t\tif context.cardarea == G.play then\n\t\t\tif context.individual then\n\t\t\t\tif context.other_card:is_suit(\"Diamonds\") and #G.jokers.cards < G.jokers.config.card_limit and picubeds_supergreedyjoker_emptyslots > 0 then\n\t\t\t\t\tSMODS.calculate_effect({ message = localize('k_picubeds_diamond'), colour = G.C.SUITS[\"Diamonds\"] },\n\t\t\t\t\t\t\tcontext.blueprint_card or card)\n\t\t\t\t\tpicubeds_supergreedyjoker_emptyslots = picubeds_supergreedyjoker_emptyslots - 1\n\t\t\t\t\tG.E_MANAGER:add_event(Event({\n\t\t\t\t\t\tfunc = function()\n\t\t\t\t\t\t\thas_diamond = true\n\t\t\t\t\t\t\tlocal mpcard = create_card('Joker', G.jokers, nil, nil, nil, nil, nil, 'pri')\n\t\t\t\t\t\t\tlocal edition = poll_edition('edi'..G.GAME.round_resets.ante, 1, true, true)\n\t\t\t\t\t\t\tmpcard:set_edition(edition, false, true)\n\t\t\t\t\t\t\tmpcard:add_to_deck()\n\t\t\t\t\t\t\tG.jokers:emplace(mpcard)\n\t\t\t\t\t\t\tmpcard:start_materialize()\n\t\t\t\t\t\t\tcard:juice_up()\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\tend\n\t\t\t\t\t}))\n\t\t\t\t\t\n\t\t\t\telseif context.other_card:is_suit(\"Diamonds\") and pseudorandom('supergreedyjoker'..G.GAME.round_resets.ante) < 1/30 then \n\t\t\t\t\tSMODS.calculate_effect({ message = localize('k_picubeds_diamond'), colour = G.C.SUITS[\"Diamonds\"] },\n\t\t\t\t\t\t\tcontext.blueprint_card or card)\n\t\t\t\t\tG.E_MANAGER:add_event(Event({\n\t\t\t\t\t\tfunc = function()\n\t\t\t\t\t\t\tlocal mpcard = create_card('Joker', G.jokers, nil, nil, nil, nil, nil, 'pri')\n\t\t\t\t\t\t\tlocal edition = \"e_negative\"\n\t\t\t\t\t\t\tmpcard:set_edition(edition, false, true)\n\t\t\t\t\t\t\tmpcard:add_to_deck()\n\t\t\t\t\t\t\tG.jokers:emplace(mpcard)\n\t\t\t\t\t\t\tmpcard:start_materialize()\n\t\t\t\t\t\t\tcard:juice_up()\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\tend\n\t\t\t\t\t}))\n\t\t\t\t\treturn {\n                        message = localize(\"k_picubeds_diamond\"),\n                        card = card,\n                        colour = G.C.SUITS[\"Diamonds\"]\n\t\t\t\t\t}\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend",
      "config": {
        "extra": {
          "num": 4,
          "num_remaining": 4
        }
      },
      "ability": {
        "extra": {
          "num": 4,
          "num_remaining": 4
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "superlustyjoker",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 7,
        "y": 3
      },
      "raw": "--Super Lusty Joker\n\tkey = 'superlustyjoker',\n\tloc_txt = {\n\t\tname = 'Super Lusty Joker',\n\t\ttext = {\n\t\t\t\"{C:attention}Retrigger{} played {C:hearts}Heart{} cards,\",\n\t\t\t\"{C:green}#2# in #3#{} chance to retrigger\",\n\t\t\t\"them {C:attention}#1#{} additional time\",\n\t\t}\n\t},\n\tpronouns = 'she_they',\n\trarity = 3,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 7, y = 3 },\n\tcost = 9,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tperishable_compat = true,\n\teternal_compat = true,\n\tconfig = { extra = { repetitions = 1, odds = 2 } },\n\tloc_vars = function(self, info_queue, card)\n\t\tlocal numerator, denominator = SMODS.get_probability_vars(card, 1, card.ability.extra.odds, 'picubed_superlustyjoker')\n\t\treturn { vars = { card.ability.extra.repetitions, numerator, denominator } }\n\tend,\n\tcalculate = function(self, card, context)\n\t\tif context.cardarea == G.play and context.repetition and not context.repetition_only then\n\t\t\tlocal bonus_retrigger = 0\n\t\t\tif SMODS.pseudorandom_probability(card, 'picubed_superlustyjoker', 1, card.ability.extra.odds) then\n\t\t\t\tbonus_retrigger = 1\n\t\t\tend\n\t\t\tif context.other_card:is_suit(\"Hearts\") then\n\t\t\t\treturn {\n\t\t\t\t\tmessage = localize('k_again_ex'),\n\t\t\t\t\trepetitions = 1 + card.ability.extra.repetitions * bonus_retrigger,\n\t\t\t\t\tcard = card,\n\t\t\t\t\tcolour = G.C.SUITS[\"Hearts\"],\n\t\t\t\t}\n\t\t\tend\n\t\tend\n\tend",
      "config": {
        "extra": {
          "repetitions": 1,
          "odds": 2
        }
      },
      "ability": {
        "extra": {
          "repetitions": 1,
          "odds": 2
        }
      },
      "vars": [
        1,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "superwrathfuljoker",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 6,
        "y": 1
      },
      "raw": "--Super Wrathful Joker\n    key = 'superwrathfuljoker',\n    loc_txt = {\n        name = 'Super Wrathful Joker',\n        text = {\n            \"All played {C:spades}Spade{} cards\",\n            \"become {C:attention}Kings{} when scored\"\n        }\n    },\n    pronouns = 'he_him',\n    rarity = 3,\n    atlas = 'PiCubedsJokers',\n    pos = { x = 6, y = 1 },\n    cost = 9,\n    discovered = true,\n    blueprint_compat = false,\n    perishable_compat = true,\n    eternal_compat = true,\n    calculate = function(self, card, context)\n        if context.before and context.cardarea == G.jokers and not context.blueprint then\n            local has_spades = false\n            for k, v in ipairs(context.scoring_hand) do\n                if not v.debuff then\n                    if v:is_suit(\"Spades\") then\n                        has_spades = true\n                        v:juice_up()\n                        assert(SMODS.change_base(v, nil, 'King'))\n                    end\n                end\n            end\n            if has_spades then\n                has_spades = false\n                if G.GAME.blind.config.blind.key == (\"bl_pillar\") then\n                    for k, v in ipairs(context.scoring_hand) do\n                        v.debuff = false\n                    end\n                end\n                return {\n                    message = localize(\"k_picubeds_spade\"),\n                    card = card,\n                    colour = G.C.SUITS[\"Spades\"]\n                }\n            end\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "surgeon",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 4,
        "y": 10
      },
      "raw": "--Surgeon\n\tkey = 'surgeon',\n\tloc_txt = {\n\t\tname = 'Surgeon',\n\t\ttext = {\n\t\t\t\"This card gains {C:attention}+#1#{} Hand Size\", \n\t\t\t\"when a {C:attention}6{} is destroyed\",\n            \"{C:inactive}(Currently {C:attention}+#2#{C:inactive} Hand Size)\",\n\t\t}\n\t},\n\tpronouns = 'he_they',\n\trarity = 3,\n    config = { extra = { hand_increase = 0, hand_increase_mod = 1 } },\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 4, y = 10 },\n\tcost = 8,\n\tdiscovered = true,\n\tblueprint_compat = false,\n    perishable_compat = false,\n\teternal_compat = true,\n\tloc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.hand_increase_mod, card.ability.extra.hand_increase } }\n\tend,\n    remove_from_deck = function(self, card, from_debuff)\n        G.hand:change_size(-card.ability.extra.hand_increase)\n    end,\n\tcalculate = function(self, card, context)\n        if context.remove_playing_cards and not context.blueprint and not context.retrigger_joker then\n            local sixes = 0\n            for _, removed_card in ipairs(context.removed) do\n                if removed_card:get_id() == 6 then sixes = sixes + 1 end\n            end\n            if sixes > 0 then\n                card.ability.extra.hand_increase = card.ability.extra.hand_increase + sixes * card.ability.extra.hand_increase_mod\n\t\t\t\tG.hand:change_size(sixes * card.ability.extra.hand_increase_mod)\n                return { message = \"+\"..tostring(card.ability.extra.hand_increase), }\n            end\n        end\n\tend",
      "config": {
        "extra": {
          "hand_increase": 0,
          "hand_increase_mod": 1
        }
      },
      "ability": {
        "extra": {
          "hand_increase": 0,
          "hand_increase_mod": 1
        }
      },
      "vars": [
        1,
        0
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "switchingteams",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 8,
        "y": 10
      },
      "raw": "--Switching Teams\n\tkey = 'switchingteams',\n\tloc_txt = {\n\t\tname = 'Switching Teams',\n\t\ttext = {\n\t\t\t\"On Play, swap\", \n\t\t\t\"base {C:chips}Chips{} and {C:mult}Mult\",\n\t\t}\n\t},\n\trarity = 2,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 8, y = 10 },\n\tcost = 7,\n\tdiscovered = true,\n\tblueprint_compat = true,\n    perishable_compat = true,\n\teternal_compat = true,\n\tcalculate = function(self, card, context)\n        if context.before and context.main_eval then\n\t\t\tlocal old_chips = hand_chips\n\t\t\tlocal old_mult = mult\n\t\t\thand_chips = old_mult\n\t\t\tmult = old_chips\n\t\t\treturn {\n                message = localize('k_picubeds_swap'),\n                colour = G.C.TAROT,\n            }\n\t\tend\n\t\tif context.individual and context.cardarea == G.play and context.other_card:get_id() == 2 then\n            if SMODS.pseudorandom_probability(card, 'picubed_bigtwo', 1, card.ability.extra.odds) then\n                return {\n                    xmult = card.ability.extra.Xmult\n                }\n            end\n        end\n\tend",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "tableexpectedgotnil",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 7,
        "y": 10
      },
      "raw": "--Table Expected, got nil\n\tkey = 'tableexpectedgotnil',\n\tloc_txt = {\n\t\tname = 'Table Expected, got nil',\n\t\ttext = {\n\t\t\t\"{X:mult,C:white}X#1#{} Mult,\",\n            \"All played cards are\",\n            \"{C:attention}not scored{}\", \n\t\t}\n\t},\n\trarity = 2,\n    config = { extra = { Xmult = 3 } },\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 7, y = 10 },\n\tcost = 5,\n\tdiscovered = true,\n\tblueprint_compat = true,\n    perishable_compat = true,\n\teternal_compat = true,\n\tloc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.Xmult } }\n\tend,\n\tcalculate = function(self, card, context)\n        if context.modify_scoring_hand and not context.blueprint then\n            return {\n                add_to_hand = false\n            }\n        end\n\t\tif context.joker_main then\n            return {\n                xmult = card.ability.extra.Xmult\n            }\n        end\n\tend",
      "config": {
        "extra": {
          "Xmult": 3
        }
      },
      "ability": {
        "extra": {
          "Xmult": 3
        }
      },
      "vars": [
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "tf_bye1",
      "atlas": null,
      "pos": null,
      "raw": "key = \"tf_bye1\",\n\tpath = \"tf_bye1.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "tf_bye2",
      "atlas": null,
      "pos": null,
      "raw": "key = \"tf_bye2\",\n\tpath = \"tf_bye2.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "tf_bye3",
      "atlas": null,
      "pos": null,
      "raw": "key = \"tf_bye3\",\n\tpath = \"tf_bye3.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "tf_hi1",
      "atlas": null,
      "pos": null,
      "raw": "key = \"tf_hi1\",\n\tpath = \"tf_hi1.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "tf_hi2",
      "atlas": null,
      "pos": null,
      "raw": "key = \"tf_hi2\",\n\tpath = \"tf_hi2.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "tf_hi3",
      "atlas": null,
      "pos": null,
      "raw": "key = \"tf_hi3\",\n\tpath = \"tf_hi3.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "tf_hi4",
      "atlas": null,
      "pos": null,
      "raw": "key = \"tf_hi4\",\n\tpath = \"tf_hi4.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "tf_hi5",
      "atlas": null,
      "pos": null,
      "raw": "key = \"tf_hi5\",\n\tpath = \"tf_hi5.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "tf_onward",
      "atlas": null,
      "pos": null,
      "raw": "key = \"tf_onward\",\n\tpath = \"tf_onward.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "tf_shop_high1",
      "atlas": null,
      "pos": null,
      "raw": "key = \"tf_shop_high1\",\n\tpath = \"tf_shop_high1.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "tf_shop_high2",
      "atlas": null,
      "pos": null,
      "raw": "key = \"tf_shop_high2\",\n\tpath = \"tf_shop_high2.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "tf_shop_high3",
      "atlas": null,
      "pos": null,
      "raw": "key = \"tf_shop_high3\",\n\tpath = \"tf_shop_high3.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "tf_shop_low1",
      "atlas": null,
      "pos": null,
      "raw": "key = \"tf_shop_low1\",\n\tpath = \"tf_shop_low1.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "tf_shop_low2",
      "atlas": null,
      "pos": null,
      "raw": "key = \"tf_shop_low2\",\n\tpath = \"tf_shop_low2.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "tf_shop_low3",
      "atlas": null,
      "pos": null,
      "raw": "key = \"tf_shop_low3\",\n\tpath = \"tf_shop_low3.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "tf_wee1",
      "atlas": null,
      "pos": null,
      "raw": "key = \"tf_wee1\",\n\tpath = \"tf_wee1.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "tf_wee2",
      "atlas": null,
      "pos": null,
      "raw": "key = \"tf_wee2\",\n\tpath = \"tf_wee2.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "talkingflower",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 0,
        "y": 7
      },
      "raw": "--Talking Flower\n\tkey = 'talkingflower',\n\tloc_txt = {\n\t\tname = 'Talking Flower',\n\t\ttext = {\n\t\t\t\"{C:dark_edition}+#1#{} Joker Slot,\",\n\t\t\t\"{C:mult}+#2#{} Mult\"\n\t\t\t\n\t\t}\n\t},\n\tpronouns = 'he_they',\n\tconfig = { extra = { slots = 1, mult = 4 } },\n\trarity = 1,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 0, y = 7 },\n\tcost = 4,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tpools = { [\"Meme\"] = true },\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.slots, card.ability.extra.mult } }\n\tend,\n\tadd_to_deck = function(self, card, from_debuff)\n\t\tG.jokers.config.card_limit = G.jokers.config.card_limit + card.ability.extra.slots\n\t\tif G.GAME.round == 0 then\n\t\t\tcard:tf_say(\"tf_onward\")\n\t\t\t--print(\"Onward and Upward!\")\n\t\telse\n\t\t\tlocal tfnum = pseudorandom_element({1,2,3,4,5}, pseudoseed(\"talkingflower\"..G.GAME.round_resets.ante))\n\t\t\tcard:tf_say(\"tf_hi\"..tfnum)\n\t\t\t--print(\"Hiiii!\")\n\t\tend\n\tend,\n\tremove_from_deck = function(self, card, from_debuff)\n\t\tG.jokers.config.card_limit = G.jokers.config.card_limit - card.ability.extra.slots\n\t\tlocal tfnum = pseudorandom_element({1,2,3}, pseudoseed(\"talkingflower\"..G.GAME.round_resets.ante))\n\t\tcard:tf_say(\"tf_bye\"..tfnum)\n\t\t--print(\"Later!\")\n\tend,\n\t\n\tcalculate = function(self, card, context)\n\t\tif context.card_added then\n\t\t\tif context.card.ability.name == 'Wee Joker' or context.card.ability.name == 'j_picubed_weemini' then\n\t\t\t\tlocal tfnum = pseudorandom_element({1,2}, pseudoseed(\"talkingflower\"..G.GAME.round_resets.ante))\n\t\t\t\tcard:tf_say(\"tf_wee\"..tfnum)\n\t\t\t\t--print(\"Weeeee!\")\n\t\t\tend\n\t\tend\n\t\tif context.starting_shop then\n\t\t\tif to_number(G.GAME.dollars) >= 15 then\n\t\t\t\tlocal tfnum = pseudorandom_element({1,2,3}, pseudoseed(\"talkingflower\"..G.GAME.round_resets.ante))\n\t\t\t\tcard:tf_say(\"tf_shop_high\"..tfnum)\n\t\t\t\t--print(\"Why not take both?\")\n\t\t\telse\n\t\t\t\tlocal tfnum = pseudorandom_element({1,2,3}, pseudoseed(\"talkingflower\"..G.GAME.round_resets.ante))\n\t\t\t\tcard:tf_say(\"tf_shop_low\"..tfnum)\n\t\t\t\t--print(\"Tough choice...\")\n\t\t\tend\n\t\tend\n\t\tif context.joker_main then\n\t\t\treturn {\n\t\t\t\tmult = card.ability.extra.mult,\n\t\t\t\tcard = card\n\t\t\t}\n\t\tend\n\tend",
      "config": {
        "extra": {
          "slots": 1,
          "mult": 4
        }
      },
      "ability": {
        "extra": {
          "slots": 1,
          "mult": 4
        }
      },
      "vars": [
        1,
        4
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "thecube",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 5,
        "y": 10
      },
      "raw": "--The Cube\n\tkey = 'thecube',\n\tloc_txt = {\n\t\tname = 'The Cube',\n\t\ttext = {\n\t\t\t\"Scored {C:attention}numbered{} cards give\", \n\t\t\t\"{C:money}${} equal to their {C:attention}Rank{}\",\n            \"{s:0.8}Aces give {s:0.8,C:money}$11{}\",\n\t\t}\n\t},\n\tpronouns = 'it_its',\n\trarity = 4,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 5, y = 10 },\n    soul_pos = { x = 0, y = 12 },\n\tcost = 20,\n\tdiscovered = true,\n\tblueprint_compat = true,\n    perishable_compat = true,\n\teternal_compat = true,\n\tconfig = { extra = { spin_pos = 5 } },\n\tupdate = function(self, card, dt)\n\t\tif not G.SETTINGS.reduced_motion then\n\t\t\tif not card.ability.extra.spin_pos then card.ability.extra.spin_pos = 0 end\n\t\t\tcard.ability.extra.spin_pos = card.ability.extra.spin_pos + dt * 3\n\t\t\tif card.ability.extra.spin_pos >= 10 then card.ability.extra.spin_pos = 0 end\n\t\t\tlocal da_spin_pos = math.floor(card.ability.extra.spin_pos)\n\t\t\tcard.children.floating_sprite:set_sprite_pos({x = da_spin_pos, y = 12})\n\t\tend\n\tend,\n\tcalculate = function(self, card, context)\n        if context.individual and context.cardarea == G.play then\n        \tlocal card_money = 0\n\t\t\tlocal coc = context.other_card\n\t\t\tif not (SMODS.has_no_rank(coc) or coc:get_id() == 11 or coc:get_id() == 12 or coc:get_id() == 13) then\n\t\t\t\tcard_money = coc.base.nominal\n\t\t\t\tif card_money > 0 then\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdollars = card_money,\n\t\t\t\t\t\tfunc = function()\n\t\t\t\t\t\t\tG.E_MANAGER:add_event(Event({\n\t\t\t\t\t\t\t\tfunc = function()\n\t\t\t\t\t\t\t\t\tG.GAME.dollar_buffer = 0\n\t\t\t\t\t\t\t\t\treturn true\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t}))\n\t\t\t\t\t\tend\n\t\t\t\t\t}\n\t\t\t\tend\n\t\t\tend\n        end\n\tend",
      "config": {
        "extra": {
          "spin_pos": 5
        }
      },
      "ability": {
        "extra": {
          "spin_pos": 5
        }
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "timidjoker",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 3,
        "y": 6
      },
      "raw": "--Timid Joker\n\tkey = 'timidjoker',\n\tloc_txt = {\n\t\tname = 'Timid Joker',\n\t\ttext = {\n\t\t\t\"{C:mult}+#1#{} Mult if this Joker\",\n\t\t\t\"is the {C:attention}right-most{} Joker\"\n\t\t}\n\t},\n\tpronouns = 'they_them',\n\trarity = 1,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 3, y = 6 },\n\tdisplay_size = { w = 0.9 * 71, h = 0.9 * 95 },\n\tcost = 6,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tperishable_compat = true,\n\teternal_compat = true,\n\tconfig = { extra = { mult = 20 } },\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.mult } }\n\tend,\n\tupdate = function(self, card, dt)\n\t\tif G.jokers then\n\t\t\tif G.jokers.cards[#G.jokers.cards] == card then\n\t\t\t\tcard.children.center:set_sprite_pos({x = 4, y = 6})\n\t\t\telse\n\t\t\t\tcard.children.center:set_sprite_pos({x = 3, y = 6})\n\t\t\tend\n\t\telse\n\t\t\tcard.children.center:set_sprite_pos({x = 4, y = 6})\n\t\tend\n\tend,\n\tcalculate = function(self, card, context)\n\t\tif context.joker_main and G.jokers.cards[#G.jokers.cards] == card then\n\t\t\treturn {\n\t\t\t\tmessage = localize { type = 'variable', key = 'a_mult', vars = { card.ability.extra.mult } },\n\t\t\t\tmult_mod = card.ability.extra.mult\n\t\t\t}\n\t\tend\n\tend",
      "config": {
        "extra": {
          "mult": 20
        }
      },
      "ability": {
        "extra": {
          "mult": 20
        }
      },
      "vars": [
        20
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "tradein",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 8,
        "y": 2
      },
      "raw": "--Trade-in\n    key = 'tradein',\n    loc_txt = {\n        name = 'Trade-in',\n        text = {\n            \"Earn {C:money}$#1#{} when a\",\n            \"playing card is\",\n            \"{C:attention}destroyed\"\n        }\n    },\n    pronouns = 'it_its',\n    rarity = 2,\n    atlas = 'PiCubedsJokers',\n    pos = { x = 8, y = 2 },\n    cost = 6,\n    discovered = true,\n    blueprint_compat = true,\n    perishable_compat = true,\n    eternal_compat = true,\n    config = { extra = { money = 5 } },\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.money } }\n    end,\n    calculate = function(self, card, context)\n        if context.remove_playing_cards then\n            local num_destroy = 0\n            for k,v in ipairs(context.removed) do\n                num_destroy = num_destroy + 1\n            end\n            if num_destroy > 0 then\n                return {\n                        dollars = card.ability.extra.money*num_destroy,\n                        card = card\n                    }\n            end\n        end\n    end",
      "config": {
        "extra": {
          "money": 5
        }
      },
      "ability": {
        "extra": {
          "money": 5
        }
      },
      "vars": [
        5
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "translucentjoker",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 8,
        "y": 7
      },
      "raw": "--Translucent Joker\n\tkey = 'translucentjoker',\n\tloc_txt = {\n\t\tname = 'Translucent Joker',\n\t\ttext = {\n\t\t\t\"After {C:attention}#1#{} rounds,\",\n\t\t\t\"sell this card to\",\n\t\t\t\"create an {C:attention}Invisible Joker{}\",\n\t\t\t\"{C:inactive}(Currently {}{C:attention}#2#{}{C:inactive}/#1# rounds){}\",\n\t\t}\n\t},\n\tpronouns = 'it_its',\n\trarity = 2,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 8, y = 7 },\n\tcost = 7,\n\tdiscovered = true,\n\tblueprint_compat = false,\n\tperishable_compat = true,\n\teternal_compat = false,\n\tconfig = { extra = { rounds_total = 2, rounds = 0 } },\n\tloc_vars = function(self, info_queue, card)\n\t\tinfo_queue[#info_queue+1] = { key = \"invisiblejoker_tooltip\", set = \"Other\" }\n\t\treturn { vars = { card.ability.extra.rounds_total, card.ability.extra.rounds } }\n\tend,\n\tcalculate = function(self, card, context)\n\t\tif context.selling_self and (card.ability.extra.rounds >= card.ability.extra.rounds_total) and not context.blueprint then\n\t\t\tlocal mpcard = create_card('Joker', G.jokers, nil, 0, nil, nil, 'j_invisible', 'tra')\n\t\t\tmpcard:add_to_deck()\n\t\t\tG.jokers:emplace(mpcard)\n\t\t\tmpcard:start_materialize()\n\t\tend\n\t\tif context.end_of_round and context.game_over == false and context.main_eval and not context.blueprint and not context.retrigger_joker then\n            card.ability.extra.rounds = card.ability.extra.rounds + 1\n            if card.ability.extra.rounds == card.ability.extra.rounds_total then\n                local eval = function(card) return not card.REMOVED end\n                juice_card_until(card, eval, true)\n            end\n            return {\n                message = (card.ability.extra.rounds < card.ability.extra.rounds_total) and\n                    (card.ability.extra.rounds .. '/' .. card.ability.extra.rounds_total) or\n                    localize('k_active_ex'),\n                colour = G.C.FILTER\n            }\n\t\tend\n\t\t\n\tend",
      "config": {
        "extra": {
          "rounds_total": 2,
          "rounds": 0
        }
      },
      "ability": {
        "extra": {
          "rounds_total": 2,
          "rounds": 0
        }
      },
      "vars": [
        2,
        0
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "turfwar",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 1,
        "y": 10
      },
      "raw": "--Turf War\n\tkey = 'turfwar',\n\tloc_txt = {\n\t\tname = 'Turf War',\n\t\ttext = {\n\t\t\t\"Gains {X:mult,C:white}X#1#{} Mult for every\", \n\t\t\t\"{C:attention}#2#{} {V:1}#4#{} cards in {C:attention}full deck{}\",\n            \"when Boss Blind is defeated\",\n            \"{s:0.8,C:attention}Suit {}{s:0.8}changes afterwards too{}\",\n            \"{C:inactive}(Currently {X:mult,C:white}X#3#{}{C:inactive} Mult){}\",\n\t\t}\n\t},\n\tpronouns = 'she_her',\n\trarity = 2,\n    config = { extra = { Xmult = 1, Xmult_mod = 0.1, num_card = 2 } },\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 1, y = 10 },\n\tcost = 7,\n\tdiscovered = true,\n\tblueprint_compat = true,\n    perishable_compat = false,\n\teternal_compat = true,\n\tloc_vars = function(self, info_queue, card)\n\t\tlocal suit = (G.GAME.current_round.picubed_turfwar or {}).suit or 'Spades'\n\t\treturn { vars = { card.ability.extra.Xmult_mod, card.ability.extra.num_card, card.ability.extra.Xmult, localize(suit, 'suits_singular'), colours = { G.C.SUITS[suit] } } \n\t\t}\n\tend,\n\tcalculate = function(self, card, context)\n    \tif context.end_of_round and context.game_over == false and context.main_eval and not context.blueprint and not context.retrigger_joker then\n            if context.beat_boss then\n\t\t\t\tlocal suit_count = 0\n\t\t\t\tfor k,v in ipairs(G.playing_cards) do\n\t\t\t\t\tif v:is_suit(G.GAME.current_round.picubed_turfwar.suit) or (v.debuff and v.base.suit == G.GAME.current_round.picubed_turfwar.suit) then \n\t\t\t\t\t\tsuit_count = suit_count + 1\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tsuit_count = (math.floor(suit_count/card.ability.extra.num_card))*card.ability.extra.Xmult_mod\n\t\t\t\treset_picubed_turfwar()\n\t\t\t\tif suit_count > 0 then\n\t\t\t\t\tcard.ability.extra.Xmult = card.ability.extra.Xmult + suit_count\n\t\t\t\t\treturn {\n\t\t\t\t\t\tmessage = \"+X\"..tostring(suit_count),\n\t\t\t\t\t\tcolour = G.C.RED\n\t\t\t\t\t}\n\t\t\t\tend\n\t\t\tend\n\t\tend\n        if context.joker_main then\n            return {\n                xmult = card.ability.extra.Xmult\n            }\n        end\n\tend",
      "config": {
        "extra": {
          "Xmult": 1,
          "Xmult_mod": 0.1,
          "num_card": 2
        }
      },
      "ability": {
        "extra": {
          "Xmult": 1,
          "Xmult_mod": 0.1,
          "num_card": 2
        }
      },
      "vars": [
        0.1,
        2,
        1,
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "tyredumpyard",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 5,
        "y": 6
      },
      "raw": "--Tyre Dumpyard\n\tkey = 'tyredumpyard',\n\tloc_txt = {\n\t\tname = 'Tyre Dumpyard',\n\t\ttext = {\n\t\t\t\"When {C:attention}Boss Blind{} is selected,\",\n\t\t\t\"fill all Consumable slots\",\n\t\t\t\"with {C:attention}The Wheel of Fortune{}\",\n\t\t\t\"{C:inactive}(Must have room){}\"\n\t\t}\n\t},\n\tpronouns = 'it_its',\n\trarity = 1,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 5, y = 6 },\n\tcost = 5,\n\tdiscovered = true,\n\tblueprint_compat = false,\n\tperishable_compat = true,\n\teternal_compat = true,\n\tconfig = { extra = { mult = 5 } },\n\tloc_vars = function(self, info_queue, card)\n\t\tinfo_queue[#info_queue+1] = G.P_CENTERS.c_wheel_of_fortune\n\t\treturn { vars = { card.ability.max_highlighted } }\n\tend,\n\tcalculate = function(self, card, context)\n\t\tif context.setting_blind and not context.repetition and not context.individual and context.blind.boss and not context.blueprint then\n\t\t\t\n\t\t\tfor i=1, (G.consumeables.config.card_limit) do\n\t\t\t\tif #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then\n\t\t\t\t\tG.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1\n\t\t\t\t\tG.E_MANAGER:add_event(Event({\n\t\t\t\t\t\ttrigger = 'before',\n\t\t\t\t\t\tdelay = 0.0,\n\t\t\t\t\t\tfunc = (function()\n\t\t\t\t\t\t\tlocal card = create_card('Tarot', G.consumeables, nil, nil, nil, nil, 'c_wheel_of_fortune')\n\t\t\t\t\t\t\tcard:add_to_deck()\n\t\t\t\t\t\t\tG.consumeables:emplace(card)\n\t\t\t\t\t\t\tG.GAME.consumeable_buffer = 0\n\t\t\t\t\t\t\tcard:juice_up(0.5, 0.5)\n\t\t\t\t\t\t\treturn true\n\t\t\t\t\t\tend)}))\n\t\t\t\t\tcard_eval_status_text(card, 'extra', nil, nil, nil, {message = localize('k_plus_tarot'), colour = G.C.PURPLE})\n\t\t\t\tend\n\t\t\tend\n\t\t\n\t\tend\n\tend",
      "config": {
        "extra": {
          "mult": 5
        }
      },
      "ability": {
        "extra": {
          "mult": 5
        }
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "upgradedjoker",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 5,
        "y": 0
      },
      "raw": "--Upgraded Joker\n    key = 'upgradedjoker',\n    loc_txt = {\n        name = 'Upgraded Joker',\n        text = {\n            \"Each played {C:attention}Enhanced card{}\",\n            \"gives {C:chips}+#1#{} Chips and\",\n            \"{C:mult}+#2#{} Mult when scored\"\n        }\n    },\n    pronouns = 'she_they',\n    config = { extra = { chips = 10, mult = 4 } },\n    rarity = 1,\n    atlas = 'PiCubedsJokers',\n    pos = { x = 5, y = 0 },\n    cost = 5,\n    discovered = true,\n    blueprint_compat = true,\n    perishable_compat = true,\n    eternal_compat = true,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.chips, card.ability.extra.mult } }\n    end,\n    calculate = function(self, card, context)\n        if context.individual and context.cardarea == G.play then\n            if (context.other_card.config.center ~= G.P_CENTERS.c_base or SMODS.get_enhancements(context.other_card)[\"m_lucky\"] == true) and not context.other_card.debuff then\n                return {\n                    chips = card.ability.extra.chips,\n                    mult = card.ability.extra.mult,\n                    card = card\n                }\n            end\n        end\n    end",
      "config": {
        "extra": {
          "chips": 10,
          "mult": 4
        }
      },
      "ability": {
        "extra": {
          "chips": 10,
          "mult": 4
        }
      },
      "vars": [
        10,
        4
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "victimcard",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 5,
        "y": 7
      },
      "raw": "--Victim Card\n\tkey = 'victimcard',\n\tloc_txt = {\n\t\tname = 'Victim Card',\n\t\ttext = {\n\t\t\t\"This Joker gains {X:mult,C:white}X#1#{} Mult if\",\n\t\t\t\"played hand does {C:attention}not beat{} the\",\n\t\t\t\"blind, this Joker is {C:attention}destroyed{}\",\n\t\t\t\"after reaching {X:mult,C:white}X#2#{} Mult\",\n\t\t\t\"{C:inactive}(Currently{} {X:mult,C:white}X#3#{} {C:inactive}Mult){}\",\n\t\t}\n\t},\n\tpronouns = 'he_him',\n\trarity = 2,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 5, y = 7 },\n\tcost = 7,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tperishable_compat = false,\n\teternal_compat = false,\n\tconfig = { extra = { Xmult_mod = 0.2, Xmult_cap = 4, Xmult = 2 } },\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.Xmult_mod, card.ability.extra.Xmult_cap, card.ability.extra.Xmult } }\n\tend,\n\tcalculate = function(self, card, context)\n\t\tif context.pre_discard and not context.blueprint then\n\t\t\tpicubed_victimcard_prehand = false\n\t\tend\n\t\tif context.hand_drawn and picubed_victimcard_prehand and not context.blueprint and not context.retrigger_joker and G.GAME.current_round.hands_played ~= 0 then\n\t\t\tcard.ability.extra.Xmult = card.ability.extra.Xmult + card.ability.extra.Xmult_mod\n\t\t\tif card.ability.extra.Xmult >= card.ability.extra.Xmult_cap then\n\t\t\t\tG.E_MANAGER:add_event(Event({\n\t\t\t\t\tfunc = function()\n\t\t\t\t\t\tplay_sound('tarot1')\n\t\t\t\t\t\tcard.T.r = -0.2\n\t\t\t\t\t\tcard:juice_up(0.3, 0.4)\n\t\t\t\t\t\tcard.states.drag.is = true\n\t\t\t\t\t\tcard.children.center.pinch.x = true\n\t\t\t\t\t\tG.E_MANAGER:add_event(Event({\n\t\t\t\t\t\t\t\ttrigger = 'after',\n\t\t\t\t\t\t\t\tdelay = 0.3,\n\t\t\t\t\t\t\t\tblockable = false,\n\t\t\t\t\t\t\t\tfunc = function()\n\t\t\t\t\t\t\t\t\t\tcard:remove()\n\t\t\t\t\t\t\t\t\t\treturn true\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t}))\n\t\t\t\t\t\treturn true\n\t\t\t\t\tend\n\t\t\t\t}))\n\t\t\t\treturn {\n\t\t\t\t\tmessage = localize('k_picubeds_victimcard'),\n\t\t\t\t\tcolour = G.C.MULT,\n\t\t\t\t\tcard = card\n\t\t\t\t}\n\t\t\telse\n\t\t\t\treturn {\n\t\t\t\t\tmessage = localize('k_upgrade_ex'),\n\t\t\t\t\tcolour = G.C.MULT,\n\t\t\t\t\tcard = card\n\t\t\t\t}\n\t\t\tend\n\t\tend\n\t\tif context.joker_main then\n\t\t\tpicubed_victimcard_prehand = true\n\t\t\treturn {\n\t\t\t\tmessage = localize { type = 'variable', key = 'a_xmult', vars = { card.ability.extra.Xmult } },\n\t\t\t\tXmult_mod = card.ability.extra.Xmult\n\t\t\t}\n\t\tend\n\tend",
      "config": {
        "extra": {
          "Xmult_mod": 0.2,
          "Xmult_cap": 4,
          "Xmult": 2
        }
      },
      "ability": {
        "extra": {
          "Xmult_mod": 0.2,
          "Xmult_cap": 4,
          "Xmult": 2
        }
      },
      "vars": [
        0.2,
        4,
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "waterbottle",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 6,
        "y": 4
      },
      "raw": "--Water Bottle\n\tkey = 'waterbottle',\n\tloc_txt = {\n\t\tname = 'Water Bottle',\n\t\ttext = {\n\t\t\t\"{C:chips}+#1#{} Chips for each\",\n\t\t\t\"Consumable used this {C:attention}Ante{}\",\n\t\t\t\"{C:inactive}(Currently {C:chips}+#2# {C:inactive}Chips)\"\n\t\t}\n\t},\n\tpronouns = 'it_its',\n\trarity = 1,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 6, y = 4 },\n\tcost = 4,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tperishable_compat = false,\n\teternal_compat = true,\n\tconfig = { extra = { chips_mod = 15, chips = 0} },\n\tpools = { [\"Food\"] = true },\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.chips_mod, card.ability.extra.chips } }\n\tend,\n\t\n\tcalculate = function(self, card, context)\n\t\tif context.using_consumeable and not context.blueprint then\n\t\t\tcard.ability.extra.chips = card.ability.extra.chips + card.ability.extra.chips_mod\n\t\t\treturn {\n\t\t\t\tmessage = localize('k_upgrade_ex'),\n\t\t\t\tcolour = G.C.CHIPS,\n\t\t\t\tcard = card\n\t\t\t}\n\t\tend\n\t\tif context.joker_main then\n\t\t\treturn {\n                chip_mod = card.ability.extra.chips,\n                message = localize { type = 'variable', key = 'a_chips', vars = { card.ability.extra.chips } }\n            }\n\t\tend\n\t\t\n\t\tif context.end_of_round and not context.blueprint and not context.retrigger_joker and G.GAME.blind.boss and card.ability.extra.chips > 0 then\n\t\t\tcard.ability.extra.chips = 0\n\t\t\treturn {\n                card = card,\n                message = localize('k_reset'),\n                colour = G.C.RED\n\t\t\t}\n\t\tend\n\tend",
      "config": {
        "extra": {
          "chips_mod": 15,
          "chips": 0
        }
      },
      "ability": {
        "extra": {
          "chips_mod": 15,
          "chips": 0
        }
      },
      "vars": [
        15,
        0
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "weemini",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 2,
        "y": 8
      },
      "raw": "--Wee Mini\n\tkey = 'weemini',\n\tloc_txt = {\n\t\tname = 'Wee Mini',\n\t\ttext = {\n\t\t\t\"If played hand or cards held\",\n\t\t\t\"in hand contain a {C:attention}2{},\",\n\t\t\t\"played hand contains a\",\n\t\t\t\"{C:attention}Two Pair{} and apply {C:attention}Splash{}\"\n\t\t}\n\t},\n\tpronouns = 'they_them',\n\trarity = 1,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 2, y = 8 },\n\tcost = 2,\n\tdiscovered = true,\n\tblueprint_compat = false,\n\tperishable_compat = true,\n\teternal_compat = true,\n\tin_pool = function(self, args)\n\t\treturn can_do_pokerhand_changer_jokers()\n\tend,\n\tloc_vars = function(self, info_queue, card)\n\t\tinfo_queue[#info_queue+1] = G.P_CENTERS.j_splash\n\t\treturn { vars = { card.ability.max_highlighted } }\n\tend,\n\tcalculate = function(self, card, context)\n\t\tif not can_do_pokerhand_changer_jokers() then\n\t\t\tprint(\"Wee Mini has limited functionality due to a mod conflict, or the 'Hand type-affecting Jokers' config option being disabled.\")\n\t\tend\n\t\tlocal count_2 = 0\n\t\tfor k,v in ipairs(G.hand.highlighted) do\n            if v:get_id() == 2 then \n                count_2 = count_2 + 1\n            end\n\t\tend\n\t\tfor k,v in ipairs(G.play.cards) do\n            if v:get_id() == 2 then \n                count_2 = count_2 + 1\n            end\n\t\tend\n\t\tfor k,v in ipairs(G.hand.cards) do\n            if v:get_id() == 2 then\n                count_2 = count_2 + 1\n            end\n\t\tend\n\t\tif context.modify_scoring_hand and not context.blueprint and count_2 >= 1 then\n\t\t\treturn {\n                add_to_hand = true\n\t\t\t}\n\t\tend\n\tend",
      "config": {
        "add_to_hand": true
      },
      "ability": {
        "add_to_hand": true
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "weighteddie",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 5,
        "y": 9
      },
      "raw": "--Weighted Die\n\tkey = 'weighteddie',\n\tloc_txt = {\n\t\tname = 'Weighted Die',\n\t\ttext = {\n\t\t\t\"The {C:attention}Wheel of Fortune{} is\", \n\t\t\t\"{E:1,C:green}guaranteed{} to succeed\",\n\t\t}\n\t},\n\tpronouns = 'they_them',\n\trarity = 2,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 5, y = 9 },\n\tcost = 5,\n\tdiscovered = true,\n\tblueprint_compat = false,\n    perishable_compat = true,\n\teternal_compat = true,\n\tloc_vars = function(self, info_queue, card)\n\t\tinfo_queue[#info_queue+1] = G.P_CENTERS.c_wheel_of_fortune\n\t\treturn { vars = { card.ability.max_highlighted } }\n\tend,",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "wordsearch",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "--Word Search\n\tkey = 'wordsearch',\n\tloc_txt = {\n\t\tname = 'Word Search',\n\t\ttext = {\n\t\t\t\"This Joker gains {C:mult}+#2#{} Mult\",\n\t\t\t\"per scoring {C:attention}#1#{} card\",\n\t\t\t\"{s:0.8}Rank changes every round\",\n\t\t\t\"{C:inactive}(Currently {C:mult}+#3#{C:inactive} Mult)\"\n\t\t}\n\t},\n\tpronouns = 'she_her',\n\tconfig = { extra = { mult = 0, mult_mod = 1 }},\n\trarity = 1,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 2, y = 0 },\n\tcost = 4,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tperishable_compat = false,\n\teternal_compat = true,\n\t\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { \n\t\t\tlocalize((G.GAME.current_round.picubed_wordsearch_card or {}).rank or 'Ace', 'ranks'), card.ability.extra.mult_mod, card.ability.extra.mult \n\t\t} }\n\tend,\n\t\n\tcalculate = function(self, card, context)\n\t\tif context.individual and context.cardarea == G.play and not \n\t\tSMODS.has_no_rank(context.other_card) then\n\t\t\tif \n\t\t\t\tcontext.other_card:get_id() == G.GAME.current_round.picubed_wordsearch_card.id\n\t\t\t\tand not context.blueprint \n\t\t\t\tand not context.retrigger_joker\n\t\t\t\tand not context.other_card.debuff then\n\t\t\t\t\tcard.ability.extra.mult = card.ability.extra.mult + card.ability.extra.mult_mod\n\t\t\t\t\treturn {\n\t\t\t\t\t\tmessage = localize('k_upgrade_ex'),\n\t\t\t\t\t\tcolour = G.C.MULT,\n\t\t\t\t\t\tcard = card\n\t\t\t\t\t}\n\t\t\tend\n\t\tend\n\t\tif context.joker_main and card.ability.extra.mult > 0 then\n\t\t\treturn {\n\t\t\t\tmessage = localize{type='variable', key='a_mult', vars = {card.ability.extra.mult} },\n\t\t\t\tmult_mod = card.ability.extra.mult, \n\t\t\t\tcolour = G.C.MULT\n\t\t\t}\n\t\tend\n\tend",
      "config": {
        "extra": {
          "mult": 0,
          "mult_mod": 1
        }
      },
      "ability": {
        "extra": {
          "mult": 0,
          "mult_mod": 1
        }
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "yawningcat",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 8,
        "y": 6
      },
      "raw": "--Yawning Cat\n\tkey = 'yawningcat',\n\tloc_txt = {\n\t\tname = 'Yawning Cat',\n\t\ttext = {\n\t\t\t\"If {C:attention}played hand{} contains\",\n\t\t\t\"at least {C:attention}#1#{} scoring\",\n\t\t\t\"cards, {C:attention}retrigger{} playing\",\n\t\t\t\"cards {C:attention}#2# additional times{}\"\n\t\t}\n\t},\n\tpronouns = 'she_her',\n\trarity = 4,\n\tatlas = 'PiCubedsJokers',\n\tpos = { x = 8, y = 6 },\n\tsoul_pos = { x = 9, y = 6 },\n\tcost = 20,\n\tdiscovered = true,\n\tblueprint_compat = true,\n\tperishable_compat = true,\n\teternal_compat = true,\n\tpools = { [\"Cat\"] = true },\n\tconfig = { extra = { num = 3, retriggers = 2 } },\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.ability.extra.num, card.ability.extra.retriggers } }\n\tend,\n\tcalculate = function(self, card, context)\n\t\tif #(context.scoring_hand or {}) >= card.ability.extra.num and context.cardarea == G.play and context.repetition and not context.repetition_only then\n\t\t\treturn {\n                repetitions = card.ability.extra.retriggers,\n                card = card\n\t\t\t}\n\t\tend\n\tend",
      "config": {
        "extra": {
          "num": 3,
          "retriggers": 2
        }
      },
      "ability": {
        "extra": {
          "num": 3,
          "retriggers": 2
        }
      },
      "vars": [
        3,
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "commander",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 9,
        "y": 3
      },
      "raw": "--Commander (Spectral card)\n    set = \"Spectral\",\n    key = \"commander\",\n    loc_txt = {\n        name = 'Commander',\n        text = {\n            \"{C:attention}Destroy{} 1 random\",\n            \"Consumable if slots are\",\n            \"filled, add {C:dark_edition}Negative{}\",\n            \"to all others\"\n        }\n    },\n    discovered = true,\n    config = { \n        extra = { num = 1 }\n    },\n    atlas = 'PiCubedsJokers',\n    pos = { x = 9, y = 3 },\n    cost = 4,\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue + 1] = {key = 'e_negative_consumable', set = 'Edition', config = {extra = G.P_CENTERS['e_negative'].config.card_limit} }\n        return { vars = { card.ability.extra.num } }\n    end,\n    can_use = function(self, card)\n        return #G.consumeables.cards >= 1\n    end,\n    in_pool = function(self, args)\n        return #G.consumeables.cards >= 1\n    end,\n    use = function(self, card, area, copier)\n        if (#G.consumeables.cards >= G.consumeables.config.card_limit) or (card.edition and card.edition.key == 'e_negative' and #G.consumeables.cards + 1 >= G.consumeables.config.card_limit) then\n            local rndcard = pseudorandom_element(G.consumeables.cards, pseudoseed('Commander'..G.GAME.round_resets.ante))\n            if rndcard ~= nil then\n                --This event bit taken from Extra Credit's Toby the Corgi\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        play_sound('tarot1')\n                        rndcard.T.r = -0.2\n                        rndcard:juice_up(0.3, 0.4)\n                        rndcard.states.drag.is = true\n                        rndcard.children.center.pinch.x = true\n                        rndcard:start_dissolve()\n                        rndcard = nil\n                        delay(0.3)\n                        return true\n                    end\n                }))\n            end\n        end\n        for k, v in ipairs(G.consumeables.cards) do\n            v:set_edition('e_negative', false, true)\n            v:juice_up()\n        end\n    end",
      "config": {
        "extra": {
          "num": 1
        }
      },
      "ability": {
        "extra": {
          "num": 1
        }
      },
      "vars": [
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "rupture",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 8,
        "y": 8
      },
      "raw": "--Rupture (Spectral card)\n    set = \"Spectral\",\n    key = \"rupture\",\n    loc_txt = {\n        name = 'Rupture',\n        text = {\n            \"{C:attention}Destroy{} left-most Joker,\",\n            \"create {C:attention}#1#{} random\",\n            \"{C:spectral}Spectral{} cards\"\n        }\n    },\n    discovered = true,\n    config = { \n        extra = { num = 2 }\n    },\n    atlas = 'PiCubedsJokers',\n    pos = { x = 8, y = 8 },\n    cost = 4,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.num } }\n    end,\n    can_use = function(self, card)\n            return true\n    end,\n    use = function(self, card, area, copier)\n        if G.jokers.cards then\n            if not SMODS.is_eternal(G.jokers.cards[1]) then\n                G.jokers.cards[1]:start_dissolve(nil, nil)\n            end\n        end\n        for i = 1, math.min(card.ability.extra.num, G.consumeables.config.card_limit - #G.consumeables.cards) do\n            G.E_MANAGER:add_event(Event({\n                trigger = 'after',\n                delay = 0.4,\n                func = function()\n                    if G.consumeables.config.card_limit > #G.consumeables.cards then\n                        play_sound('timpani')\n                        SMODS.add_card({ set = 'Spectral' })\n                        card:juice_up(0.3, 0.5)\n                    end\n                    return true\n                end\n            }))\n        end\n        delay(0.6)\n    end,",
      "config": {
        "extra": {
          "num": 2
        }
      },
      "ability": {
        "extra": {
          "num": 2
        }
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "extinction",
      "atlas": "PiCubedsJokers",
      "pos": {
        "x": 9,
        "y": 8
      },
      "raw": "--Extinction (Spectral card)\n    set = \"Spectral\",\n    key = \"extinction\",\n    loc_txt = {\n        name = 'Extinction',\n        text = {\n            \"{C:attention}Destroy{} all cards of\",\n            \"a {C:attention}random rank{}\",\n            \"from your deck\"\n        }\n    },\n    discovered = true,\n    atlas = 'PiCubedsJokers',\n    pos = { x = 9, y = 8 },\n    cost = 4,\n    can_use = function(self, card)\n        return true\n    end,\n    use = function(self, card, area, copier)\n        if next(SMODS.find_card('j_gros_michel')) then\n            for k, v in ipairs(G.jokers.cards) do\n                if v.ability.name == 'Gros Michel' then\n                    check_for_unlock({type = 'picubed_extinction_grossedoff'})\n                    card_eval_status_text(v, 'extra', nil, nil, nil, {message = localize('k_extinct_ex') })\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            play_sound('tarot1')\n                            v.T.r = -0.2\n                            v:juice_up(0.3, 0.4)\n                            v.states.drag.is = true\n                            v.children.center.pinch.x = true\n                            G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.3, blockable = false,\n                                func = function()\n                                    G.jokers:remove_card(v)\n                                    v:remove()\n                                    v = nil\n                                return true; end})) \n                            return true\n                        end\n                    }))\n                    G.GAME.pool_flags.gros_michel_extinct = true\n                end\n            end\n        end\n        local rank_list = {2,3,4,5,6,7,8,9,10,11,12,13,14}\n        local chrank = pseudorandom_element(rank_list, \"extinction\"..G.GAME.round_resets.ante)\n        local the_key = chrank\n        if the_key == 11 then the_key = 'Jack'\n        elseif the_key == 12 then the_key = 'Queen'\n        elseif the_key == 13 then the_key = 'King'\n        elseif the_key == 14 then the_key = 'Ace' end\n        card_eval_status_text(card, 'extra', nil, nil, nil, {message = localize(tostring(the_key), 'ranks'),\n            colour = G.C.SECONDARY_SET.Spectral })\n        for k, v in ipairs(G.playing_cards) do\n            if v:get_id() == chrank then\n                SMODS.destroy_cards(v)\n            end\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sticker",
      "key": "contractual",
      "atlas": "picubedsstickers",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "-- Contractual sticker\n    key = \"contractual\",\n    loc_txt = {\n        name = 'Contractual',\n        text = {\n            \"Can't be sold or destroyed\", \n            \"for the next {C:attention}#1#{} rounds,\",\n            \"then expires and is removed\",\n            \"{C:inactive}({C:attention}#2#{C:inactive} remaining)\",\n        }\n    },\n    badge_colour = HEX 'c27760',\n    atlas = 'picubedsstickers',\n    pos = { x = 0, y = 0 },\n    --rate = 0.3,\n    --[[should_apply = function(self, card, center, area, bypass_roll)\n        return G.GAME.modifiers.enable_picubed_contractuals_in_shop and card.config.center.eternal_compat and card.config.center.perishable_compat and not card.ability.eternal and not card.ability.perishable --and not card.ability.eternal and not card.ability.perishable\n    end,]]\n    --needs_enable_flag = true,\n    --[[apply = function(self, card, val)\n        card:set_picubed_contractual()\n        card.ability[self.key] = val\n        if card.ability[self.key] then \n            card:set_cost()\n            card.ability.contract_tally = 10 \n        end\n    end,]]\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.contract_rounds or 10, card.ability.contract_tally or 10 } }\n    end,\n    calculate = function(self, card, context)\n        if context.end_of_round and not context.repetition and not context.individual then\n            card:calculate_picubed_contractual()\n        end\n    end",
      "config": {},
      "ability": {},
      "vars": [
        10,
        10
      ],
      "infoQueue": []
    },
    {
      "type": "Tag",
      "key": "reboundtag",
      "atlas": "picubed_tags",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "-- Rebound Tag\n\tkey = 'reboundtag',\n\tloc_txt = {\n\t\tname = \"Rebound Tag\",\n\t\ttext = {\n\t\t\t\"Retrigger played cards {C:attention}#1#{}\",\n\t\t\t\"additional times for\",\n            \"next round\",\n\t\t}\n\t},\n\tconfig = { extra = { retriggers = 2, rounds_played = 0 } },\n\tatlas = \"picubed_tags\",\n\tpos = { x = 2, y = 0 },\n\tdiscovered = true,\n\tmin_ante = 2,\n\tloc_vars = function(self, info_queue, card)\n\t\treturn { vars = { card.config.extra.retriggers } }\n\tend,\n\tapply = function(self, tag, context)\n\t\tif context.type == 'round_start_bonus' then\n            tag:yep('+', G.C.BLUE, function()\n                return true\n            end)\n            G.GAME.round_resets.temp_handsize = 0\n            SMODS.add_card({set = 'Joker', area = G.jokers, skip_materialize = true, key = \"j_picubed_reboundtag_joker\", edition = 'e_negative' })\n            tag.triggered = true\n            return true\n        end\n\tend",
      "config": {
        "extra": {
          "retriggers": 2,
          "rounds_played": 0
        }
      },
      "ability": {
        "extra": {
          "retriggers": 2,
          "rounds_played": 0
        }
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "reboundtag_joker",
      "atlas": "picubed_tags",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "-- Rebound Tag (Joker-fied)\n    key = 'reboundtag_joker',\n\tloc_txt = {\n\t\tname = 'Rebound Tag',\n\t\ttext = {\n\t\t\t\"Retrigger played cards {C:attention}#1#{}\",\n\t\t\t\"additional times for\",\n            \"next round\",\n\t\t}\n\t},\n\trarity = 1,\n    config = { extra = { retriggers = 2 } },\n\tatlas = 'picubed_tags',\n\tpos = { x = 2, y = 0,\n        draw = function(card, scale_mod, rotate_mod) \n            card.children.center:draw_shader(nil, nil, card.ARGS.send_to_shader)\n        end\n    },\n    display_size = { w = 34, h = 34 },\n\tcost = 0,\n    no_collection = true,\n\tdiscovered = true,\n\tblueprint_compat = false,\n    perishable_compat = false,\n\teternal_compat = false,\n    in_pool = function(self, args) return false end,\n\tloc_vars = function(self, info_queue, card)\n        --info_queue[1] = nil\n        return { vars = { card.ability.extra.retriggers } }\n\tend,\n    set_badges = function(self, card, badges)\n        badges[2] = nil\n        badges[1] = nil\n    end,\n    add_to_deck = function(self, card, from_debuff)\n\t\t--card:set_edition('e_negative', false, true)\n        card.ability.extra_value = -card.sell_cost\n\tend,\n\tcalculate = function(self, card, context)\n        card.sell_cost = 0\n        if context.end_of_round and context.game_over == false and context.main_eval and not context.blueprint and not context.retrigger_joker then\n            if card.ability.extra.retriggers ~= 0 then\n                G.E_MANAGER:add_event(Event({\n                    func = function()\n                        play_sound('tarot1')\n                        card.T.r = -0.2\n                        card:juice_up(0.3, 0.4)\n                        card.states.drag.is = true\n                        card.children.center.pinch.x = true\n                        G.E_MANAGER:add_event(Event({\n                            trigger = 'after',\n                            delay = 0.3,\n                            blockable = false,\n                            func = function()\n                                card:remove()\n                                return true\n                            end\n                        }))\n                        return true\n                    end\n                }))\n            end\n        end\n\t\tif context.repetition and context.cardarea == G.play and card.ability.extra.retriggers >= 1 and not context.blueprint and not context.retrigger_joker then\n            return {\n                repetitions = card.ability.extra.retriggers\n            }\n        end\n\tend",
      "config": {
        "extra": {
          "retriggers": 2
        }
      },
      "ability": {
        "extra": {
          "retriggers": 2
        }
      },
      "vars": [
        2
      ],
      "infoQueue": []
    }
  ],
  "version": "v1.1.3"
}