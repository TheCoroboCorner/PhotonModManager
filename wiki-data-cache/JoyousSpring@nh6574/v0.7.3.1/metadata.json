{
  "locMap": {},
  "atlases": {
    "hanafuda": {
      "path": "hanafuda.png",
      "px": 71,
      "py": 95,
      "resolvedGitHubPath": "hanafuda.png",
      "localPath": null
    }
  },
  "cards": [
    {
      "type": "Font",
      "key": "font",
      "atlas": null,
      "pos": null,
      "raw": "key = \"font\",\n    path = \"DoHyeon-Regular.ttf\",\n    FONTSCALE = 0.1"
    },
    {
      "type": "Gradient",
      "key": "PENDULUM_NORMAL",
      "atlas": null,
      "pos": null,
      "raw": "key = \"PENDULUM_NORMAL\",\n    colours = { G.C.JOY.SPELL, G.C.JOY.NORMAL },\n    cycle = 7.5,"
    },
    {
      "type": "Gradient",
      "key": "PENDULUM_EFFECT",
      "atlas": null,
      "pos": null,
      "raw": "key = \"PENDULUM_EFFECT\",\n    colours = { G.C.JOY.SPELL, G.C.JOY.EFFECT },\n    cycle = 7.5,"
    },
    {
      "type": "Gradient",
      "key": "PENDULUM_RITUAL",
      "atlas": null,
      "pos": null,
      "raw": "key = \"PENDULUM_RITUAL\",\n    colours = { G.C.JOY.SPELL, G.C.JOY.RITUAL },\n    cycle = 7.5,"
    },
    {
      "type": "Gradient",
      "key": "PENDULUM_FUSION",
      "atlas": null,
      "pos": null,
      "raw": "key = \"PENDULUM_FUSION\",\n    colours = { G.C.JOY.SPELL, G.C.JOY.FUSION },\n    cycle = 7.5,"
    },
    {
      "type": "Gradient",
      "key": "PENDULUM_SYNCHRO",
      "atlas": null,
      "pos": null,
      "raw": "key = \"PENDULUM_SYNCHRO\",\n    colours = { G.C.JOY.SPELL, G.C.JOY.SYNCHRO },\n    cycle = 7.5,"
    },
    {
      "type": "Gradient",
      "key": "PENDULUM_XYZ",
      "atlas": null,
      "pos": null,
      "raw": "key = \"PENDULUM_XYZ\",\n    colours = { G.C.JOY.SPELL, G.C.JOY.XYZ },\n    cycle = 7.5,"
    },
    {
      "type": "Atlas",
      "key": "Dragonmaid",
      "atlas": null,
      "pos": null,
      "raw": "key = \"Dragonmaid\",\n    path = \"01Dragonmaid.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Joker",
      "key": "dmaid_kitchen",
      "atlas": "Dragonmaid",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"dmaid_kitchen\",\n    atlas = 'Dragonmaid',\n    pos = { x = 0, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_transform\" }\n        end\n        return { vars = { card.ability.extra.base_rerolls, card.ability.extra.rerolls } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_dmaid_tinkhec\",                                      name = \"k_joy_transforms_into\" },\n        { properties = { { monster_archetypes = { \"Dragonmaid\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"FIRE\",\n                monster_type = \"Dragon\",\n                monster_archetypes = { [\"Dragonmaid\"] = true },\n            },\n            base_rerolls = 1,\n            rerolls = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.setting_blind and context.main_eval then\n                JoyousSpring.transform_card(card, \"j_joy_dmaid_tinkhec\")\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not from_debuff and not card.debuff then\n            local count_graveyard = (next(SMODS.find_card(\"j_joy_dmaid_house\")) or\n                next(SMODS.find_card(\"j_joy_dmaid_sheou\"))) and true\n            local dragonmaid_count = JoyousSpring.count_materials_owned({ { monster_archetypes = { \"Dragonmaid\" } } }) +\n                (count_graveyard and JoyousSpring.count_materials_in_graveyard({ { monster_archetypes = { \"Dragonmaid\" } } }) or 0)\n\n            card.ability.extra.rerolls = card.ability.extra.base_rerolls * dragonmaid_count\n            if not card.area or card.area ~= G.jokers then\n                card.ability.extra.rerolls = card.ability.extra.rerolls + 1\n            end\n            G.GAME.current_round.free_rerolls = G.GAME.current_round.free_rerolls + card.ability.extra.rerolls\n            calculate_reroll_cost(true)\n            card:juice_up()\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "dmaid_tinkhec",
      "atlas": "Dragonmaid",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"dmaid_tinkhec\",\n    atlas = 'Dragonmaid',\n    pos = { x = 1, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_transform\" }\n        end\n        return { vars = { card.ability.extra.mult } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_dmaid_kitchen\",                                      name = \"k_joy_transforms_into\" },\n        { properties = { { monster_archetypes = { \"Dragonmaid\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"FIRE\",\n                monster_type = \"Dragon\",\n                monster_archetypes = { [\"Dragonmaid\"] = true },\n            },\n            mult = 20\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.end_of_round and context.game_over == false and context.main_eval then\n                JoyousSpring.transform_card(card, \"j_joy_dmaid_kitchen\")\n            end\n            if context.other_joker and context.other_joker.facing == \"front\" and JoyousSpring.is_monster_archetype(context.other_joker, \"Dragonmaid\") then\n                return {\n                    mult = card.ability.extra.mult,\n                    message_card = context.other_joker\n                }\n            end\n            if context.joker_main then\n                local count_graveyard = (next(SMODS.find_card(\"j_joy_dmaid_house\")) or\n                    next(SMODS.find_card(\"j_joy_dmaid_sheou\"))) and true\n                local dragonmaid_count = 0\n                if count_graveyard then\n                    dragonmaid_count = JoyousSpring.count_materials_in_graveyard({ { monster_archetypes = { \"Dragonmaid\" } } })\n                    return {\n                        mult = card.ability.extra.mult * dragonmaid_count,\n                    }\n                end\n            end\n        end\n    end,\n    in_pool = function(self, args)\n        return args and args.source and args.source == \"JoyousSpring\" or false\n    end,\n    joker_display_def = function(JokerDisplay)\n        return {\n            text = {\n                { text = \"+\" },\n                { ref_table = \"card.joker_display_values\", ref_value = \"mult\", retrigger_type = \"mult\" }\n            },\n            text_config = { colour = G.C.MULT },\n            calc_function = function(card)\n                local count_graveyard = (next(SMODS.find_card(\"j_joy_dmaid_house\")) or\n                    next(SMODS.find_card(\"j_joy_dmaid_sheou\"))) and true\n                local dragonmaid_count = 0\n                if count_graveyard then\n                    dragonmaid_count = JoyousSpring.count_materials_in_graveyard({ { monster_archetypes = { \"Dragonmaid\" } } })\n                end\n                card.joker_display_values.mult = card.ability.extra.mult * dragonmaid_count\n            end,\n            mod_function = function(card, mod_joker)\n                return {\n                    mult = (JoyousSpring.is_monster_archetype(card, \"Dragonmaid\") and mod_joker.ability.extra.mult and\n                        mod_joker.ability.extra.mult * JokerDisplay.calculate_joker_triggers(mod_joker) or nil)\n                }\n            end\n        }\n    end"
    },
    {
      "type": "Joker",
      "key": "dmaid_parlor",
      "atlas": "Dragonmaid",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"dmaid_parlor\",\n    atlas = 'Dragonmaid',\n    pos = { x = 2, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 4,\n    loc_vars = function(self, info_queue, card)\n        if not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = G.P_TAGS.tag_joy_booster\n            if not JoyousSpring.config.disable_tooltips then\n                info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_transform\" }\n            end\n        end\n        return {\n            vars = { card.ability.extra.tags_to_add, card.ability.extra.dragonmaid_count,\n                card.ability.extra.extra_dragonmaid_count, card.ability.extra.mills }\n        }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_dmaid_lorpar\",                                       name = \"k_joy_transforms_into\" },\n        { properties = { { monster_archetypes = { \"Dragonmaid\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"WIND\",\n                monster_type = \"Dragon\",\n                monster_archetypes = { [\"Dragonmaid\"] = true },\n            },\n            tags_to_add = 1,\n            dragonmaid_count = 5,\n            extra_dragonmaid_count = 15,\n            mills = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.setting_blind and context.main_eval then\n                JoyousSpring.transform_card(card, \"j_joy_dmaid_lorpar\")\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not from_debuff and not card.debuff then\n            local count_graveyard = (next(SMODS.find_card(\"j_joy_dmaid_house\")) or\n                next(SMODS.find_card(\"j_joy_dmaid_sheou\"))) and true\n            local dragonmaid_count = JoyousSpring.count_materials_owned({ { monster_archetypes = { \"Dragonmaid\" } } }) +\n                (count_graveyard and JoyousSpring.count_materials_in_graveyard({ { monster_archetypes = { \"Dragonmaid\" } } }) or 0)\n            if not card.area or card.area ~= G.jokers then\n                dragonmaid_count = dragonmaid_count + 1\n            end\n            if dragonmaid_count >= card.ability.extra.dragonmaid_count then\n                for j = 1, card.ability.extra.tags_to_add do\n                    add_tag(Tag('tag_joy_booster'))\n                end\n            end\n            local number_to_add = math.max(0,\n                math.floor((dragonmaid_count - card.ability.extra.dragonmaid_count) /\n                    card.ability.extra.extra_dragonmaid_count))\n            for i = 1, number_to_add do\n                for j = 1, card.ability.extra.tags_to_add do\n                    add_tag(Tag('tag_joy_booster'))\n                end\n            end\n            local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Dragonmaid\" }, is_main_deck = true } })\n\n            for i = 1, card.ability.extra.mills do\n                JoyousSpring.send_to_graveyard(pseudorandom_element(choices, 'j_joy_dmaid_laundry'))\n            end\n            SMODS.calculate_effect({ message = localize(\"k_joy_mill\") }, card)\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "dmaid_lorpar",
      "atlas": "Dragonmaid",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"dmaid_lorpar\",\n    atlas = 'Dragonmaid',\n    pos = { x = 3, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 4,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_transform\" }\n        end\n        return { vars = { card.ability.extra.xmult } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_dmaid_parlor\",                                       name = \"k_joy_transforms_into\" },\n        { properties = { { monster_archetypes = { \"Dragonmaid\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"WIND\",\n                monster_type = \"Dragon\",\n                monster_archetypes = { [\"Dragonmaid\"] = true },\n            },\n            xmult = 1.1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.end_of_round and context.game_over == false and context.main_eval then\n                JoyousSpring.transform_card(card, \"j_joy_dmaid_parlor\")\n            end\n            if context.other_joker and context.other_joker.facing == \"front\" and JoyousSpring.is_monster_archetype(context.other_joker, \"Dragonmaid\") then\n                return {\n                    xmult = card.ability.extra.xmult,\n                    message_card = context.other_joker\n                }\n            end\n            if context.joker_main then\n                local count_graveyard = (next(SMODS.find_card(\"j_joy_dmaid_house\")) or\n                    next(SMODS.find_card(\"j_joy_dmaid_sheou\"))) and true\n                local dragonmaid_count = 0\n                if count_graveyard then\n                    dragonmaid_count = JoyousSpring.count_materials_in_graveyard({ { monster_archetypes = { \"Dragonmaid\" } } })\n                    return {\n                        xmult = card.ability.extra.xmult ^ dragonmaid_count,\n                    }\n                end\n            end\n        end\n    end,\n    in_pool = function(self, args)\n        return args and args.source and args.source == \"JoyousSpring\" or false\n    end,\n    joker_display_def = function(JokerDisplay)\n        return {\n            text = {\n                {\n                    border_nodes = {\n                        { text = \"X\" },\n                        { ref_table = \"card.joker_display_values\", ref_value = \"xmult\", retrigger_type = \"exp\" }\n                    }\n                }\n            },\n            calc_function = function(card)\n                local count_graveyard = (next(SMODS.find_card(\"j_joy_dmaid_house\")) or\n                    next(SMODS.find_card(\"j_joy_dmaid_sheou\"))) and true\n                local dragonmaid_count = 0\n                if count_graveyard then\n                    dragonmaid_count = JoyousSpring.count_materials_in_graveyard({ { monster_archetypes = { \"Dragonmaid\" } } })\n                end\n                card.joker_display_values.xmult = card.ability.extra.xmult ^ dragonmaid_count\n            end,\n            mod_function = function(card, mod_joker)\n                return {\n                    x_mult = (JoyousSpring.is_monster_archetype(card, \"Dragonmaid\") and mod_joker.ability.extra.xmult and\n                        mod_joker.ability.extra.xmult ^ JokerDisplay.calculate_joker_triggers(mod_joker) or nil)\n                }\n            end\n        }\n    end"
    },
    {
      "type": "Joker",
      "key": "dmaid_nurse",
      "atlas": "Dragonmaid",
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "key = \"dmaid_nurse\",\n    atlas = 'Dragonmaid',\n    pos = { x = 4, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 3,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_transform\" }\n        end\n        return { vars = { G.GAME.probabilities.normal or 1, card.ability.extra.odds, card.ability.extra.revives } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_dmaid_ernus\",                                        name = \"k_joy_transforms_into\" },\n        { properties = { { monster_archetypes = { \"Dragonmaid\" } } }, name = \"k_joy_archetype\" },\n    },\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"EARTH\",\n                monster_type = \"Dragon\",\n                monster_archetypes = { [\"Dragonmaid\"] = true },\n            },\n            revives = 1,\n            odds = 2\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.setting_blind and context.main_eval then\n                JoyousSpring.transform_card(card, \"j_joy_dmaid_ernus\")\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not from_debuff and not card.debuff then\n            local has_revived = false\n            if pseudorandom(\"j_joy_dmaid_nurse\") < G.GAME.probabilities.normal / card.ability.extra.odds then\n                for i = 1, card.ability.extra.revives do\n                    local revived_card = JoyousSpring.revive_pseudorandom(\n                        { { rarity = 1, monster_archetypes = { \"Dragonmaid\" } } },\n                        'j_joy_dmaid_nurse',\n                        true\n                    )\n                    has_revived = (revived_card and true) or has_revived\n                end\n            end\n            if has_revived then\n                SMODS.calculate_effect({ message = localize(\"k_joy_revive\") }, card)\n            end\n        end\n    end,\n    joker_display_def = function(JokerDisplay)\n        return {\n            extra = {\n                {\n                    { text = \"(\" },\n                    { ref_table = \"card.joker_display_values\", ref_value = \"odds\" },\n                    { text = \")\" },\n                }\n            },\n            extra_config = { colour = G.C.GREEN, scale = 0.3 },\n            calc_function = function(card)\n                card.joker_display_values.odds = localize { type = 'variable', key = \"jdis_odds\", vars = { (G.GAME and G.GAME.probabilities.normal or 1), card.ability.extra.odds } }\n            end\n        }\n    end"
    },
    {
      "type": "Joker",
      "key": "dmaid_ernus",
      "atlas": "Dragonmaid",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"dmaid_ernus\",\n    atlas = 'Dragonmaid',\n    pos = { x = 0, y = 1 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 3,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_transform\" }\n        end\n        return { vars = { card.ability.extra.mult } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_dmaid_nurse\",                                        name = \"k_joy_transforms_into\" },\n        { properties = { { monster_archetypes = { \"Dragonmaid\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"EARTH\",\n                monster_type = \"Dragon\",\n                monster_archetypes = { [\"Dragonmaid\"] = true },\n            },\n            mult = 2\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.end_of_round and context.game_over == false and context.main_eval then\n                JoyousSpring.transform_card(card, \"j_joy_dmaid_nurse\")\n            end\n\n            if context.joker_main then\n                local dragonmaid_count = JoyousSpring.count_materials_in_graveyard({ { monster_archetypes = { \"Dragonmaid\" } } })\n\n                return {\n                    mult = card.ability.extra.mult * dragonmaid_count,\n                }\n            end\n        end\n    end,\n    in_pool = function(self, args)\n        return args and args.source and args.source == \"JoyousSpring\" or false\n    end,\n    joker_display_def = function(JokerDisplay)\n        return {\n            text = {\n                { text = \"+\" },\n                { ref_table = \"card.joker_display_values\", ref_value = \"mult\", retrigger_type = \"mult\" }\n            },\n            text_config = { colour = G.C.MULT },\n            calc_function = function(card)\n                local dragonmaid_count = JoyousSpring.count_materials_in_graveyard({ { monster_archetypes = { \"Dragonmaid\" } } })\n                card.joker_display_values.mult = card.ability.extra.mult * dragonmaid_count\n            end,\n        }\n    end"
    },
    {
      "type": "Joker",
      "key": "dmaid_laundry",
      "atlas": "Dragonmaid",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"dmaid_laundry\",\n    atlas = 'Dragonmaid',\n    pos = { x = 1, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_main_deck_joker\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_transform\" }\n        end\n        return { vars = { card.ability.extra.mills } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_dmaid_nudyarl\",                                      name = \"k_joy_transforms_into\" },\n        { properties = { { monster_archetypes = { \"Dragonmaid\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"WATER\",\n                monster_type = \"Dragon\",\n                monster_archetypes = { [\"Dragonmaid\"] = true },\n            },\n            mills = 3\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.setting_blind and context.main_eval then\n                JoyousSpring.transform_card(card, \"j_joy_dmaid_nudyarl\")\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not from_debuff and not card.debuff then\n            local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Dragonmaid\" }, is_main_deck = true } })\n\n            for i = 1, card.ability.extra.mills do\n                JoyousSpring.send_to_graveyard(pseudorandom_element(choices, 'j_joy_dmaid_laundry'))\n            end\n            SMODS.calculate_effect({ message = localize(\"k_joy_mill\") }, card)\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "dmaid_nudyarl",
      "atlas": "Dragonmaid",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"dmaid_nudyarl\",\n    atlas = 'Dragonmaid',\n    pos = { x = 2, y = 1 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_transform\" }\n        end\n        return { vars = { card.ability.extra.chips } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_dmaid_laundry\",                                      name = \"k_joy_transforms_into\" },\n        { properties = { { monster_archetypes = { \"Dragonmaid\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"WATER\",\n                monster_type = \"Dragon\",\n                monster_archetypes = { [\"Dragonmaid\"] = true },\n            },\n            chips = 3\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.end_of_round and context.game_over == false and context.main_eval then\n                JoyousSpring.transform_card(card, \"j_joy_dmaid_laundry\")\n            end\n\n            if context.joker_main then\n                local dragonmaid_count = JoyousSpring.count_materials_in_graveyard({ { monster_archetypes = { \"Dragonmaid\" } } })\n\n                return {\n                    chips = card.ability.extra.chips * dragonmaid_count,\n                }\n            end\n        end\n    end,\n    in_pool = function(self, args)\n        return args and args.source and args.source == \"JoyousSpring\" or false\n    end,\n    joker_display_def = function(JokerDisplay)\n        return {\n            text = {\n                { text = \"+\" },\n                { ref_table = \"card.joker_display_values\", ref_value = \"chips\", retrigger_type = \"mult\" }\n            },\n            text_config = { colour = G.C.CHIPS },\n            calc_function = function(card)\n                local dragonmaid_count = JoyousSpring.count_materials_in_graveyard({ { monster_archetypes = { \"Dragonmaid\" } } })\n                card.joker_display_values.chips = card.ability.extra.chips * dragonmaid_count\n            end,\n        }\n    end"
    },
    {
      "type": "Joker",
      "key": "dmaid_chamber",
      "atlas": "Dragonmaid",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"dmaid_chamber\",\n    atlas = 'Dragonmaid',\n    pos = { x = 3, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 2,\n    loc_vars = function(self, info_queue, card)\n        if not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = G.P_TAGS.tag_voucher\n            if not JoyousSpring.config.disable_tooltips then\n                info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_transform\" }\n            end\n        end\n        return {\n            vars = { card.ability.extra.tags_to_add, card.ability.extra.dragonmaid_count,\n                card.ability.extra.extra_dragonmaid_count, card.ability.extra.mills }\n        }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_dmaid_cehrmba\",                                      name = \"k_joy_transforms_into\" },\n        { properties = { { monster_archetypes = { \"Dragonmaid\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Dragon\",\n                monster_archetypes = { [\"Dragonmaid\"] = true },\n            },\n            mills = 1,\n            tags_to_add = 1,\n            dragonmaid_count = 5,\n            extra_dragonmaid_count = 15\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.setting_blind and context.main_eval then\n                JoyousSpring.transform_card(card, \"j_joy_dmaid_cehrmba\")\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not from_debuff and not card.debuff then\n            local count_graveyard = (next(SMODS.find_card(\"j_joy_dmaid_house\")) or\n                next(SMODS.find_card(\"j_joy_dmaid_sheou\"))) and true\n            local dragonmaid_count = JoyousSpring.count_materials_owned({ { monster_archetypes = { \"Dragonmaid\" } } }) +\n                (count_graveyard and JoyousSpring.count_materials_in_graveyard({ { monster_archetypes = { \"Dragonmaid\" } } }) or 0)\n            if not card.area or card.area ~= G.jokers then\n                dragonmaid_count = dragonmaid_count + 1\n            end\n            if dragonmaid_count >= card.ability.extra.dragonmaid_count then\n                for j = 1, card.ability.extra.tags_to_add do\n                    add_tag(Tag('tag_voucher'))\n                end\n            end\n            local number_to_add = math.max(0,\n                math.floor((dragonmaid_count - card.ability.extra.dragonmaid_count) /\n                    card.ability.extra.extra_dragonmaid_count))\n            for i = 1, number_to_add do\n                for j = 1, card.ability.extra.tags_to_add do\n                    add_tag(Tag('tag_voucher'))\n                end\n            end\n            local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Dragonmaid\" }, is_main_deck = true } })\n\n            for i = 1, card.ability.extra.mills do\n                JoyousSpring.send_to_graveyard(pseudorandom_element(choices, 'j_joy_dmaid_laundry'))\n            end\n            SMODS.calculate_effect({ message = localize(\"k_joy_mill\") }, card)\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "dmaid_cehrmba",
      "atlas": "Dragonmaid",
      "pos": {
        "x": 4,
        "y": 1
      },
      "raw": "key = \"dmaid_cehrmba\",\n    atlas = 'Dragonmaid',\n    pos = { x = 4, y = 1 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 2,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_transform\" }\n        end\n        return { vars = { G.GAME.probabilities.normal or 1, card.ability.extra.odds, card.ability.extra.revives } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_dmaid_chamber\",                                      name = \"k_joy_transforms_into\" },\n        { properties = { { monster_archetypes = { \"Dragonmaid\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Dragon\",\n                monster_archetypes = { [\"Dragonmaid\"] = true },\n            },\n            revives = 1,\n            odds = 2\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.end_of_round and context.game_over == false and context.main_eval then\n                JoyousSpring.transform_card(card, \"j_joy_dmaid_chamber\")\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not from_debuff and not card.debuff then\n            local has_revived = false\n            if pseudorandom(\"j_joy_dmaid_cehrmba\") < G.GAME.probabilities.normal / card.ability.extra.odds then\n                for i = 1, card.ability.extra.revives do\n                    local revived_card\n                    JoyousSpring.revive_pseudorandom(\n                        {\n                            { rarity = 2, monster_archetypes = { \"Dragonmaid\" } },\n                            { rarity = 3, monster_archetypes = { \"Dragonmaid\" } },\n                        },\n                        'j_joy_dmaid_cehrmba',\n                        true\n                    )\n                    has_revived = revived_card and true or has_revived\n                end\n            end\n            if has_revived then\n                SMODS.calculate_effect({ message = localize(\"k_joy_revive\") }, card)\n            end\n        end\n    end,\n    in_pool = function(self, args)\n        return args and args.source and args.source == \"JoyousSpring\" or false\n    end,\n    joker_display_def = function(JokerDisplay)\n        return {\n            extra = {\n                {\n                    { text = \"(\" },\n                    { ref_table = \"card.joker_display_values\", ref_value = \"odds\" },\n                    { text = \")\" },\n                }\n            },\n            extra_config = { colour = G.C.GREEN, scale = 0.3 },\n            calc_function = function(card)\n                card.joker_display_values.odds = localize { type = 'variable', key = \"jdis_odds\", vars = { (G.GAME and G.GAME.probabilities.normal or 1), card.ability.extra.odds } }\n            end\n        }\n    end"
    },
    {
      "type": "Joker",
      "key": "dmaid_lady",
      "atlas": "Dragonmaid",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = \"dmaid_lady\",\n    atlas = 'Dragonmaid',\n    pos = { x = 0, y = 2 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 9,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_transform\" }\n        end\n        return {\n            vars = { G.GAME.probabilities.normal or 1, card.ability.extra.odds }\n        }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_dmaid_house\",                                        name = \"k_joy_adds\" },\n        { properties = { { monster_archetypes = { \"Dragonmaid\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"FUSION\",\n                attribute = \"LIGHT\",\n                monster_type = \"Dragon\",\n                monster_archetypes = { [\"Dragonmaid\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"FUSION\",\n                        materials = {\n                            { monster_archetypes = { \"Dragonmaid\" } },\n                            {}\n                        }\n                    }\n                },\n            },\n            odds = 2\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.setting_blind and context.main_eval then\n                if pseudorandom(\"j_joy_dmaid_lady\") < G.GAME.probabilities.normal / card.ability.extra.odds then\n                    local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Dragonmaid\" }, rarity = 2 } })\n                    JoyousSpring.transform_card(card,\n                        pseudorandom_element(choices, 'j_joy_dmaid_lady') or j_joy_dmaid_tinkhec)\n                end\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not from_debuff and not card.debuff then\n            if #JoyousSpring.extra_deck_area.cards < JoyousSpring.extra_deck_area.config.card_limit then\n                JoyousSpring.add_to_extra_deck(\"j_joy_dmaid_house\")\n                SMODS.calculate_effect({ message = localize(\"k_joy_add\") }, card)\n            end\n        end\n    end,\n    joker_display_def = function(JokerDisplay)\n        return {\n            extra = {\n                {\n                    { text = \"(\" },\n                    { ref_table = \"card.joker_display_values\", ref_value = \"odds\" },\n                    { text = \")\" },\n                }\n            },\n            extra_config = { colour = G.C.GREEN, scale = 0.3 },\n            calc_function = function(card)\n                card.joker_display_values.odds = localize { type = 'variable', key = \"jdis_odds\", vars = { (G.GAME and G.GAME.probabilities.normal or 1), card.ability.extra.odds } }\n            end\n        }\n    end"
    },
    {
      "type": "Joker",
      "key": "dmaid_house",
      "atlas": "Dragonmaid",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "key = \"dmaid_house\",\n    atlas = 'Dragonmaid',\n    pos = { x = 1, y = 2 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 9,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_transform\" }\n        end\n        return {\n            vars = {\n                card.ability.extra.xmult,\n                1 +\n                (card.ability.extra.xmult * JoyousSpring.count_all_materials({ { monster_archetypes = { \"Dragonmaid\" } } })),\n                card.ability.extra.blinds,\n                math.min(card.ability.extra.blinds_won, 3)\n            }\n        }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_dmaid_sheou\",                                        name = \"k_joy_transforms_into\" },\n        { properties = { { monster_archetypes = { \"Dragonmaid\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"FUSION\",\n                attribute = \"LIGHT\",\n                monster_type = \"Dragon\",\n                monster_archetypes = { [\"Dragonmaid\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"FUSION\",\n                        materials = {\n                            { monster_archetypes = { \"Dragonmaid\" } },\n                            { monster_archetypes = { \"Dragonmaid\" } }\n                        }\n                    }\n                },\n            },\n            xmult = 0.1,\n            blinds = 3,\n            blinds_won = 0\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.end_of_round and context.game_over == false and context.main_eval then\n                card.ability.extra.blinds_won = card.ability.extra.blinds_won + 1\n                if card.ability.extra.blinds_won >= 3 then\n                    JoyousSpring.transform_card(card, \"j_joy_dmaid_sheou\")\n                end\n            end\n            if context.joker_main then\n                local dragonmaid_count = JoyousSpring.count_all_materials({ { monster_archetypes = { \"Dragonmaid\" } } })\n\n                return {\n                    xmult = 1 + (card.ability.extra.xmult * dragonmaid_count),\n                }\n            end\n        end\n    end,\n    joker_display_def = function(JokerDisplay)\n        return {\n            text = {\n                {\n                    border_nodes = {\n                        { text = \"X\" },\n                        { ref_table = \"card.joker_display_values\", ref_value = \"xmult\", retrigger_type = \"exp\" }\n                    }\n                }\n            },\n            reminder_text = {\n                { text = \"(\" },\n                { ref_table = \"card.ability.extra\", ref_value = \"blinds_won\" },\n                { text = \"/\" },\n                { ref_table = \"card.ability.extra\", ref_value = \"blinds\" },\n                { text = \")\" },\n            },\n            calc_function = function(card)\n                local dragonmaid_count = JoyousSpring.count_all_materials({ { monster_archetypes = { \"Dragonmaid\" } } })\n                card.joker_display_values.xmult = 1 + (card.ability.extra.xmult * dragonmaid_count)\n            end,\n        }\n    end"
    },
    {
      "type": "Joker",
      "key": "dmaid_sheou",
      "atlas": "Dragonmaid",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "key = \"dmaid_sheou\",\n    atlas = 'Dragonmaid',\n    pos = { x = 2, y = 2 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 9,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_transform\" }\n        end\n        return { vars = { card.ability.extra.cards_to_create } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_dmaid_house\",                                        name = \"k_joy_transforms_into\" },\n        { properties = { { monster_archetypes = { \"Dragonmaid\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"FUSION\",\n                attribute = \"LIGHT\",\n                monster_type = \"Dragon\",\n                monster_archetypes = { [\"Dragonmaid\"] = true },\n            },\n            cards_to_create = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) or card.joy_faceup_before_blind then\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.setting_blind and context.main_eval then\n                card.ability.extra.faceup_before_blind = nil\n                if G.GAME.blind and ((not G.GAME.blind.disabled) and (G.GAME.blind.boss)) then\n                    G.GAME.blind:disable()\n\n                    for i = 1, card.ability.extra.cards_to_create do\n                        JoyousSpring.create_pseudorandom({ { monster_archetypes = { \"Dragonmaid\" }, rarity = 1 } },\n                            'j_joy_dmaid_sheou', true)\n                    end\n                    JoyousSpring.transform_card(card, \"j_joy_dmaid_house\")\n                    return { message = localize('ph_boss_disabled') }\n                end\n            end\n        end\n    end,\n    in_pool = function(self, args)\n        return args and args.source and args.source == \"JoyousSpring\" or false\n    end,"
    },
    {
      "type": "Atlas",
      "key": "LiveTwin",
      "atlas": null,
      "pos": null,
      "raw": "key = \"LiveTwin\",\n    path = \"02LiveTwin.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Atlas",
      "key": "LiveTwin02",
      "atlas": null,
      "pos": null,
      "raw": "key = \"LiveTwin02\",\n    path = \"02LiveTwin02.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Joker",
      "key": "ltwin_lilla",
      "atlas": "LiveTwin",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"ltwin_lilla\",\n    atlas = 'LiveTwin',\n    pos = { x = 0, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 2,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.chips, card.ability.extra.cards_to_create } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_ltwin_kisikil\",                                                                             name = \"k_joy_creates\" },\n        { properties = { { monster_archetypes = { \"LiveTwin\" } }, { monster_archetypes = { \"EvilTwin\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Cyberse\",\n                monster_archetypes = { [\"LiveTwin\"] = true, [\"Lilla\"] = true },\n            },\n            chips = 40,\n            cards_to_create = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    chips = card.ability.extra.chips,\n                }\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not next(SMODS.find_card(\"j_joy_ltwin_kisikil\", true)) and not card.debuff and not from_debuff then\n            for i = 1, card.ability.extra.cards_to_create do\n                JoyousSpring.create_summon({\n                    key = \"j_joy_ltwin_kisikil\"\n                }, true)\n\n                card:juice_up()\n            end\n        end\n    end,\n    joker_display_def = function(JokerDisplay)\n        return {\n            text = {\n                { text = \"+\" },\n                { ref_table = \"card.ability.extra\", ref_value = \"chips\", retrigger_type = \"mult\" }\n            },\n            text_config = { colour = G.C.CHIPS },\n        }\n    end"
    },
    {
      "type": "Joker",
      "key": "ltwin_kisikil",
      "atlas": "LiveTwin",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"ltwin_kisikil\",\n    atlas = 'LiveTwin',\n    pos = { x = 1, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 2,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.mult, card.ability.extra.cards_to_create } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_ltwin_lilla\",                                                                               name = \"k_joy_creates\" },\n        { properties = { { monster_archetypes = { \"LiveTwin\" } }, { monster_archetypes = { \"EvilTwin\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"LIGHT\",\n                monster_type = \"Cyberse\",\n                monster_archetypes = { [\"LiveTwin\"] = true, [\"Kisikil\"] = true },\n            },\n            mult = 10,\n            cards_to_create = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    mult = card.ability.extra.mult,\n                }\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not next(SMODS.find_card(\"j_joy_ltwin_lilla\", true)) and not card.debuff and not from_debuff then\n            for i = 1, card.ability.extra.cards_to_create do\n                JoyousSpring.create_summon({\n                    key = \"j_joy_ltwin_lilla\"\n                }, true)\n                card:juice_up()\n            end\n        end\n    end,\n    joker_display_def = function(JokerDisplay)\n        return {\n            text = {\n                { text = \"+\" },\n                { ref_table = \"card.ability.extra\", ref_value = \"mult\", retrigger_type = \"mult\" }\n            },\n            text_config = { colour = G.C.MULT },\n        }\n    end"
    },
    {
      "type": "Joker",
      "key": "ltwin_lilla_treat",
      "atlas": "LiveTwin",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"ltwin_lilla_treat\",\n    atlas = 'LiveTwin',\n    pos = { x = 2, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.discards } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Zombie\",\n                monster_archetypes = { [\"LiveTwin\"] = true, [\"Lilla\"] = true },\n            },\n            discards = 1\n        },\n    },\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"LiveTwin\" } }, { monster_archetypes = { \"EvilTwin\" } } }, name = \"k_joy_archetype\" },\n    },\n    add_to_deck = function(self, card, from_debuff)\n        if not JoyousSpring.is_perma_debuffed(card) then\n            G.GAME.round_resets.discards = G.GAME.round_resets.discards + card.ability.extra.discards\n            ease_discard(card.ability.extra.discards)\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        if not JoyousSpring.is_perma_debuffed(card) then\n            G.GAME.round_resets.discards = G.GAME.round_resets.discards - card.ability.extra.discards\n            ease_discard(-card.ability.extra.discards)\n        end\n    end,\n    joy_set_cost = function(card)\n        if JoyousSpring.count_materials_owned({ { monster_archetypes = { \"Kisikil\" } } }) > 0 then\n            card.cost = 0\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "ltwin_lilla_sweet",
      "atlas": "LiveTwin",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"ltwin_lilla_sweet\",\n    atlas = 'LiveTwin',\n    pos = { x = 3, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.hands } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"LiveTwin\" } }, { monster_archetypes = { \"EvilTwin\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Spellcaster\",\n                monster_archetypes = { [\"LiveTwin\"] = true, [\"Lilla\"] = true },\n            },\n            hands = 1\n        },\n    },\n    add_to_deck = function(self, card, from_debuff)\n        if not JoyousSpring.is_perma_debuffed(card) then\n            G.GAME.round_resets.hands = G.GAME.round_resets.hands + card.ability.extra.hands\n            ease_hands_played(card.ability.extra.hands)\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        if not JoyousSpring.is_perma_debuffed(card) then\n            G.GAME.round_resets.hands = G.GAME.round_resets.hands - card.ability.extra.hands\n            ease_hands_played(-card.ability.extra.hands)\n        end\n    end,\n    joy_set_cost = function(card)\n        if JoyousSpring.count_materials_owned({ { monster_archetypes = { \"Kisikil\" } } }) > 0 then\n            card.cost = 0\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "ltwin_kisikil_frost",
      "atlas": "LiveTwin",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"ltwin_kisikil_frost\",\n    atlas = 'LiveTwin',\n    pos = { x = 0, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.h_size } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"LiveTwin\" } }, { monster_archetypes = { \"EvilTwin\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"LIGHT\",\n                monster_type = \"Aqua\",\n                monster_archetypes = { [\"LiveTwin\"] = true, [\"Kisikil\"] = true },\n            },\n            h_size = 1\n        },\n    },\n    add_to_deck = function(self, card, from_debuff)\n        if not JoyousSpring.is_perma_debuffed(card) then\n            G.hand:change_size(card.ability.extra.h_size)\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        if not JoyousSpring.is_perma_debuffed(card) then\n            G.hand:change_size(-card.ability.extra.h_size)\n        end\n    end,\n    joy_set_cost = function(card)\n        if JoyousSpring.count_materials_owned({ { monster_archetypes = { \"Lilla\" } } }) > 0 then\n            card.cost = 0\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "etwin_kisikil_deal",
      "atlas": "LiveTwin",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"etwin_kisikil_deal\",\n    atlas = 'LiveTwin',\n    pos = { x = 2, y = 1 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 4,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_main_deck_joker\" }\n        end\n        return { vars = { card.ability.extra.mult, card.ability.extra.h_size, card.ability.extra.mills, card.ability.extra.adds } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"LiveTwin\" } }, { monster_archetypes = { \"EvilTwin\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"LINK\",\n                attribute = \"LIGHT\",\n                monster_type = \"Fiend\",\n                monster_archetypes = { [\"EvilTwin\"] = true, [\"Kisikil\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"LINK\",\n                        materials = {\n                            { monster_archetypes = { \"Kisikil\" } },\n                        }\n                    }\n                },\n            },\n            mult = 10,\n            h_size = 1,\n            mills = 1,\n            adds = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    mult = card.ability.extra.mult,\n                }\n            end\n            if context.setting_blind and context.main_eval then\n                local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Lilla\" }, is_main_deck = true } })\n\n                for i = 1, card.ability.extra.mills do\n                    JoyousSpring.send_to_graveyard(pseudorandom_element(choices, 'j_joy_etwin_kisikil_deal'))\n                end\n                return {\n                    message = localize(\"k_joy_mill\")\n                }\n            end\n        end\n        if JoyousSpring.used_as_material(card, context) and JoyousSpring.is_summon_type(context.joy_card, \"LINK\") then\n            local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"EvilTwin\" }, is_extra_deck = true } })\n            for i = 1, card.ability.extra.adds do\n                local key_to_add, _ = pseudorandom_element(choices, 'j_joy_ignis_doyon')\n                if key_to_add and #JoyousSpring.extra_deck_area.cards < JoyousSpring.extra_deck_area.config.card_limit then\n                    JoyousSpring.add_to_extra_deck(key_to_add)\n                end\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not JoyousSpring.is_perma_debuffed(card) then\n            G.hand:change_size(card.ability.extra.h_size)\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        if not JoyousSpring.is_perma_debuffed(card) then\n            G.hand:change_size(-card.ability.extra.h_size)\n        end\n    end,\n    joker_display_def = function(JokerDisplay)\n        return {\n            text = {\n                { text = \"+\" },\n                { ref_table = \"card.ability.extra\", ref_value = \"mult\", retrigger_type = \"mult\" }\n            },\n            text_config = { colour = G.C.MULT },\n        }\n    end"
    },
    {
      "type": "Joker",
      "key": "etwin_kisikil",
      "atlas": "LiveTwin",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"etwin_kisikil\",\n    atlas = 'LiveTwin',\n    pos = { x = 3, y = 1 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n        end\n        return { vars = { card.ability.extra.mult, card.ability.extra.h_size, card.ability.extra.revives } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"LiveTwin\" } }, { monster_archetypes = { \"EvilTwin\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"LINK\",\n                attribute = \"LIGHT\",\n                monster_type = \"Fiend\",\n                monster_archetypes = { [\"EvilTwin\"] = true, [\"Kisikil\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"LINK\",\n                        materials = {\n                            { monster_archetypes = { \"Kisikil\" } },\n                            {}\n                        }\n                    }\n                },\n            },\n            mult = 20,\n            h_size = 1,\n            revives = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    mult = card.ability.extra.mult,\n                }\n            end\n            if context.setting_blind and context.main_eval then\n                local has_revived = false\n                if JoyousSpring.graveyard[\"j_joy_etwin_lilla\"] and JoyousSpring.graveyard[\"j_joy_etwin_lilla\"].summonable > 0 then\n                    for i = 1, card.ability.extra.revives do\n                        local revived_card = JoyousSpring.revive(\"j_joy_etwin_lilla\", true)\n                        has_revived = revived_card and true or has_revived\n                    end\n                else\n                    for i = 1, card.ability.extra.revives do\n                        local revived_card = JoyousSpring.revive_pseudorandom(\n                            { { monster_archetypes = { \"Lilla\" } } },\n                            'j_joy_etwin_kisikil',\n                            true\n                        )\n                        has_revived = revived_card and true or has_revived\n                    end\n                end\n                if has_revived then\n                    return {\n                        message = localize(\"k_joy_revive\")\n                    }\n                end\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff and JoyousSpring.count_materials_owned({ { monster_archetypes = { \"Lilla\" } } }) > 0 then\n            G.hand:change_size(card.ability.extra.h_size)\n            SMODS.calculate_effect(\n                { message = localize { type = 'variable', key = 'a_handsize', vars = { card.ability.extra.h_size } } },\n                card)\n        end\n    end,\n    joker_display_def = function(JokerDisplay)\n        return {\n            text = {\n                { text = \"+\" },\n                { ref_table = \"card.ability.extra\", ref_value = \"mult\", retrigger_type = \"mult\" }\n            },\n            text_config = { colour = G.C.MULT },\n        }\n    end"
    },
    {
      "type": "Joker",
      "key": "etwin_lilla",
      "atlas": "LiveTwin",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = \"etwin_lilla\",\n    atlas = 'LiveTwin',\n    pos = { x = 0, y = 2 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n        end\n        return { vars = { card.ability.extra.chips, card.ability.extra.money, card.ability.extra.revives } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"LiveTwin\" } }, { monster_archetypes = { \"EvilTwin\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"LINK\",\n                attribute = \"DARK\",\n                monster_type = \"Fiend\",\n                monster_archetypes = { [\"EvilTwin\"] = true, [\"Lilla\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"LINK\",\n                        materials = {\n                            { monster_archetypes = { \"Lilla\" } },\n                            {}\n                        }\n                    }\n                },\n            },\n            chips = 80,\n            money = 10,\n            revives = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    chips = card.ability.extra.chips,\n                }\n            end\n            if context.setting_blind and context.main_eval then\n                local has_revived = false\n                if JoyousSpring.graveyard[\"j_joy_etwin_kisikil\"] and JoyousSpring.graveyard[\"j_joy_etwin_kisikil\"].summonable > 0 then\n                    for i = 1, card.ability.extra.revives do\n                        local revived_card = JoyousSpring.revive(\"j_joy_etwin_kisikil\", true)\n                        has_revived = revived_card and true or has_revived\n                    end\n                else\n                    for i = 1, card.ability.extra.revives do\n                        local revived_card = JoyousSpring.revive_pseudorandom(\n                            { { monster_archetypes = { \"Kisikil\" } } },\n                            'j_joy_etwin_lilla',\n                            true\n                        )\n                        has_revived = revived_card and true or has_revived\n                    end\n                end\n                if has_revived then\n                    return {\n                        message = localize(\"k_joy_revive\")\n                    }\n                end\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff and JoyousSpring.count_materials_owned({ { monster_archetypes = { \"Kisikil\" } } }) > 0 then\n            SMODS.calculate_effect({ dollars = card.ability.extra.money }, card)\n        end\n    end,\n    joker_display_def = function(JokerDisplay)\n        return {\n            text = {\n                { text = \"+\" },\n                { ref_table = \"card.ability.extra\", ref_value = \"chips\", retrigger_type = \"mult\" }\n            },\n            text_config = { colour = G.C.CHIPS },\n        }\n    end"
    },
    {
      "type": "Joker",
      "key": "etwin_kisikil_lilla",
      "atlas": "LiveTwin",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"etwin_kisikil_lilla\",\n    atlas = 'LiveTwin',\n    pos = { x = 1, y = 1 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        return {\n            vars = {\n                card.ability.extra.chips,\n                card.ability.extra.mult,\n                card.ability.extra.h_size,\n                card.ability.extra.chips *\n                JoyousSpring.count_materials_in_graveyard({ { monster_archetypes = { \"Lilla\" } } }),\n                card.ability.extra.mult *\n                JoyousSpring.count_materials_in_graveyard({ { monster_archetypes = { \"Kisikil\" } } })\n            }\n        }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"LiveTwin\" } }, { monster_archetypes = { \"EvilTwin\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Fiend\",\n                monster_archetypes = { [\"EvilTwin\"] = true, [\"Kisikil\"] = true, [\"Lilla\"] = true },\n                cannot_revive = true,\n            },\n            chips = 80,\n            mult = 20,\n            h_size = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.setting_blind and context.main_eval then\n                local links_owned = JoyousSpring.count_materials_owned({ { summon_type = \"LINK\" } })\n                if links_owned and links_owned > 0 then\n                    ease_discard(-links_owned)\n                    card:juice_up()\n                end\n            end\n            if context.joker_main then\n                return {\n                    chips = card.ability.extra.chips *\n                        JoyousSpring.count_materials_in_graveyard({ { monster_archetypes = { \"Lilla\" } } }),\n                    mult = card.ability.extra.mult *\n                        JoyousSpring.count_materials_in_graveyard({ { monster_archetypes = { \"Kisikil\" } } }),\n                }\n            end\n        end\n    end,\n    joker_display_def = function(JokerDisplay)\n        return {\n            text = {\n                { text = \"+\",                              colour = G.C.CHIPS },\n                { ref_table = \"card.joker_display_values\", ref_value = \"chips\", colour = G.C.CHIPS, retrigger_type = \"mult\" },\n                { text = \" +\",                             colour = G.C.MULT },\n                { ref_table = \"card.joker_display_values\", ref_value = \"mult\",  colour = G.C.MULT,  retrigger_type = \"mult\" }\n            },\n            calc_function = function(card)\n                card.joker_display_values.chips = card.ability.extra.chips *\n                    JoyousSpring.count_materials_in_graveyard({ { monster_archetypes = { \"Lilla\" } } })\n                card.joker_display_values.mult = card.ability.extra.mult *\n                    JoyousSpring.count_materials_in_graveyard({ { monster_archetypes = { \"Kisikil\" } } })\n            end\n        }\n    end"
    },
    {
      "type": "Joker",
      "key": "etwin_sunny",
      "atlas": "LiveTwin",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "key = \"etwin_sunny\",\n    atlas = 'LiveTwin',\n    pos = { x = 1, y = 2 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 8,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n        end\n        return { vars = { card.ability.extra.chips, card.ability.extra.mult, card.ability.extra.revives } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_etwin_kisikil\",                                                                             \"j_joy_etwin_lilla\",     name = \"Revives\" },\n        { properties = { { monster_archetypes = { \"LiveTwin\" } }, { monster_archetypes = { \"EvilTwin\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"LINK\",\n                attribute = \"LIGHT\",\n                monster_type = \"Fiend\",\n                monster_archetypes = { [\"EvilTwin\"] = true, [\"Kisikil\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"LINK\",\n                        materials = {\n                            { monster_archetypes = { \"EvilTwin\" } },\n                            { monster_archetypes = { \"EvilTwin\" } },\n                        }\n                    }\n                },\n            },\n            chips = 160,\n            mult = 40,\n            revives = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.end_of_round and context.game_over == false and context.main_eval then\n                if #JoyousSpring.extra_deck_area.cards < JoyousSpring.extra_deck_area.config.card_limit +\n                    ((card.edition and card.edition.negative) and 1 or 0) then\n                    local is_lilla_owned = JoyousSpring.count_materials_owned({ { monster_archetypes = { \"Lilla\" } } }) >\n                        0\n                    local kisikil_summoned = {}\n                    local has_revived = false\n                    if JoyousSpring.graveyard[\"j_joy_etwin_kisikil\"] and JoyousSpring.graveyard[\"j_joy_etwin_kisikil\"].summonable > 0 then\n                        for i = 1, card.ability.extra.revives do\n                            local revived_card = JoyousSpring.revive(\"j_joy_etwin_kisikil\", true)\n                            if revived_card then\n                                table.insert(kisikil_summoned, revived_card)\n                                has_revived = true\n                            end\n                        end\n                    end\n                    if JoyousSpring.graveyard[\"j_joy_etwin_lilla\"] and JoyousSpring.graveyard[\"j_joy_etwin_lilla\"].summonable > 0 then\n                        for i = 1, card.ability.extra.revives do\n                            local revived_card = JoyousSpring.revive(\"j_joy_etwin_lilla\", true)\n                            if revived_card then\n                                has_revived = true\n                            end\n                        end\n                    end\n                    if not is_lilla_owned then\n                        for _, joker in ipairs(kisikil_summoned) do\n                            joker.config.center:add_to_deck(joker)\n                        end\n                    end\n                    if has_revived then\n                        JoyousSpring.return_to_extra_deck(card)\n                    end\n                end\n            end\n            if context.joker_main then\n                return {\n                    chips = card.ability.extra.chips,\n                    mult = card.ability.extra.mult,\n                }\n            end\n        end\n    end,\n    joker_display_def = function(JokerDisplay)\n        return {\n            text = {\n                { text = \"+\",                       colour = G.C.CHIPS },\n                { ref_table = \"card.ability.extra\", ref_value = \"chips\", colour = G.C.CHIPS, retrigger_type = \"mult\" },\n                { text = \" +\",                      colour = G.C.MULT },\n                { ref_table = \"card.ability.extra\", ref_value = \"mult\",  colour = G.C.MULT,  retrigger_type = \"mult\" }\n            },\n        }\n    end"
    },
    {
      "type": "Joker",
      "key": "ltwin_channel",
      "atlas": "LiveTwin02",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"ltwin_channel\",\n    atlas = 'LiveTwin02',\n    pos = { x = 0, y = 0 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_tribute\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n        end\n        return { vars = { card.ability.extra.tributes, card.ability.extra.revives } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"LiveTwin\" } }, { monster_archetypes = { \"EvilTwin\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_field_spell = true,\n                monster_archetypes = { [\"LiveTwin\"] = true },\n            },\n            tributes = 2,\n            revives = 1,\n        },\n    },\n    calculate = function(self, card, context)\n        if context.joy_activate_effect and context.joy_activated_card == card then\n            local materials = JoyousSpring.get_materials_owned(\n                { { summon_type = \"LINK\", monster_archetypes = { \"Kisikil\" } }, { summon_type = \"LINK\", monster_archetypes = { \"Lilla\" } } },\n                false, true)\n            if #materials >= card.ability.extra.tributes then\n                JoyousSpring.create_overlay_effect_selection(card, materials, card.ability.extra.tributes,\n                    card.ability.extra.tributes)\n            end\n        end\n        if context.joy_exit_effect_selection and context.joy_card == card and\n            #context.joy_selection == card.ability.extra.tributes and G.GAME.blind.in_blind then\n            JoyousSpring.tribute(card, context.joy_selection)\n\n            G.GAME.chips = G.GAME.chips * 2\n            if (G.GAME.chips >= G.GAME.blind.chips) then\n                G.STATE = G.STATES.HAND_PLAYED\n                G.STATE_COMPLETE = true\n                end_round()\n            end\n\n            return {\n                message = localize(\"k_joy_activated_ex\")\n            }\n        end\n        if context.ending_shop and context.main_eval then\n            for i = 1, card.ability.extra.revives do\n                JoyousSpring.revive_pseudorandom(\n                    { { monster_archetypes = { \"Kisikil\" } }, { monster_archetypes = { \"Lilla\" } } },\n                    'j_joy_ltwin_channel',\n                    true\n                )\n            end\n        end\n    end,\n    joy_can_activate = function(card)\n        if not G.GAME.blind.in_blind then\n            return false\n        end\n        local materials = JoyousSpring.get_materials_owned(\n            { { summon_type = \"LINK\", monster_archetypes = { \"Kisikil\" } }, { summon_type = \"LINK\", monster_archetypes = { \"Lilla\" } } },\n            false, true)\n        return #materials >= card.ability.extra.tributes\n    end,"
    },
    {
      "type": "Atlas",
      "key": "Dogmatika",
      "atlas": null,
      "pos": null,
      "raw": "key = \"Dogmatika\",\n    path = \"03Dogmatika.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Atlas",
      "key": "Dogmatika02",
      "atlas": null,
      "pos": null,
      "raw": "key = \"Dogmatika02\",\n    path = \"03Dogmatika02.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Atlas",
      "key": "Dogmatika03",
      "atlas": null,
      "pos": null,
      "raw": "key = \"Dogmatika03\",\n    path = \"03Dogmatika03.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Joker",
      "key": "dogma_ecclesia",
      "atlas": "Dogmatika",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"dogma_ecclesia\",\n    atlas = 'Dogmatika',\n    pos = { x = 0, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 7,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_extra_deck_joker\" }\n        end\n        return { vars = { card.ability.extra.base_xmult, card.ability.extra.xmult } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Dogmatika\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"LIGHT\",\n                monster_type = \"Spellcaster\",\n                monster_archetypes = { [\"Dogmatika\"] = true },\n            },\n            base_xmult = 0.05,\n            xmult = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.selling_card and JoyousSpring.is_extra_deck_monster(context.card) then\n                card.ability.extra.xmult = card.ability.extra.xmult + card.ability.extra.base_xmult\n                return {\n                    message = localize('k_upgrade_ex')\n                }\n            end\n            if context.joker_main then\n                return {\n                    xmult = card.ability.extra.xmult\n                }\n            end\n        end\n    end,\n    joker_display_def = function(JokerDisplay)\n        return {\n            text = {\n                {\n                    border_nodes = {\n                        { text = \"X\" },\n                        { ref_table = \"card.ability.extra\", ref_value = \"xmult\", retrigger_type = \"exp\" }\n                    }\n                }\n            },\n        }\n    end"
    },
    {
      "type": "Joker",
      "key": "dogma_fleur",
      "atlas": "Dogmatika",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"dogma_fleur\",\n    atlas = 'Dogmatika',\n    pos = { x = 1, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 4,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.mult } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Dogmatika\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"LIGHT\",\n                monster_type = \"Spellcaster\",\n                monster_archetypes = { [\"Dogmatika\"] = true },\n            },\n            mult = 25\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.other_joker and context.other_joker.facing == \"front\" and JoyousSpring.is_monster_archetype(context.other_joker, \"Dogmatika\") then\n                return {\n                    mult = card.ability.extra.mult,\n                    message_card = context.other_joker\n                }\n            end\n        end\n    end,\n    joy_set_cost = function(card)\n        if JoyousSpring.count_materials_owned({ { is_extra_deck = true, is_debuffed = true } }) > 0 or\n            (next(SMODS.find_card(\"j_joy_dogma_relic\")) and\n                JoyousSpring.count_materials_in_graveyard({ { is_extra_deck = true } }) > 0) then\n            card.cost = 0\n        end\n    end,\n    joker_display_def = function(JokerDisplay)\n        return {\n            mod_function = function(card, mod_joker)\n                return {\n                    mult = (JoyousSpring.is_monster_archetype(card, \"Dogmatika\") and mod_joker.ability.extra.mult and\n                        mod_joker.ability.extra.mult * JokerDisplay.calculate_joker_triggers(mod_joker) or nil)\n                }\n            end\n        }\n    end"
    },
    {
      "type": "Joker",
      "key": "dogma_maximus",
      "atlas": "Dogmatika",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"dogma_maximus\",\n    atlas = 'Dogmatika',\n    pos = { x = 2, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 2,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_extra_deck_joker\" }\n        end\n        return { vars = { card.ability.extra.cards_to_create } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Dogmatika\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"LIGHT\",\n                monster_type = \"Spellcaster\",\n                monster_archetypes = { [\"Dogmatika\"] = true },\n            },\n            cards_to_create = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.setting_blind and context.main_eval then\n                for i = 1, card.ability.extra.cards_to_create do\n                    local key_to_add = pseudorandom_element(\n                        JoyousSpring.get_materials_in_collection({ { is_extra_deck = true } }),\n                        'j_joy_dogma_maximus')\n                    if key_to_add then\n                        JoyousSpring.create_perma_debuffed_card(key_to_add, \"Dogmatika\", { negative = true })\n                    end\n                end\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "dogma_adin",
      "atlas": "Dogmatika",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"dogma_adin\",\n    atlas = 'Dogmatika',\n    pos = { x = 0, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 4,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_extra_deck_joker\" }\n        end\n        return { vars = { card.ability.extra.cards_to_create } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Dogmatika\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"LIGHT\",\n                monster_type = \"Spellcaster\",\n                monster_archetypes = { [\"Dogmatika\"] = true },\n            },\n            cards_to_create = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.end_of_round and context.game_over == false and context.main_eval then\n                if G.GAME.blind.boss then\n                    for i = 1, card.ability.extra.cards_to_create do\n                        JoyousSpring.create_pseudorandom(\n                            { { monster_archetypes = { \"Dogmatika\" }, summon_type = \"NORMAL\" } },\n                            'j_joy_dogma_adin', true)\n                    end\n                end\n            end\n        end\n    end,\n    joy_set_cost = function(card)\n        if JoyousSpring.count_materials_owned({ { is_extra_deck = true, is_debuffed = true } }) > 0 or\n            (next(SMODS.find_card(\"j_joy_dogma_relic\")) and\n                JoyousSpring.count_materials_in_graveyard({ { is_extra_deck = true } }) > 0) then\n            card.cost = 0\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "dogma_theo",
      "atlas": "Dogmatika",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"dogma_theo\",\n    atlas = 'Dogmatika',\n    pos = { x = 1, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 3,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_extra_deck_joker\" }\n        end\n        local debuffed_ed_count = JoyousSpring.count_materials_owned({ { is_extra_deck = true, is_debuffed = true } })\n        if next(SMODS.find_card(\"j_joy_dogma_relic\")) then\n            debuffed_ed_count = debuffed_ed_count +\n                JoyousSpring.count_materials_in_graveyard({ { is_extra_deck = true } })\n        end\n        return { vars = { card.ability.extra.chips, card.ability.extra.extra_chips, card.ability.extra.chips + card.ability.extra.extra_chips * debuffed_ed_count } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Dogmatika\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"LIGHT\",\n                monster_type = \"Spellcaster\",\n                monster_archetypes = { [\"Dogmatika\"] = true },\n            },\n            chips = 100,\n            extra_chips = 100\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                local debuffed_ed_count = JoyousSpring.count_materials_owned({ { is_extra_deck = true, is_debuffed = true } })\n                if next(SMODS.find_card(\"j_joy_dogma_relic\")) then\n                    debuffed_ed_count = debuffed_ed_count +\n                        JoyousSpring.count_materials_in_graveyard({ { is_extra_deck = true } })\n                end\n\n                return {\n                    chips = card.ability.extra.chips + card.ability.extra.extra_chips * debuffed_ed_count\n                }\n            end\n        end\n    end,\n    joy_set_cost = function(card)\n        if JoyousSpring.count_materials_owned({ { is_extra_deck = true, is_debuffed = true } }) > 0 or\n            (next(SMODS.find_card(\"j_joy_dogma_relic\")) and\n                JoyousSpring.count_materials_in_graveyard({ { is_extra_deck = true } }) > 0) then\n            card.cost = 0\n        end\n    end,\n    joker_display_def = function(JokerDisplay)\n        return {\n            text = {\n                { text = \"+\", },\n                { ref_table = \"card.joker_display_values\", ref_value = \"chips\", retrigger_type = \"mult\" },\n            },\n            text_config = { colour = G.C.CHIPS },\n            calc_function = function(card)\n                local debuffed_ed_count = JoyousSpring.count_materials_owned({ { is_extra_deck = true, is_debuffed = true } })\n                if next(SMODS.find_card(\"j_joy_dogma_relic\")) then\n                    debuffed_ed_count = debuffed_ed_count +\n                        JoyousSpring.count_materials_in_graveyard({ { is_extra_deck = true } })\n                end\n                card.joker_display_values.chips = card.ability.extra.chips +\n                    card.ability.extra.extra_chips * debuffed_ed_count\n            end\n        }\n    end"
    },
    {
      "type": "Joker",
      "key": "dogma_ashiyan",
      "atlas": "Dogmatika",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"dogma_ashiyan\",\n    atlas = 'Dogmatika',\n    pos = { x = 2, y = 1 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 2,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_extra_deck_joker\" }\n        end\n        return { vars = { card.ability.extra.revives, card.ability.extra.adds } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Dogmatika\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"LIGHT\",\n                monster_type = \"Spellcaster\",\n                monster_archetypes = { [\"Dogmatika\"] = true },\n            },\n            revives = 1,\n            adds = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.end_of_round and context.game_over == false and context.main_eval and G.GAME.blind.boss then\n                local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Dogmatika\" }, summon_type = \"RITUAL\" } })\n                for i = 1, card.ability.extra.adds do\n                    key_to_add = pseudorandom_element(choices, 'j_joy_dogma_ashiyan')\n                    JoyousSpring.add_monster_tag(key_to_add or \"j_joy_dogma_relic\")\n                end\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not from_debuff and not card.debuff then\n            for i = 1, card.ability.extra.revives do\n                JoyousSpring.revive_pseudorandom(\n                    { { monster_archetypes = { \"Dogmatika\" } } },\n                    'j_joy_dogma_ashiyan',\n                    true\n                )\n            end\n        end\n    end,\n    joy_set_cost = function(card)\n        if JoyousSpring.count_materials_owned({ { is_extra_deck = true, is_debuffed = true } }) > 0 or\n            (next(SMODS.find_card(\"j_joy_dogma_relic\")) and\n                JoyousSpring.count_materials_in_graveyard({ { is_extra_deck = true } }) > 0) then\n            card.cost = 0\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "dogma_nexus",
      "atlas": "Dogmatika",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = \"dogma_nexus\",\n    atlas = 'Dogmatika',\n    pos = { x = 0, y = 2 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_extra_deck_joker\" }\n        end\n        return { vars = { card.ability.extra.duplicates } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Dogmatika\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"LIGHT\",\n                monster_type = \"Spellcaster\",\n                monster_archetypes = { [\"Dogmatika\"] = true },\n            },\n            duplicates = 2\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.end_of_round and context.game_over == false and context.main_eval then\n                for i = 1, card.ability.extra.duplicates do\n                    local choices = next(SMODS.find_card(\"j_joy_dogma_relic\")) and\n                        JoyousSpring.get_all_material_keys({ { is_extra_deck = true } }) or\n                        JoyousSpring.get_materials_owned({ { is_extra_deck = true } })\n\n                    local key_to_add = pseudorandom_element(choices, 'j_joy_dogma_maximus')\n                    if key_to_add and type(key_to_add) ~= \"string\" then\n                        key_to_add = key_to_add.config.center_key\n                    end\n                    if key_to_add then\n                        JoyousSpring.create_perma_debuffed_card(key_to_add, \"Dogmatika\", { negative = true })\n                    end\n                end\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "dogma_relic",
      "atlas": "Dogmatika",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "key = \"dogma_relic\",\n    atlas = 'Dogmatika',\n    pos = { x = 1, y = 2 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_extra_deck_joker\" }\n        end\n        return {\n            vars = {\n                card.ability.extra.base_h_size,\n                card.ability.extra.debuffed_ed_count,\n                math.floor((JoyousSpring.count_materials_owned({ { is_extra_deck = true, is_debuffed = true } }) +\n                        JoyousSpring.count_materials_in_graveyard({ { is_extra_deck = true } })) /\n                    card.ability.extra.debuffed_ed_count)\n            }\n\n        }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Dogmatika\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"RITUAL\",\n                attribute = \"LIGHT\",\n                monster_type = \"Spellcaster\",\n                monster_archetypes = { [\"Dogmatika\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"RITUAL\",\n                        materials = {\n                            { monster_archetypes = { \"Dogmatika\" } },\n                            {},\n                        }\n                    }\n                }\n            },\n            base_h_size = 1,\n            h_size = 0,\n            debuffed_ed_count = 5\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.hand_drawn and not context.blueprint_card and not context.retrigger_joker then\n                local debuffed_ed_count = JoyousSpring.count_materials_owned({ { is_extra_deck = true, is_debuffed = true } }) +\n                    JoyousSpring.count_materials_in_graveyard({ { is_extra_deck = true } })\n                debuffed_ed_count = math.floor(debuffed_ed_count / card.ability.extra.debuffed_ed_count)\n                if debuffed_ed_count ~= card.ability.extra.h_size then\n                    G.hand:change_size(debuffed_ed_count - card.ability.extra.h_size)\n                    card.ability.extra.h_size = debuffed_ed_count\n                end\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        local debuffed_ed_count = JoyousSpring.count_materials_owned({ { is_extra_deck = true, is_debuffed = true } }) +\n            JoyousSpring.count_materials_in_graveyard({ { is_extra_deck = true } })\n        debuffed_ed_count = math.floor(debuffed_ed_count / card.ability.extra.debuffed_ed_count)\n        G.hand:change_size(debuffed_ed_count)\n        card.ability.extra.h_size = debuffed_ed_count\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        G.hand:change_size(-card.ability.extra.h_size)\n    end,"
    },
    {
      "type": "Joker",
      "key": "dogma_knight",
      "atlas": "Dogmatika",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "key = \"dogma_knight\",\n    atlas = 'Dogmatika',\n    pos = { x = 2, y = 2 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_extra_deck_joker\" }\n        end\n        local debuffed_ed_count = JoyousSpring.count_materials_owned({ { is_extra_deck = true, is_debuffed = true } })\n        if next(SMODS.find_card(\"j_joy_dogma_relic\")) then\n            debuffed_ed_count = debuffed_ed_count +\n                JoyousSpring.count_materials_in_graveyard({ { is_extra_deck = true } })\n        end\n        return { vars = { card.ability.extra.mult, debuffed_ed_count * card.ability.extra.mult } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Dogmatika\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"RITUAL\",\n                attribute = \"LIGHT\",\n                monster_type = \"Spellcaster\",\n                monster_archetypes = { [\"Dogmatika\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"RITUAL\",\n                        materials = {\n                            { monster_archetypes = { \"Dogmatika\" } },\n                            {},\n                        }\n                    }\n                }\n            },\n            mult = 25\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                local debuffed_ed_count = JoyousSpring.count_materials_owned({ { is_extra_deck = true, is_debuffed = true } })\n                if next(SMODS.find_card(\"j_joy_dogma_relic\")) then\n                    debuffed_ed_count = debuffed_ed_count +\n                        JoyousSpring.count_materials_in_graveyard({ { is_extra_deck = true } })\n                end\n                if debuffed_ed_count > 0 then\n                    return {\n                        mult = card.ability.extra.mult * debuffed_ed_count\n                    }\n                end\n            end\n        end\n    end,\n    joy_create_card_for_shop = function(card, other_card, area)\n        if other_card and JoyousSpring.is_extra_deck_monster(other_card) and next(SMODS.find_card(\"j_joy_dogma_knight\")) then\n            other_card.ability.extra.joyous_spring.is_free = true\n            JoyousSpring.create_perma_debuffed_card(other_card, \"Dogmatika\")\n            other_card:set_cost()\n        end\n    end,\n    joker_display_def = function(JokerDisplay)\n        return {\n            text = {\n                { text = \"+\", },\n                { ref_table = \"card.joker_display_values\", ref_value = \"mult\", retrigger_type = \"mult\" },\n            },\n            text_config = { colour = G.C.MULT },\n            calc_function = function(card)\n                local debuffed_ed_count = JoyousSpring.count_materials_owned({ { is_extra_deck = true, is_debuffed = true } })\n                if next(SMODS.find_card(\"j_joy_dogma_relic\")) then\n                    debuffed_ed_count = debuffed_ed_count +\n                        JoyousSpring.count_materials_in_graveyard({ { is_extra_deck = true } })\n                end\n                card.joker_display_values.mult = card.ability.extra.mult * debuffed_ed_count\n            end\n        }\n    end"
    },
    {
      "type": "Joker",
      "key": "dogma_albazoa",
      "atlas": "Dogmatika03",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"dogma_albazoa\",\n    atlas = 'Dogmatika03',\n    pos = { x = 0, y = 0 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_extra_deck_joker\" }\n        end\n        local debuffed_ed_count = JoyousSpring.count_materials_owned({ { is_extra_deck = true, is_debuffed = true } })\n        if next(SMODS.find_card(\"j_joy_dogma_relic\")) then\n            debuffed_ed_count = debuffed_ed_count +\n                JoyousSpring.count_materials_in_graveyard({ { is_extra_deck = true } })\n        end\n        return { vars = { card.ability.extra.mills, card.ability.extra.xmult, 1 + debuffed_ed_count * card.ability.extra.xmult } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Dogmatika\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"RITUAL\",\n                attribute = \"LIGHT\",\n                monster_type = \"Spellcaster\",\n                monster_archetypes = { [\"Dogmatika\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"RITUAL\",\n                        materials = {\n                            { monster_archetypes = { \"Dogmatika\" } },\n                            { monster_archetypes = { \"Dogmatika\" } },\n                        }\n                    }\n                }\n            },\n            mills = 1,\n            xmult = 0.05\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.setting_blind and context.main_eval and #JoyousSpring.extra_deck_area.cards > 0 then\n                for _, joker in ipairs(JoyousSpring.extra_deck_area.cards) do\n                    for i = 1, card.ability.extra.mills do\n                        JoyousSpring.send_to_graveyard(joker.config.center.key)\n                    end\n                end\n                return { message = localize(\"k_joy_mill\") }\n            end\n            if context.other_joker and JoyousSpring.is_main_deck_monster(context.other_joker) then\n                local debuffed_ed_count = JoyousSpring.count_materials_owned({ { is_extra_deck = true, is_debuffed = true } })\n                if next(SMODS.find_card(\"j_joy_dogma_relic\")) then\n                    debuffed_ed_count = debuffed_ed_count +\n                        JoyousSpring.count_materials_in_graveyard({ { is_extra_deck = true } })\n                end\n                if debuffed_ed_count > 0 then\n                    return {\n                        xmult = 1 + card.ability.extra.xmult * debuffed_ed_count,\n                        message_card = context.other_joker\n                    }\n                end\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "dogma_nation",
      "atlas": "Dogmatika02",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"dogma_nation\",\n    atlas = 'Dogmatika02',\n    pos = { x = 0, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_tribute\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_extra_deck_joker\" }\n        end\n        local debuffed_ed_count = JoyousSpring.count_materials_owned({ { is_extra_deck = true, is_debuffed = true } })\n        if next(SMODS.find_card(\"j_joy_dogma_relic\")) then\n            debuffed_ed_count = debuffed_ed_count +\n                JoyousSpring.count_materials_in_graveyard({ { is_extra_deck = true } })\n        end\n        return { vars = { card.ability.extra.money, card.ability.extra.money * debuffed_ed_count, card.ability.extra.tributes, card.ability.extra.creates } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Dogmatika\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_field_spell = true,\n                monster_archetypes = { [\"Dogmatika\"] = true },\n            },\n            money = 1,\n            tributes = 4,\n            creates = 1,\n        },\n    },\n    calculate = function(self, card, context)\n        if context.joy_activate_effect and context.joy_activated_card == card then\n            local materials = JoyousSpring.get_materials_owned({ { is_extra_deck = true } }, false, true)\n            if #materials >= card.ability.extra.tributes then\n                JoyousSpring.create_overlay_effect_selection(card, materials, card.ability.extra.tributes,\n                    card.ability.extra.tributes)\n            end\n        end\n        if context.joy_exit_effect_selection and context.joy_card == card and\n            #context.joy_selection == card.ability.extra.tributes then\n            local tribute_amount = card.ability.extra.tributes\n            for _, joker in ipairs(context.joy_selection) do\n                tribute_amount = tribute_amount - ((joker.edition and joker.edition.negative) and 1 or 0)\n            end\n\n            if #G.jokers.cards + G.GAME.joker_buffer - tribute_amount < G.jokers.config.card_limit then\n                JoyousSpring.tribute(card, context.joy_selection)\n\n                for i = 1, card.ability.extra.creates do\n                    if #G.jokers.cards + G.GAME.joker_buffer - tribute_amount < G.jokers.config.card_limit then\n                        JoyousSpring.create_pseudorandom(\n                            { { monster_archetypes = { \"Dogmatika\" } } },\n                            'j_joy_dogma_nation', true, true)\n                    end\n                end\n            end\n        end\n    end,\n    calc_dollar_bonus = function(self, card)\n        local debuffed_ed_count = JoyousSpring.count_materials_owned({ { is_extra_deck = true, is_debuffed = true } })\n        if next(SMODS.find_card(\"j_joy_dogma_relic\")) then\n            debuffed_ed_count = debuffed_ed_count +\n                JoyousSpring.count_materials_in_graveyard({ { is_extra_deck = true } })\n        end\n        local ret = card.ability.extra.money * debuffed_ed_count\n        return ret > 0 and ret or nil\n    end,\n    joy_can_activate = function(card)\n        if not (#G.jokers.cards + G.GAME.joker_buffer - card.ability.extra.tributes < G.jokers.config.card_limit) then\n            return false\n        end\n        local materials = JoyousSpring.get_materials_owned({ { is_extra_deck = true } }, false, true)\n        return #materials >= card.ability.extra.tributes\n    end,"
    },
    {
      "type": "Atlas",
      "key": "GhostGirls",
      "atlas": null,
      "pos": null,
      "raw": "key = \"GhostGirls\",\n    path = \"04GhostGirls.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Joker",
      "key": "yokai_ogre",
      "atlas": "GhostGirls",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"yokai_ogre\",\n    atlas = 'GhostGirls',\n    pos = { x = 0, y = 0 },\n    rarity = 4,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 12,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.base_xmult, card.ability.extra.xmult } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_tuner = true,\n                attribute = \"LIGHT\",\n                monster_type = \"Psychic\"\n            },\n            base_xmult = 0.5,\n            xmult = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.destroy_card and context.cardarea == G.play then\n                card.ability.extra.xmult = card.ability.extra.xmult + card.ability.extra.base_xmult\n                for _, joker in ipairs(SMODS.find_card(\"j_joy_yokai_ogre\")) do\n                    if joker ~= card then\n                        joker.ability.extra.xmult = joker.ability.extra.xmult + joker.ability.extra.base_xmult\n                        return { message = localize('k_upgrade_ex') }\n                    end\n                end\n                return { remove = true, message = localize('k_upgrade_ex'), message_card = card }\n            end\n\n            if context.joker_main then\n                return {\n                    xmult = card.ability.extra.xmult\n                }\n            end\n        end\n    end,\n    get_weight = function(self, args)\n        return 0.01\n    end,\n    joker_display_def = function(JokerDisplay)\n        return {\n            text = {\n                {\n                    border_nodes = {\n                        { text = \"X\" },\n                        { ref_table = \"card.ability.extra\", ref_value = \"xmult\", retrigger_type = \"exp\" }\n                    }\n                }\n            },\n        }\n    end"
    },
    {
      "type": "Joker",
      "key": "yokai_reaper",
      "atlas": "GhostGirls",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"yokai_reaper\",\n    atlas = 'GhostGirls',\n    pos = { x = 1, y = 0 },\n    rarity = 4,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 12,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_extra_deck_joker\" }\n        end\n        return { vars = { card.ability.extra.xmult, 1 + card.ability.extra.xmult * JoyousSpring.count_materials_in_graveyard({ { is_extra_deck = true } }) } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_tuner = true,\n                attribute = \"DARK\",\n                monster_type = \"Zombie\"\n            },\n            xmult = 0.2\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    xmult = 1 +\n                        card.ability.extra.xmult *\n                        JoyousSpring.count_materials_in_graveyard({ { is_extra_deck = true } })\n                }\n            end\n        end\n    end,\n    get_weight = function(self, args)\n        return 0.01\n    end,\n    joker_display_def = function(JokerDisplay)\n        return {\n            text = {\n                {\n                    border_nodes = {\n                        { text = \"X\" },\n                        { ref_table = \"card.joker_display_values\", ref_value = \"xmult\", retrigger_type = \"exp\" }\n                    }\n                }\n            },\n            calc_function = function(card)\n                card.joker_display_values.xmult = 1 +\n                    card.ability.extra.xmult * JoyousSpring.count_materials_in_graveyard({ { is_extra_deck = true } })\n            end\n        }\n    end"
    },
    {
      "type": "Joker",
      "key": "yokai_ash",
      "atlas": "GhostGirls",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"yokai_ash\",\n    atlas = 'GhostGirls',\n    pos = { x = 2, y = 0 },\n    rarity = 4,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 12,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { G.GAME.probabilities.normal or 1, card.ability.extra.odds, card.ability.extra.base_xmult, card.ability.extra.xmult } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_tuner = true,\n                attribute = \"FIRE\",\n                monster_type = \"Zombie\"\n            },\n            odds = 2,\n            base_xmult = 0.2,\n            xmult = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and context.joy_no_draw then\n                card.ability.extra.xmult = card.ability.extra.xmult + card.ability.extra.base_xmult\n                return {\n                    message = localize('k_upgrade_ex')\n                }\n            end\n\n            if context.joker_main then\n                return {\n                    xmult = card.ability.extra.xmult\n                }\n            end\n        end\n    end,\n    get_weight = function(self, args)\n        return 0.01\n    end,\n    joker_display_def = function(JokerDisplay)\n        return {\n            text = {\n                {\n                    border_nodes = {\n                        { text = \"X\" },\n                        { ref_table = \"card.ability.extra\", ref_value = \"xmult\", retrigger_type = \"exp\" }\n                    }\n                }\n            },\n        }\n    end"
    },
    {
      "type": "Joker",
      "key": "yokai_belle",
      "atlas": "GhostGirls",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"yokai_belle\",\n    atlas = 'GhostGirls',\n    pos = { x = 0, y = 1 },\n    rarity = 4,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 12,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n        end\n        return { vars = { card.ability.extra.base_xmult, card.ability.extra.xmult } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_tuner = true,\n                attribute = \"EARTH\",\n                monster_type = \"Zombie\"\n            },\n            base_xmult = 0.5,\n            xmult = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and context.joy_revived then\n                card.ability.extra.xmult = card.ability.extra.xmult + card.ability.extra.base_xmult\n                return {\n                    message = localize('k_upgrade_ex')\n                }\n            end\n\n            if context.joker_main then\n                return {\n                    xmult = card.ability.extra.xmult\n                }\n            end\n        end\n    end,\n    get_weight = function(self, args)\n        return 0.01\n    end,\n    joker_display_def = function(JokerDisplay)\n        return {\n            text = {\n                {\n                    border_nodes = {\n                        { text = \"X\" },\n                        { ref_table = \"card.ability.extra\", ref_value = \"xmult\", retrigger_type = \"exp\" }\n                    }\n                }\n            },\n        }\n    end"
    },
    {
      "type": "Joker",
      "key": "yokai_sister",
      "atlas": "GhostGirls",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"yokai_sister\",\n    atlas = 'GhostGirls',\n    pos = { x = 1, y = 1 },\n    rarity = 4,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 12,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.base_xmult, card.ability.extra.xmult } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_tuner = true,\n                attribute = \"WATER\",\n                monster_type = \"Zombie\"\n            },\n            base_xmult = 0.5,\n            xmult = 1,\n            consumable_count = 0\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker then\n                if context.setting_blind and context.main_eval then\n                    local eval = function(card)\n                        return (card.ability.extra.consumable_count == 0) and not G\n                            .RESET_JIGGLES and\n                            card.config.center.key == \"j_joy_yokai_sister\" -- for transformations\n                    end\n                    juice_card_until(card, eval, true)\n                end\n                if context.using_consumeable and G.GAME.blind.in_blind then\n                    card.ability.extra.xmult = card.ability.extra.xmult + card.ability.extra.base_xmult\n                    card.ability.extra.consumable_count = card.ability.extra.consumable_count + 1\n                    return {\n                        message = localize('k_upgrade_ex')\n                    }\n                end\n            end\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.end_of_round and context.game_over == false and context.main_eval then\n                if card.ability.extra.consumable_count > 0 then\n                    card.ability.extra.consumable_count = 0\n                else\n                    JoyousSpring.defeated_by = card.config.center.key\n                    G.STATE = G.STATES.GAME_OVER\n                    G.STATE_COMPLETE = false\n                end\n            end\n            if context.joker_main then\n                return {\n                    xmult = card.ability.extra.xmult\n                }\n            end\n        end\n    end,\n    get_weight = function(self, args)\n        return 0.01\n    end,\n    joker_display_def = function(JokerDisplay)\n        return {\n            text = {\n                {\n                    border_nodes = {\n                        { text = \"X\" },\n                        { ref_table = \"card.ability.extra\", ref_value = \"xmult\", retrigger_type = \"exp\" }\n                    }\n                }\n            },\n        }\n    end"
    },
    {
      "type": "Joker",
      "key": "yokai_mourner",
      "atlas": "GhostGirls",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"yokai_mourner\",\n    atlas = 'GhostGirls',\n    pos = { x = 2, y = 1 },\n    rarity = 4,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 12,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.base_xmult, card.ability.extra.xmult } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_tuner = true,\n                attribute = \"WIND\",\n                monster_type = \"Zombie\"\n            },\n            base_xmult = 0.2,\n            xmult = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and context.selling_card then\n                if context.card.debuff then\n                    card.ability.extra.xmult = card.ability.extra.xmult + card.ability.extra.base_xmult\n                    return {\n                        message = localize('k_upgrade_ex')\n                    }\n                end\n            end\n\n            if context.joker_main then\n                return {\n                    xmult = card.ability.extra.xmult\n                }\n            end\n        end\n    end,\n    joy_apply_to_jokers_added = function(card, added_card)\n        if not card.debuff and added_card.config.center.rarity == 1 or added_card.config.center.rarity == 2 then\n            SMODS.debuff_card(added_card, true, \"j_joy_yokai_mourner\")\n        end\n    end,\n    get_weight = function(self, args)\n        return 0.08\n    end,\n    joker_display_def = function(JokerDisplay)\n        return {\n            text = {\n                {\n                    border_nodes = {\n                        { text = \"X\" },\n                        { ref_table = \"card.ability.extra\", ref_value = \"xmult\", retrigger_type = \"exp\" }\n                    }\n                }\n            },\n        }\n    end"
    },
    {
      "type": "Atlas",
      "key": "Spright",
      "atlas": null,
      "pos": null,
      "raw": "key = \"Spright\",\n    path = \"05Spright.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Joker",
      "key": "spright_blue",
      "atlas": "Spright",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"spright_blue\",\n    atlas = 'Spright',\n    pos = { x = 0, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 8,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_main_deck_joker\" }\n        end\n        return { vars = { card.ability.extra.cards_to_create } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Spright\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Thunder\",\n                monster_archetypes = { [\"Spright\"] = true }\n            },\n            cards_to_create = 1,\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.end_of_round and context.game_over == false and context.main_eval then\n                for i = 1, card.ability.extra.cards_to_create do\n                    JoyousSpring.create_pseudorandom(\n                        { { monster_archetypes = { \"Spright\" }, is_main_deck = true, exclude_keys = { \"j_joy_spright_blue\" } } },\n                        'j_joy_spright_blue', true)\n                end\n            end\n        end\n    end,\n    joy_set_cost = function(card)\n        if JoyousSpring.count_materials_owned({ { rarity = 2 } }) > 0 then\n            card.cost = 0\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "spright_jet",
      "atlas": "Spright",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"spright_jet\",\n    atlas = 'Spright',\n    pos = { x = 1, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 2,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.mill } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Spright\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Thunder\",\n                monster_archetypes = { [\"Spright\"] = true }\n            },\n            mill = 2,\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.setting_blind and context.main_eval then\n                local choices = JoyousSpring.get_materials_in_collection({ { rarity = 2 } })\n\n                for i = 1, card.ability.extra.mill do\n                    JoyousSpring.send_to_graveyard(pseudorandom_element(choices, 'j_joy_spright_jet'))\n                end\n            end\n        end\n    end,\n    joy_set_cost = function(card)\n        if JoyousSpring.count_materials_owned({ { rarity = 2 } }) > 0 then\n            card.cost = 0\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "spright_carrot",
      "atlas": "Spright",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"spright_carrot\",\n    atlas = 'Spright',\n    pos = { x = 2, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        return {\n            vars = {\n                card.ability.extra.xmult,\n                1 + card.ability.extra.xmult *\n                (JoyousSpring.count_materials_owned({ { rarity = 2 } }) + (next(SMODS.find_card(\"j_joy_spright_elf\")) and JoyousSpring.count_materials_in_graveyard({ { rarity = 2 } }) or 0))\n            }\n        }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Spright\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"FIRE\",\n                monster_type = \"Thunder\",\n                monster_archetypes = { [\"Spright\"] = true }\n            },\n            xmult = 0.1,\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                local uncommon_count = JoyousSpring.count_materials_owned({ { rarity = 2 } }) +\n                    (next(SMODS.find_card(\"j_joy_spright_elf\")) and JoyousSpring.count_materials_in_graveyard({ { rarity = 2 } }) or 0)\n                return {\n                    xmult = 1 + card.ability.extra.xmult * uncommon_count\n                }\n            end\n        end\n    end,\n    joy_set_cost = function(card)\n        if JoyousSpring.count_materials_owned({ { rarity = 2 } }) > 0 then\n            card.cost = 0\n        end\n    end,\n    joker_display_def = function(JokerDisplay)\n        return {\n            text = {\n                {\n                    border_nodes = {\n                        { text = \"X\" },\n                        { ref_table = \"card.joker_display_values\", ref_value = \"xmult\", retrigger_type = \"exp\" }\n                    }\n                }\n            },\n            calc_function = function(card)\n                local uncommon_count = JoyousSpring.count_materials_owned({ { rarity = 2 } }) +\n                    (next(SMODS.find_card(\"j_joy_spright_elf\")) and JoyousSpring.count_materials_in_graveyard({ { rarity = 2 } }) or 0)\n                card.joker_display_values.xmult = 1 + card.ability.extra.xmult * uncommon_count\n            end\n        }\n    end"
    },
    {
      "type": "Joker",
      "key": "spright_red",
      "atlas": "Spright",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"spright_red\",\n    atlas = 'Spright',\n    pos = { x = 0, y = 1 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        return {\n            vars = {\n                card.ability.extra.mult,\n                card.ability.extra.mult *\n                (JoyousSpring.count_materials_owned({ { rarity = 2 } }) + (next(SMODS.find_card(\"j_joy_spright_elf\")) and JoyousSpring.count_materials_in_graveyard({ { rarity = 2 } }) or 0))\n            }\n        }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Spright\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"FIRE\",\n                monster_type = \"Thunder\",\n                monster_archetypes = { [\"Spright\"] = true }\n            },\n            mult = 10,\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                local uncommon_count = JoyousSpring.count_materials_owned({ { rarity = 2 } }) +\n                    (next(SMODS.find_card(\"j_joy_spright_elf\")) and JoyousSpring.count_materials_in_graveyard({ { rarity = 2 } }) or 0)\n                return {\n                    mult = card.ability.extra.mult * uncommon_count\n                }\n            end\n        end\n    end,\n    joy_set_cost = function(card)\n        if JoyousSpring.count_materials_owned({ { rarity = 2 } }) > 0 then\n            card.cost = 0\n        end\n    end,\n    joker_display_def = function(JokerDisplay)\n        return {\n            text = {\n                { text = \"+\" },\n                { ref_table = \"card.joker_display_values\", ref_value = \"mult\", retrigger_type = \"mult\" }\n            },\n            text_config = { colour = G.C.MULT },\n            calc_function = function(card)\n                local uncommon_count = JoyousSpring.count_materials_owned({ { rarity = 2 } }) +\n                    (next(SMODS.find_card(\"j_joy_spright_elf\")) and JoyousSpring.count_materials_in_graveyard({ { rarity = 2 } }) or 0)\n                card.joker_display_values.mult = card.ability.extra.mult * uncommon_count\n            end\n        }\n    end"
    },
    {
      "type": "Joker",
      "key": "spright_pixies",
      "atlas": "Spright",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"spright_pixies\",\n    atlas = 'Spright',\n    pos = { x = 1, y = 1 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        return {\n            vars = {\n                card.ability.extra.chips,\n                card.ability.extra.chips *\n                (JoyousSpring.count_materials_owned({ { rarity = 2 } }) + (next(SMODS.find_card(\"j_joy_spright_elf\")) and JoyousSpring.count_materials_in_graveyard({ { rarity = 2 } }) or 0))\n            }\n        }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Spright\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Thunder\",\n                monster_archetypes = { [\"Spright\"] = true }\n            },\n            chips = 40,\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                local uncommon_count = JoyousSpring.count_materials_owned({ { rarity = 2 } }) +\n                    (next(SMODS.find_card(\"j_joy_spright_elf\")) and JoyousSpring.count_materials_in_graveyard({ { rarity = 2 } }) or 0)\n                return {\n                    chips = card.ability.extra.chips * uncommon_count\n                }\n            end\n        end\n    end,\n    joy_set_cost = function(card)\n        if JoyousSpring.count_materials_owned({ { rarity = 2 } }) > 0 then\n            card.cost = 0\n        end\n    end,\n    joker_display_def = function(JokerDisplay)\n        return {\n            text = {\n                { text = \"+\" },\n                { ref_table = \"card.joker_display_values\", ref_value = \"chips\", retrigger_type = \"mult\" }\n            },\n            text_config = { colour = G.C.CHIPS },\n            calc_function = function(card)\n                local uncommon_count = JoyousSpring.count_materials_owned({ { rarity = 2 } }) +\n                    (next(SMODS.find_card(\"j_joy_spright_elf\")) and JoyousSpring.count_materials_in_graveyard({ { rarity = 2 } }) or 0)\n                card.joker_display_values.chips = card.ability.extra.chips * uncommon_count\n            end\n        }\n    end"
    },
    {
      "type": "Joker",
      "key": "spright_elf",
      "atlas": "Spright",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = \"spright_elf\",\n    atlas = 'Spright',\n    pos = { x = 0, y = 2 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 8,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n        end\n        return { vars = { card.ability.extra.revives } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Spright\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"LINK\",\n                attribute = \"FIRE\",\n                monster_type = \"Thunder\",\n                monster_archetypes = { [\"Spright\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"LINK\",\n                        materials = {\n                            { rarity = 2 },\n                            { rarity = 2 }\n                        }\n                    }\n                }\n            },\n            revives = 1,\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.setting_blind and context.main_eval then\n                for i = 1, card.ability.extra.revives do\n                    JoyousSpring.revive_pseudorandom(\n                        { { rarity = 2 } },\n                        'j_joy_spright_elf',\n                        true\n                    )\n                end\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "spright_sprind",
      "atlas": "Spright",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "key = \"spright_sprind\",\n    atlas = 'Spright',\n    pos = { x = 1, y = 2 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.base_materials, card.ability.extra.detached } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_spright_gigantic\",                                name = \"k_joy_adds\" },\n        { properties = { { monster_archetypes = { \"Spright\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"LINK\",\n                attribute = \"FIRE\",\n                monster_type = \"Thunder\",\n                monster_archetypes = { [\"Spright\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"LINK\",\n                        materials = {\n                            { rarity = 2, summon_type = \"XYZ\" },\n                            { rarity = 2 }\n                        }\n                    }\n                }\n            },\n            base_materials = 4,\n            detached = 0\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and context.joy_detach then\n                card.ability.extra.detached = card.ability.extra.detached + 1\n                if card.ability.extra.detached >= card.ability.extra.base_materials then\n                    card.ability.extra.detached = 0\n                    if #JoyousSpring.extra_deck_area.cards < JoyousSpring.extra_deck_area.config.card_limit then\n                        G.E_MANAGER:add_event(Event({\n                            func = function()\n                                card:juice_up(0.5, 0.5)\n                                return true\n                            end,\n                        }))\n                        JoyousSpring.add_to_extra_deck(\"j_joy_spright_gigantic\")\n                    end\n                end\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not from_debuff then\n            card.ability.extra.unique_count = #SMODS.find_card(\"j_joy_spright_sprind\", true)\n        end\n        if not card.debuff then\n            local spright_material = false\n            for _, key in ipairs(JoyousSpring.get_materials(card)) do\n                if JoyousSpring.is_material_center(key, { monster_archetypes = { \"Spright\" } }) then\n                    spright_material = true\n                    break\n                end\n            end\n            if spright_material then\n                for _, joker in ipairs(G.jokers.cards) do\n                    if joker.config.center.rarity == 2 then\n                        if not joker.edition then\n                            joker:set_edition({ negative = true })\n                        end\n                    else\n                        SMODS.debuff_card(joker, true, \"j_joy_spright_sprind\" .. (card.ability.extra.unique_count or 0))\n                    end\n                end\n            end\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        for _, joker in ipairs(G.jokers.cards) do\n            SMODS.debuff_card(joker, false, \"j_joy_spright_sprind\" .. (card.ability.extra.unique_count or 0))\n        end\n    end,\n    joy_apply_to_jokers_added = function(card, added_card)\n        if not card.debuff then\n            local spright_material = false\n            for _, key in ipairs(JoyousSpring.get_materials(card)) do\n                if JoyousSpring.is_material_center(key, { monster_archetypes = { \"Spright\" } }) then\n                    spright_material = true\n                    break\n                end\n            end\n            if spright_material then\n                if added_card.config.center.rarity == 2 then\n                    if not added_card.edition then\n                        added_card:set_edition({ negative = true })\n                    end\n                else\n                    SMODS.debuff_card(added_card, true, \"j_joy_spright_sprind\" .. (card.ability.extra.unique_count or 0))\n                end\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "spright_gigantic",
      "atlas": "Spright",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"spright_gigantic\",\n    atlas = 'Spright',\n    pos = { x = 2, y = 1 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 15,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_detach\" }\n        end\n        return { vars = { card.ability.extra.cards_to_create } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    update = JoyousSpring.update_counter,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Spright\" } } }, name = \"k_joy_archetype\" },\n    },\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"XYZ\",\n                attribute = \"DARK\",\n                monster_type = \"Thunder\",\n                monster_archetypes = { [\"Spright\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"XYZ\",\n                        materials = {\n                            { rarity = 2, exclude_tokens = true, exclude_summon_types = { \"XYZ\" } },\n                            { rarity = 2, exclude_tokens = true, exclude_summon_types = { \"XYZ\" } }\n                        },\n                    }\n                }\n            },\n            cards_to_create = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.joy_detach and context.joy_detaching_card == card then\n                if #G.jokers.cards + G.GAME.joker_buffer < G.jokers.config.card_limit then\n                    JoyousSpring.ease_detach(card)\n                end\n\n                for i = 1, card.ability.extra.cards_to_create do\n                    if #G.jokers.cards + G.GAME.joker_buffer < G.jokers.config.card_limit then\n                        JoyousSpring.create_summon({\n                            set = \"Joker\",\n                            rarity = \"Uncommon\",\n                            key_append = \"JoyousSpring\"\n                        }, true)\n                    end\n                end\n            end\n        end\n    end,"
    },
    {
      "type": "Atlas",
      "key": "MekkKnight",
      "atlas": null,
      "pos": null,
      "raw": "key = \"MekkKnight\",\n    path = \"06MekkKnight.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Atlas",
      "key": "MekkKnight02",
      "atlas": null,
      "pos": null,
      "raw": "key = \"MekkKnight02\",\n    path = \"06MekkKnight02.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Joker",
      "key": "mekk_avram",
      "atlas": "MekkKnight",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"mekk_avram\",\n    atlas = 'MekkKnight',\n    pos = { x = 0, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 1,\n    joy_desc_cards = {\n        { \"j_joy_mekkleg_scars\", properties = { { monster_archetypes = { \"MekkKnight\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_effect = false,\n                attribute = \"LIGHT\",\n                monster_type = \"Psychic\",\n                monster_archetypes = { [\"MekkKnight\"] = true }\n            },\n        },\n    },\n    in_pool = function(self, args)\n        return args and args.source and args.source == \"JoyousSpring\" or false\n    end,"
    },
    {
      "type": "Joker",
      "key": "mekk_red",
      "atlas": "MekkKnight",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"mekk_red\",\n    atlas = 'MekkKnight',\n    pos = { x = 1, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 4,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.mult, JoyousSpring.get_joker_column(card) } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_mekkleg_scars\", properties = { { monster_archetypes = { \"MekkKnight\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"LIGHT\",\n                monster_type = \"Psychic\",\n                monster_archetypes = { [\"MekkKnight\"] = true }\n            },\n            mult = 5\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.individual and context.cardarea == G.play then\n                if next(SMODS.find_card(\"j_joy_mekk_spectrum\")) or JoyousSpring.get_joker_column(card) == (JoyousSpring.index_of(context.full_hand, context.other_card)) then\n                    return {\n                        mult = context.other_card.base.nominal * card.ability.extra.mult\n                    }\n                end\n            end\n        end\n    end,\n    joker_display_def = function(JokerDisplay)\n        return {\n            reminder_text = {\n                { text = \"(\" },\n                { ref_table = \"card.joker_display_values\", ref_value = \"localized_text\" },\n                { text = \" \" },\n                { ref_table = \"card.joker_display_values\", ref_value = \"column\" },\n                { text = \")\" },\n            },\n            calc_function = function(card)\n                card.joker_display_values.localized_text = localize(\"k_joy_column\")\n                card.joker_display_values.column = JoyousSpring.get_joker_column(card)\n            end\n        }\n    end"
    },
    {
      "type": "Joker",
      "key": "mekk_orange",
      "atlas": "MekkKnight",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"mekk_orange\",\n    atlas = 'MekkKnight',\n    pos = { x = 2, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { JoyousSpring.get_joker_column(card), card.ability.extra.xchips, card.ability.extra.current_xchips } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_mekkleg_scars\", properties = { { monster_archetypes = { \"MekkKnight\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"LIGHT\",\n                monster_type = \"Psychic\",\n                monster_archetypes = { [\"MekkKnight\"] = true }\n            },\n            xchips = 0.1,\n            current_xchips = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    xchips = card.ability.extra.current_xchips\n                }\n            end\n            if context.modify_scoring_hand then\n                local scoring = context.in_scoring\n                if next(SMODS.find_card(\"j_joy_mekk_spectrum\")) or JoyousSpring.get_joker_column(card) == (JoyousSpring.index_of(context.full_hand, context.other_card)) then\n                    local in_hand = false\n                    if scoring then\n                        for _, pcard in ipairs(context.scoring_hand) do\n                            if pcard == context.other_card then\n                                in_hand = true\n                                break\n                            end\n                        end\n                        if not in_hand then\n                            card.ability.extra.current_xchips = card.ability.extra.current_xchips +\n                                card.ability.extra.xchips\n                        end\n                    end\n                    return {\n                        add_to_hand = true,\n                        message = not in_hand and scoring and localize(\"k_joy_splash\") or nil\n                    }\n                end\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "mekk_yellow",
      "atlas": "MekkKnight",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"mekk_yellow\",\n    atlas = 'MekkKnight',\n    pos = { x = 3, y = 0 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.money, JoyousSpring.get_joker_column(card) } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_mekkleg_scars\", properties = { { monster_archetypes = { \"MekkKnight\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"LIGHT\",\n                monster_type = \"Psychic\",\n                monster_archetypes = { [\"MekkKnight\"] = true }\n            },\n            money = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.individual and context.cardarea == G.play then\n                if next(SMODS.find_card(\"j_joy_mekk_spectrum\")) or JoyousSpring.get_joker_column(card) == (JoyousSpring.index_of(context.full_hand, context.other_card)) then\n                    return {\n                        dollars = context.other_card.base.nominal * card.ability.extra.money\n                    }\n                end\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "mekk_green",
      "atlas": "MekkKnight",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"mekk_green\",\n    atlas = 'MekkKnight',\n    pos = { x = 0, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 4,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { (G.GAME.probabilities.normal or 1) + JoyousSpring.count_materials_owned({ { monster_archetypes = { \"MekkKnight\" } } }) - (card.area and card.area == G.jokers and 1 or 0), JoyousSpring.get_joker_column(card) } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_mekkleg_scars\", properties = { { monster_archetypes = { \"MekkKnight\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"LIGHT\",\n                monster_type = \"Psychic\",\n                monster_archetypes = { [\"MekkKnight\"] = true }\n            },\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.repetition and context.cardarea == G.play then\n                if next(SMODS.find_card(\"j_joy_mekk_spectrum\")) or JoyousSpring.get_joker_column(card) == (JoyousSpring.index_of(context.full_hand, context.other_card)) then\n                    if pseudorandom(\"j_joy_mekk_green\") < (G.GAME.probabilities.normal + JoyousSpring.count_materials_owned({ { monster_archetypes = { \"MekkKnight\" } } }) - 1) / (context.other_card.base.nominal >= 1 and context.other_card.base.nominal or 1) then\n                        return {\n                            repetitions = ((context.other_card.base.nominal >= 1) and context.other_card.base.nominal or nil)\n                        }\n                    end\n                end\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "mekk_blue",
      "atlas": "MekkKnight",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"mekk_blue\",\n    atlas = 'MekkKnight',\n    pos = { x = 1, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 4,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.chips, JoyousSpring.get_joker_column(card) } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_mekkleg_scars\", properties = { { monster_archetypes = { \"MekkKnight\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"LIGHT\",\n                monster_type = \"Psychic\",\n                monster_archetypes = { [\"MekkKnight\"] = true }\n            },\n            chips = 20\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.individual and context.cardarea == G.play then\n                if next(SMODS.find_card(\"j_joy_mekk_spectrum\")) or JoyousSpring.get_joker_column(card) == (JoyousSpring.index_of(context.full_hand, context.other_card)) then\n                    return {\n                        chips = context.other_card.base.nominal * card.ability.extra.chips\n                    }\n                end\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "mekk_indigo",
      "atlas": "MekkKnight",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"mekk_indigo\",\n    atlas = 'MekkKnight',\n    pos = { x = 2, y = 1 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 7,\n    loc_vars = function(self, info_queue, card)\n        local has_spectrum = next(SMODS.find_card(\"j_joy_mekk_spectrum\"))\n        return {\n            vars = {\n                card.ability.extra.chips,\n                card.ability.extra.mult,\n                card.ability.extra.xmult,\n                card.ability.extra.money,\n                colours = {\n                    (has_spectrum or JoyousSpring.get_joker_column(card) == 1) and G.C.UI.TEXT_DARK or\n                    G.C.UI.TEXT_INACTIVE,\n                    (has_spectrum or JoyousSpring.get_joker_column(card) == 2) and G.C.UI.TEXT_DARK or\n                    G.C.UI.TEXT_INACTIVE,\n                    (has_spectrum or JoyousSpring.get_joker_column(card) == 3) and G.C.UI.TEXT_DARK or\n                    G.C.UI.TEXT_INACTIVE,\n                    (has_spectrum or JoyousSpring.get_joker_column(card) == 4) and G.C.UI.TEXT_DARK or\n                    G.C.UI.TEXT_INACTIVE,\n                    (has_spectrum or JoyousSpring.get_joker_column(card) >= 5) and G.C.UI.TEXT_DARK or\n                    G.C.UI.TEXT_INACTIVE\n                }\n            },\n        }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_mekkleg_scars\", properties = { { monster_archetypes = { \"MekkKnight\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"LIGHT\",\n                monster_type = \"Psychic\",\n                monster_archetypes = { [\"MekkKnight\"] = true }\n            },\n            chips = 20,\n            mult = 20,\n            xmult = 2,\n            money = 5\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                local has_spectrum = next(SMODS.find_card(\"j_joy_mekk_spectrum\"))\n                return {\n                    chips = (has_spectrum or JoyousSpring.get_joker_column(card) == 2) and card.ability.extra.chips or\n                        nil,\n                    mult = (has_spectrum or JoyousSpring.get_joker_column(card) == 3) and card.ability.extra.mult or nil,\n                    xmult = (has_spectrum or JoyousSpring.get_joker_column(card) == 4) and card.ability.extra.xmult or\n                        nil\n                }\n            end\n            if context.repetition and context.cardarea == G.play then\n                if next(SMODS.find_card(\"j_joy_mekk_spectrum\")) or JoyousSpring.get_joker_column(card) == 1 then\n                    return {\n                        repetitions = 1\n                    }\n                end\n            end\n        end\n    end,\n    calc_dollar_bonus = function(self, card)\n        return JoyousSpring.can_use_abilities(card) and\n            (next(SMODS.find_card(\"j_joy_mekk_spectrum\")) or JoyousSpring.get_joker_column(card) >= 5) and\n            card.ability.extra.money or nil\n    end,"
    },
    {
      "type": "Joker",
      "key": "mekk_purple",
      "atlas": "MekkKnight",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"mekk_purple\",\n    atlas = 'MekkKnight',\n    pos = { x = 3, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_banish\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_main_deck_joker\" }\n        end\n        return { vars = { card.ability.extra.cards_to_create } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_mekkleg_scars\", properties = { { monster_archetypes = { \"MekkKnight\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"LIGHT\",\n                monster_type = \"Psychic\",\n                monster_archetypes = { [\"MekkKnight\"] = true }\n            },\n            cards_to_create = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.setting_blind and context.main_eval then\n                if #G.jokers.cards + G.GAME.joker_buffer < G.jokers.config.card_limit +\n                    ((card.edition and card.edition.negative) and 0 or 1) then\n                    JoyousSpring.banish(card, \"end_of_ante\")\n\n                    for i = 1, card.ability.extra.cards_to_create do\n                        JoyousSpring.create_pseudorandom(\n                            { { monster_archetypes = { \"MekkKnight\" }, is_main_deck = true, exclude_keys = { \"j_joy_mekk_purple\" } } },\n                            'j_joy_mekk_purple', true)\n                    end\n                end\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "mekk_morningstar",
      "atlas": "MekkKnight",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = \"mekk_morningstar\",\n    atlas = 'MekkKnight',\n    pos = { x = 0, y = 2 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.xmult, JoyousSpring.get_joker_column(card) - 1, JoyousSpring.get_joker_column(card) + 1 } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_mekkleg_scars\", properties = { { monster_archetypes = { \"MekkKnight\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"LINK\",\n                attribute = \"LIGHT\",\n                monster_type = \"Machine\",\n                monster_archetypes = { [\"MekkKnight\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"LINK\",\n                        materials = {\n                            {},\n                            {},\n                        },\n                    }\n                }\n            },\n            xmult = 5\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.individual and context.cardarea == G.play then\n                local card_index = JoyousSpring.index_of(context.full_hand, context.other_card)\n                local is_mekk = G.jokers.cards[card_index] and\n                    JoyousSpring.is_monster_archetype(G.jokers.cards[card_index], \"MekkKnight\")\n                if is_mekk and (next(SMODS.find_card(\"j_joy_mekk_spectrum\")) or\n                        card_index == JoyousSpring.get_joker_column(card) - 1 or card_index == JoyousSpring.get_joker_column(card) + 1) then\n                    return {\n                        xmult = card.ability.extra.xmult\n                    }\n                end\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "mekk_spectrum",
      "atlas": "MekkKnight",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "key = \"mekk_spectrum\",\n    atlas = 'MekkKnight',\n    pos = { x = 1, y = 2 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 7,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_main_deck_joker\" }\n        end\n        return { vars = { card.ability.extra.cards_to_create } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_mekkleg_scars\", properties = { { monster_archetypes = { \"MekkKnight\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"LINK\",\n                attribute = \"LIGHT\",\n                monster_type = \"Cyberse\",\n                monster_archetypes = { [\"MekkKnight\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"LINK\",\n                        materials = {\n                            { monster_archetypes = { \"MekkKnight\" } },\n                            { monster_archetypes = { \"MekkKnight\" } },\n                            { monster_archetypes = { \"MekkKnight\" } },\n                        },\n                    }\n                }\n            },\n            cards_to_create = 1,\n            activated = false\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not card.ability.extra.activated and context.selling_card and JoyousSpring.is_monster_archetype(context.card, \"MekkKnight\") then\n                card.ability.extra.activated = true\n\n                for i = 1, card.ability.extra.cards_to_create do\n                    JoyousSpring.create_pseudorandom(\n                        { { monster_archetypes = { \"MekkKnight\" }, is_main_deck = true } },\n                        \"j_joy_mekk_spectrum\", false, false, \"e_negative\")\n                end\n            end\n            if context.end_of_round and context.game_over == false and context.main_eval then\n                card.ability.extra.activated = false\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "mekkcrus_avramax",
      "atlas": "MekkKnight",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "key = \"mekkcrus_avramax\",\n    atlas = 'MekkKnight',\n    pos = { x = 2, y = 2 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 12,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.blinds, #JoyousSpring.get_materials(card) } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_mekkleg_scars\", properties = { { monster_archetypes = { \"MekkKnight\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"LINK\",\n                attribute = \"LIGHT\",\n                monster_type = \"Cyberse\",\n                monster_archetypes = { [\"MekkKnight\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"LINK\",\n                        materials = {\n                            { min = 2, is_summoned = true, is_extra_deck = true },\n                        },\n                    }\n                }\n            },\n            blinds = 0\n        },\n    },\n    calculate = function(self, card, context)\n        if context.joy_selecting_hand then\n            G.GAME.chips = G.GAME.blind.chips\n            G.STATE = G.STATES.HAND_PLAYED\n            G.STATE_COMPLETE = true\n            end_round()\n            return {\n                message = localize(\"k_joy_defeated\")\n            }\n        end\n        if not context.blueprint and context.end_of_round and context.game_over == false and context.main_eval then\n            card.ability.extra.blinds = card.ability.extra.blinds + 1\n            if card.ability.extra.blinds >= #JoyousSpring.get_materials(card) then\n                card.getting_sliced = true\n                card:start_dissolve()\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and G.STATE == G.STATES.SELECTING_HAND then\n            G.GAME.chips = G.GAME.blind.chips\n            G.STATE = G.STATES.HAND_PLAYED\n            G.STATE_COMPLETE = true\n            end_round()\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "mekkleg_scars",
      "atlas": "MekkKnight02",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"mekkleg_scars\",\n    atlas = 'MekkKnight02',\n    pos = { x = 0, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_tribute\" }\n        end\n\n        return { vars = { card.ability.extra.mult, card.ability.extra.tributes, card.ability.extra.hands, card.ability.extra.mekk_count } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_mekkleg_scars\", properties = { { monster_archetypes = { \"MekkKnight\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_field_spell = true,\n                monster_archetypes = { [\"WorldLegacy\"] = true },\n            },\n            mult = 50,\n            tributes = 1,\n            hands = 1,\n            mekk_count = 8,\n        },\n    },\n    calculate = function(self, card, context)\n        if context.joy_activate_effect and context.joy_activated_card == card then\n            local materials = JoyousSpring.get_materials_owned({ { monster_archetypes = { \"MekkKnight\" } } }, false, true)\n            if next(materials) then\n                JoyousSpring.create_overlay_effect_selection(card, materials, card.ability.extra.tributes,\n                    card.ability.extra.tributes)\n            end\n        end\n        if context.joy_exit_effect_selection and context.joy_card == card and\n            #context.joy_selection == card.ability.extra.tributes and G.GAME.blind.in_blind then\n            JoyousSpring.tribute(card, context.joy_selection)\n            ease_hands_played(card.ability.extra.hands)\n        end\n        if context.other_joker and context.other_joker.facing == \"front\" and JoyousSpring.is_monster_archetype(context.other_joker, \"MekkKnight\") then\n            return {\n                mult = card.ability.extra.mult,\n                message_card = context.other_joker\n            }\n        end\n        if context.selling_self and G.GAME.blind.in_blind and JoyousSpring.count_materials_in_graveyard({ { monster_archetypes = { \"MekkKnight\" } } }, false, true) >= card.ability.extra.mekk_count then\n            G.GAME.chips = G.GAME.blind.chips\n            G.STATE = G.STATES.HAND_PLAYED\n            G.STATE_COMPLETE = true\n            end_round()\n            return {\n                message = localize(\"k_joy_defeated\")\n            }\n        end\n    end,\n    joy_can_activate = function(card)\n        if not G.GAME.blind.in_blind then\n            return false\n        end\n        local materials = JoyousSpring.get_materials_owned({ { monster_archetypes = { \"MekkKnight\" } } }, false, true)\n        return next(materials) and true or false\n    end,"
    },
    {
      "type": "Atlas",
      "key": "Generaider",
      "atlas": null,
      "pos": null,
      "raw": "key = \"Generaider\",\n    path = \"07Generaider.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Joker",
      "key": "generaider_loptr",
      "atlas": "Generaider",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"generaider_loptr\",\n    atlas = 'Generaider',\n    pos = { x = 0, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = false,\n    cost = 8,\n    loc_vars = function(self, info_queue, card)\n        return {}\n    end,\n    joy_desc_cards = {\n        { \"j_joy_generaider_boss_stage\",                              name = \"k_joy_creates\" },\n        { properties = { { monster_archetypes = { \"Generaider\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"FIRE\",\n                monster_type = \"Fairy\",\n                monster_archetypes = { [\"Generaider\"] = true }\n            },\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.end_of_round and context.game_over == false and context.main_eval and G.GAME.blind.boss then\n                if #JoyousSpring.field_spell_area.cards < JoyousSpring.field_spell_area.config.card_limit then\n                    JoyousSpring.add_to_extra_deck(\"j_joy_generaider_boss_stage\")\n                    card.getting_sliced = true\n                    card:start_dissolve()\n                end\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "generaider_vala",
      "atlas": "Generaider",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"generaider_vala\",\n    atlas = 'Generaider',\n    pos = { x = 1, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = false,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n        end\n        return { vars = { card.ability.extra.mills, card.ability.extra.revives, card.ability.extra.creates } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Generaider\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"FIRE\",\n                monster_type = \"Fairy\",\n                monster_archetypes = { [\"Generaider\"] = true }\n            },\n            mills = 1,\n            revives = 1,\n            creates = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.end_of_round and context.game_over == false and context.main_eval and G.GAME.blind.boss then\n                if #G.jokers.cards + G.GAME.joker_buffer < G.jokers.config.card_limit +\n                    ((card.edition and card.edition.negative) and 0 or 1) then\n                    for i = 1, card.ability.extra.revives do\n                        if #G.jokers.cards + G.GAME.joker_buffer < G.jokers.config.card_limit +\n                            ((card.edition and card.edition.negative) and 0 or 1) then\n                            JoyousSpring.revive_pseudorandom(\n                                { { rarity = 3, monster_archetypes = { \"Generaider\" } } },\n                                'j_joy_generaider_vala',\n                                false\n                            )\n                        end\n                    end\n                    for i = 1, card.ability.extra.creates do\n                        JoyousSpring.create_summon({\n                            key = \"j_joy_generaider_loptr\"\n                        })\n                    end\n                    card.getting_sliced = true\n                    card:start_dissolve()\n                end\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not from_debuff and not card.debuff then\n            local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Generaider\" }, rarity = 3, is_main_deck = true } })\n\n            for i = 1, card.ability.extra.mills do\n                JoyousSpring.send_to_graveyard(pseudorandom_element(choices, 'j_joy_generaider_vala'))\n            end\n            SMODS.calculate_effect({ message = localize(\"k_joy_mill\") }, card)\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "generaider_harr",
      "atlas": "Generaider",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"generaider_harr\",\n    atlas = 'Generaider',\n    pos = { x = 2, y = 0 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_tribute\" }\n        end\n        return { vars = { card.ability.extra.tributes } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Generaider\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Spellcaster\",\n                monster_archetypes = { [\"Generaider\"] = true }\n            },\n            tributes = 2\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) and not context.blueprint_card then\n            if context.joy_activate_effect and context.joy_activated_card == card then\n                local materials = JoyousSpring.get_materials_owned(\n                    { { monster_archetypes = { \"Generaider\" } }, { monster_type = \"Spellcaster\" } }, false, true)\n                if #materials >= card.ability.extra.tributes then\n                    JoyousSpring.create_overlay_effect_selection(card, materials, card.ability.extra.tributes,\n                        card.ability.extra.tributes)\n                end\n            end\n            if context.joy_exit_effect_selection and context.joy_card == card and\n                #context.joy_selection == card.ability.extra.tributes then\n                JoyousSpring.tribute(card, context.joy_selection)\n                G.GAME.blind:disable()\n            end\n        end\n    end,\n    joy_can_activate = function(card)\n        if not G.GAME.blind or (not G.GAME.blind.disabled and G.GAME.blind.boss) then\n            return false\n        end\n        local materials = JoyousSpring.get_materials_owned(\n            { { monster_archetypes = { \"Generaider\" } }, { monster_type = \"Spellcaster\" } }, false, true)\n        return #materials >= card.ability.extra.tributes\n    end,\n    in_pool = function(self, args)\n        return args and args.source and args.source == \"JoyousSpring\" or false\n    end,"
    },
    {
      "type": "Joker",
      "key": "generaider_nidhogg",
      "atlas": "Generaider",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"generaider_nidhogg\",\n    atlas = 'Generaider',\n    pos = { x = 3, y = 0 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_tribute\" }\n        end\n        return { vars = { card.ability.extra.tributes } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Generaider\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"WATER\",\n                monster_type = \"Wyrm\",\n                monster_archetypes = { [\"Generaider\"] = true }\n            },\n            tributes = 2,\n            active = false\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card then\n                if context.joy_activate_effect and context.joy_activated_card == card then\n                    local materials_owned = JoyousSpring.get_materials_owned(\n                        { { monster_archetypes = { \"Generaider\" } }, { monster_type = \"Wyrm\" } }, false, true)\n                    local materials = {}\n                    for _, material in ipairs(materials_owned) do\n                        if material ~= card then\n                            materials[#materials + 1] = material\n                        end\n                    end\n                    if #materials >= card.ability.extra.tributes then\n                        JoyousSpring.create_overlay_effect_selection(card, materials, card.ability.extra.tributes,\n                            card.ability.extra.tributes)\n                    end\n                end\n                if context.joy_exit_effect_selection and context.joy_card == card and\n                    #context.joy_selection == card.ability.extra.tributes then\n                    JoyousSpring.tribute(card, context.joy_selection)\n                    card.ability.extra.active = true\n                end\n                if context.end_of_round and context.game_over == false and context.main_eval then\n                    card.ability.extra.active = false\n                end\n            end\n            if context.repetition and context.cardarea == G.play then\n                if card.ability.extra.active then\n                    return {\n                        repetitions = 1\n                    }\n                end\n            end\n        end\n    end,\n    joy_can_activate = function(card)\n        if card.ability.extra.active then\n            return false\n        end\n        local materials_owned = JoyousSpring.get_materials_owned(\n            { { monster_archetypes = { \"Generaider\" } }, { monster_type = \"Wyrm\" } }, false, true)\n        local materials = {}\n        for _, material in ipairs(materials_owned) do\n            if material ~= card then\n                materials[#materials + 1] = material\n            end\n        end\n        return #materials >= card.ability.extra.tributes\n    end,\n    in_pool = function(self, args)\n        return args and args.source and args.source == \"JoyousSpring\" or false\n    end,"
    },
    {
      "type": "Joker",
      "key": "generaider_frodi",
      "atlas": "Generaider",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"generaider_frodi\",\n    atlas = 'Generaider',\n    pos = { x = 0, y = 1 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_tribute\" }\n        end\n        return {}\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Generaider\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"WIND\",\n                monster_type = \"Warrior\",\n                monster_archetypes = { [\"Generaider\"] = true }\n            },\n            hand_gain = 0\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card then\n                if context.joy_activate_effect and context.joy_activated_card == card then\n                    local materials_owned = JoyousSpring.get_materials_owned(\n                        { { monster_archetypes = { \"Generaider\" } }, { monster_type = \"Spellcaster\" } }, false, true)\n                    local materials = {}\n                    for _, material in ipairs(materials_owned) do\n                        if material ~= card then\n                            materials[#materials + 1] = material\n                        end\n                    end\n                    if next(materials) then\n                        JoyousSpring.create_overlay_effect_selection(card, materials, 1, 52)\n                    end\n                end\n                if context.joy_exit_effect_selection and context.joy_card == card and\n                    #context.joy_selection > 0 then\n                    local count = #context.joy_selection\n                    JoyousSpring.tribute(card, context.joy_selection)\n                    G.hand:change_size(count)\n                    card.ability.extra.hand_gain = card.ability.extra.hand_gain + count\n                end\n                if context.end_of_round and context.game_over == false and context.main_eval then\n                    G.hand:change_size(-card.ability.extra.hand_gain)\n                    card.ability.extra.hand_gain = 0\n                end\n            end\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        G.hand:change_size(-card.ability.extra.hand_gain)\n        card.ability.extra.hand_gain = 0\n    end,\n    joy_can_activate = function(card)\n        local materials_owned = JoyousSpring.get_materials_owned(\n            { { monster_archetypes = { \"Generaider\" } }, { monster_type = \"Warrior\" } }, false, true)\n        local materials = {}\n        for _, material in ipairs(materials_owned) do\n            if material ~= card then\n                materials[#materials + 1] = material\n            end\n        end\n        return next(materials) and true or false\n    end,\n    in_pool = function(self, args)\n        return args and args.source and args.source == \"JoyousSpring\" or false\n    end,"
    },
    {
      "type": "Joker",
      "key": "generaider_utgarda",
      "atlas": "Generaider",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"generaider_utgarda\",\n    atlas = 'Generaider',\n    pos = { x = 1, y = 1 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_tribute\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_banish\" }\n        end\n        return { vars = { card.ability.extra.tributes } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Generaider\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"LIGHT\",\n                monster_type = \"Rock\",\n                monster_archetypes = { [\"Generaider\"] = true }\n            },\n            tributes = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) and not context.blueprint_card then\n            if context.joy_activate_effect and context.joy_activated_card == card then\n                local materials = JoyousSpring.get_materials_owned(\n                    { { monster_archetypes = { \"Generaider\" } }, { monster_type = \"Rock\" } }, false, true)\n                if #materials >= card.ability.extra.tributes then\n                    JoyousSpring.create_overlay_effect_selection(card, materials, card.ability.extra.tributes,\n                        card.ability.extra.tributes)\n                end\n            end\n            if context.joy_exit_effect_selection and context.joy_card == card and\n                #context.joy_selection == card.ability.extra.tributes then\n                JoyousSpring.tribute(card, context.joy_selection)\n                local choices = G.consumeables.cards\n                local to_banish = pseudorandom_element(choices, 'j_joy_generaider_utgarda')\n                if to_banish then\n                    JoyousSpring.banish(to_banish, \"blind_selected\")\n                end\n            end\n        end\n    end,\n    joy_can_activate = function(card)\n        if not (#G.consumeables.cards > 0) then\n            return false\n        end\n        local materials = JoyousSpring.get_materials_owned(\n            { { monster_archetypes = { \"Generaider\" } }, { monster_type = \"Rock\" } }, false, true)\n        return #materials >= card.ability.extra.tributes\n    end,\n    in_pool = function(self, args)\n        return args and args.source and args.source == \"JoyousSpring\" or false\n    end,"
    },
    {
      "type": "Joker",
      "key": "generaider_mardel",
      "atlas": "Generaider",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"generaider_mardel\",\n    atlas = 'Generaider',\n    pos = { x = 2, y = 1 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_tribute\" }\n        end\n        return { vars = { card.ability.extra.tributes, card.ability.extra.cards_to_create } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Generaider\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"LIGHT\",\n                monster_type = \"Plant\",\n                monster_archetypes = { [\"Generaider\"] = true }\n            },\n            tributes = 1,\n            cards_to_create = 1,\n            activated = false\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) and not context.blueprint_card then\n            if not card.ability.extra.activated and context.joy_activate_effect and context.joy_activated_card == card then\n                local materials = JoyousSpring.get_materials_owned(\n                    { { monster_archetypes = { \"Generaider\" } }, { monster_type = \"Plant\" } }, false, true)\n                if #materials >= card.ability.extra.tributes then\n                    JoyousSpring.create_overlay_effect_selection(card, materials, card.ability.extra.tributes,\n                        card.ability.extra.tributes)\n                end\n            end\n            if not card.ability.extra.activated and context.joy_exit_effect_selection and context.joy_card == card and\n                #context.joy_selection == card.ability.extra.tributes then\n                card.ability.extra.activated = true\n                JoyousSpring.tribute(card, context.joy_selection)\n                for i = 1, card.ability.extra.cards_to_create do\n                    JoyousSpring.create_pseudorandom(\n                        { { monster_archetypes = { \"Generaider\" }, rarity = 1 }, { monster_archetypes = { \"Generaider\" }, rarity = 2 } },\n                        'j_joy_generaider_mardel', true)\n                end\n            end\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval then\n            card.ability.extra.activated = false\n        end\n    end,\n    joy_can_activate = function(card)\n        if card.ability.extra.activated or not (#G.jokers.cards + G.GAME.joker_buffer - card.ability.extra.tributes < G.jokers.config.card_limit) then\n            return false\n        end\n        local materials = JoyousSpring.get_materials_owned(\n            { { monster_archetypes = { \"Generaider\" } }, { monster_type = \"Plant\" } }, false, true)\n        return #materials >= card.ability.extra.tributes\n    end,\n    in_pool = function(self, args)\n        return args and args.source and args.source == \"JoyousSpring\" or false\n    end,"
    },
    {
      "type": "Joker",
      "key": "generaider_dovelgus",
      "atlas": "Generaider",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"generaider_dovelgus\",\n    atlas = 'Generaider',\n    pos = { x = 3, y = 1 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_tribute\" }\n        end\n        return { vars = { card.ability.extra.tributes, card.ability.extra.xmult } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Generaider\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"EARTH\",\n                monster_type = \"Machine\",\n                monster_archetypes = { [\"Generaider\"] = true }\n            },\n            tributes = 2,\n            xmult = 4\n        },\n        active = false\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card then\n                if context.joy_activate_effect and context.joy_activated_card == card then\n                    local materials_owned = JoyousSpring.get_materials_owned(\n                        { { monster_archetypes = { \"Generaider\" } }, { monster_type = \"Machine\" } }, false, true)\n                    local materials = {}\n                    for _, material in ipairs(materials_owned) do\n                        if material ~= card then\n                            materials[#materials + 1] = material\n                        end\n                    end\n                    if #materials >= card.ability.extra.tributes then\n                        JoyousSpring.create_overlay_effect_selection(card, materials, card.ability.extra.tributes,\n                            card.ability.extra.tributes)\n                    end\n                end\n                if context.joy_exit_effect_selection and context.joy_card == card and\n                    #context.joy_selection == card.ability.extra.tributes then\n                    JoyousSpring.tribute(card, context.joy_selection)\n                    card.ability.extra.active = true\n                end\n                if context.end_of_round and context.game_over == false and context.main_eval then\n                    card.ability.extra.active = false\n                end\n            end\n            if context.other_joker and context.other_joker.facing == \"front\" and (JoyousSpring.is_monster_archetype(context.other_joker, \"Generaider\") or\n                    JoyousSpring.is_monster_type(context.other_joker, \"Machine\")) then\n                if card.ability.extra.active then\n                    return {\n                        xmult = card.ability.extra.xmult,\n                        message_card = context.other_joker\n                    }\n                end\n            end\n        end\n    end,\n    joy_can_activate = function(card)\n        if card.ability.extra.active then\n            return false\n        end\n        local materials_owned = JoyousSpring.get_materials_owned(\n            { { monster_archetypes = { \"Generaider\" } }, { monster_type = \"Machine\" } }, false, true)\n        local materials = {}\n        for _, material in ipairs(materials_owned) do\n            if material ~= card then\n                materials[#materials + 1] = material\n            end\n        end\n        return #materials >= card.ability.extra.tributes\n    end,\n    in_pool = function(self, args)\n        return args and args.source and args.source == \"JoyousSpring\" or false\n    end,"
    },
    {
      "type": "Joker",
      "key": "generaider_naglfar",
      "atlas": "Generaider",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = \"generaider_naglfar\",\n    atlas = 'Generaider',\n    pos = { x = 0, y = 2 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_tribute\" }\n        end\n        return { vars = { card.ability.extra.tributes, card.ability.extra.hands, card.ability.extra.discards } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Generaider\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"FIRE\",\n                monster_type = \"BeastWarrior\",\n                monster_archetypes = { [\"Generaider\"] = true }\n            },\n            tributes = 2,\n            hands = 1,\n            discards = 1,\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card then\n                if context.joy_activate_effect and context.joy_activated_card == card then\n                    local materials = JoyousSpring.get_materials_owned(\n                        { { monster_archetypes = { \"Generaider\" } }, { monster_type = \"BeastWarrior\" } }, false, true)\n                    if #materials >= card.ability.extra.tributes then\n                        JoyousSpring.create_overlay_effect_selection(card, materials, card.ability.extra.tributes,\n                            card.ability.extra.tributes)\n                    end\n                end\n                if context.joy_exit_effect_selection and context.joy_card == card and\n                    #context.joy_selection == card.ability.extra.tributes then\n                    JoyousSpring.tribute(card, context.joy_selection)\n                    ease_hands_played(card.ability.extra.hands)\n                    ease_discard(card.ability.extra.discards)\n                end\n            end\n        end\n    end,\n    joy_can_activate = function(card)\n        if not (G.GAME.blind and G.GAME.blind.in_blind) then\n            return false\n        end\n        local materials = JoyousSpring.get_materials_owned(\n            { { monster_archetypes = { \"Generaider\" } }, { monster_type = \"BeastWarrior\" } }, false, true)\n        return #materials >= card.ability.extra.tributes\n    end,\n    in_pool = function(self, args)\n        return args and args.source and args.source == \"JoyousSpring\" or false\n    end,"
    },
    {
      "type": "Joker",
      "key": "generaider_hela",
      "atlas": "Generaider",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "key = \"generaider_hela\",\n    atlas = 'Generaider',\n    pos = { x = 1, y = 2 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_tribute\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n        end\n        return { vars = { card.ability.extra.tributes, card.ability.extra.revives } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Generaider\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Zombie\",\n                monster_archetypes = { [\"Generaider\"] = true }\n            },\n            tributes = 2,\n            revives = 1,\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card then\n                if context.joy_activate_effect and context.joy_activated_card == card then\n                    local materials = JoyousSpring.get_materials_owned(\n                        { { monster_archetypes = { \"Generaider\" } }, { monster_type = \"Zombie\" } }, false, true)\n                    if #materials >= card.ability.extra.tributes then\n                        JoyousSpring.create_overlay_effect_selection(card, materials, card.ability.extra.tributes,\n                            card.ability.extra.tributes)\n                    end\n                end\n                if context.joy_exit_effect_selection and context.joy_card == card and\n                    #context.joy_selection == card.ability.extra.tributes then\n                    JoyousSpring.tribute(card, context.joy_selection)\n                    for i = 1, card.ability.extra.revives do\n                        JoyousSpring.revive_pseudorandom(\n                            { { rarity = 3, monster_archetypes = { \"Generaider\" } } },\n                            'j_joy_generaider_hela',\n                            false,\n                            { negative = true }\n                        )\n                    end\n                end\n            end\n        end\n    end,\n    joy_can_activate = function(card)\n        if not (G.GAME.blind and G.GAME.blind.in_blind) then\n            return false\n        end\n        local materials = JoyousSpring.get_materials_owned(\n            { { monster_archetypes = { \"Generaider\" } }, { monster_type = \"Zombie\" } }, false, true)\n        return #materials >= card.ability.extra.tributes\n    end,\n    in_pool = function(self, args)\n        return args and args.source and args.source == \"JoyousSpring\" or false\n    end,"
    },
    {
      "type": "Joker",
      "key": "generaider_jormungandr",
      "atlas": "Generaider",
      "pos": {
        "x": 3,
        "y": 2
      },
      "raw": "key = \"generaider_jormungandr\",\n    atlas = 'Generaider',\n    pos = { x = 3, y = 2 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 8,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_detach\" }\n        end\n        return { vars = { card.ability.extra.mult, card.ability.extra.joyous_spring.xyz_materials * card.ability.extra.mult, card.ability.extra.detach, card.ability.extra.hsize } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Generaider\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    update = JoyousSpring.update_counter,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"XYZ\",\n                attribute = \"EARTH\",\n                monster_type = \"Reptile\",\n                monster_archetypes = { [\"Generaider\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"XYZ\",\n                        materials = {\n                            { min = 2, rarity = 3, exclude_tokens = true, exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                        },\n                    }\n                }\n            },\n            mult = 100,\n            detach = 2,\n            hsize = 1,\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.joy_detach and context.joy_detaching_card == card then\n                JoyousSpring.ease_detach(card)\n                G.hand:change_size(card.ability.extra.hsize)\n            end\n            if context.joker_main then\n                return {\n                    mult = card.ability.extra.joyous_spring.xyz_materials * card.ability.extra.mult\n                }\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "generaider_laevatein",
      "atlas": "Generaider",
      "pos": {
        "x": 0,
        "y": 3
      },
      "raw": "key = \"generaider_laevatein\",\n    atlas = 'Generaider',\n    pos = { x = 0, y = 3 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 12,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_detach\" }\n        end\n        return { vars = { card.ability.extra.detach } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_generaider_jormungandr\",                             name = \"k_joy_creates\" },\n        { properties = { { monster_archetypes = { \"Generaider\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"XYZ\",\n                attribute = \"FIRE\",\n                monster_type = \"Fairy\",\n                monster_archetypes = { [\"Generaider\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"XYZ\",\n                        materials = {\n                            { rarity = 3, exclude_tokens = true, exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                            { rarity = 3, exclude_tokens = true, exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                            { rarity = 3, exclude_tokens = true, exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                            { rarity = 3, exclude_tokens = true, exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                            { rarity = 3, exclude_tokens = true, exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                        },\n                    }\n                }\n            },\n            detach = 5\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.joy_detach and context.joy_detaching_card == card then\n                for _, joker in ipairs(G.jokers.cards) do\n                    if joker ~= card then\n                        joker.getting_sliced = true\n                        joker:start_dissolve()\n                    end\n                end\n                local added_card = JoyousSpring.create_summon({\n                    key = \"j_joy_generaider_jormungandr\"\n                }, true)\n                added_card.ability.extra.joyous_spring.xyz_materials = JoyousSpring.get_graveyard_count()\n                JoyousSpring.empty_graveyard()\n                JoyousSpring.ease_detach(card)\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "generaider_boss_stage",
      "atlas": "Generaider",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "key = \"generaider_boss_stage\",\n    atlas = 'Generaider',\n    pos = { x = 2, y = 2 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 15,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_token\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_tribute\" }\n        end\n        return { vars = { card.ability.extra.mult, card.ability.extra.current_mult, card.ability.extra.tributes, card.ability.extra.cards_to_create } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Generaider\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_field_spell = true,\n                monster_archetypes = { [\"Generaider\"] = true },\n            },\n            mult = 1,\n            current_mult = 0,\n            tributes = 2,\n            cards_to_create = 1,\n            used = false,\n        },\n    },\n    calculate = function(self, card, context)\n        if context.joy_tributed then\n            card.ability.extra.current_mult = card.ability.extra.current_mult + card.ability.extra.mult\n        end\n        if context.other_joker and context.other_joker.facing == \"front\" and JoyousSpring.is_monster_archetype(context.other_joker, \"Generaider\") then\n            return {\n                mult = card.ability.extra.current_mult,\n                message_card = context.other_joker\n            }\n        end\n        if context.setting_blind and context.main_eval then\n            local generaiders = JoyousSpring.get_materials_owned({ { monster_archetypes = { \"Generaider\" }, exclude_tokens = true } })\n            local count = 0\n            for _, joker in ipairs(generaiders) do\n                if not joker.edition or not joker.edition.negative then\n                    count = count + 1\n                end\n            end\n            local i = 0\n            while (#G.jokers.cards + G.GAME.joker_buffer < G.jokers.config.card_limit - i + count) and (i < 20) do\n                JoyousSpring.summon_token(\"generaider\")\n                i = i + 1\n            end\n        end\n        if context.joy_activate_effect and context.joy_activated_card == card then\n            local tokens = JoyousSpring.get_materials_owned({ { key = \"j_joy_token\", monster_archetypes = { \"Generaider\" } } })\n            if #tokens >= card.ability.extra.tributes then\n                JoyousSpring.create_overlay_effect_selection(card, tokens, card.ability.extra.tributes,\n                    card.ability.extra.tributes)\n            end\n        end\n        if context.joy_exit_effect_selection and context.joy_card == card and\n            #context.joy_selection == card.ability.extra.tributes then\n            JoyousSpring.tribute(card, context.joy_selection)\n            card.ability.extra.used = true\n\n            for i = 1, card.ability.extra.cards_to_create do\n                JoyousSpring.create_pseudorandom(\n                    { { monster_archetypes = { \"Generaider\" }, rarity = 3, is_main_deck = true } },\n                    'j_joy_generaider_boss_stage', true, true)\n            end\n        end\n        if context.end_of_round and context.main_eval then\n            card.ability.extra.used = false\n        end\n    end,\n    joy_can_activate = function(card)\n        local tokens = JoyousSpring.get_materials_owned({ { key = \"j_joy_token\", monster_archetypes = { \"Generaider\" } } })\n        return not card.debuff and\n            (not card.ability.extra.used and #G.jokers.cards + G.GAME.joker_buffer - card.ability.extra.tributes < G.jokers.config.card_limit and #tokens >= card.ability.extra.tributes) and\n            true or false\n    end,"
    },
    {
      "type": "Atlas",
      "key": "Ghoti",
      "atlas": null,
      "pos": null,
      "raw": "key = \"Ghoti\",\n    path = \"08Ghoti.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Atlas",
      "key": "Ghoti02",
      "atlas": null,
      "pos": null,
      "raw": "key = \"Ghoti02\",\n    path = \"08Ghoti02.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Joker",
      "key": "fish_keaf",
      "atlas": "Ghoti",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"fish_keaf\",\n    atlas = 'Ghoti',\n    pos = { x = 0, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 2,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_banish\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n        end\n        return { vars = { card.ability.extra.revives } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_fish_depths\", properties = { { monster_archetypes = { \"Ghoti\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"WATER\",\n                monster_type = \"Fish\",\n                monster_archetypes = { [\"Ghoti\"] = true }\n            },\n            revives = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.end_of_round and context.game_over == false and context.main_eval then\n                local func = function(c)\n                    for i = 1, c.ability.extra.revives do\n                        JoyousSpring.revive_pseudorandom(\n                            {\n                                { summon_type = \"SYNCHRO\" },\n                            },\n                            'j_joy_fish_keaf',\n                            true\n                        )\n                    end\n                end\n                JoyousSpring.banish(card, \"blind_selected\", func)\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "fish_paces",
      "atlas": "Ghoti",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"fish_paces\",\n    atlas = 'Ghoti',\n    pos = { x = 1, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 4,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_banish\" }\n        end\n        return { vars = { card.ability.extra.chips } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_fish_depths\", properties = { { monster_archetypes = { \"Ghoti\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_tuner = true,\n                attribute = \"WATER\",\n                monster_type = \"Fish\",\n                monster_archetypes = { [\"Ghoti\"] = true }\n            },\n            chips = 50\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.end_of_round and context.game_over == false and context.main_eval then\n                JoyousSpring.banish(card, \"blind_selected\")\n            end\n            if context.joker_main then\n                return {\n                    chips = card.ability.extra.chips\n                }\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "fish_shif",
      "atlas": "Ghoti",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"fish_shif\",\n    atlas = 'Ghoti',\n    pos = { x = 2, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 4,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_banish\" }\n        end\n        return { vars = { card.ability.extra.mult } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_fish_depths\", properties = { { monster_archetypes = { \"Ghoti\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_tuner = true,\n                attribute = \"WATER\",\n                monster_type = \"Fish\",\n                monster_archetypes = { [\"Ghoti\"] = true }\n            },\n            mult = 15\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.end_of_round and context.game_over == false and context.main_eval then\n                JoyousSpring.banish(card, \"blind_selected\")\n            end\n            if context.joker_main then\n                return {\n                    mult = card.ability.extra.mult\n                }\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "fish_zep",
      "atlas": "Ghoti",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"fish_zep\",\n    atlas = 'Ghoti',\n    pos = { x = 3, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 2,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_banish\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_main_deck_joker\" }\n        end\n        return { vars = { card.ability.extra.revives } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_fish_depths\", properties = { { monster_archetypes = { \"Ghoti\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_tuner = true,\n                attribute = \"WATER\",\n                monster_type = \"Fish\",\n                monster_archetypes = { [\"Ghoti\"] = true }\n            },\n            revives = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.end_of_round and context.game_over == false and context.main_eval then\n                local func = function(c)\n                    for i = 1, c.ability.extra.revives do\n                        JoyousSpring.revive_pseudorandom(\n                            { { is_main_deck = true, monster_archetypes = { \"Ghoti\" } } },\n                            'j_joy_fish_zep',\n                            true\n                        )\n                    end\n                end\n                JoyousSpring.banish(card, \"blind_selected\", func)\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "fish_ixeep",
      "atlas": "Ghoti",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"fish_ixeep\",\n    atlas = 'Ghoti',\n    pos = { x = 0, y = 1 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 4,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_banish\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_main_deck_joker\" }\n        end\n        return { vars = { card.ability.extra.cards_to_create } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_fish_depths\", properties = { { monster_archetypes = { \"Ghoti\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"WATER\",\n                monster_type = \"Fish\",\n                monster_archetypes = { [\"Ghoti\"] = true }\n            },\n            cards_to_create = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.end_of_round and context.game_over == false and context.main_eval then\n                local func = function(c)\n                    for i = 1, c.ability.extra.cards_to_create do\n                        JoyousSpring.create_pseudorandom(\n                            { { monster_archetypes = { \"Ghoti\" }, is_main_deck = true, exclude_keys = { \"j_joy_fish_ixeep\" } } },\n                            'j_joy_fish_ixeep', true)\n                    end\n                end\n                JoyousSpring.banish(card, \"boss_selected\", func)\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "fish_eanoc",
      "atlas": "Ghoti",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"fish_eanoc\",\n    atlas = 'Ghoti',\n    pos = { x = 1, y = 1 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 4,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_banish\" }\n        end\n        return { vars = { card.ability.extra.cards_to_create, card.ability.extra.times, card.ability.extra.returned } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_fish_depths\", properties = { { monster_archetypes = { \"Ghoti\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"WATER\",\n                monster_type = \"Fish\",\n                monster_archetypes = { [\"Ghoti\"] = true }\n            },\n            cards_to_create = 1,\n            times = 3,\n            returned = 0\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.end_of_round and context.game_over == false and context.main_eval then\n                JoyousSpring.banish(card, \"blind_selected\")\n            end\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.joy_returned and context.joy_returned_card == card then\n                card.ability.extra.returned = card.ability.extra.returned + 1\n                if card.ability.extra.returned >= card.ability.extra.times then\n                    card.ability.extra.returned = 0\n                    local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Ghoti\" }, is_extra_deck = true } })\n\n                    for i = 1, card.ability.extra.cards_to_create do\n                        local key_to_add, _ = pseudorandom_element(choices, 'j_joy_fish_eanoc')\n                        if key_to_add and #JoyousSpring.extra_deck_area.cards < JoyousSpring.extra_deck_area.config.card_limit then\n                            JoyousSpring.add_to_extra_deck(key_to_add)\n                        end\n                    end\n                end\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "fish_psiics",
      "atlas": "Ghoti",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"fish_psiics\",\n    atlas = 'Ghoti',\n    pos = { x = 2, y = 1 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_banish\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n        end\n        return { vars = { card.ability.extra.revives } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_fish_depths\", properties = { { monster_archetypes = { \"Ghoti\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"WATER\",\n                monster_type = \"Fish\",\n                monster_archetypes = { [\"Ghoti\"] = true }\n            },\n            revives = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.end_of_round and context.game_over == false and context.main_eval then\n                local func = function(c)\n                    for i = 1, c.ability.extra.revives do\n                        JoyousSpring.revive_pseudorandom(\n                            {\n                                { is_tuner = true },\n                            },\n                            'j_joy_fish_psiics',\n                            false,\n                            { negative = true }\n                        )\n                    end\n                end\n                JoyousSpring.banish(card, \"boss_selected\", func)\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "fish_snopios",
      "atlas": "Ghoti",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"fish_snopios\",\n    atlas = 'Ghoti',\n    pos = { x = 3, y = 1 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 7,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_banish\" }\n        end\n        return { vars = { card.ability.extra.banishes, card.ability.extra.times, card.ability.extra.returned } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_fish_depths\", name = \"k_joy_adds\" },\n        { \"j_joy_fish_depths\", properties = { { monster_archetypes = { \"Ghoti\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"WATER\",\n                monster_type = \"Fish\",\n                monster_archetypes = { [\"Ghoti\"] = true }\n            },\n            banishes = 1,\n            times = 6,\n            returned = 0\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.end_of_round and context.game_over == false and context.main_eval then\n                JoyousSpring.banish(card, \"blind_selected\")\n                local choices = {}\n                for _, consumable in ipairs(G.consumeables.cards) do\n                    table.insert(choices, consumable)\n                end\n                for i = 1, card.ability.extra.banishes do\n                    if #choices > 0 then\n                        local to_banish, pos = pseudorandom_element(choices, 'j_joy_fish_snopios')\n                        if to_banish then\n                            JoyousSpring.banish(to_banish, \"blind_selected\")\n                        end\n                        table.remove(choices, pos)\n                    end\n                end\n            end\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.joy_returned and context.joy_returned_card == card then\n                card.ability.extra.returned = card.ability.extra.returned + 1\n                if card.ability.extra.returned >= card.ability.extra.times then\n                    card.ability.extra.returned = 0\n\n                    if #JoyousSpring.field_spell_area.cards < JoyousSpring.field_spell_area.config.card_limit then\n                        JoyousSpring.add_to_extra_deck(\"j_joy_fish_depths\")\n                    end\n                end\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "fish_arionpos",
      "atlas": "Ghoti",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = \"fish_arionpos\",\n    atlas = 'Ghoti',\n    pos = { x = 0, y = 2 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 9,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_banish\" }\n        end\n        return { vars = { card.ability.extra.chips, card.ability.extra.chips * (G.GAME.joy_cards_banished or 0), card.ability.extra.cards_to_create } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_fish_depths\", properties = { { monster_archetypes = { \"Ghoti\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"SYNCHRO\",\n                attribute = \"WATER\",\n                monster_type = \"Fish\",\n                monster_archetypes = { [\"Ghoti\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"SYNCHRO\",\n                        materials = {\n                            { is_tuner = true,       monster_type = \"Fish\",                   exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                            { exclude_tuners = true, exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                        },\n                    }\n                }\n            },\n            chips = 5,\n            cards_to_create = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.end_of_round and context.game_over == false and context.main_eval then\n                local func = function(c)\n                    local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Ghoti\" }, is_extra_deck = true } })\n\n                    for i = 1, c.ability.extra.cards_to_create do\n                        local key_to_add, _ = pseudorandom_element(choices, 'j_joy_fish_arionpos')\n                        if key_to_add and #JoyousSpring.extra_deck_area.cards < JoyousSpring.extra_deck_area.config.card_limit then\n                            JoyousSpring.add_to_extra_deck(key_to_add)\n                        end\n                    end\n                end\n                JoyousSpring.banish(card, \"blind_selected\", func)\n            end\n            if context.joker_main then\n                return {\n                    chips = card.ability.extra.chips * (G.GAME.joy_cards_banished or 0)\n                }\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "fish_askaan",
      "atlas": "Ghoti",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "key = \"fish_askaan\",\n    atlas = 'Ghoti',\n    pos = { x = 1, y = 2 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_banish\" }\n        end\n        return { vars = { card.ability.extra.mult, card.ability.extra.mult * (G.GAME.joy_cards_banished or 0) } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_fish_depths\", properties = { { monster_archetypes = { \"Ghoti\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"SYNCHRO\",\n                attribute = \"WATER\",\n                monster_type = \"Fish\",\n                monster_archetypes = { [\"Ghoti\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"SYNCHRO\",\n                        materials = {\n                            { is_tuner = true, exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                            { rarity = 3,      exclude_tuners = true,                   exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                        },\n                    }\n                }\n            },\n            mult = 5,\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.end_of_round and context.game_over == false and context.main_eval then\n                JoyousSpring.banish(card, \"blind_selected\")\n\n                local choices = JoyousSpring.get_materials_owned({ { exclude_monster_archetypes = { \"Ghoti\" } } })\n                local to_banish = pseudorandom_element(choices, 'j_joy_fish_askaan')\n                if to_banish then\n                    JoyousSpring.banish(to_banish, \"blind_selected\")\n                end\n            end\n            if context.joker_main then\n                return {\n                    mult = card.ability.extra.mult * (G.GAME.joy_cards_banished or 0)\n                }\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "fish_guoglim",
      "atlas": "Ghoti",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "key = \"fish_guoglim\",\n    atlas = 'Ghoti',\n    pos = { x = 2, y = 2 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_banish\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n        end\n        return { vars = { card.ability.extra.xmult, 1 + (card.ability.extra.xmult * (G.GAME.joy_cards_banished or 0)) } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_fish_depths\", properties = { { monster_archetypes = { \"Ghoti\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"SYNCHRO\",\n                attribute = \"WATER\",\n                monster_type = \"Fish\",\n                monster_archetypes = { [\"Ghoti\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"SYNCHRO\",\n                        materials = {\n                            { is_tuner = true, exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                            { rarity = 3,      exclude_tuners = true,                   exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                        },\n                    }\n                }\n            },\n            xmult = 0.1,\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.end_of_round and context.game_over == false and context.main_eval then\n                JoyousSpring.banish(card, \"blind_selected\")\n            end\n            if context.joker_main then\n                return {\n                    xmult = 1 + (card.ability.extra.xmult * (G.GAME.joy_cards_banished or 0))\n                }\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not from_debuff and not card.debuff then\n            if (#G.jokers.cards + G.GAME.joker_buffer < G.jokers.config.card_limit - ((card.edition and card.edition.negative) and 0 or 1)) then\n                local revive_fish = JoyousSpring.revive_pseudorandom(\n                    { { monster_type = \"Fish\" } },\n                    'j_joy_fish_guoglim',\n                    true\n                )\n                while revive_fish and (#G.jokers.cards + G.GAME.joker_buffer < G.jokers.config.card_limit - ((card.edition and card.edition.negative) and 0 or 1)) do\n                    revive_fish = JoyousSpring.revive_pseudorandom(\n                        { { monster_type = \"Fish\" } },\n                        'j_joy_fish_guoglim',\n                        true\n                    )\n                end\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "fish_deepbeyond",
      "atlas": "Ghoti",
      "pos": {
        "x": 3,
        "y": 2
      },
      "raw": "key = \"fish_deepbeyond\",\n    atlas = 'Ghoti',\n    pos = { x = 3, y = 2 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 12,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_banish\" }\n        end\n        return {}\n    end,\n    joy_desc_cards = {\n        { \"j_joy_fish_depths\", properties = { { monster_archetypes = { \"Ghoti\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"SYNCHRO\",\n                attribute = \"WATER\",\n                monster_type = \"Fish\",\n                monster_archetypes = { [\"Ghoti\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"SYNCHRO\",\n                        materials = {\n                            { is_tuner = true, monster_type = \"Fish\", exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                            { is_tuner = true, monster_type = \"Fish\", exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                            { rarity = 3,      exclude_tuners = true, exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                        },\n                    }\n                }\n            },\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.end_of_round and context.game_over == false and context.main_eval then\n                JoyousSpring.banish(card, \"blind_selected\")\n                local choices = JoyousSpring.get_materials_owned({ { exclude_monster_archetypes = { \"Ghoti\" } } })\n                for _, joker in ipairs(choices) do\n                    JoyousSpring.banish(joker, \"blind_selected\")\n                end\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "fish_depths",
      "atlas": "Ghoti02",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"fish_depths\",\n    atlas = 'Ghoti02',\n    pos = { x = 0, y = 0 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_banish\" }\n        end\n\n        return { vars = { card.ability.extra.money } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_fish_depths\", properties = { { monster_archetypes = { \"Ghoti\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_field_spell = true,\n            },\n            money = 1,\n        },\n    },\n    calculate = function(self, card, context)\n        if context.joy_banished then\n            return {\n                dollars = card.ability.extra.money\n            }\n        end\n    end,"
    },
    {
      "type": "Atlas",
      "key": "PSYFrame",
      "atlas": null,
      "pos": null,
      "raw": "key = \"PSYFrame\",\n    path = \"09PSYFrame.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Atlas",
      "key": "PSYFrame02",
      "atlas": null,
      "pos": null,
      "raw": "key = \"PSYFrame02\",\n    path = \"09PSYFrame02.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Joker",
      "key": "psy_driver",
      "atlas": "PSYFrame",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"psy_driver\",\n    atlas = 'PSYFrame',\n    pos = { x = 0, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 1,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"PSYFrame\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_effect = false,\n                attribute = \"LIGHT\",\n                monster_type = \"Psychic\",\n                monster_archetypes = { [\"PSYFrame\"] = true }\n            },\n        },\n    },\n    in_pool = function(self, args)\n        return args and args.source and args.source == \"JoyousSpring\" or false\n    end,"
    },
    {
      "type": "Joker",
      "key": "psy_alpha",
      "atlas": "PSYFrame",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"psy_alpha\",\n    atlas = 'PSYFrame',\n    pos = { x = 1, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_banish\" }\n        end\n        return { vars = { card.ability.extra.cards_to_create, card.ability.extra.xmult } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"PSYFrame\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_tuner = true,\n                attribute = \"LIGHT\",\n                monster_type = \"Psychic\",\n                monster_archetypes = { [\"PSYFrame\"] = true }\n            },\n            cards_to_create = 1,\n            xmult = 1.1,\n            active = true\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and context.setting_blind and context.main_eval then\n                local _, driver = next(SMODS.find_card(\"j_joy_psy_driver\", true))\n                if not driver then\n                    _, driver = next(SMODS.find_card(\"j_joy_psy_multithreader\", true))\n                end\n                if driver then\n                    JoyousSpring.banish(driver, \"end_of_round\", nil, true)\n                    card.ability.extra.active = true\n                elseif next(SMODS.find_card(\"j_joy_psy_lambda\")) then\n                    card.ability.extra.active = true\n                end\n            end\n            if card.ability.extra.active and context.individual and context.cardarea == G.hand then\n                return {\n                    xmult = card.ability.extra.xmult\n                }\n            end\n        end\n        if not context.blueprint_card and context.end_of_round and context.game_over == false and context.main_eval then\n            card.ability.extra.active = false\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff then\n            for i = 1, card.ability.extra.cards_to_create do\n                JoyousSpring.create_summon({\n                    key = \"j_joy_psy_driver\"\n                }, true)\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "psy_beta",
      "atlas": "PSYFrame",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"psy_beta\",\n    atlas = 'PSYFrame',\n    pos = { x = 2, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_banish\" }\n        end\n        return { vars = { card.ability.extra.cards_to_create, card.ability.extra.xmult } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"PSYFrame\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_tuner = true,\n                attribute = \"LIGHT\",\n                monster_type = \"Psychic\",\n                monster_archetypes = { [\"PSYFrame\"] = true }\n            },\n            cards_to_create = 1,\n            xmult = 1.5\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and context.setting_blind and context.main_eval then\n                local _, driver = next(SMODS.find_card(\"j_joy_psy_driver\", true))\n                if not driver then\n                    _, driver = next(SMODS.find_card(\"j_joy_psy_multithreader\", true))\n                end\n                if driver then\n                    JoyousSpring.banish(driver, \"end_of_round\", nil, true)\n                    card.ability.extra.active = true\n                elseif next(SMODS.find_card(\"j_joy_psy_lambda\")) then\n                    card.ability.extra.active = true\n                end\n            end\n            if card.ability.extra.active and context.individual and context.cardarea == G.play then\n                return {\n                    xmult = card.ability.extra.xmult\n                }\n            end\n        end\n        if not context.blueprint_card and context.end_of_round and context.game_over == false and context.main_eval then\n            card.ability.extra.active = false\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff then\n            for i = 1, card.ability.extra.cards_to_create do\n                JoyousSpring.create_summon({\n                    key = \"j_joy_psy_driver\"\n                }, true)\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "psy_gamma",
      "atlas": "PSYFrame",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"psy_gamma\",\n    atlas = 'PSYFrame',\n    pos = { x = 3, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_banish\" }\n        end\n        return { vars = { card.ability.extra.cards_to_create, card.ability.extra.xmult } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"PSYFrame\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_tuner = true,\n                attribute = \"LIGHT\",\n                monster_type = \"Psychic\",\n                monster_archetypes = { [\"PSYFrame\"] = true }\n            },\n            cards_to_create = 1,\n            xmult = 1.2\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and context.setting_blind and context.main_eval then\n                local _, driver = next(SMODS.find_card(\"j_joy_psy_driver\", true))\n                if not driver then\n                    _, driver = next(SMODS.find_card(\"j_joy_psy_multithreader\", true))\n                end\n                if driver then\n                    JoyousSpring.banish(driver, \"end_of_round\", nil, true)\n                    card.ability.extra.active = true\n                elseif next(SMODS.find_card(\"j_joy_psy_lambda\")) then\n                    card.ability.extra.active = true\n                end\n            end\n            if card.ability.extra.active and context.other_joker then\n                return {\n                    xmult = card.ability.extra.xmult,\n                    message_card = context.other_joker\n                }\n            end\n        end\n        if not context.blueprint_card and context.end_of_round and context.game_over == false and context.main_eval then\n            card.ability.extra.active = false\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff then\n            for i = 1, card.ability.extra.cards_to_create do\n                JoyousSpring.create_summon({\n                    key = \"j_joy_psy_driver\"\n                }, true)\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "psy_delta",
      "atlas": "PSYFrame",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"psy_delta\",\n    atlas = 'PSYFrame',\n    pos = { x = 0, y = 1 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_banish\" }\n        end\n        return { vars = { card.ability.extra.cards_to_create, card.ability.extra.xmult } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"PSYFrame\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_tuner = true,\n                attribute = \"LIGHT\",\n                monster_type = \"Psychic\",\n                monster_archetypes = { [\"PSYFrame\"] = true }\n            },\n            cards_to_create = 1,\n            xmult = 2\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and context.setting_blind and context.main_eval then\n                local _, driver = next(SMODS.find_card(\"j_joy_psy_driver\", true))\n                if not driver then\n                    _, driver = next(SMODS.find_card(\"j_joy_psy_multithreader\", true))\n                end\n                if driver then\n                    JoyousSpring.banish(driver, \"end_of_round\", nil, true)\n                    card.ability.extra.active = true\n                elseif next(SMODS.find_card(\"j_joy_psy_lambda\")) then\n                    card.ability.extra.active = true\n                end\n            end\n            if card.ability.extra.active and context.other_consumeable and context.other_consumeable.ability.set == \"Tarot\" then\n                return {\n                    xmult = card.ability.extra.xmult\n                }\n            end\n        end\n        if not context.blueprint_card and context.end_of_round and context.game_over == false and context.main_eval then\n            card.ability.extra.active = false\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff then\n            for i = 1, card.ability.extra.cards_to_create do\n                JoyousSpring.create_summon({\n                    key = \"j_joy_psy_driver\"\n                }, true)\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "psy_epsilon",
      "atlas": "PSYFrame",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"psy_epsilon\",\n    atlas = 'PSYFrame',\n    pos = { x = 1, y = 1 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_banish\" }\n        end\n        return { vars = { card.ability.extra.cards_to_create, card.ability.extra.xmult } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"PSYFrame\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_tuner = true,\n                attribute = \"LIGHT\",\n                monster_type = \"Psychic\",\n                monster_archetypes = { [\"PSYFrame\"] = true }\n            },\n            cards_to_create = 1,\n            xmult = 2\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and context.setting_blind and context.main_eval then\n                local _, driver = next(SMODS.find_card(\"j_joy_psy_driver\", true))\n                if not driver then\n                    _, driver = next(SMODS.find_card(\"j_joy_psy_multithreader\", true))\n                end\n                if driver then\n                    JoyousSpring.banish(driver, \"end_of_round\", nil, true)\n                    card.ability.extra.active = true\n                elseif next(SMODS.find_card(\"j_joy_psy_lambda\")) then\n                    card.ability.extra.active = true\n                end\n            end\n            if card.ability.extra.active and context.other_consumeable and context.other_consumeable.ability.set == \"Planet\" then\n                return {\n                    xmult = card.ability.extra.xmult\n                }\n            end\n        end\n        if not context.blueprint_card and context.end_of_round and context.game_over == false and context.main_eval then\n            card.ability.extra.active = false\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff then\n            for i = 1, card.ability.extra.cards_to_create do\n                JoyousSpring.create_summon({\n                    key = \"j_joy_psy_driver\"\n                }, true)\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "psy_multithreader",
      "atlas": "PSYFrame",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"psy_multithreader\",\n    atlas = 'PSYFrame',\n    pos = { x = 2, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 3,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_main_deck_joker\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_banish\" }\n        end\n        return { vars = { card.ability.extra.cards_to_create } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"PSYFrame\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"LIGHT\",\n                monster_type = \"Psychic\",\n                monster_archetypes = { [\"PSYFrame\"] = true }\n            },\n            cards_to_create = 1,\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and context.joy_returned and context.joy_returned_card == card then\n                for i = 1, card.ability.extra.cards_to_create do\n                    JoyousSpring.create_pseudorandom(\n                        { { monster_archetypes = { \"PSYFrame\" }, is_main_deck = true, is_effect = true, exclude_keys = { \"j_joy_psy_multithreader\" } } },\n                        'j_joy_psy_multithreader', true)\n                end\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "psy_zeta",
      "atlas": "PSYFrame",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"psy_zeta\",\n    atlas = 'PSYFrame',\n    pos = { x = 3, y = 1 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_banish\" }\n        end\n        return { vars = { card.ability.extra.banishes } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"PSYFrame\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"SYNCHRO\",\n                attribute = \"LIGHT\",\n                monster_type = \"Psychic\",\n                monster_archetypes = { [\"PSYFrame\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"SYNCHRO\",\n                        materials = {\n                            { is_tuner = true, exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                            { rarity = 1,      exclude_tuners = true,                   exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                        },\n                    }\n                }\n            },\n            banishes = 2\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and context.end_of_round and context.game_over == false and context.main_eval then\n                JoyousSpring.banish(card, \"blind_selected\")\n                local choices = {}\n                for _, consumable in ipairs(G.consumeables.cards) do\n                    table.insert(choices, consumable)\n                end\n                for i = 1, card.ability.extra.banishes do\n                    if #choices > 0 then\n                        local to_banish, pos = pseudorandom_element(choices, 'j_joy_psy_zeta')\n                        if to_banish then\n                            JoyousSpring.banish(to_banish, \"blind_selected\")\n                        end\n                        table.remove(choices, pos)\n                    end\n                end\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "psy_omega",
      "atlas": "PSYFrame",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = \"psy_omega\",\n    atlas = 'PSYFrame',\n    pos = { x = 0, y = 2 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_banish\" }\n        end\n        return {}\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"PSYFrame\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"SYNCHRO\",\n                attribute = \"LIGHT\",\n                monster_type = \"Psychic\",\n                monster_archetypes = { [\"PSYFrame\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"SYNCHRO\",\n                        materials = {\n                            { is_tuner = true, exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                            { rarity = 1,      exclude_tuners = true,                   exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                        },\n                    }\n                }\n            },\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and context.end_of_round and context.game_over == false and context.main_eval then\n                JoyousSpring.banish(card, \"blind_selected\")\n                local choices = JoyousSpring.get_materials_owned({ { exclude_keys = { \"j_joy_psy_omega\" } } })\n                local to_banish = pseudorandom_element(choices, 'j_joy_psy_omega')\n                if to_banish then\n                    JoyousSpring.banish(to_banish, \"blind_selected\")\n                end\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "psy_lambda",
      "atlas": "PSYFrame",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "key = \"psy_lambda\",\n    atlas = 'PSYFrame',\n    pos = { x = 1, y = 2 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 8,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_banish\" }\n        end\n        return { vars = { card.ability.extra.cards_to_create } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"PSYFrame\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"LINK\",\n                attribute = \"LIGHT\",\n                monster_type = \"Psychic\",\n                monster_archetypes = { [\"PSYFrame\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"LINK\",\n                        materials = {\n                            { exclude_tokens = true },\n                            { exclude_tokens = true },\n                        },\n                    }\n                }\n            },\n            cards_to_create = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.joy_returned and JoyousSpring.is_monster_type(context.joy_returned_card, \"Psychic\") then\n                local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"PSYFrame\" }, is_extra_deck = true, exclude_keys = { \"j_joy_psy_lambda\" } } })\n\n                for i = 1, card.ability.extra.cards_to_create do\n                    local key_to_add, _ = pseudorandom_element(choices, 'j_joy_psy_lambda')\n                    if key_to_add and #JoyousSpring.extra_deck_area.cards < JoyousSpring.extra_deck_area.config.card_limit then\n                        JoyousSpring.add_to_extra_deck(key_to_add)\n                    end\n                end\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "psy_circuit",
      "atlas": "PSYFrame02",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"psy_circuit\",\n    atlas = 'PSYFrame02',\n    pos = { x = 0, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.money } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"PSYFrame\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_field_spell = true,\n                monster_archetypes = { [\"PSYFrame\"] = true },\n            },\n            money = 10,\n        },\n    },\n    calculate = function(self, card, context)\n        if context.joy_summon and JoyousSpring.is_summon_type(context.joy_card, \"SYNCHRO\") then\n            return {\n                dollars = card.ability.extra.money\n            }\n        end\n    end,\n    joy_apply_to_jokers_added = function(card, added_card)\n        if not card.debuff then\n            if JoyousSpring.is_monster_type(added_card, \"Psychic\") and JoyousSpring.is_summon_type(added_card, \"SYNCHRO\") and JoyousSpring.is_summoned(added_card) then\n                if not added_card.edition then\n                    added_card:set_edition(\"e_negative\")\n                end\n            end\n        end\n    end,"
    },
    {
      "type": "Atlas",
      "key": "Runick",
      "atlas": null,
      "pos": null,
      "raw": "key = \"Runick\",\n    path = \"10Runick.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Joker",
      "key": "runick_hugin",
      "atlas": "Runick",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"runick_hugin\",\n    atlas = 'Runick',\n    pos = { x = 1, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.extra_slots, card.ability.extra.cards_to_create, card.ability.extra.adds } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_runick_fountain\",                                name = \"k_joy_creates\" },\n        { properties = { { monster_archetypes = { \"Runick\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"FUSION\",\n                attribute = \"LIGHT\",\n                monster_type = \"Fairy\",\n                monster_archetypes = { [\"Runick\"] = true },\n                summon_consumeable_conditions = {\n                    tarot = 3\n                }\n            },\n            extra_slots = 1,\n            cards_to_create = 1,\n            adds = 1\n        },\n    },\n    add_to_deck = function(self, card, from_debuff)\n        if not JoyousSpring.is_perma_debuffed(card) then\n            G.consumeables.config.card_limit = G.consumeables.config.card_limit + 1\n            if not card.debuff and not from_debuff then\n                for i = 1, card.ability.extra.cards_to_create do\n                    if #JoyousSpring.field_spell_area.cards < JoyousSpring.field_spell_area.config.card_limit then\n                        JoyousSpring.add_to_extra_deck(\"j_joy_runick_fountain\")\n                    end\n                end\n                local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Runick\" }, is_extra_deck = true } })\n                for i = 1, card.ability.extra.adds do\n                    local key_to_add, _ = pseudorandom_element(choices, 'j_joy_runick_hugin')\n                    if key_to_add and #JoyousSpring.extra_deck_area.cards < JoyousSpring.extra_deck_area.config.card_limit then\n                        JoyousSpring.add_to_extra_deck(key_to_add)\n                    end\n                end\n            end\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        if not JoyousSpring.is_perma_debuffed(card) then\n            G.consumeables.config.card_limit = G.consumeables.config.card_limit - 1\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "runick_munin",
      "atlas": "Runick",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"runick_munin\",\n    atlas = 'Runick',\n    pos = { x = 2, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.extra_slots, card.ability.extra.adds, card.ability.extra.base_xchips, card.ability.extra.xchips } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Runick\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"FUSION\",\n                attribute = \"LIGHT\",\n                monster_type = \"Fairy\",\n                monster_archetypes = { [\"Runick\"] = true },\n                summon_consumeable_conditions = {\n                    tarot = 2\n                }\n            },\n            extra_slots = 1,\n            adds = 1,\n            base_xchips = 0.2,\n            xchips = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker then\n                if context.using_consumeable and G.GAME.blind.in_blind and context.consumeable.ability.set == 'Tarot' then\n                    card.ability.extra.xchips = card.ability.extra.xchips + card.ability.extra.base_xchips\n                    return {\n                        message = localize('k_upgrade_ex')\n                    }\n                end\n            end\n            if context.joker_main then\n                return {\n                    xchips = card.ability.extra.xchips\n                }\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not JoyousSpring.is_perma_debuffed(card) then\n            G.consumeables.config.card_limit = G.consumeables.config.card_limit + 1\n        end\n        if not from_debuff then\n            local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Runick\" }, is_extra_deck = true } })\n            for i = 1, card.ability.extra.adds do\n                local key_to_add, _ = pseudorandom_element(choices, 'j_joy_runick_munin')\n                if key_to_add and #JoyousSpring.extra_deck_area.cards < JoyousSpring.extra_deck_area.config.card_limit then\n                    JoyousSpring.add_to_extra_deck(key_to_add)\n                end\n            end\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        if not JoyousSpring.is_perma_debuffed(card) then\n            G.consumeables.config.card_limit = G.consumeables.config.card_limit - 1\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "runick_geri",
      "atlas": "Runick",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"runick_geri\",\n    atlas = 'Runick',\n    pos = { x = 0, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 7,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.fields_to_create, card.ability.extra.adds, card.ability.extra.cards_to_create } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_runick_fountain\",                                name = \"k_joy_creates\" },\n        { properties = { { monster_archetypes = { \"Runick\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"FUSION\",\n                attribute = \"DARK\",\n                monster_type = \"Beast\",\n                monster_archetypes = { [\"Runick\"] = true },\n                summon_consumeable_conditions = {\n                    tarot = 2\n                }\n            },\n            fields_to_create = 1,\n            adds = 1,\n            cards_to_create = 2\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.selling_self then\n                for i = 1, card.ability.extra.cards_to_create do\n                    if #G.consumeables.cards < G.consumeables.config.card_limit then\n                        SMODS.add_card({\n                            set = 'Tarot'\n                        })\n                    else\n                        break\n                    end\n                end\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff then\n            for i = 1, card.ability.extra.fields_to_create do\n                if JoyousSpring.graveyard[\"j_joy_runick_fountain\"] and JoyousSpring.graveyard[\"j_joy_runick_fountain\"].count > 0 and #JoyousSpring.field_spell_area.cards < JoyousSpring.field_spell_area.config.card_limit then\n                    JoyousSpring.add_to_extra_deck(\"j_joy_runick_fountain\")\n                end\n            end\n\n            local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Runick\" }, is_extra_deck = true } })\n            for i = 1, card.ability.extra.adds do\n                local key_to_add, _ = pseudorandom_element(choices, 'j_joy_runick_geri')\n                if key_to_add and #JoyousSpring.extra_deck_area.cards < JoyousSpring.extra_deck_area.config.card_limit then\n                    JoyousSpring.add_to_extra_deck(key_to_add)\n                end\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "runick_freki",
      "atlas": "Runick",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"runick_freki\",\n    atlas = 'Runick',\n    pos = { x = 1, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 7,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.adds, card.ability.extra.playing_cards_to_create, card.ability.extra.cards_to_create } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Runick\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"FUSION\",\n                attribute = \"DARK\",\n                monster_type = \"Beast\",\n                monster_archetypes = { [\"Runick\"] = true },\n                summon_consumeable_conditions = {\n                    tarot = 2\n                }\n            },\n            adds = 1,\n            playing_cards_to_create = 2,\n            cards_to_create = 2\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.selling_self then\n                for i = 1, card.ability.extra.cards_to_create do\n                    if #G.consumeables.cards < G.consumeables.config.card_limit then\n                        SMODS.add_card({\n                            set = 'Tarot'\n                        })\n                    else\n                        break\n                    end\n                end\n            end\n            if context.using_consumeable and G.GAME.blind.in_blind and context.consumeable.ability.set == 'Tarot' then\n                for i = 1, card.ability.extra.playing_cards_to_create do\n                    SMODS.add_card { set = \"Playing Card\" }\n                end\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff then\n            local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Runick\" }, is_extra_deck = true } })\n            for i = 1, card.ability.extra.adds do\n                local key_to_add, _ = pseudorandom_element(choices, 'j_joy_runick_freki')\n                if key_to_add and #JoyousSpring.extra_deck_area.cards < JoyousSpring.extra_deck_area.config.card_limit then\n                    JoyousSpring.add_to_extra_deck(key_to_add)\n                end\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "runick_sleipnir",
      "atlas": "Runick",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"runick_sleipnir\",\n    atlas = 'Runick',\n    pos = { x = 2, y = 1 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_banish\" }\n        end\n        return { vars = { card.ability.extra.adds, card.ability.extra.cards_to_create } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Runick\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"FUSION\",\n                attribute = \"LIGHT\",\n                monster_type = \"Beast\",\n                monster_archetypes = { [\"Runick\"] = true },\n                summon_consumeable_conditions = {\n                    tarot = 4\n                }\n            },\n            adds = 1,\n            cards_to_create = 2\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.end_of_round and context.game_over == false and context.main_eval then\n                JoyousSpring.banish(card, \"blind_selected\")\n            end\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.joy_returned and context.joy_returned_card == card then\n                for i = 1, card.ability.extra.cards_to_create do\n                    SMODS.add_card({\n                        set = 'Tarot',\n                        edition = \"e_negative\"\n                    })\n                end\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff then\n            local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Runick\" }, is_extra_deck = true } })\n            for i = 1, card.ability.extra.adds do\n                local key_to_add, _ = pseudorandom_element(choices, 'j_joy_runick_sleipnir')\n                if key_to_add and #JoyousSpring.extra_deck_area.cards < JoyousSpring.extra_deck_area.config.card_limit then\n                    JoyousSpring.add_to_extra_deck(key_to_add)\n                end\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "runick_fountain",
      "atlas": "Runick",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"runick_fountain\",\n    atlas = 'Runick',\n    pos = { x = 0, y = 0 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 15,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.cards_to_destroy } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Runick\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_field_spell = true,\n                monster_archetypes = { [\"Runick\"] = true },\n            },\n            cards_to_destroy = 2,\n            tarots_used = {}\n        },\n    },\n    calculate = function(self, card, context)\n        if context.setting_blind and context.main_eval then\n            for i = 1, card.ability.extra.cards_to_destroy do\n                local card_to_destroy, _ = pseudorandom_element(G.deck.cards, 'j_joy_runick_fountain')\n                if card_to_destroy then\n                    if i == 1 then\n                        SMODS.calculate_effect({ message = localize('k_joy_banished') }, card_to_destroy)\n                    end\n                    card_to_destroy.getting_sliced = true\n                    card_to_destroy:start_dissolve()\n                end\n            end\n        end\n        if context.using_consumeable and G.GAME.blind.in_blind and context.consumeable.ability.set == 'Tarot' then\n            table.insert(card.ability.extra.tarots_used, context.consumeable.config.center.key)\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval then\n            for _, key in ipairs(card.ability.extra.tarots_used) do\n                if #G.consumeables.cards < G.consumeables.config.card_limit then\n                    SMODS.add_card({\n                        key = key,\n                        no_edition = true\n                    })\n                else\n                    break\n                end\n            end\n            card.ability.extra.tarots_used = {}\n        end\n    end,"
    },
    {
      "type": "Atlas",
      "key": "BA",
      "atlas": null,
      "pos": null,
      "raw": "key = \"BA\",\n    path = \"11BurningAbyss.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Joker",
      "key": "ba_alich",
      "atlas": "BA",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"ba_alich\",\n    atlas = 'BA',\n    pos = { x = 0, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = false,\n    cost = 4,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.percent * 100 } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_ba_beatrice\", properties = { { monster_archetypes = { \"BurningAbyss\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Fiend\",\n                monster_archetypes = { [\"BurningAbyss\"] = true }\n            },\n            percent = 0.1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.setting_blind and context.main_eval then\n                if ba_die() and not context.blueprint then\n                    card.getting_sliced = true\n                    card:start_dissolve()\n                else\n                    G.GAME.blind.chips = math.floor(G.GAME.blind.chips - G.GAME.blind.chips * card.ability.extra.percent)\n                    G.GAME.blind.chip_text = number_format(G.GAME.blind.chips)\n                    return {\n                        message = localize(\"k_active_ex\")\n                    }\n                end\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and G.GAME.blind.in_blind then\n            G.GAME.blind.chips = math.floor(G.GAME.blind.chips -\n                G.GAME.blind.chips * card.ability.extra.percent)\n            G.GAME.blind.chip_text = number_format(G.GAME.blind.chips)\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "ba_barbar",
      "atlas": "BA",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"ba_barbar\",\n    atlas = 'BA',\n    pos = { x = 1, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = false,\n    cost = 4,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.mult, card.ability.extra.extra_mult, card.ability.extra.mult + (card.ability.extra.extra_mult * JoyousSpring.count_materials_in_graveyard({ { monster_type = \"Fiend\" } })) } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_ba_beatrice\", properties = { { monster_archetypes = { \"BurningAbyss\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Fiend\",\n                monster_archetypes = { [\"BurningAbyss\"] = true }\n            },\n            mult = 50,\n            extra_mult = 3\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.setting_blind and context.main_eval and ba_die() and not context.blueprint then\n                card.getting_sliced = true\n                card:start_dissolve()\n            end\n            if context.joker_main then\n                return {\n                    mult = card.ability.extra.mult +\n                        (card.ability.extra.extra_mult * JoyousSpring.count_materials_in_graveyard({ { monster_type = \"Fiend\" } }))\n                }\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "ba_cagna",
      "atlas": "BA",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"ba_cagna\",\n    atlas = 'BA',\n    pos = { x = 2, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = false,\n    cost = 4,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.chips, card.ability.extra.mills } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_type = \"Fiend\" } }, name = \"k_joy_mills\" },\n        { \"j_joy_ba_beatrice\",                         properties = { { monster_archetypes = { \"BurningAbyss\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Fiend\",\n                monster_archetypes = { [\"BurningAbyss\"] = true }\n            },\n            chips = 200,\n            mills = 3\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.setting_blind and context.main_eval then\n                if ba_die() and not context.blueprint then\n                    card.getting_sliced = true\n                    card:start_dissolve()\n                else\n                    local choices = JoyousSpring.get_materials_in_collection({ { monster_type = \"Fiend\" } })\n                    for _ = 1, card.ability.extra.mills do\n                        local key_to_send = pseudorandom_element(choices, 'j_joy_ba_cagna')\n                        JoyousSpring.send_to_graveyard(key_to_send or \"j_joy_ba_cagna\")\n                    end\n                end\n            end\n            if context.joker_main then\n                return {\n                    chips = card.ability.extra.chips\n                }\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "ba_calcab",
      "atlas": "BA",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"ba_calcab\",\n    atlas = 'BA',\n    pos = { x = 3, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = false,\n    cost = 4,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.h_size } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_ba_beatrice\", properties = { { monster_archetypes = { \"BurningAbyss\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Fiend\",\n                monster_archetypes = { [\"BurningAbyss\"] = true }\n            },\n            h_size = 3\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.setting_blind and context.main_eval and ba_die() and not context.blueprint then\n                card.getting_sliced = true\n                card:start_dissolve()\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not JoyousSpring.is_perma_debuffed(card) then\n            G.hand:change_size(card.ability.extra.h_size)\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        if not JoyousSpring.is_perma_debuffed(card) then\n            G.hand:change_size(-card.ability.extra.h_size)\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "ba_cir",
      "atlas": "BA",
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "key = \"ba_cir\",\n    atlas = 'BA',\n    pos = { x = 4, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = false,\n    cost = 4,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n        end\n        return { vars = { card.ability.extra.xmult, card.ability.extra.revives } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_ba_beatrice\", properties = { { monster_archetypes = { \"BurningAbyss\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Fiend\",\n                monster_archetypes = { [\"BurningAbyss\"] = true }\n            },\n            xmult = 3,\n            revives = 2\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.setting_blind and context.main_eval then\n                if ba_die() and not context.blueprint then\n                    card.getting_sliced = true\n                    card:start_dissolve()\n                else\n                    for _ = 1, card.ability.extra.revives do\n                        JoyousSpring.revive_pseudorandom({ { monster_archetypes = { \"BurningAbyss\" } } },\n                            'j_joy_ba_cir', true)\n                    end\n                end\n            end\n            if context.joker_main then\n                return {\n                    xmult = card.ability.extra.xmult\n                }\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "ba_draghig",
      "atlas": "BA",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"ba_draghig\",\n    atlas = 'BA',\n    pos = { x = 0, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = false,\n    cost = 4,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_special\" }\n        end\n        return { vars = { card.ability.extra.chips, card.ability.extra.creates } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_ba_beatrice\", properties = { { monster_archetypes = { \"BurningAbyss\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Fiend\",\n                monster_archetypes = { [\"BurningAbyss\"] = true }\n            },\n            chips = 100,\n            creates = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.setting_blind and context.main_eval and ba_die() and not context.blueprint then\n                card.getting_sliced = true\n                card:start_dissolve()\n            end\n            if context.other_joker and context.other_joker.facing == \"front\" and JoyousSpring.is_monster_type(context.other_joker, \"Fiend\") then\n                return {\n                    chips = card.ability.extra.chips,\n                    message_card = context.other_joker\n                }\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff and JoyousSpring.can_use_abilities(card) then\n            for _ = 1, card.ability.extra.creates do\n                JoyousSpring.create_pseudorandom(\n                    { { monster_archetypes = { \"BurningAbyss\" }, is_main_deck = true, exclude_summon_types = { \"RITUAL\" }, exclude_keys = { \"j_joy_ba_draghig\" } } },\n                    'j_joy_ba_draghig', true)\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "ba_farfa",
      "atlas": "BA",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"ba_farfa\",\n    atlas = 'BA',\n    pos = { x = 1, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = false,\n    cost = 4,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_banish\" }\n        end\n        return { vars = { card.ability.extra.banish } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_ba_beatrice\", properties = { { monster_archetypes = { \"BurningAbyss\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Fiend\",\n                monster_archetypes = { [\"BurningAbyss\"] = true }\n            },\n            banish = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.setting_blind and context.main_eval and ba_die() and not context.blueprint then\n                card.getting_sliced = true\n                card:start_dissolve()\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff and JoyousSpring.can_use_abilities(card) then\n            local choices = JoyousSpring.get_materials_owned({ { exclude_keys = { \"j_joy_ba_farfa\" } } })\n            local to_banish = pseudorandom_element(choices, 'j_joy_ba_farfa')\n            if to_banish then\n                JoyousSpring.banish(to_banish, \"end_of_round\")\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "ba_graff",
      "atlas": "BA",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"ba_graff\",\n    atlas = 'BA',\n    pos = { x = 2, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = false,\n    cost = 4,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_special\" }\n        end\n        return { vars = { card.ability.extra.mult, card.ability.extra.creates } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_ba_beatrice\", properties = { { monster_archetypes = { \"BurningAbyss\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Fiend\",\n                monster_archetypes = { [\"BurningAbyss\"] = true }\n            },\n            mult = 25,\n            creates = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.setting_blind and context.main_eval and ba_die() and not context.blueprint then\n                card.getting_sliced = true\n                card:start_dissolve()\n            end\n            if context.other_joker and context.other_joker.facing == \"front\" and JoyousSpring.is_monster_type(context.other_joker, \"Fiend\") then\n                return {\n                    mult = card.ability.extra.mult,\n                    message_card = context.other_joker\n                }\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff and JoyousSpring.can_use_abilities(card) then\n            for _ = 1, card.ability.extra.creates do\n                JoyousSpring.create_pseudorandom(\n                    { { monster_archetypes = { \"BurningAbyss\" }, is_main_deck = true, exclude_summon_types = { \"RITUAL\" }, exclude_keys = { \"j_joy_ba_graff\" } } },\n                    'j_joy_ba_graff', true)\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "ba_libic",
      "atlas": "BA",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"ba_libic\",\n    atlas = 'BA',\n    pos = { x = 3, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = false,\n    cost = 3,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n        end\n        return { vars = { card.ability.extra.revives } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_ba_beatrice\", properties = { { monster_archetypes = { \"BurningAbyss\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Fiend\",\n                monster_archetypes = { [\"BurningAbyss\"] = true }\n            },\n            revives = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if (context.selling_self or (context.setting_blind and context.main_eval and ba_die())) and not context.blueprint then\n                card.getting_sliced = true\n                card:start_dissolve()\n                for _ = 1, card.ability.extra.revives do\n                    JoyousSpring.revive_pseudorandom({ { monster_type = \"Fiend\" } },\n                        'j_joy_ba_libic', true)\n                end\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "ba_rubic",
      "atlas": "BA",
      "pos": {
        "x": 4,
        "y": 1
      },
      "raw": "key = \"ba_rubic\",\n    atlas = 'BA',\n    pos = { x = 4, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = false,\n    cost = 3,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.adds } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_ba_beatrice\", properties = { { monster_archetypes = { \"BurningAbyss\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_tuner = true,\n                attribute = \"DARK\",\n                monster_type = \"Fiend\",\n                monster_archetypes = { [\"BurningAbyss\"] = true }\n            },\n            adds = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if (context.selling_self or (context.setting_blind and context.main_eval and ba_die())) and not context.blueprint then\n                card.getting_sliced = true\n                card:start_dissolve()\n\n                local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"BurningAbyss\" }, is_extra_deck = true } })\n                for _ = 1, card.ability.extra.adds do\n                    local key_to_add = pseudorandom_element(choices, 'j_joy_ba_draghig')\n                    if #JoyousSpring.extra_deck_area.cards < JoyousSpring.extra_deck_area.config.card_limit then\n                        JoyousSpring.add_to_extra_deck(key_to_add or \"j_joy_ba_dante\")\n                    end\n                end\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "ba_scarm",
      "atlas": "BA",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = \"ba_scarm\",\n    atlas = 'BA',\n    pos = { x = 0, y = 2 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = false,\n    cost = 3,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_main_deck_joker\" }\n        end\n        return { vars = { card.ability.extra.creates } }\n    end,\n    joy_desc_cards = {\n        { properties = { { is_main_deck = true, monster_type = \"Fiend\" } }, name = \"k_joy_creates\" },\n        { \"j_joy_ba_beatrice\",                                              properties = { { monster_archetypes = { \"BurningAbyss\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Fiend\",\n                monster_archetypes = { [\"BurningAbyss\"] = true }\n            },\n            creates = 2\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if (context.selling_self or (context.setting_blind and context.main_eval and ba_die())) and not context.blueprint then\n                card.getting_sliced = true\n                card:start_dissolve()\n\n                for _ = 1, card.ability.extra.creates do\n                    JoyousSpring.create_pseudorandom(\n                        { { monster_type = \"Fiend\", is_main_deck = true, exclude_keys = { \"j_joy_ba_scarm\" } } },\n                        'j_joy_ba_scarm', true)\n                end\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "ba_malacoda",
      "atlas": "BA",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "key = \"ba_malacoda\",\n    atlas = 'BA',\n    pos = { x = 1, y = 2 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 8,\n    loc_vars = function(self, info_queue, card)\n        return {\n            vars = { card.ability.extra.xmult, 1 +\n            (card.ability.extra.xmult * JoyousSpring.count_materials_in_graveyard({ { monster_type = \"Fiend\" } })) }\n        }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_ba_beatrice\", properties = { { monster_archetypes = { \"BurningAbyss\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"RITUAL\",\n                attribute = \"DARK\",\n                monster_type = \"Fiend\",\n                monster_archetypes = { [\"BurningAbyss\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"RITUAL\",\n                        materials = {\n                            { monster_type = \"Fiend\" },\n                            {},\n                        }\n                    }\n                }\n            },\n            xmult = 0.1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    xmult = 1 +\n                        (card.ability.extra.xmult * JoyousSpring.count_materials_in_graveyard({ { monster_type = \"Fiend\" } }))\n                }\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "ba_cherubini",
      "atlas": "BA",
      "pos": {
        "x": 1,
        "y": 3
      },
      "raw": "key = \"ba_cherubini\",\n    atlas = 'BA',\n    pos = { x = 1, y = 3 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.mills } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_ba_beatrice\", properties = { { monster_archetypes = { \"BurningAbyss\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"LINK\",\n                attribute = \"DARK\",\n                monster_type = \"Fairy\",\n                monster_archetypes = { [\"BurningAbyss\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"LINK\",\n                        materials = {\n                            { monster_type = \"Fiend\" },\n                            { monster_type = \"Fiend\" },\n                        }\n                    }\n                }\n            },\n            mills = 3\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.setting_blind and context.main_eval then\n                local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"BurningAbyss\" } } })\n                for _ = 1, card.ability.extra.mills do\n                    local key_to_send = pseudorandom_element(choices, 'j_joy_ba_cherubini')\n                    JoyousSpring.send_to_graveyard(key_to_send or \"j_joy_ba_cagna\")\n                end\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "ba_dante",
      "atlas": "BA",
      "pos": {
        "x": 4,
        "y": 2
      },
      "raw": "key = \"ba_dante\",\n    atlas = 'BA',\n    pos = { x = 4, y = 2 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 8,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_detach\" }\n        end\n        return { vars = { card.ability.extra.mult, card.ability.extra.mult * JoyousSpring.get_graveyard_count(), card.ability.extra.detach, card.ability.extra.mills } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_ba_beatrice\", properties = { { monster_archetypes = { \"BurningAbyss\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    update = JoyousSpring.update_counter,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"XYZ\",\n                attribute = \"LIGHT\",\n                monster_type = \"Warrior\",\n                monster_archetypes = { [\"BurningAbyss\"] = true, [\"Dante\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"XYZ\",\n                        materials = {\n                            { rarity = 1, exclude_tokens = true, exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                            { rarity = 1, exclude_tokens = true, exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                        }\n                    }\n                }\n            },\n            mult = 1,\n            detach = 1,\n            mills = 20\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and context.joy_detach and context.joy_detaching_card == card then\n                local choices = JoyousSpring.get_materials_in_collection({ { is_monster = true, exclude_tokens = true } })\n                for _ = 1, card.ability.extra.mills do\n                    local key_to_send = pseudorandom_element(choices, 'j_joy_ba_dante')\n                    JoyousSpring.send_to_graveyard(key_to_send or \"j_joy_ba_cir\")\n                end\n                JoyousSpring.ease_detach(card)\n            end\n            if context.joker_main then\n                return {\n                    mult = card.ability.extra.mult * JoyousSpring.get_graveyard_count()\n                }\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "ba_pilgrim",
      "atlas": "BA",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "key = \"ba_pilgrim\",\n    atlas = 'BA',\n    pos = { x = 2, y = 2 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 8,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.hands, card.ability.extra.discards } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_ba_beatrice\", properties = { { monster_archetypes = { \"BurningAbyss\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"FUSION\",\n                attribute = \"LIGHT\",\n                monster_type = \"Fairy\",\n                monster_archetypes = { [\"BurningAbyss\"] = true, [\"Dante\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"FUSION\",\n                        materials = {\n                            { monster_archetypes = { \"BurningAbyss\" } },\n                            { monster_archetypes = { \"BurningAbyss\" } },\n                            { monster_archetypes = { \"BurningAbyss\" } },\n                        },\n                        restrictions = {\n                            different_names = true\n                        }\n                    }\n                }\n            },\n            hands = 2,\n            discards = 2\n        },\n    },\n    add_to_deck = function(self, card, from_debuff)\n        if not JoyousSpring.is_perma_debuffed(card) then\n            G.GAME.round_resets.discards = G.GAME.round_resets.discards + card.ability.extra.discards\n            ease_discard(card.ability.extra.discards)\n            G.GAME.round_resets.hands = G.GAME.round_resets.hands + card.ability.extra.hands\n            ease_hands_played(card.ability.extra.hands)\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        if not JoyousSpring.is_perma_debuffed(card) then\n            G.GAME.round_resets.discards = G.GAME.round_resets.discards - card.ability.extra.discards\n            ease_discard(-card.ability.extra.discards)\n            G.GAME.round_resets.hands = G.GAME.round_resets.hands - card.ability.extra.hands\n            ease_hands_played(-card.ability.extra.hands)\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "ba_virgil",
      "atlas": "BA",
      "pos": {
        "x": 3,
        "y": 2
      },
      "raw": "key = \"ba_virgil\",\n    atlas = 'BA',\n    pos = { x = 3, y = 2 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 8,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.h_size } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_ba_beatrice\", properties = { { monster_archetypes = { \"BurningAbyss\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"SYNCHRO\",\n                attribute = \"LIGHT\",\n                monster_type = \"Spellcaster\",\n                monster_archetypes = { [\"BurningAbyss\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"SYNCHRO\",\n                        materials = {\n                            { is_tuner = true,        exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                            { monster_type = \"Fiend\", exclude_tuners = true,                   exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                        },\n                    }\n                }\n            },\n            h_size = 2\n        },\n    },\n    add_to_deck = function(self, card, from_debuff)\n        if not JoyousSpring.is_perma_debuffed(card) then\n            G.hand:change_size(card.ability.extra.h_size)\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "ba_beatrice",
      "atlas": "BA",
      "pos": {
        "x": 0,
        "y": 3
      },
      "raw": "key = \"ba_beatrice\",\n    atlas = 'BA',\n    pos = { x = 0, y = 3 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n        end\n        return { vars = { card.ability.extra.xmult, 1 + (card.ability.extra.xmult * JoyousSpring.get_graveyard_count()), card.ability.extra.detach, card.ability.extra.revives } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_ba_dante\",    \"j_joy_ba_pilgrim\",                                           name = \"k_joy_adds\" },\n        { \"j_joy_ba_beatrice\", properties = { { monster_archetypes = { \"BurningAbyss\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    update = JoyousSpring.update_counter,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"XYZ\",\n                attribute = \"LIGHT\",\n                monster_type = \"Fairy\",\n\n                summon_conditions = {\n                    {\n                        type = \"XYZ\",\n                        materials = {\n                            { rarity = 3, exclude_tokens = true, exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                            { rarity = 3, exclude_tokens = true, exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                        }\n                    },\n                    {\n                        type = \"XYZ\",\n                        materials = {\n                            { monster_archetypes = { \"Dante\" } },\n                        },\n                        transfer_materials = true\n                    },\n                }\n            },\n            xmult = 0.05,\n            detach = 1,\n            revives = 1,\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and context.joy_detach and context.joy_detaching_card == card then\n                JoyousSpring.ease_detach(card)\n                for _ = 1, card.ability.extra.revives do\n                    local revived = JoyousSpring.revive_pseudorandom({ { monster_archetypes = { \"BurningAbyss\" } } },\n                        \"j_joy_ba_beatrice\", false, \"e_negative\")\n                    if not revived then\n                        revived = JoyousSpring.revive_pseudorandom({ {} }, 'j_joy_ba_beatrice', false,\n                            \"e_negative\")\n                    end\n                end\n            end\n            if context.selling_self and not context.blueprint then\n                if #JoyousSpring.extra_deck_area.cards + 1 < JoyousSpring.extra_deck_area.config.card_limit then\n                    JoyousSpring.add_to_extra_deck(\"j_joy_ba_dante\")\n                    JoyousSpring.add_to_extra_deck(\"j_joy_ba_pilgrim\")\n                end\n            end\n            if context.joker_main then\n                return {\n                    xmult = 1 + (card.ability.extra.xmult * JoyousSpring.get_graveyard_count())\n                }\n            end\n        end\n    end"
    },
    {
      "type": "Atlas",
      "key": "lab",
      "atlas": null,
      "pos": null,
      "raw": "key = \"lab\",\n    path = \"12Labrynth.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Joker",
      "key": "lab_clock",
      "atlas": "lab",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"lab_clock\",\n    atlas = 'lab',\n    pos = { x = 0, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 3,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_tribute\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n        end\n        return { vars = { card.ability.extra.flips, card.ability.extra.bonus_mult, card.ability.extra.revives } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Labrynth\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Fiend\",\n                monster_archetypes = { [\"Labrynth\"] = true }\n            },\n            flips = 1,\n            bonus_mult = 10,\n            revives = 2,\n            any_flipped = false\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card then\n                if context.joy_activate_effect and context.joy_activated_card == card and not card.ability.eternal then\n                    card.ability.extra.any_flipped = false\n                    return {\n                        message = localize(\"k_joy_flip_ex\"),\n                        func = function()\n                            G.E_MANAGER:add_event(Event({\n                                trigger = 'after',\n                                delay = 0.3,\n                                func = (function()\n                                    for i = 1, card.ability.extra.flips do\n                                        local flipped_card = JoyousSpring.flip_random_card(card, G.hand.cards, 'front',\n                                            \"j_joy_lab_clock\")\n                                        if flipped_card then\n                                            card.ability.extra.any_flipped = true\n                                            flipped_card.ability.perma_mult = (flipped_card.ability.perma_mult or 0) +\n                                                card.ability.extra.bonus_mult\n                                        else\n                                            break\n                                        end\n                                    end\n\n                                    return true\n                                end)\n                            }))\n                        end,\n                        extra = {\n                            message = localize(\"k_joy_revive\"),\n                            func = function()\n                                G.E_MANAGER:add_event(Event({\n                                    trigger = 'after',\n                                    delay = 0.3,\n                                    func = (function()\n                                        if card.ability.extra.any_flipped then\n                                            card.ability.extra.any_flipped = false\n                                            G.hand:shuffle(\"j_joy_lab_clock\")\n                                        end\n                                        for i = 1, card.ability.extra.revives do\n                                            if #G.jokers.cards + G.GAME.joker_buffer < G.jokers.config.card_limit +\n                                                ((card.edition and card.edition.negative) and 0 or 1) then\n                                                JoyousSpring.revive_pseudorandom(\n                                                    { { rarity = 1, monster_archetypes = { \"Labrynth\" }, exclude_keys = { \"j_joy_lab_clock\" } } },\n                                                    'j_joy_lab_clock',\n                                                    false\n                                                )\n                                            end\n                                        end\n\n                                        return true\n                                    end)\n                                }))\n                                G.E_MANAGER:add_event(Event({\n                                    trigger = 'after',\n                                    delay = 0.8,\n                                    func = (function()\n                                        JoyousSpring.tribute(card, { card })\n\n                                        return true\n                                    end)\n                                }))\n                            end\n                        }\n                    }\n                end\n            end\n        end\n    end,\n    joy_can_activate = function(card)\n        return not card.ability.eternal and G.GAME.blind.in_blind or false\n    end,"
    },
    {
      "type": "Joker",
      "key": "lab_stovie",
      "atlas": "lab",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"lab_stovie\",\n    atlas = 'lab',\n    pos = { x = 1, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 3,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_tribute\" }\n        end\n        return { vars = { card.ability.extra.flips, card.ability.extra.bonus_chips, card.ability.extra.money } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Labrynth\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Fiend\",\n                monster_archetypes = { [\"Labrynth\"] = true }\n            },\n            flips = 3,\n            bonus_chips = 50,\n            money = 10,\n            tributes = 1,\n            any_flipped = false\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card then\n                if context.joy_activate_effect and context.joy_activated_card == card and not card.ability.eternal then\n                    local materials = {}\n                    for i, joker in ipairs(G.jokers.cards) do\n                        if joker ~= card and not joker.ability.eternal then\n                            materials[#materials + 1] = joker\n                        end\n                    end\n                    if next(materials) then\n                        JoyousSpring.create_overlay_effect_selection(card, materials, card.ability.extra.tributes,\n                            card.ability.extra.tributes)\n                    end\n                end\n                if context.joy_exit_effect_selection and context.joy_card == card and\n                    #context.joy_selection == card.ability.extra.tributes then\n                    card.ability.extra.any_flipped = false\n                    local fiend_tributed = false\n                    for i, joker in ipairs(context.joy_selection) do\n                        if JoyousSpring.is_monster_type(joker, \"Fiend\") then\n                            fiend_tributed = true\n                        end\n                    end\n                    return {\n                        message = localize(\"k_joy_flip_ex\"),\n                        func = function()\n                            G.E_MANAGER:add_event(Event({\n                                trigger = 'after',\n                                delay = 0.3,\n                                func = (function()\n                                    for i = 1, card.ability.extra.flips do\n                                        local flipped_card = JoyousSpring.flip_random_card(card, G.hand.cards, 'front',\n                                            \"j_joy_lab_stovie\")\n                                        if flipped_card then\n                                            card.ability.extra.any_flipped = true\n                                            flipped_card.ability.perma_bonus = (flipped_card.ability.perma_bonus or 0) +\n                                                card.ability.extra.bonus_chips\n                                        else\n                                            break\n                                        end\n                                    end\n\n                                    return true\n                                end)\n                            }))\n                        end,\n                        extra = {\n                            dollars = fiend_tributed and 3 or nil,\n                            func = function()\n                                G.E_MANAGER:add_event(Event({\n                                    trigger = 'after',\n                                    delay = 0.8,\n                                    func = (function()\n                                        G.E_MANAGER:add_event(Event({\n                                            trigger = 'after',\n                                            delay = 0.3,\n                                            func = (function()\n                                                if card.ability.extra.any_flipped then\n                                                    card.ability.extra.any_flipped = false\n                                                    G.hand:shuffle(\"j_joy_lab_stovie\")\n                                                end\n\n                                                return true\n                                            end)\n                                        }))\n                                        JoyousSpring.tribute(card, context.joy_selection)\n                                        JoyousSpring.tribute(card, { card })\n\n                                        return true\n                                    end)\n                                }))\n                            end\n                        }\n                    }\n                end\n            end\n        end\n    end,\n    joy_can_activate = function(card)\n        if card.ability.eternal or not G.GAME.blind.in_blind then\n            return false\n        end\n        for i, joker in ipairs(G.jokers.cards) do\n            if joker ~= card and not joker.ability.eternal then\n                return true\n            end\n        end\n        return false\n    end,"
    },
    {
      "type": "Joker",
      "key": "lab_changdra",
      "atlas": "lab",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"lab_changdra\",\n    atlas = 'lab',\n    pos = { x = 2, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 3,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_tribute\" }\n        end\n        return { vars = { card.ability.extra.flips, card.ability.extra.bonus_dollars, card.ability.extra.creates } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Labrynth\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Fiend\",\n                monster_archetypes = { [\"Labrynth\"] = true }\n            },\n            flips = 3,\n            bonus_dollars = 3,\n            creates = 2,\n            tributes = 1,\n            any_flipped = false\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card then\n                if context.joy_activate_effect and context.joy_activated_card == card and not card.ability.eternal then\n                    local materials = {}\n                    for i, joker in ipairs(G.jokers.cards) do\n                        if joker ~= card and not joker.ability.eternal then\n                            materials[#materials + 1] = joker\n                        end\n                    end\n                    if next(materials) then\n                        JoyousSpring.create_overlay_effect_selection(card, materials, card.ability.extra.tributes,\n                            card.ability.extra.tributes)\n                    end\n                end\n                if context.joy_exit_effect_selection and context.joy_card == card and\n                    #context.joy_selection == card.ability.extra.tributes then\n                    card.ability.extra.any_flipped = false\n                    local fiend_tributed = false\n                    for i, joker in ipairs(context.joy_selection) do\n                        if JoyousSpring.is_monster_type(joker, \"Fiend\") then\n                            fiend_tributed = true\n                        end\n                    end\n                    return {\n                        message = localize(\"k_joy_flip_ex\"),\n                        func = function()\n                            G.E_MANAGER:add_event(Event({\n                                trigger = 'after',\n                                delay = 0.3,\n                                func = (function()\n                                    for i = 1, card.ability.extra.flips do\n                                        local flipped_card = JoyousSpring.flip_random_card(card, G.hand.cards, 'front',\n                                            \"j_joy_lab_changdra\")\n                                        if flipped_card then\n                                            card.ability.extra.any_flipped = true\n                                            flipped_card.ability.perma_p_dollars = (flipped_card.ability.perma_p_dollars or 0) +\n                                                card.ability.extra.bonus_dollars\n                                        else\n                                            break\n                                        end\n                                    end\n\n                                    return true\n                                end)\n                            }))\n                        end,\n                        extra = {\n                            func = function()\n                                G.E_MANAGER:add_event(Event({\n                                    trigger = 'after',\n                                    delay = 0.8,\n                                    func = (function()\n                                        G.E_MANAGER:add_event(Event({\n                                            trigger = 'after',\n                                            delay = 0.3,\n                                            func = (function()\n                                                if card.ability.extra.any_flipped then\n                                                    card.ability.extra.any_flipped = false\n                                                    G.hand:shuffle(\"j_joy_lab_changdra\")\n                                                end\n\n                                                if fiend_tributed then\n                                                    for i = 1, card.ability.extra.creates do\n                                                        JoyousSpring.add_random_tag()\n                                                    end\n                                                end\n\n                                                return true\n                                            end)\n                                        }))\n                                        JoyousSpring.tribute(card, context.joy_selection)\n                                        JoyousSpring.tribute(card, { card })\n\n                                        return true\n                                    end)\n                                }))\n                            end\n                        }\n                    }\n                end\n            end\n        end\n    end,\n    joy_can_activate = function(card)\n        if card.ability.eternal or not G.GAME.blind.in_blind then\n            return false\n        end\n        local materials = {}\n        for i, joker in ipairs(G.jokers.cards) do\n            if joker ~= card and not joker.ability.eternal then\n                return true\n            end\n        end\n        return false\n    end,"
    },
    {
      "type": "Joker",
      "key": "lab_ariane",
      "atlas": "lab",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"lab_ariane\",\n    atlas = 'lab',\n    pos = { x = 3, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.mult, card.ability.extra.h_size, card.ability.extra.flipped, card.ability.extra.count } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Labrynth\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Fiend\",\n                monster_archetypes = { [\"Labrynth\"] = true }\n            },\n            mult = 10,\n            h_size = 1,\n            flipped = 5,\n            count = 0,\n            pcard_count = 0,\n            active = false,\n            hand_size_changed = 0\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    mult = card.ability.extra.mult\n                }\n            end\n            if context.setting_blind and context.main_eval then\n                if card.ability.extra.pcard_count > 0 then\n                    card.ability.extra.hand_size_changed = card.ability.extra.h_size * card.ability.extra.pcard_count\n                    G.hand:change_size(card.ability.extra.hand_size_changed)\n                end\n                card.ability.extra.count = 0\n                card.ability.extra.pcard_count = 0\n            end\n        end\n        if context.joy_card_flipped then\n            if JoyousSpring.is_playing_card(context.joy_card_flipped) then\n                card.ability.extra.pcard_count = card.ability.extra.pcard_count + 1\n            end\n            card.ability.extra.count = card.ability.extra.count + 1\n            if JoyousSpring.can_use_abilities(card) and not card.ability.extra.active and card.ability.extra.count >= card.ability.extra.flipped then\n                local choices = JoyousSpring.get_materials_in_collection({ { rarity = 2, monster_archetypes = { \"Labrynth\" } } })\n                local pick = pseudorandom_element(choices, 'j_joy_lab_ariane')\n\n                JoyousSpring.add_monster_tag(pick or \"j_joy_lab_arianna\")\n                card.ability.extra.active = true\n            end\n        end\n        if not context.blueprint_card and context.end_of_round and context.game_over == false and context.main_eval then\n            if card.ability.extra.hand_size_changed > 0 then\n                G.hand:change_size(-card.ability.extra.hand_size_changed)\n            end\n            card.ability.extra.hand_size_changed = 0\n            card.ability.extra.active = false\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        if card.ability.extra.hand_size_changed > 0 then\n            G.hand:change_size(-card.ability.extra.hand_size_changed)\n            card.ability.extra.hand_size_changed = 0\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "lab_arianna",
      "atlas": "lab",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"lab_arianna\",\n    atlas = 'lab',\n    pos = { x = 0, y = 1 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.chips, card.ability.extra.h_size, card.ability.extra.flipped, card.ability.extra.count } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Labrynth\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Fiend\",\n                monster_archetypes = { [\"Labrynth\"] = true }\n            },\n            chips = 50,\n            h_size = 1,\n            flipped = 5,\n            count = 0,\n            pcard_count = 0,\n            active = false,\n            hand_size_changed = 0\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    chips = card.ability.extra.chips\n                }\n            end\n            if context.setting_blind and context.main_eval then\n                if card.ability.extra.pcard_count > 0 then\n                    card.ability.extra.hand_size_changed = card.ability.extra.h_size * card.ability.extra.pcard_count\n                    G.hand:change_size(card.ability.extra.hand_size_changed)\n                end\n                card.ability.extra.count = 0\n                card.ability.extra.pcard_count = 0\n            end\n        end\n        if context.joy_card_flipped then\n            if JoyousSpring.is_playing_card(context.joy_card_flipped) then\n                card.ability.extra.pcard_count = card.ability.extra.pcard_count + 1\n            end\n            card.ability.extra.count = card.ability.extra.count + 1\n            if JoyousSpring.can_use_abilities(card) and not card.ability.extra.active and card.ability.extra.count >= card.ability.extra.flipped then\n                local choices = JoyousSpring.get_materials_in_collection({ { rarity = 1, monster_archetypes = { \"Labrynth\" } } })\n                local pick = pseudorandom_element(choices, 'j_joy_lab_arianna')\n                JoyousSpring.add_monster_tag(pick or \"j_joy_lab_clock\")\n                card.ability.extra.active = true\n            end\n        end\n        if not context.blueprint_card and context.end_of_round and context.game_over == false and context.main_eval then\n            if card.ability.extra.hand_size_changed > 0 then\n                G.hand:change_size(-card.ability.extra.hand_size_changed)\n            end\n            card.ability.extra.hand_size_changed = 0\n            card.ability.extra.active = false\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        if card.ability.extra.hand_size_changed > 0 then\n            G.hand:change_size(-card.ability.extra.hand_size_changed)\n            card.ability.extra.hand_size_changed = 0\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "lab_arias",
      "atlas": "lab",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"lab_arias\",\n    atlas = 'lab',\n    pos = { x = 1, y = 1 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.chips, card.ability.extra.chips * card.ability.extra.total_count, card.ability.extra.flipped, card.ability.extra.count } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Labrynth\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Fiend\",\n                monster_archetypes = { [\"Labrynth\"] = true }\n            },\n            chips = 25,\n            flipped = 10,\n            count = 0,\n            active = false,\n            total_count = 0\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.setting_blind and context.main_eval then\n                card.ability.extra.count = 0\n            end\n            if context.joker_main then\n                return {\n                    chips = card.ability.extra.chips * card.ability.extra.total_count\n                }\n            end\n        end\n        if context.joy_card_flipped then\n            if JoyousSpring.is_playing_card(context.joy_card_flipped) then\n                card.ability.extra.total_count = card.ability.extra.total_count + 1\n            end\n            card.ability.extra.count = card.ability.extra.count + 1\n            if JoyousSpring.can_use_abilities(card) and not card.ability.extra.active and card.ability.extra.count > card.ability.extra.flipped then\n                local choices = JoyousSpring.get_materials_in_collection({ { rarity = 3, monster_archetypes = { \"Labrynth\" } } })\n                local pick = pseudorandom_element(choices, 'j_joy_lab_arianna')\n                JoyousSpring.add_monster_tag(pick or \"j_joy_lab_lovely\")\n                card.ability.extra.active = true\n            end\n        end\n        if not context.blueprint_card and context.end_of_round and context.game_over == false and context.main_eval then\n            card.ability.extra.active = false\n        end\n    end,\n    joy_set_cost = function(card)\n        if JoyousSpring.count_materials_owned({ { monster_archetypes = { \"Labrynth\" } } }) > 0 then\n            card.cost = 0\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "lab_archfiend",
      "atlas": "lab",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"lab_archfiend\",\n    atlas = 'lab',\n    pos = { x = 2, y = 1 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.mult, card.ability.extra.mult * JoyousSpring.count_materials_in_graveyard({ { monster_type = \"Fiend\" } }) } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Labrynth\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Fiend\",\n                monster_archetypes = { [\"Labrynth\"] = true }\n            },\n            mult = 5,\n            flips = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    mult = card.ability.extra.mult *\n                        JoyousSpring.count_materials_in_graveyard({ { monster_type = \"Fiend\" } })\n                }\n            end\n            if context.joy_card_flipped and JoyousSpring.is_playing_card(context.joy_card_flipped) and not (context.joy_source and context.joy_source.config.center.key == \"j_joy_lab_archfiend\") then\n                return {\n                    func = function()\n                        G.E_MANAGER:add_event(Event({\n                            trigger = 'after',\n                            delay = 0.3,\n                            func = (function()\n                                for i = 1, card.ability.extra.flips do\n                                    local flipped_card = JoyousSpring.flip_random_card(card, G.hand.cards, 'front',\n                                        \"j_joy_lab_archfiend\")\n                                    if flipped_card then\n                                        card.ability.extra.any_flipped = true\n                                    else\n                                        break\n                                    end\n                                end\n\n                                return true\n                            end)\n                        }))\n                    end,\n                    extra = {\n                        func = function()\n                            G.E_MANAGER:add_event(Event({\n                                trigger = 'after',\n                                delay = 0.8,\n                                func = (function()\n                                    G.E_MANAGER:add_event(Event({\n                                        trigger = 'after',\n                                        delay = 0.3,\n                                        func = (function()\n                                            if card.ability.extra.any_flipped then\n                                                card.ability.extra.any_flipped = false\n                                                G.hand:shuffle(\"j_joy_lab_archfiend\")\n                                                SMODS.calculate_effect({ message = localize(\"k_joy_flip_ex\") }, card)\n                                            end\n                                            return true\n                                        end)\n                                    }))\n                                    return true\n                                end)\n                            }))\n                        end\n                    }\n                }\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "lab_lovely",
      "atlas": "lab",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"lab_lovely\",\n    atlas = 'lab',\n    pos = { x = 3, y = 1 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { G.GAME.probabilities.normal or 1, math.max(1, card.ability.extra.odds - JoyousSpring.count_materials_owned({ { monster_type = \"Fiend\" } })), card.ability.extra.extra_mult, card.ability.extra.mult } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Labrynth\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Fiend\",\n                monster_archetypes = { [\"Labrynth\"] = true }\n            },\n            odds = 8,\n            extra_mult = 3,\n            mult = 0\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    mult = card.ability.extra.mult\n                }\n            end\n            if context.joy_card_flipped and context.joy_card_flipped.facing == 'back' then\n                card.ability.extra.mult = card.ability.extra.mult + card.ability.extra.extra_mult\n            end\n            if context.stay_flipped and context.to_area == G.hand and\n                pseudorandom(\"j_joy_lab_lovely\") <\n                G.GAME.probabilities.normal /\n                math.max(1, card.ability.extra.odds - JoyousSpring.count_materials_owned({ { monster_type = \"Fiend\" } })) then\n                return {\n                    stay_flipped = true\n                }\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "lab_lady",
      "atlas": "lab",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = \"lab_lady\",\n    atlas = 'lab',\n    pos = { x = 0, y = 2 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 11,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.extra_xmult, 1 + card.ability.extra.xmult } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Labrynth\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Fiend\",\n                monster_archetypes = { [\"Labrynth\"] = true }\n            },\n            xmult = 0,\n            extra_xmult = 0.1\n        },\n    },\n    calculate = function(self, card, context)\n        if context.joker_main then\n            if card.ability.extra.xmult > 0 then\n                return {\n                    xmult = 1 + card.ability.extra.xmult,\n                }\n            end\n        end\n        if context.joy_card_flipped then\n            card.ability.extra.xmult = card.ability.extra.xmult + card.ability.extra.extra_xmult\n        end\n    end,\n    joy_allow_ability = function(card, other_card)\n        return not JoyousSpring.is_trap_monster(other_card) and JoyousSpring.is_monster_type(other_card, \"Fiend\") and\n            true or false\n    end"
    },
    {
      "type": "Joker",
      "key": "lab_labyrinth",
      "atlas": "lab",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "key = \"lab_labyrinth\",\n    atlas = 'lab',\n    pos = { x = 1, y = 2 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 8,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.money, G.GAME.probabilities.normal or 1, card.ability.extra.odds, card.ability.extra.flips } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Labrynth\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_field_spell = true,\n                monster_archetypes = { [\"Labrynth\"] = true }\n            },\n            money = 5,\n            odds = 2,\n            flips = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joy_card_flipped and not (context.joy_source and context.joy_source.config.center.key == \"j_joy_lab_labyrinth\") then\n                if context.joy_card_flipped.ability.set == \"Joker\" then\n                    return {\n                        dollars = card.ability.extra.money\n                    }\n                end\n                if JoyousSpring.is_playing_card(context.joy_card_flipped) and pseudorandom(\"j_joy_lab_labyrinth\") <\n                    G.GAME.probabilities.normal / card.ability.extra.odds then\n                    return {\n                        func = function()\n                            G.E_MANAGER:add_event(Event({\n                                trigger = 'after',\n                                delay = 0.3,\n                                func = (function()\n                                    for i = 1, card.ability.extra.flips do\n                                        local flipped_card = JoyousSpring.flip_random_card(card, G.hand.cards, 'front',\n                                            \"j_joy_lab_labyrinth\")\n                                        if flipped_card then\n                                            card.ability.extra.any_flipped = true\n                                        else\n                                            break\n                                        end\n                                    end\n\n                                    return true\n                                end)\n                            }))\n                        end,\n                        extra = {\n                            func = function()\n                                G.E_MANAGER:add_event(Event({\n                                    trigger = 'after',\n                                    delay = 0.8,\n                                    func = (function()\n                                        G.E_MANAGER:add_event(Event({\n                                            trigger = 'after',\n                                            delay = 0.3,\n                                            func = (function()\n                                                if card.ability.extra.any_flipped then\n                                                    card.ability.extra.any_flipped = false\n                                                    G.hand:shuffle(\"j_joy_lab_labyrinth\")\n                                                    SMODS.calculate_effect({ message = localize(\"k_joy_flip_ex\") }, card)\n                                                end\n                                                return true\n                                            end)\n                                        }))\n                                        return true\n                                    end)\n                                }))\n                            end\n                        }\n                    }\n                end\n            end\n        end\n    end,"
    },
    {
      "type": "Atlas",
      "key": "sub",
      "atlas": null,
      "pos": null,
      "raw": "key = \"sub\",\n    path = \"13Subterror.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Joker",
      "key": "sub_fiendess",
      "atlas": "sub",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"sub_fiendess\",\n    atlas = 'sub',\n    pos = { x = 0, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n        end\n        return { vars = { card.ability.extra.revives } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_sub_city\", properties = { { monster_archetypes = { \"Subterror\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"EARTH\",\n                monster_type = \"Spellcaster\",\n                monster_archetypes = { [\"Subterror\"] = true }\n            },\n            flips = 1,\n            revives = 1,\n            activated = false\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card then\n                if not card.ability.extra.activated and context.joy_activate_effect and context.joy_activated_card == card then\n                    local targets = JoyousSpring.get_materials_owned({ { can_flip = true } })\n                    local materials = {}\n                    for i, joker in ipairs(targets) do\n                        if joker ~= card and joker.facing == 'front' then\n                            materials[#materials + 1] = joker\n                        end\n                    end\n                    if next(materials) then\n                        JoyousSpring.create_overlay_effect_selection(card, materials, card.ability.extra.flips,\n                            card.ability.extra.flips, localize(\"k_joy_select\"))\n                    end\n                end\n                if not card.ability.extra.activated and context.joy_exit_effect_selection and context.joy_card == card and\n                    #context.joy_selection == card.ability.extra.flips then\n                    for _, selected_card in ipairs(context.joy_selection) do\n                        selected_card:flip(card)\n                    end\n                    card:flip(card)\n                    for i = 1, card.ability.extra.revives do\n                        JoyousSpring.revive_pseudorandom(\n                            { { monster_archetypes = { \"Subterror\" } } },\n                            'j_joy_sub_fiendess',\n                            false,\n                            { negative = true }\n                        )\n                    end\n                    card.ability.extra.activated = true\n                end\n            end\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval then\n            card.ability.extra.activated = false\n        end\n    end,\n    joy_can_activate = function(card)\n        if card.ability.extra.activated then\n            return false\n        end\n        local targets = JoyousSpring.get_materials_owned({ { can_flip = true } })\n        local faceup_joker = false\n        for _, joker in ipairs(targets) do\n            if joker ~= card and joker.facing == 'front' then\n                return true\n            end\n        end\n        return false\n    end,"
    },
    {
      "type": "Joker",
      "key": "sub_defender",
      "atlas": "sub",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"sub_defender\",\n    atlas = 'sub',\n    pos = { x = 1, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.chips, card.ability.extra.chips * (JoyousSpring.count_flipped('back', { G.jokers }) + JoyousSpring.count_materials_owned({ { monster_archetypes = { \"Subterror\" } } })) } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_sub_city\", properties = { { monster_archetypes = { \"Subterror\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"EARTH\",\n                monster_type = \"BeastWarrior\",\n                monster_archetypes = { [\"Subterror\"] = true, [\"SubterrorNemesis\"] = true }\n            },\n            chips = 50\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    chips = card.ability.extra.chips *\n                        (JoyousSpring.count_flipped('back', { G.jokers }) + JoyousSpring.count_materials_owned({ { monster_archetypes = { \"Subterror\" } } }))\n                }\n            end\n            if context.selling_self and not context.blueprint then\n                JoyousSpring.flip_all_cards(card, 'front')\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "sub_archer",
      "atlas": "sub",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"sub_archer\",\n    atlas = 'sub',\n    pos = { x = 2, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 8,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.creates } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_sub_city\", properties = { { monster_archetypes = { \"Subterror\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"EARTH\",\n                monster_type = \"Fairy\",\n                monster_archetypes = { [\"Subterror\"] = true, [\"SubterrorNemesis\"] = true }\n            },\n            flips = 1,\n            creates = 1,\n            activated = false\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card then\n                if not card.ability.extra.activated and context.joy_activate_effect and context.joy_activated_card == card then\n                    local targets = JoyousSpring.get_materials_owned({ { can_flip = true } })\n                    local materials = {}\n                    for i, joker in ipairs(targets) do\n                        if joker ~= card and joker.facing == 'front' then\n                            materials[#materials + 1] = joker\n                        end\n                    end\n                    if next(materials) then\n                        JoyousSpring.create_overlay_effect_selection(card, materials, card.ability.extra.flips,\n                            card.ability.extra.flips, localize(\"k_joy_select\"))\n                    end\n                end\n                if not card.ability.extra.activated and context.joy_exit_effect_selection and context.joy_card == card and\n                    #context.joy_selection == card.ability.extra.flips then\n                    for _, selected_card in ipairs(context.joy_selection) do\n                        selected_card:flip(card)\n                    end\n                    card:flip(card)\n                    JoyousSpring.create_pseudorandom(\n                        { { monster_archetypes = { \"Subterror\" }, exclude_keys = { \"j_joy_sub_archer\" }, rarity = 1 }, { monster_archetypes = { \"Subterror\" }, exclude_keys = { \"j_joy_sub_archer\" }, rarity = 2 } },\n                        \"j_joy_sub_archer\", false, false, \"e_negative\")\n                    card.ability.extra.activated = true\n                end\n            end\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval and G.GAME.blind.boss then\n            card.ability.extra.activated = false\n        end\n    end,\n    joy_can_activate = function(card)\n        if card.ability.extra.activated then\n            return false\n        end\n        local targets = JoyousSpring.get_materials_owned({ { can_flip = true } })\n        local faceup_joker = false\n        for _, joker in ipairs(targets) do\n            if joker ~= card and joker.facing == 'front' then\n                faceup_joker = true\n                break\n            end\n        end\n        return faceup_joker\n    end,"
    },
    {
      "type": "Joker",
      "key": "sub_warrior",
      "atlas": "sub",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"sub_warrior\",\n    atlas = 'sub',\n    pos = { x = 3, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_tribute\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n        end\n        return { vars = { card.ability.extra.revives, card.ability.extra.mills } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_sub_city\", properties = { { monster_archetypes = { \"Subterror\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_flip = true,\n                attribute = \"EARTH\",\n                monster_type = \"Warrior\",\n                monster_archetypes = { [\"Subterror\"] = true, [\"SubterrorNemesis\"] = true }\n            },\n            tributes = 1,\n            revives = 1,\n            mills = 2\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card then\n                if context.joy_activate_effect and context.joy_activated_card == card then\n                    local targets = G.jokers.cards\n                    local materials = {}\n                    for i, joker in ipairs(targets) do\n                        if joker ~= card and not joker.ability.eternal then\n                            materials[#materials + 1] = joker\n                        end\n                    end\n                    if next(materials) then\n                        JoyousSpring.create_overlay_effect_selection(card, materials, card.ability.extra.tributes,\n                            card.ability.extra.tributes)\n                    end\n                end\n                if context.joy_exit_effect_selection and context.joy_card == card and\n                    #context.joy_selection == card.ability.extra.tributes then\n                    JoyousSpring.tribute(card, context.joy_selection)\n                    JoyousSpring.tribute(card, { card })\n                    for i = 1, card.ability.extra.revives do\n                        local revived_card = JoyousSpring.revive_pseudorandom(\n                            { { monster_archetypes = { \"SubterrorBehemoth\" } } },\n                            'j_joy_sub_warrior',\n                            true\n                        )\n                        if not revived_card then\n                            revived_card = JoyousSpring.revive_pseudorandom(\n                                { { monster_archetypes = { \"Subterror\" } } },\n                                'j_joy_sub_warrior',\n                                true\n                            )\n                        end\n                    end\n                end\n            end\n            if JoyousSpring.calculate_flip_effect(card, context) then\n                local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"SubterrorBehemoth\" } } })\n\n                for i = 1, card.ability.extra.mills do\n                    JoyousSpring.send_to_graveyard(pseudorandom_element(choices, 'j_joy_sub_warrior'))\n                end\n            end\n        end\n    end,\n    joy_can_activate = function(card)\n        local targets = G.jokers.cards\n        local materials = {}\n        for i, joker in ipairs(targets) do\n            if joker ~= card and not joker.ability.eternal then\n                materials[#materials + 1] = joker\n            end\n        end\n        return next(materials) and JoyousSpring.count_materials_in_graveyard(\n            { { monster_archetypes = { \"SubterrorBehemoth\" } }, { monster_archetypes = { \"Subterror\" } } }, true) > 0\n    end,"
    },
    {
      "type": "Joker",
      "key": "sub_guru",
      "atlas": "sub",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"sub_guru\",\n    atlas = 'sub',\n    pos = { x = 0, y = 1 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.flips, card.ability.extra.xmult, card.ability.extra.h_size, card.ability.extra.creates } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_sub_city\", properties = { { monster_archetypes = { \"Subterror\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_flip = true,\n                attribute = \"EARTH\",\n                monster_type = \"Dragon\",\n                monster_archetypes = { [\"Subterror\"] = true, [\"SubterrorBehemoth\"] = true }\n            },\n            flips = 2,\n            xmult = 2,\n            h_size = 1,\n            creates = 1,\n            activated = false,\n            current_xmult = 0,\n            current_h_size = 0,\n        },\n    },\n    calculate = function(self, card, context)\n        if context.setting_blind and context.main_eval and card.facing == 'back' then\n            card:flip(card)\n        end\n        if context.joker_main then\n            if card.ability.extra.current_xmult > 0 then\n                return {\n                    xmult = card.ability.extra.current_xmult\n                }\n            end\n        end\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card then\n                if not card.ability.extra.activated and context.joy_activate_effect and context.joy_activated_card == card then\n                    local targets = JoyousSpring.get_materials_owned({ { facedown = true }, { can_flip = true } })\n                    local materials = {}\n                    for i, joker in ipairs(targets) do\n                        if joker ~= card then\n                            materials[#materials + 1] = joker\n                        end\n                    end\n                    if next(materials) then\n                        JoyousSpring.create_overlay_effect_selection(card, materials, card.ability.extra.flips,\n                            card.ability.extra.flips, localize(\"k_joy_select\"))\n                    end\n                end\n                if not card.ability.extra.activated and context.joy_exit_effect_selection and context.joy_card == card and\n                    #context.joy_selection == card.ability.extra.flips then\n                    local flips = { front = 0, back = 0 }\n                    for _, selected_card in ipairs(context.joy_selection) do\n                        selected_card:flip(card)\n                        flips[selected_card.facing] = flips[selected_card.facing] + 1\n                    end\n                    card:flip(card)\n                    flips[card.facing] = flips[card.facing] + 1\n\n                    card.ability.extra.current_xmult = card.ability.extra.xmult * flips.back\n                    card.ability.extra.current_h_size = card.ability.extra.h_size * flips.front\n                    G.hand:change_size(card.ability.extra.current_h_size)\n\n                    card.ability.extra.activated = true\n                end\n                if JoyousSpring.calculate_flip_effect(card, context) then\n                    for _ = 1, card.ability.extra.creates do\n                        JoyousSpring.create_pseudorandom(\n                            { { monster_archetypes = { \"Subterror\" }, exclude_keys = { \"j_joy_sub_guru\" }, rarity = 1 }, { monster_archetypes = { \"Subterror\" }, exclude_keys = { \"j_joy_sub_guru\" }, rarity = 2 } },\n                            'j_joy_sub_guru', true)\n                    end\n                end\n            end\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval then\n            G.hand:change_size(-card.ability.extra.current_h_size)\n            card.ability.extra.current_xmult = 0\n            card.ability.extra.current_h_size = 0\n            card.ability.extra.activated = false\n        end\n    end,\n    joy_can_activate = function(card)\n        if card.ability.extra.activated or not G.GAME.blind.in_blind then\n            return false\n        end\n        local targets = JoyousSpring.get_materials_owned({ { facedown = true }, { can_flip = true } })\n        local faceup_joker = 0\n        for _, joker in ipairs(targets) do\n            if joker ~= card then\n                faceup_joker = faceup_joker + 1\n            end\n        end\n        return faceup_joker >= card.ability.extra.flips\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        if card.ability.extra.current_h_size > 0 then\n            G.hand:change_size(-card.ability.extra.h_size)\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "sub_stygo",
      "atlas": "sub",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"sub_stygo\",\n    atlas = 'sub',\n    pos = { x = 1, y = 1 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.xmult } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_sub_city\", properties = { { monster_archetypes = { \"Subterror\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_flip = true,\n                attribute = \"EARTH\",\n                monster_type = \"SeaSerpent\",\n                monster_archetypes = { [\"Subterror\"] = true, [\"SubterrorBehemoth\"] = true }\n            },\n            xmult = 1.5\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            JoyousSpring.calculate_flip_effect(card, context)\n            if JoyousSpring.is_flip_active(card) then\n                if (context.individual and context.cardarea == G.hand) or context.other_joker or context.other_consumeable then\n                    local other_card = context.other_card or context.other_joker or context.other_consumeable\n                    if other_card and other_card.facing == 'back' then\n                        return {\n                            xmult = card.ability.extra.xmult,\n                            message_card = other_card\n                        }\n                    end\n                end\n            end\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval and G.GAME.blind.boss then\n            card:flip(card)\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff then\n            card:flip(card)\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "sub_drago",
      "atlas": "sub",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"sub_drago\",\n    atlas = 'sub',\n    pos = { x = 2, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        return { vars = {} }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_sub_city\", properties = { { monster_archetypes = { \"Subterror\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_flip = true,\n                attribute = \"EARTH\",\n                monster_type = \"Zombie\",\n                monster_archetypes = { [\"Subterror\"] = true, [\"SubterrorBehemoth\"] = true }\n            },\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if JoyousSpring.calculate_flip_effect(card, context) then\n                local choices = JoyousSpring.get_materials_owned({ { facedown = true, exclude_edition = true }, { monster_archetypes = { \"Subterror\" }, exclude_edition = true } })\n                local pick = pseudorandom_element(choices, 'j_joy_sub_drago')\n                if pick then\n                    local edition = poll_edition(\"j_joy_sub_drago\", nil, nil, true) or 'e_foil'\n                    pick:set_edition(edition)\n                end\n            end\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval and G.GAME.blind.boss then\n            card:flip(card)\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff then\n            card:flip(card)\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "sub_uma",
      "atlas": "sub",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"sub_uma\",\n    atlas = 'sub',\n    pos = { x = 3, y = 1 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 7,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_banish\" }\n        end\n        return { vars = { card.ability.extra.banishes } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_sub_city\", properties = { { monster_archetypes = { \"Subterror\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_flip = true,\n                attribute = \"EARTH\",\n                monster_type = \"Reptile\",\n                monster_archetypes = { [\"Subterror\"] = true, [\"SubterrorBehemoth\"] = true }\n            },\n            banishes = 2\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if JoyousSpring.is_flip_active(card) and not context.blueprint_card and context.end_of_round and context.game_over == false and context.main_eval then\n                local choices = JoyousSpring.get_materials_owned({ { exclude_keys = { \"j_joy_sub_uma\" } } })\n                local to_banish, index = pseudorandom_element(choices, 'j_joy_sub_uma')\n                table.remove(choices, index)\n                local to_banish2 = pseudorandom_element(choices, 'j_joy_sub_uma')\n                if to_banish then\n                    JoyousSpring.banish(to_banish, \"blind_selected\")\n                end\n                if to_banish2 then\n                    JoyousSpring.banish(to_banish2, \"blind_selected\")\n                end\n            end\n            JoyousSpring.calculate_flip_effect(card, context)\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval and G.GAME.blind.boss then\n            card:flip(card)\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff then\n            card:flip(card)\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "sub_phos",
      "atlas": "sub",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = \"sub_phos\",\n    atlas = 'sub',\n    pos = { x = 0, y = 2 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.chips, card.ability.extra.chips * JoyousSpring.count_materials_in_graveyard({ { monster_type = \"Aqua\" }, { monster_archetypes = { \"Subterror\" } } }), card.ability.extra.mills } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_sub_city\", properties = { { monster_archetypes = { \"Subterror\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_flip = true,\n                attribute = \"EARTH\",\n                monster_type = \"Aqua\",\n                monster_archetypes = { [\"Subterror\"] = true, [\"SubterrorBehemoth\"] = true }\n            },\n            chips = 30,\n            mills = 5\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if JoyousSpring.calculate_flip_effect(card, context) then\n                local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Subterror\" } } })\n\n                for i = 1, card.ability.extra.mills do\n                    JoyousSpring.send_to_graveyard(pseudorandom_element(choices, 'j_joy_sub_warrior'))\n                end\n            end\n            if context.joker_main then\n                return {\n                    chips = card.ability.extra.chips *\n                        JoyousSpring.count_materials_in_graveyard({ { monster_type = \"Aqua\" }, { monster_archetypes = { \"Subterror\" } } })\n                }\n            end\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval and G.GAME.blind.boss then\n            card:flip(card)\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff then\n            card:flip(card)\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "sub_volt",
      "atlas": "sub",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "key = \"sub_volt\",\n    atlas = 'sub',\n    pos = { x = 1, y = 2 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        return {\n            vars = { card.ability.extra.mult, card.ability.extra.mult *\n            JoyousSpring.count_flipped('back') }\n        }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_sub_city\", properties = { { monster_archetypes = { \"Subterror\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_flip = true,\n                attribute = \"EARTH\",\n                monster_type = \"Thunder\",\n                monster_archetypes = { [\"Subterror\"] = true, [\"SubterrorBehemoth\"] = true }\n            },\n            mult = 50\n        },\n    },\n    calculate = function(self, card, context)\n        if context.first_hand_drawn and G.GAME.blind.boss then\n            card:flip(card)\n        end\n        if JoyousSpring.can_use_abilities(card) then\n            if JoyousSpring.calculate_flip_effect(card, context) then\n                JoyousSpring.flip_all_cards(card, 'back', { G.hand })\n            end\n            if context.joker_main then\n                return {\n                    mult = card.ability.extra.mult *\n                        JoyousSpring.count_flipped('back')\n                }\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff then\n            card:flip(card)\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "sub_stala",
      "atlas": "sub",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "key = \"sub_stala\",\n    atlas = 'sub',\n    pos = { x = 2, y = 2 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 8,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.draws } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_sub_city\", properties = { { monster_archetypes = { \"Subterror\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_flip = true,\n                attribute = \"EARTH\",\n                monster_type = \"Rock\",\n                monster_archetypes = { [\"Subterror\"] = true, [\"SubterrorBehemoth\"] = true }\n            },\n            draws = 5,\n            stay_flipped = fals,\n            draw_count = 0\n        },\n    },\n    calculate = function(self, card, context)\n        if context.setting_blind and context.main_eval and G.GAME.blind.boss then\n            card:flip(card)\n        end\n        if JoyousSpring.can_use_abilities(card) then\n            if JoyousSpring.calculate_flip_effect(card, context) and G.GAME.blind.in_blind then\n                card.ability.extra.stay_flipped = true\n                for i = 1, card.ability.extra.draws do\n                    draw_card(G.deck, G.hand, i * 100 / card.ability.extra.draws, 'up', false, nil, 0, nil, true)\n                end\n            end\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval then\n            card.ability.extra.stay_flipped = false\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff then\n            card:flip(card)\n        end\n    end,\n    joy_stay_flipped = function(card, playing_card)\n        if card.ability.extra.stay_flipped then\n            card.ability.extra.draw_count = card.ability.extra.draw_count + 1\n            if card.ability.extra.draw_count >= card.ability.extra.draws or (#G.deck.cards == 0) then\n                card.ability.extra.stay_flipped = false\n            end\n            return true\n        end\n        return false\n    end"
    },
    {
      "type": "Joker",
      "key": "sub_speleo",
      "atlas": "sub",
      "pos": {
        "x": 3,
        "y": 2
      },
      "raw": "key = \"sub_speleo\",\n    atlas = 'sub',\n    pos = { x = 3, y = 2 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 9,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.extra_xmult, 1 + card.ability.extra.xmult } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_sub_city\", properties = { { monster_archetypes = { \"Subterror\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_flip = true,\n                attribute = \"EARTH\",\n                monster_type = \"Fiend\",\n                monster_archetypes = { [\"Subterror\"] = true, [\"SubterrorBehemoth\"] = true }\n            },\n            xmult = 0,\n            extra_xmult = 0.1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if JoyousSpring.calculate_flip_effect(card, context) then\n                for _, joker in ipairs(G.jokers.cards) do\n                    if card ~= joker and joker.facing == 'back' then\n                        joker:flip(card)\n                    end\n                end\n            end\n            if context.joker_main then\n                if card.ability.extra.xmult > 0 then\n                    return {\n                        xmult = 1 + card.ability.extra.xmult,\n                    }\n                end\n            end\n        end\n        if context.joy_card_flipped then\n            card.ability.extra.xmult = card.ability.extra.xmult + card.ability.extra.extra_xmult\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval and G.GAME.blind.boss then\n            card:flip(card)\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff then\n            card:flip(card)\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "sub_ultra",
      "atlas": "sub",
      "pos": {
        "x": 0,
        "y": 3
      },
      "raw": "key = \"sub_ultra\",\n    atlas = 'sub',\n    pos = { x = 0, y = 3 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 9,\n    loc_vars = function(self, info_queue, card)\n        return {\n            vars = { card.ability.extra.chips, card.ability.extra.chips *\n            JoyousSpring.count_flipped('back') }\n        }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_sub_city\", properties = { { monster_archetypes = { \"Subterror\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_flip = true,\n                attribute = \"EARTH\",\n                monster_type = \"Pyro\",\n                monster_archetypes = { [\"Subterror\"] = true, [\"SubterrorBehemoth\"] = true }\n            },\n            chips = 200\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if JoyousSpring.calculate_flip_effect(card, context) then\n                for _, joker in ipairs(G.jokers.cards) do\n                    if card ~= joker and joker.facing == 'front' then\n                        joker:flip(card)\n                    end\n                end\n            end\n            if context.joker_main then\n                return {\n                    chips = card.ability.extra.chips *\n                        JoyousSpring.count_flipped('back')\n                }\n            end\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval and G.GAME.blind.boss then\n            card:flip(card)\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff then\n            card:flip(card)\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "sub_befiendess",
      "atlas": "sub",
      "pos": {
        "x": 2,
        "y": 3
      },
      "raw": "key = \"sub_befiendess\",\n    atlas = 'sub',\n    pos = { x = 2, y = 3 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        local mult_count = 0\n        for _, material in ipairs(JoyousSpring.get_materials(card)) do\n            if JoyousSpring.is_material_center(material, { monster_archetypes = { \"Subterror\" } }) then\n                mult_count = mult_count + 1\n            end\n        end\n        local current_chips = card.ability.extra.chips * #JoyousSpring.get_materials(card)\n        local current_mult = card.ability.extra.mult * mult_count\n        return { vars = { card.ability.extra.chips, card.ability.extra.mult, current_chips, current_mult, card.ability.extra.flips, card.ability.extra.creates } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_sub_city\", properties = { { monster_archetypes = { \"Subterror\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"LINK\",\n                attribute = \"EARTH\",\n                monster_type = \"Wyrm\",\n                monster_archetypes = { [\"Subterror\"] = true, [\"SubterrorBehemoth\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"LINK\",\n                        materials = {\n                            { facedown = true, min = 2 },\n                        },\n                    },\n                    {\n                        type = \"LINK\",\n                        materials = {\n                            { is_flip = true, min = 2 },\n                        },\n                    },\n                    {\n                        type = \"LINK\",\n                        materials = {\n                            { facedown = true, min = 1 },\n                            { is_flip = true,  min = 1 },\n                        },\n                    }\n                }\n            },\n            chips = 100,\n            mult = 50,\n            flips = 2,\n            creates = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card then\n                if not card.ability.extra.activated and context.joy_activate_effect and context.joy_activated_card == card then\n                    local targets = JoyousSpring.get_materials_owned({ { can_flip = true } })\n                    local materials = {}\n                    for i, joker in ipairs(targets) do\n                        if joker ~= card and joker.facing == 'front' then\n                            materials[#materials + 1] = joker\n                        end\n                    end\n                    if next(materials) then\n                        JoyousSpring.create_overlay_effect_selection(card, materials, card.ability.extra.flips,\n                            card.ability.extra.flips, localize(\"k_joy_select\"))\n                    end\n                end\n                if not card.ability.extra.activated and context.joy_exit_effect_selection and context.joy_card == card and\n                    #context.joy_selection == card.ability.extra.flips then\n                    for _, selected_card in ipairs(context.joy_selection) do\n                        selected_card:flip(card)\n                    end\n\n                    for _ = 1, card.ability.extra.creates do\n                        JoyousSpring.create_pseudorandom(\n                            { { monster_archetypes = { \"SubterrorBehemoth\" }, exclude_keys = { \"j_joy_sub_befiendess\" } } },\n                            'j_joy_sub_befiendess', true)\n                    end\n                    card.ability.extra.activated = true\n                end\n            end\n            if context.joker_main then\n                local mult_count = 0\n                for _, material in ipairs(JoyousSpring.get_materials(card)) do\n                    if JoyousSpring.is_material_center(material, { monster_archetypes = { \"Subterror\" } }) then\n                        mult_count = mult_count + 1\n                    end\n                end\n                local current_chips = card.ability.extra.chips * #JoyousSpring.get_materials(card)\n                local current_mult = card.ability.extra.mult * mult_count\n                return {\n                    chips = current_chips,\n                    mult = current_mult\n                }\n            end\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval then\n            card.ability.extra.activated = false\n        end\n    end,\n    joy_can_activate = function(card)\n        if card.ability.extra.activated then\n            return false\n        end\n        local targets = JoyousSpring.get_materials_owned({ { can_flip = true } })\n        local faceup_joker = 0\n        for _, joker in ipairs(targets) do\n            if joker ~= card and joker.facing == 'front' then\n                faceup_joker = faceup_joker + 1\n            end\n        end\n        return faceup_joker >= card.ability.extra.flips\n    end,"
    },
    {
      "type": "Joker",
      "key": "sub_city",
      "atlas": "sub",
      "pos": {
        "x": 1,
        "y": 3
      },
      "raw": "key = \"sub_city\",\n    atlas = 'sub',\n    pos = { x = 1, y = 3 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_monster\" }\n        end\n        return { vars = { card.ability.extra.money } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_sub_city\", properties = { { monster_archetypes = { \"Subterror\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_field_spell = true,\n            },\n            flips = 1,\n            money = 5,\n            activated = false\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card then\n                if not card.ability.extra.activated and context.joy_activate_effect and context.joy_activated_card == card then\n                    local materials = JoyousSpring.get_materials_owned({ { facedown = true }, { can_flip = true } })\n                    if next(materials) then\n                        JoyousSpring.create_overlay_effect_selection(card, materials, card.ability.extra.flips,\n                            card.ability.extra.flips, localize(\"k_joy_select\"))\n                    end\n                end\n                if not card.ability.extra.activated and context.joy_exit_effect_selection and context.joy_card == card and\n                    #context.joy_selection == card.ability.extra.flips then\n                    for _, selected_card in ipairs(context.joy_selection) do\n                        selected_card:flip(card)\n                    end\n                    card.ability.extra.activated = true\n                end\n            end\n            if context.joy_card_flipped and context.joy_card_flipped.ability.set == \"Joker\" then\n                if (context.joy_card_flipped.facing == \"back\") == JoyousSpring.is_monster_card(context.joy_card_flipped) then\n                    return {\n                        dollars = card.ability.extra.money\n                    }\n                end\n            end\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval then\n            card.ability.extra.activated = false\n        end\n    end,\n    joy_can_activate = function(card)\n        if card.ability.extra.activated then\n            return false\n        end\n        return JoyousSpring.count_materials_owned({ { facedown = true }, { can_flip = true } }) >\n            0\n    end,"
    },
    {
      "type": "Atlas",
      "key": "eld",
      "atlas": null,
      "pos": null,
      "raw": "key = \"eld\",\n    path = \"14Eldlich.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Joker",
      "key": "eld_eldlich",
      "atlas": "eld",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"eld_eldlich\",\n    atlas = 'eld',\n    pos = { x = 0, y = 0 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 12,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_tribute\" }\n        end\n        return { vars = { card.ability.extra.money, card.ability.extra.tributes, card.ability.extra.creates } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Eldlich\" } }, { monster_archetypes = { \"GoldenLand\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"LIGHT\",\n                monster_type = \"Zombie\",\n                monster_archetypes = { [\"Eldlich\"] = true }\n            },\n            money = 0.25,\n            tributes = 1,\n            creates = 1,\n            activated = false\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.individual and context.cardarea == G.play and SMODS.has_enhancement(context.other_card, 'm_gold') then\n                return {\n                    dollars = card.ability.extra.money *\n                        JoyousSpring.count_all_materials({ { monster_type = \"Zombie\" } })\n                }\n            end\n            if context.after and context.main_eval then\n                return {\n                    func = function()\n                        for _, playing_card in ipairs(context.scoring_hand) do\n                            playing_card:set_ability(G.P_CENTERS.m_gold, nil, true)\n                            playing_card:juice_up()\n                        end\n                    end\n                }\n            end\n            if not context.blueprint then\n                if not card.ability.extra.activated and context.joy_activate_effect and context.joy_activated_card == card then\n                    local materials = JoyousSpring.get_materials_owned(\n                        { { monster_type = \"Zombie\" }, { is_trap = true } }, false, true)\n                    if next(materials) then\n                        JoyousSpring.create_overlay_effect_selection(card, materials, card.ability.extra.tributes,\n                            card.ability.extra.tributes)\n                    end\n                end\n                if not card.ability.extra.activated and context.joy_exit_effect_selection and context.joy_card == card and\n                    #context.joy_selection == card.ability.extra.tributes then\n                    card.ability.extra.activated = true\n                    JoyousSpring.tribute(card, context.joy_selection)\n\n                    for i = 1, card.ability.extra.creates do\n                        JoyousSpring.create_pseudorandom(\n                            { { monster_archetypes = { \"GoldenLand\" }, is_main_deck = true } },\n                            'j_joy_eld_eldlich', true)\n                    end\n                end\n            end\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval then\n            card.ability.extra.activated = false\n        end\n    end,\n    joy_can_activate = function(card)\n        if card.ability.extra.activated or not (#G.jokers.cards + G.GAME.joker_buffer - card.ability.extra.tributes < G.jokers.config.card_limit) then\n            return false\n        end\n        local materials = JoyousSpring.get_materials_owned({ { monster_type = \"Zombie\" }, { is_trap = true } }, false,\n            true)\n        return next(materials) and true or false\n    end,"
    },
    {
      "type": "Joker",
      "key": "eld_conq",
      "atlas": "eld",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"eld_conq\",\n    atlas = 'eld',\n    pos = { x = 1, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 8,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.chips, card.ability.extra.discards } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Eldlich\" } }, { monster_archetypes = { \"GoldenLand\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_flip = true,\n                is_trap = true,\n                attribute = \"LIGHT\",\n                monster_type = \"Zombie\",\n                monster_archetypes = { [\"GoldenLand\"] = true }\n            },\n            chips = 2,\n            discards = 1,\n            activated = false\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.individual and context.cardarea == G.play and SMODS.has_enhancement(context.other_card, 'm_gold') then\n                return {\n                    chips = card.ability.extra.chips *\n                        JoyousSpring.count_all_materials({ { monster_type = \"Zombie\" } })\n                }\n            end\n            if context.repetition and (context.cardarea == G.play or (context.cardarea == G.hand and JoyousSpring.count_materials_owned({ { monster_archetypes = { \"Eldlich\" } } }) > 0)) and next(SMODS.get_enhancements(context.other_card) or {}) then\n                return {\n                    repetitions = 1\n                }\n            end\n        end\n        if card.ability.extra.activated and context.end_of_round and context.game_over == false and context.main_eval then\n            card.ability.extra.activated = false\n            G.GAME.round_resets.discards = G.GAME.round_resets.discards - card.ability.extra.discards\n            ease_discard(-card.ability.extra.discards)\n        end\n        if JoyousSpring.calculate_flip_effect(card, context) and not card.ability.extra.activated then\n            card.ability.extra.activated = true\n            G.GAME.round_resets.discards = G.GAME.round_resets.discards + card.ability.extra.discards\n            ease_discard(card.ability.extra.discards)\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff and JoyousSpring.should_trap_flip(card) then\n            card:flip(card)\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        if card.ability.extra.activated then\n            card.ability.extra.activated = false\n            G.GAME.round_resets.discards = G.GAME.round_resets.discards - card.ability.extra.discards\n            ease_discard(-card.ability.extra.discards)\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "eld_guard",
      "atlas": "eld",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"eld_guard\",\n    atlas = 'eld',\n    pos = { x = 0, y = 1 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 8,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.mult, card.ability.extra.hands } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Eldlich\" } }, { monster_archetypes = { \"GoldenLand\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_flip = true,\n                is_trap = true,\n                attribute = \"LIGHT\",\n                monster_type = \"Zombie\",\n                monster_archetypes = { [\"GoldenLand\"] = true }\n            },\n            mult = 1,\n            hands = 1,\n            activated = false\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.individual and context.cardarea == G.play and SMODS.has_enhancement(context.other_card, 'm_gold') then\n                return {\n                    mult = card.ability.extra.mult *\n                        JoyousSpring.count_all_materials({ { monster_type = \"Zombie\" } })\n                }\n            end\n            if context.repetition and (context.cardarea == G.play or (context.cardarea == G.hand and JoyousSpring.count_materials_owned({ { monster_archetypes = { \"Eldlich\" } } }) > 0)) and next(SMODS.get_enhancements(context.other_card) or {}) then\n                return {\n                    repetitions = 1\n                }\n            end\n        end\n        if card.ability.extra.activated and context.end_of_round and context.game_over == false and context.main_eval then\n            card.ability.extra.activated = false\n            G.GAME.round_resets.hands = G.GAME.round_resets.hands - card.ability.extra.hands\n            ease_hands_played(-card.ability.extra.hands)\n        end\n        if JoyousSpring.calculate_flip_effect(card, context) and not card.ability.extra.activated then\n            card.ability.extra.activated = true\n            G.GAME.round_resets.hands = G.GAME.round_resets.hands + card.ability.extra.hands\n            ease_hands_played(card.ability.extra.hands)\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff and JoyousSpring.should_trap_flip(card) then\n            card:flip(card)\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        if card.ability.extra.activated then\n            card.ability.extra.activated = false\n            G.GAME.round_resets.hands = G.GAME.round_resets.hands - card.ability.extra.hands\n            ease_hands_played(-card.ability.extra.hands)\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "eld_huaq",
      "atlas": "eld",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"eld_huaq\",\n    atlas = 'eld',\n    pos = { x = 2, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 8,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_banish\" }\n        end\n        return { vars = { card.ability.extra.chips, card.ability.extra.banishes } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Eldlich\" } }, { monster_archetypes = { \"GoldenLand\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_flip = true,\n                is_trap = true,\n                attribute = \"LIGHT\",\n                monster_type = \"Zombie\",\n                monster_archetypes = { [\"GoldenLand\"] = true }\n            },\n            chips = 2,\n            banishes = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.individual and context.cardarea == G.play and SMODS.has_enhancement(context.other_card, 'm_gold') then\n                return {\n                    chips = card.ability.extra.chips *\n                        JoyousSpring.count_all_materials({ { monster_type = \"Zombie\" } })\n                }\n            end\n            if context.repetition and (context.cardarea == G.play or (context.cardarea == G.hand and JoyousSpring.count_materials_owned({ { monster_archetypes = { \"Eldlich\" } } }) > 0)) and next(SMODS.get_enhancements(context.other_card) or {}) then\n                return {\n                    repetitions = 1\n                }\n            end\n            if JoyousSpring.is_flip_active(card) and not context.blueprint_card and context.end_of_round and context.game_over == false and context.main_eval then\n                local choices = JoyousSpring.get_materials_owned({ { monster_type = \"Zombie\", exclude_keys = { \"j_joy_eld_huaq\" } } })\n                local to_banish = pseudorandom_element(choices, 'j_joy_sub_uma')\n                if to_banish then\n                    JoyousSpring.banish(to_banish, \"blind_selected\")\n                end\n            end\n        end\n        JoyousSpring.calculate_flip_effect(card, context)\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff and JoyousSpring.should_trap_flip(card) then\n            card:flip(card)\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "eld_glorious",
      "atlas": "eld",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"eld_glorious\",\n    atlas = 'eld',\n    pos = { x = 1, y = 1 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 8,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n        end\n        return { vars = { card.ability.extra.mult, card.ability.extra.revives } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Eldlich\" } }, { monster_archetypes = { \"GoldenLand\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_flip = true,\n                is_trap = true,\n                attribute = \"LIGHT\",\n                monster_type = \"Zombie\",\n                monster_archetypes = { [\"GoldenLand\"] = true, [\"Eldlixir\"] = true }\n            },\n            mult = 1,\n            revives = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.individual and context.cardarea == G.play and SMODS.has_enhancement(context.other_card, 'm_gold') then\n                return {\n                    mult = card.ability.extra.mult *\n                        JoyousSpring.count_all_materials({ { monster_type = \"Zombie\" } })\n                }\n            end\n            if context.repetition and (context.cardarea == G.play or (context.cardarea == G.hand and JoyousSpring.count_materials_owned({ { monster_archetypes = { \"Eldlich\" } } }) > 0)) and next(SMODS.get_enhancements(context.other_card) or {}) then\n                return {\n                    repetitions = 1\n                }\n            end\n        end\n        if JoyousSpring.calculate_flip_effect(card, context) then\n            local revived_card = JoyousSpring.revive_pseudorandom({ { monster_archetypes = { \"GoldenLand\" } } },\n                'j_joy_eld_glorious', true)\n            if not revived_card then\n                JoyousSpring.revive_pseudorandom({ { is_trap = true } },\n                    'j_joy_eld_glorious', true)\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff and JoyousSpring.should_trap_flip(card) then\n            card:flip(card)\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "eld_mad",
      "atlas": "eld",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"eld_mad\",\n    atlas = 'eld',\n    pos = { x = 2, y = 1 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 12,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.xmult } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Eldlich\" } }, { monster_archetypes = { \"GoldenLand\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"FUSION\",\n                attribute = \"LIGHT\",\n                monster_type = \"Zombie\",\n                monster_archetypes = { [\"Eldlich\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"FUSION\",\n                        materials = {\n                            { monster_archetypes = { \"Eldlich\" } },\n                            { monster_type = \"Zombie\" }\n                        }\n                    }\n                },\n            },\n            xmult = 0.1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.individual and context.cardarea == G.play and SMODS.has_enhancement(context.other_card, 'm_gold') then\n                return {\n                    xmult = 1 +\n                        card.ability.extra.xmult * JoyousSpring.count_all_materials({ { monster_type = \"Zombie\" } })\n                }\n            end\n            if context.after and context.main_eval then\n                return {\n                    func = function()\n                        for _, playing_card in ipairs(context.full_hand) do\n                            playing_card:set_ability(G.P_CENTERS.m_gold, nil, true)\n                            playing_card:juice_up()\n                        end\n                    end\n                }\n            end\n        end\n    end,\n    joy_prevent_trap_flip = function(card, other_card)\n        return other_card.facing == 'front'\n    end,\n    joy_flip_effect_active = function(card, other_card)\n        return JoyousSpring.is_trap_monster(other_card)\n    end"
    },
    {
      "type": "Joker",
      "key": "eld_angel",
      "atlas": "eld",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = \"eld_angel\",\n    atlas = 'eld',\n    pos = { x = 0, y = 2 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n        end\n        info_queue[#info_queue + 1] = JoyousSpring.PokerHandDummies[\"phd_joy_eldlixir\"]\n        return { vars = { card.ability.extra.mills, card.ability.extra.revives } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_eld_eldlich\",                                                                                name = \"k_joy_mills\" },\n        { properties = { { monster_archetypes = { \"Eldlich\" } }, { monster_archetypes = { \"GoldenLand\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"FUSION\",\n                attribute = \"LIGHT\",\n                monster_type = \"Zombie\",\n                monster_archetypes = { [\"GoldenLand\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"FUSION\",\n                        materials = {\n                            { is_trap = true },\n                            {}\n                        }\n                    }\n                },\n            },\n            mills = 1,\n            revives = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joy_sent_to_gy and context.joy_from_field and context.joy_card == card then\n                JoyousSpring.revive_pseudorandom(\n                    { { monster_archetypes = { \"Eldlich\" } } },\n                    'j_joy_eld_angel',\n                    false,\n                    { negative = true }\n                )\n            end\n            if context.joy_flip_activated and JoyousSpring.is_trap_monster(context.joy_flip_activated) then\n                return {\n                    level_up = 1,\n                    level_up_hand = \"joy_eldlixir\"\n                }\n            end\n            if context.before and context.main_eval and next(context.poker_hands[\"joy_eldlixir\"]) then\n                for i = 1, card.ability.extra.mills do\n                    JoyousSpring.send_to_graveyard(\"j_joy_eld_eldlich\")\n                end\n                SMODS.calculate_effect({ message = localize(\"k_joy_mill\") }, card)\n            end\n        end\n    end,"
    },
    {
      "type": "Atlas",
      "key": "ignis",
      "atlas": null,
      "pos": null,
      "raw": "key = \"ignis\",\n    path = \"15Ignister.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Joker",
      "key": "ignis_achichi",
      "atlas": "ignis",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"ignis_achichi\",\n    atlas = 'ignis',\n    pos = { x = 0, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_main_deck_joker\" }\n        end\n        return { vars = { card.ability.extra.mult, card.ability.extra.creates } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_ignis_ailand\", properties = { { monster_archetypes = { \"Ignister\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"FIRE\",\n                monster_type = \"Cyberse\",\n                monster_archetypes = { [\"Ignister\"] = true }\n            },\n            mult = 15,\n            creates = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    mult = card.ability.extra.mult\n                }\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff then\n            for i = 1, card.ability.extra.creates do\n                JoyousSpring.create_pseudorandom(\n                    { { rarity = 1, monster_archetypes = { \"Ignister\" }, is_main_deck = true } },\n                    'j_joy_ignis_achichi', true)\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "ignis_pikari",
      "atlas": "ignis",
      "pos": {
        "x": 4,
        "y": 1
      },
      "raw": "key = \"ignis_pikari\",\n    atlas = 'ignis',\n    pos = { x = 4, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.dollars, card.ability.extra.creates } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_ignis_ailand\", properties = { { monster_archetypes = { \"Ignister\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"LIGHT\",\n                monster_type = \"Cyberse\",\n                monster_archetypes = { [\"Ignister\"] = true }\n            },\n            dollars = 3,\n            creates = 1\n        },\n    },\n    calc_dollar_bonus = function(self, card)\n        return JoyousSpring.can_use_abilities(card) and card.ability.extra.dollars or nil\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff then\n            for i = 1, card.ability.extra.creates do\n                if #G.consumeables.cards < G.consumeables.config.card_limit then\n                    SMODS.add_card({\n                        set = 'Tarot'\n                    })\n                end\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "ignis_hiyari",
      "atlas": "ignis",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"ignis_hiyari\",\n    atlas = 'ignis',\n    pos = { x = 3, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_tribute\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_main_deck_joker\" }\n        end\n        return { vars = { card.ability.extra.h_size, card.ability.extra.tributes, card.ability.extra.creates } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_ignis_ailand\", properties = { { monster_archetypes = { \"Ignister\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"WATER\",\n                monster_type = \"Cyberse\",\n                monster_archetypes = { [\"Ignister\"] = true }\n            },\n            h_size = 1,\n            tributes = 1,\n            creates = 1,\n            activated = false\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not card.ability.extra.activated then\n                if context.joy_activate_effect and context.joy_activated_card == card then\n                    local targets = JoyousSpring.get_materials_owned({ { monster_type = \"Cyberse\" } }, false, true)\n                    local materials = {}\n                    for i, joker in ipairs(targets) do\n                        if not joker.ability.eternal then\n                            materials[#materials + 1] = joker\n                        end\n                    end\n                    if next(materials) then\n                        JoyousSpring.create_overlay_effect_selection(card, materials, card.ability.extra.tributes,\n                            card.ability.extra.tributes)\n                    end\n                end\n                if context.joy_exit_effect_selection and context.joy_card == card and\n                    #context.joy_selection == card.ability.extra.tributes then\n                    card.ability.extra.activated = true\n                    JoyousSpring.tribute(card, context.joy_selection)\n\n                    for i = 1, card.ability.extra.creates do\n                        JoyousSpring.create_pseudorandom(\n                            { { rarity = 2, monster_archetypes = { \"Ignister\" }, is_main_deck = true } },\n                            'j_joy_ignis_hiyari', true)\n                    end\n                end\n            end\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval then\n            card.ability.extra.activated = false\n        end\n    end,\n    joy_can_activate = function(card)\n        if card.ability.extra.activated then\n            return false\n        end\n        local targets = JoyousSpring.get_materials_owned({ { monster_type = \"Cyberse\" } }, false, true)\n        for i, joker in ipairs(targets) do\n            if not joker.ability.eternal then\n                return true\n            end\n        end\n        return false\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not JoyousSpring.is_perma_debuffed(card) then\n            G.hand:change_size(card.ability.extra.h_size)\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        if not JoyousSpring.is_perma_debuffed(card) then\n            G.hand:change_size(-card.ability.extra.h_size)\n        end\n    end,\n    joy_set_cost = function(card)\n        if JoyousSpring.count_materials_owned({ { monster_archetypes = { \"Ignister\" } } }) > 0 then\n            card.cost = 0\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "ignis_bururu",
      "atlas": "ignis",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"ignis_bururu\",\n    atlas = 'ignis',\n    pos = { x = 1, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 3,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_main_deck_joker\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return { vars = { card.ability.extra.mills, card.ability.extra.revives } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_ignis_ailand\", properties = { { monster_archetypes = { \"Ignister\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_tuner = true,\n                attribute = \"WIND\",\n                monster_type = \"Cyberse\",\n                monster_archetypes = { [\"Ignister\"] = true }\n            },\n            mills = 3,\n            revives = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.used_as_material(card, context) and JoyousSpring.is_monster_type(context.joy_card, \"Cyberse\") then\n            for i = 1, card.ability.extra.revives do\n                JoyousSpring.revive_pseudorandom(\n                    { { monster_archetypes = { \"Ignister\" }, is_main_deck = true } },\n                    \"j_joy_ignis_bururu\", false, \"e_negative\")\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff then\n            local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Ignister\" } } })\n\n            for i = 1, card.ability.extra.mills do\n                JoyousSpring.send_to_graveyard(pseudorandom_element(choices, 'j_joy_ignis_bururu'))\n            end\n            SMODS.calculate_effect({ message = localize(\"k_joy_mill\") }, card)\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "ignis_doshin",
      "atlas": "ignis",
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "key = \"ignis_doshin\",\n    atlas = 'ignis',\n    pos = { x = 4, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 2,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_extra_deck_joker\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return { vars = { card.ability.extra.chips, card.ability.extra.revives } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_ignis_ailand\", properties = { { monster_archetypes = { \"Ignister\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"EARTH\",\n                monster_type = \"Cyberse\",\n                monster_archetypes = { [\"Ignister\"] = true }\n            },\n            chips = 50,\n            revives = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.used_as_material(card, context) and JoyousSpring.is_monster_type(context.joy_card, \"Cyberse\") then\n            for i = 1, card.ability.extra.revives do\n                JoyousSpring.revive_pseudorandom(\n                    { { monster_archetypes = { \"Ignister\" }, is_extra_deck = true } },\n                    'j_joy_ignis_doshin', true)\n            end\n        end\n        if JoyousSpring.can_use_abilities(card) and context.joker_main then\n            return {\n                chips = card.ability.extra.chips\n            }\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "ignis_gatchiri",
      "atlas": "ignis",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"ignis_gatchiri\",\n    atlas = 'ignis',\n    pos = { x = 1, y = 1 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 7,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return { vars = { card.ability.extra.xmult } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_ignis_ailand\", properties = { { monster_archetypes = { \"Ignister\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_all_materials = { LINK = true },\n                attribute = \"EARTH\",\n                monster_type = \"Cyberse\",\n                monster_archetypes = { [\"Ignister\"] = true }\n            },\n            xmult = 1.1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    xmult = card.ability.extra.xmult\n                }\n            end\n        end\n    end,\n    joy_can_transfer_ability = function(self, other_card, card)\n        return JoyousSpring.is_monster_type(other_card, \"Cyberse\")\n    end,\n    joy_transfer_add_to_deck = function(self, other_card, config, card, from_debuff, materials, was_material)\n        other_card.ability.extra.joyous_spring.cannot_flip = true\n        SMODS.debuff_card(other_card, 'prevent_debuff', 'j_joy_ignis_gatchiri')\n    end,\n    joy_transfer_loc_vars = function(self, info_queue, card, config)\n        return { vars = {} }\n    end"
    },
    {
      "type": "Joker",
      "key": "ignis_gussari",
      "atlas": "ignis",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"ignis_gussari\",\n    atlas = 'ignis',\n    pos = { x = 2, y = 1 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return { vars = { card.ability.extra.mult } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_ignis_ailand\", properties = { { monster_archetypes = { \"Ignister\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_all_materials = { LINK = true },\n                attribute = \"EARTH\",\n                monster_type = \"Cyberse\",\n                monster_archetypes = { [\"Ignister\"] = true }\n            },\n            mult = 30\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    mult = card.ability.extra.mult\n                }\n            end\n        end\n    end,\n    joy_can_transfer_ability = function(self, other_card, card)\n        return JoyousSpring.is_summon_type(other_card, \"LINK\")\n    end,\n    joy_transfer_add_to_deck = function(self, other_card, config, card, from_debuff, materials, was_material)\n        if materials then\n            config.current_mult = #materials * config.mult\n        end\n    end,\n    joy_transfer_ability_calculate = function(self, other_card, context, config)\n        if JoyousSpring.can_use_abilities(other_card) and context.joker_main then\n            return {\n                mult = config.current_mult\n            }\n        end\n    end,\n    joy_transfer_config = function(self, other_card)\n        return { mult = 30, current_mult = 0 }\n    end,\n    joy_transfer_loc_vars = function(self, info_queue, card, config)\n        return { vars = { config.mult, config.current_mult } }\n    end"
    },
    {
      "type": "Joker",
      "key": "ignis_danmari",
      "atlas": "ignis",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"ignis_danmari\",\n    atlas = 'ignis',\n    pos = { x = 2, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 4,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return { vars = { card.ability.extra.percent * 100 } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_ignis_ailand\", properties = { { monster_archetypes = { \"Ignister\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Cyberse\",\n                monster_archetypes = { [\"Ignister\"] = true }\n            },\n            percent = 0.05\n        },\n    },\n    joy_can_transfer_ability = function(self, other_card, card)\n        return JoyousSpring.is_summon_type(other_card, \"LINK\")\n    end,\n    joy_transfer_ability_calculate = function(self, other_card, context, config)\n        if JoyousSpring.can_use_abilities(other_card) then\n            if context.setting_blind and context.main_eval then\n                G.GAME.blind.chips = math.floor(G.GAME.blind.chips - G.GAME.blind.chips * config.percent)\n                G.GAME.blind.chip_text = number_format(G.GAME.blind.chips)\n                return {\n                    message = localize(\"k_active_ex\")\n                }\n            end\n        end\n    end,\n    joy_transfer_config = function(self, other_card)\n        return { percent = 0.05 }\n    end,\n    joy_transfer_loc_vars = function(self, info_queue, card, config)\n        return { vars = { config.percent * 100 } }\n    end"
    },
    {
      "type": "Joker",
      "key": "ignis_doyon",
      "atlas": "ignis",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"ignis_doyon\",\n    atlas = 'ignis',\n    pos = { x = 0, y = 1 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 4,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_main_deck_joker\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return { vars = { card.ability.extra.revives, card.ability.extra.adds } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_ignis_ailand\", properties = { { monster_archetypes = { \"Ignister\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Cyberse\",\n                monster_archetypes = { [\"Ignister\"] = true }\n            },\n            revives = 1,\n            adds = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.used_as_material(card, context) and JoyousSpring.is_monster_type(context.joy_card, \"Cyberse\") then\n            local choices = JoyousSpring.get_materials_in_collection(\n                { { monster_archetypes = { \"Ignister\" }, is_extra_deck = true } }, true, true)\n            if #choices > 0 then\n                for i = 1, card.ability.extra.adds do\n                    local key_to_add, _ = pseudorandom_element(choices, 'j_joy_ignis_doyon')\n                    if key_to_add and #JoyousSpring.extra_deck_area.cards < JoyousSpring.extra_deck_area.config.card_limit then\n                        JoyousSpring.add_to_extra_deck(key_to_add)\n                    end\n                end\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff then\n            for i = 1, card.ability.extra.revives do\n                JoyousSpring.revive_pseudorandom(\n                    { { monster_archetypes = { \"Ignister\" }, is_main_deck = true } },\n                    'j_joy_ignis_bururu', true, nil, (card.edition and card.edition.negative) and 0 or -1)\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "ignis_donyoribo",
      "atlas": "ignis",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"ignis_donyoribo\",\n    atlas = 'ignis',\n    pos = { x = 3, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 8,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_banish\" }\n        end\n        return { vars = { card.ability.extra.money, card.ability.extra.banishes } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_ignis_ailand\", properties = { { monster_archetypes = { \"Ignister\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Cyberse\",\n                monster_archetypes = { [\"Ignister\"] = true }\n            },\n            money = 2,\n            banishes = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.buying_card and JoyousSpring.is_monster_archetype(context.card, \"Ignister\") then\n                return {\n                    dollars = card.ability.extra.money\n                }\n            end\n            if context.selling_self then\n                local materials = JoyousSpring.get_materials_owned({ { monster_archetypes = { \"Ignister\" } } })\n                local choices = {}\n                for i, joker in ipairs(materials) do\n                    if joker ~= card then\n                        table.insert(choices, joker)\n                    end\n                end\n                for i = 1, card.ability.extra.banishes do\n                    local to_banish = pseudorandom_element(choices, 'j_joy_ignis_donyoribo')\n                    if to_banish then\n                        JoyousSpring.banish(to_banish, \"blind_selected\")\n                    end\n                end\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "ignis_backup",
      "atlas": "ignis",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = \"ignis_backup\",\n    atlas = 'ignis',\n    pos = { x = 0, y = 2 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return { vars = { card.ability.extra.to_negative } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_ignis_ailand\", properties = { { monster_archetypes = { \"Ignister\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_tuner = true,\n                attribute = \"DARK\",\n                monster_type = \"Cyberse\",\n                monster_archetypes = { [\"Ignister\"] = true }\n            },\n            to_negative = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.used_as_material(card, context) and JoyousSpring.is_monster_type(context.joy_card, \"Cyberse\") and not context.joy_card.edition then\n            context.joy_card:set_edition(\"e_negative\")\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff then\n            local materials = JoyousSpring.get_materials_owned({ { monster_type = \"Cyberse\" } })\n            local choices = {}\n            for i, joker in ipairs(materials) do\n                if joker ~= card and not joker.edition then\n                    table.insert(choices, joker)\n                end\n            end\n            for i = 1, card.ability.extra.to_negative do\n                local to_negative = pseudorandom_element(choices, 'j_joy_ignis_backup')\n                if to_negative then\n                    to_negative:set_edition(\"e_negative\")\n                end\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "ignis_wizard",
      "atlas": "ignis",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "key = \"ignis_wizard\",\n    atlas = 'ignis',\n    pos = { x = 2, y = 2 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_tribute\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_extra_deck_joker\" }\n        end\n        return { vars = { card.ability.extra.revives } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_ignis_ailand\", properties = { { monster_archetypes = { \"Ignister\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Cyberse\",\n                monster_archetypes = { [\"Ignister\"] = true }\n            },\n            revives = 2,\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card then\n                if context.joy_activate_effect and context.joy_activated_card == card and not card.ability.eternal then\n                    JoyousSpring.tribute(card, { card })\n                    for i = 1, card.ability.extra.revives do\n                        JoyousSpring.revive_pseudorandom({ { monster_type = \"Cyberse\" } },\n                            'j_joy_ignis_wizard', true, nil,\n                            (card.edition and card.edition.negative) and 0 or 1, true)\n                    end\n                    if JoyousSpring.count_materials_owned({ { monster_type = \"Cyberse\", is_summoned = true, is_extra_deck = true } }) > 0 then\n                        JoyousSpring.revive_pseudorandom({ { monster_archetypes = { \"Ignister\" } } },\n                            \"j_joy_ignis_wizard\", false, \"e_negative\")\n                    end\n                end\n            end\n        end\n    end,\n    joy_can_activate = function(card)\n        return not card.ability.eternal and JoyousSpring.count_materials_in_graveyard({ { monster_type = \"Cyberse\" } },\n            true) > 0 or false\n    end,"
    },
    {
      "type": "Joker",
      "key": "ignis_kiruku",
      "atlas": "ignis",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "key = \"ignis_kiruku\",\n    atlas = 'ignis',\n    pos = { x = 1, y = 2 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 12,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_extra_deck_joker\" }\n        end\n        return { vars = {} }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_ignis_ailand\", properties = { { monster_archetypes = { \"Ignister\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Cyberse\",\n                monster_archetypes = { [\"Ignister\"] = true }\n            },\n        },\n    },\n    calculate = function(self, card, context)\n        if not context.blueprint_card and context.selling_self then\n            if G.GAME.blind and ((not G.GAME.blind.disabled) and (G.GAME.blind:get_type() == 'Boss')) then\n                G.GAME.blind:disable()\n\n                if JoyousSpring.count_materials_owned({ { monster_type = \"Cyberse\", is_summoned = true, is_extra_deck = true } }) > 0 then\n                    JoyousSpring.add_monster_tag(\"j_joy_ignis_kiruku\")\n                end\n                return { message = localize('ph_boss_disabled') }\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "ignis_leviathan",
      "atlas": "ignis",
      "pos": {
        "x": 4,
        "y": 2
      },
      "raw": "key = \"ignis_leviathan\",\n    atlas = 'ignis',\n    pos = { x = 4, y = 2 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        local current_chips = card.ability.extra.chips *\n            JoyousSpring.get_attribute_count(JoyousSpring.get_materials(card))\n        return { vars = { card.ability.extra.adds, card.ability.extra.chips, current_chips } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_ignis_ailand\", properties = { { monster_archetypes = { \"Ignister\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"WATER\",\n                monster_type = \"Cyberse\",\n                monster_archetypes = { [\"Ignister\"] = true },\n                summon_type = \"RITUAL\",\n                summon_conditions = {\n                    {\n                        type = \"RITUAL\",\n                        materials = {\n                            { min = 2, monster_type = \"Cyberse\" },\n                        },\n                    }\n                }\n            },\n            adds = 1,\n            chips = 100,\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.individual and context.cardarea == G.play then\n                local current_chips = card.ability.extra.chips *\n                    JoyousSpring.get_attribute_count(JoyousSpring.get_materials(card))\n                context.other_card.ability.perma_bonus = (context.other_card.ability.perma_bonus or 1) +\n                    current_chips\n                return {\n                    message = localize('k_upgrade_ex'), colour = G.C.CHIPS\n                }\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff then\n            local choices = JoyousSpring.get_materials_in_collection(\n                { { monster_archetypes = { \"Ignister\" }, is_extra_deck = true } }, true, true)\n            if #choices > 0 then\n                for i = 1, card.ability.extra.adds do\n                    local key_to_add, _ = pseudorandom_element(choices, 'j_joy_ignis_leviathan')\n                    if key_to_add and #JoyousSpring.extra_deck_area.cards < JoyousSpring.extra_deck_area.config.card_limit then\n                        JoyousSpring.add_to_extra_deck(key_to_add)\n                    end\n                end\n            end\n        end\n    end,\n    joy_can_transfer_ability = function(self, other_card, card)\n        return JoyousSpring.is_summon_type(other_card, \"LINK\")\n    end,\n    joy_transfer_ability_calculate = function(self, other_card, context, config)\n        if JoyousSpring.can_use_abilities(other_card) then\n            if context.individual and context.cardarea == G.play then\n                local current_chips = config.chips *\n                    JoyousSpring.get_attribute_count(JoyousSpring.get_materials(other_card))\n                context.other_card.ability.perma_bonus = (context.other_card.ability.perma_bonus or 1) +\n                    current_chips\n                return {\n                    message = localize('k_upgrade_ex'), colour = G.C.CHIPS\n                }\n            end\n        end\n    end,\n    joy_transfer_config = function(self, other_card)\n        return { chips = 100 }\n    end,\n    joy_transfer_loc_vars = function(self, info_queue, card, config)\n        local current_chips = config.chips *\n            JoyousSpring.get_attribute_count(JoyousSpring.get_materials(card))\n        return { vars = { config.chips, current_chips } }\n    end"
    },
    {
      "type": "Joker",
      "key": "ignis_golem",
      "atlas": "ignis",
      "pos": {
        "x": 0,
        "y": 3
      },
      "raw": "key = \"ignis_golem\",\n    atlas = 'ignis',\n    pos = { x = 0, y = 3 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return { vars = { card.ability.extra.adds, card.ability.extra.slots, card.ability.extra.slots * JoyousSpring.get_attribute_count(JoyousSpring.get_materials(card)) } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_ignis_ailand\", properties = { { monster_archetypes = { \"Ignister\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"EARTH\",\n                monster_type = \"Cyberse\",\n                monster_archetypes = { [\"Ignister\"] = true },\n                summon_type = \"FUSION\",\n                summon_conditions = {\n                    {\n                        type = \"FUSION\",\n                        materials = {\n                            { min = 2, monster_type = \"Cyberse\" },\n                        },\n                    }\n                }\n            },\n            adds = 1,\n            slots = 1\n        },\n    },\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff then\n            local choices = JoyousSpring.get_materials_in_collection(\n                { { monster_archetypes = { \"Ignister\" }, is_extra_deck = true } }, true, true)\n            if #choices > 0 then\n                for i = 1, card.ability.extra.adds do\n                    local key_to_add, _ = pseudorandom_element(choices, 'j_joy_ignis_golem')\n                    if key_to_add and #JoyousSpring.extra_deck_area.cards < JoyousSpring.extra_deck_area.config.card_limit then\n                        JoyousSpring.add_to_extra_deck(key_to_add)\n                    end\n                end\n            end\n        end\n        G.jokers.config.card_limit = G.jokers.config.card_limit +\n            (card.ability.extra.slots * JoyousSpring.get_attribute_count(JoyousSpring.get_materials(card)))\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        G.jokers.config.card_limit = G.jokers.config.card_limit -\n            (card.ability.extra.slots * JoyousSpring.get_attribute_count(JoyousSpring.get_materials(card)))\n    end,\n    joy_can_transfer_ability = function(self, other_card, card)\n        return JoyousSpring.is_summon_type(other_card, \"LINK\")\n    end,\n    joy_transfer_add_to_deck = function(self, other_card, config, card, from_debuff, materials, was_material)\n        G.jokers.config.card_limit = G.jokers.config.card_limit +\n            (config.slots * JoyousSpring.get_attribute_count(JoyousSpring.get_materials(other_card)))\n    end,\n    joy_transfer_remove_from_deck = function(self, other_card, config, from_debuff)\n        G.jokers.config.card_limit = G.jokers.config.card_limit -\n            (config.slots * JoyousSpring.get_attribute_count(JoyousSpring.get_materials(other_card)))\n    end,\n    joy_transfer_config = function(self, other_card)\n        return { slots = 1 }\n    end,\n    joy_transfer_loc_vars = function(self, info_queue, card, config)\n        return { vars = { config.slots, config.slots * JoyousSpring.get_attribute_count(JoyousSpring.get_materials(card)) } }\n    end"
    },
    {
      "type": "Joker",
      "key": "ignis_pegasus",
      "atlas": "ignis",
      "pos": {
        "x": 1,
        "y": 3
      },
      "raw": "key = \"ignis_pegasus\",\n    atlas = 'ignis',\n    pos = { x = 1, y = 3 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return { vars = { card.ability.extra.adds, G.GAME.probabilities.normal or 1, math.max(1, card.ability.extra.odds - JoyousSpring.get_attribute_count(JoyousSpring.get_materials(card))) } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_ignis_ailand\", properties = { { monster_archetypes = { \"Ignister\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"WIND\",\n                monster_type = \"Cyberse\",\n                monster_archetypes = { [\"Ignister\"] = true },\n                summon_type = \"SYNCHRO\",\n                summon_conditions = {\n                    {\n                        type = \"SYNCHRO\",\n                        materials = {\n                            { is_tuner = true,       exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                            { exclude_tuners = true, min = 1,                                 monster_type = \"Cyberse\", exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                        },\n                    }\n                }\n            },\n            adds = 1,\n            odds = 6\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.repetition and context.cardarea == G.play then\n                if pseudorandom(\"j_joy_ignis_pegasus\") < G.GAME.probabilities.normal / math.max(1, card.ability.extra.odds - JoyousSpring.get_attribute_count(JoyousSpring.get_materials(card))) then\n                    return {\n                        repetitions = 1\n                    }\n                end\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff then\n            local choices = JoyousSpring.get_materials_in_collection(\n                { { monster_archetypes = { \"Ignister\" }, is_extra_deck = true } }, true, true)\n            if #choices > 0 then\n                for i = 1, card.ability.extra.adds do\n                    local key_to_add, _ = pseudorandom_element(choices, 'j_joy_ignis_pegasus')\n                    if key_to_add and #JoyousSpring.extra_deck_area.cards < JoyousSpring.extra_deck_area.config.card_limit then\n                        JoyousSpring.add_to_extra_deck(key_to_add)\n                    end\n                end\n            end\n        end\n    end,\n    joy_can_transfer_ability = function(self, other_card, card)\n        return JoyousSpring.is_summon_type(other_card, \"LINK\")\n    end,\n    joy_transfer_ability_calculate = function(self, other_card, context, config)\n        if JoyousSpring.can_use_abilities(other_card) then\n            if context.repetition and context.cardarea == G.play then\n                if pseudorandom(\"j_joy_ignis_pegasus\") < G.GAME.probabilities.normal / math.max(1, config.odds - JoyousSpring.get_attribute_count(JoyousSpring.get_materials(other_card))) then\n                    return {\n                        repetitions = 1\n                    }\n                end\n            end\n        end\n    end,\n    joy_transfer_config = function(self, other_card)\n        return { odds = 6 }\n    end,\n    joy_transfer_loc_vars = function(self, info_queue, card, config)\n        return { vars = { G.GAME.probabilities.normal or 1, math.max(1, config.odds - JoyousSpring.get_attribute_count(JoyousSpring.get_materials(card))) } }\n    end"
    },
    {
      "type": "Joker",
      "key": "ignis_dragon",
      "atlas": "ignis",
      "pos": {
        "x": 2,
        "y": 3
      },
      "raw": "key = \"ignis_dragon\",\n    atlas = 'ignis',\n    pos = { x = 2, y = 3 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return { vars = { card.ability.extra.adds, card.ability.extra.money, card.ability.extra.money * JoyousSpring.get_attribute_count(JoyousSpring.get_materials(card)) } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_ignis_ailand\", properties = { { monster_archetypes = { \"Ignister\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    update = JoyousSpring.update_counter,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"LIGHT\",\n                monster_type = \"Cyberse\",\n                monster_archetypes = { [\"Ignister\"] = true },\n                summon_type = \"XYZ\",\n                summon_conditions = {\n                    {\n                        type = \"XYZ\",\n                        materials = {\n                            { min = 2, monster_type = \"Cyberse\", exclude_tokens = true, exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                        },\n                    }\n                }\n            },\n            adds = 1,\n            money = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.individual and context.cardarea == G.play then\n                context.other_card.ability.perma_h_dollars = (context.other_card.ability.perma_h_dollars or 0) +\n                    (card.ability.extra.money * JoyousSpring.get_attribute_count(JoyousSpring.get_materials(card)))\n                return {\n                    extra = { message = localize('k_upgrade_ex'), colour = G.C.MONEY },\n                    card = card\n                }\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff then\n            local choices = JoyousSpring.get_materials_in_collection(\n                { { monster_archetypes = { \"Ignister\" }, is_extra_deck = true } }, true, true)\n            if #choices > 0 then\n                for i = 1, card.ability.extra.adds do\n                    local key_to_add, _ = pseudorandom_element(choices, 'j_joy_ignis_dragon')\n                    if key_to_add and #JoyousSpring.extra_deck_area.cards < JoyousSpring.extra_deck_area.config.card_limit then\n                        JoyousSpring.add_to_extra_deck(key_to_add)\n                    end\n                end\n            end\n        end\n    end,\n    joy_can_transfer_ability = function(self, other_card, card)\n        return JoyousSpring.is_summon_type(other_card, \"LINK\")\n    end,\n    joy_transfer_ability_calculate = function(self, other_card, context, config)\n        if JoyousSpring.can_use_abilities(other_card) then\n            if context.individual and context.cardarea == G.play then\n                context.other_card.ability.perma_h_dollars = (context.other_card.ability.perma_h_dollars or 0) +\n                    (config.money * JoyousSpring.get_attribute_count(JoyousSpring.get_materials(other_card)))\n                return {\n                    extra = { message = localize('k_upgrade_ex'), colour = G.C.MONEY },\n                    card = other_card\n                }\n            end\n        end\n    end,\n    joy_transfer_config = function(self, other_card)\n        return { money = 1 }\n    end,\n    joy_transfer_loc_vars = function(self, info_queue, card, config)\n        return { vars = { config.money, config.money * JoyousSpring.get_attribute_count(JoyousSpring.get_materials(card)) } }\n    end"
    },
    {
      "type": "Joker",
      "key": "ignis_phoenix",
      "atlas": "ignis",
      "pos": {
        "x": 3,
        "y": 3
      },
      "raw": "key = \"ignis_phoenix\",\n    atlas = 'ignis',\n    pos = { x = 3, y = 3 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        local current_mult = card.ability.extra.mult *\n            JoyousSpring.get_attribute_count(JoyousSpring.get_materials(card))\n        return { vars = { card.ability.extra.adds, card.ability.extra.creates, card.ability.extra.mult, current_mult } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_ignis_ailand\", properties = { { monster_archetypes = { \"Ignister\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"FIRE\",\n                monster_type = \"Cyberse\",\n                monster_archetypes = { [\"Ignister\"] = true },\n                summon_type = \"LINK\",\n                summon_conditions = {\n                    {\n                        type = \"LINK\",\n                        materials = {\n                            { min = 2, monster_type = \"Cyberse\" },\n                        },\n                    }\n                }\n            },\n            adds = 1,\n            creates = 1,\n            mult = 2,\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.individual and context.cardarea == G.play then\n                local current_mult = card.ability.extra.mult *\n                    JoyousSpring.get_attribute_count(JoyousSpring.get_materials(card))\n                context.other_card.ability.perma_mult = (context.other_card.ability.perma_mult or 1) +\n                    current_mult\n                return { message = localize('k_upgrade_ex'), colour = G.C.MULT }\n            end\n        end\n        if context.joy_summon and not context.blueprint_card then\n            if JoyousSpring.used_as_material(card, context) and JoyousSpring.is_monster_type(context.joy_card, \"Cyberse\") then\n                JoyousSpring.create_perma_debuffed_card(\"j_joy_ignis_phoenix\", \"j_joy_ignis_phoenix\",\n                    \"e_negative\")\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff then\n            local choices = JoyousSpring.get_materials_in_collection(\n                { { monster_archetypes = { \"Ignister\" }, is_extra_deck = true } }, true, true)\n            if #choices > 0 then\n                for i = 1, card.ability.extra.adds do\n                    local key_to_add, _ = pseudorandom_element(choices, 'j_joy_ignis_phoenix')\n                    if key_to_add and #JoyousSpring.extra_deck_area.cards < JoyousSpring.extra_deck_area.config.card_limit then\n                        JoyousSpring.add_to_extra_deck(key_to_add)\n                    end\n                end\n            end\n        end\n    end,\n    joy_can_transfer_ability = function(self, other_card, card)\n        return JoyousSpring.is_summon_type(other_card, \"LINK\")\n    end,\n    joy_transfer_ability_calculate = function(self, other_card, context, config)\n        if JoyousSpring.can_use_abilities(other_card) then\n            if context.individual and context.cardarea == G.play then\n                local current_mult = config.mult *\n                    JoyousSpring.get_attribute_count(JoyousSpring.get_materials(other_card))\n                context.other_card.ability.perma_mult = (context.other_card.ability.perma_mult or 1) + current_mult\n                return { message = localize('k_upgrade_ex'), colour = G.C.MULT }\n            end\n        end\n    end,\n    joy_transfer_config = function(self, other_card)\n        return {\n            mult = 2\n        }\n    end,\n    joy_transfer_loc_vars = function(self, info_queue, card, config)\n        local current_mult = config.mult *\n            JoyousSpring.get_attribute_count(JoyousSpring.get_materials(card))\n        return { vars = { config.mult, current_mult } }\n    end"
    },
    {
      "type": "Joker",
      "key": "ignis_allied",
      "atlas": "ignis",
      "pos": {
        "x": 4,
        "y": 3
      },
      "raw": "key = \"ignis_allied\",\n    atlas = 'ignis',\n    pos = { x = 4, y = 3 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n        end\n        return { vars = { card.ability.extra.xmult, math.max(1, card.ability.extra.xmult * JoyousSpring.count_materials_owned({ { summon_type = \"LINK\" } })), card.ability.extra.revives } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_ignis_ailand\", properties = { { monster_archetypes = { \"Ignister\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Cyberse\",\n                monster_archetypes = { [\"Ignister\"] = true },\n                summon_type = \"LINK\",\n                summon_conditions = {\n                    {\n                        type = \"LINK\",\n                        materials = {\n                            { summon_type = \"LINK\" },\n                            { summon_type = \"LINK\" },\n                            { summon_type = \"LINK\" },\n                        },\n                    }\n                }\n            },\n            xmult = 3,\n            revives = 3\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) and context.joker_main and JoyousSpring.count_materials_owned({ { summon_type = \"LINK\" } }) > 0 then\n            return {\n                xmult = card.ability.extra.xmult * JoyousSpring.count_materials_owned({ { summon_type = \"LINK\" } })\n            }\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff then\n            for i = 1, card.ability.extra.revives do\n                JoyousSpring.revive_pseudorandom(\n                    { { summon_type = \"LINK\" } },\n                    'j_joy_ignis_accode', true, nil, (card.edition and card.edition.negative) and 0 or -1)\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "ignis_infant",
      "atlas": "ignis",
      "pos": {
        "x": 0,
        "y": 4
      },
      "raw": "key = \"ignis_infant\",\n    atlas = 'ignis',\n    pos = { x = 0, y = 4 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return { vars = { card.ability.extra.creates } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_ignis_ailand\", name = \"Creates\" },\n        { \"j_joy_ignis_ailand\", properties = { { monster_archetypes = { \"Ignister\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_all_attributes = true,\n                is_all_materials = { LINK = true },\n                attribute = \"DARK\",\n                monster_type = \"Cyberse\",\n                monster_archetypes = { [\"Ignister\"] = true },\n                summon_type = \"LINK\",\n                summon_conditions = {\n                    {\n                        type = \"LINK\",\n                        materials = {\n                            { monster_type = \"Cyberse\" },\n                        },\n                    }\n                }\n            },\n            creates = 1\n        },\n    },\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff then\n            if #JoyousSpring.field_spell_area.cards < JoyousSpring.field_spell_area.config.card_limit then\n                JoyousSpring.add_to_extra_deck(\"j_joy_ignis_ailand\")\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "ignis_templar",
      "atlas": "ignis",
      "pos": {
        "x": 1,
        "y": 4
      },
      "raw": "key = \"ignis_templar\",\n    atlas = 'ignis',\n    pos = { x = 1, y = 4 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 15,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return { vars = { card.ability.extra.revives } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_ignis_ailand\", properties = { { monster_archetypes = { \"Ignister\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Cyberse\",\n                monster_archetypes = { [\"Ignister\"] = true },\n                summon_type = \"LINK\",\n                summon_conditions = {\n                    {\n                        type = \"LINK\",\n                        materials = {\n                            { monster_archetypes = { \"Ignister\" } },\n                            { monster_archetypes = { \"Ignister\" } },\n                            { monster_archetypes = { \"Ignister\" } },\n                        },\n                    }\n                }\n            },\n            revives = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.used_as_material(card, context) and JoyousSpring.is_monster_type(context.joy_card, \"Cyberse\") then\n            for i = 1, card.ability.extra.revives do\n                JoyousSpring.revive_pseudorandom(\n                    { { monster_type = \"Cyberse\", is_main_deck = true } },\n                    'j_joy_ignis_templar', true)\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff then\n            for i = 1, card.ability.extra.revives do\n                local choices = JoyousSpring.get_materials_in_graveyard({ { monster_archetypes = { \"Ignister\" } } }, true,\n                    true)\n\n                for _, joker_key in ipairs(choices) do\n                    JoyousSpring.revive(joker_key, false, \"e_negative\", nil, \"j_joy_ignis_templar\")\n                end\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "ignis_arrival",
      "atlas": "ignis",
      "pos": {
        "x": 2,
        "y": 4
      },
      "raw": "key = \"ignis_arrival\",\n    atlas = 'ignis',\n    pos = { x = 2, y = 4 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 20,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        local current_xmult = card.ability.extra.xmult *\n            JoyousSpring.get_attribute_count(JoyousSpring.get_materials(card))\n        return {\n            vars = {\n                card.ability.extra.xmult,\n                current_xmult > 0 and current_xmult or 1,\n                card.ability.extra.money,\n                card.ability.extra.creates,\n                card.ability.extra.chips,\n                card.ability.extra.mult,\n                G.GAME.probabilities.normal or 1,\n                card.ability.extra.odds,\n                card.ability.extra.h_size,\n                colours = {\n                    card.ability.extra.attributes[\"LIGHT\"] and G.C.JOY.LIGHT or G.C.UI.TEXT_INACTIVE,\n                    card.ability.extra.attributes[\"LIGHT\"] and G.C.MONEY or G.C.UI.TEXT_INACTIVE,\n                    card.ability.extra.attributes[\"LIGHT\"] and G.C.UI.TEXT_DARK or G.C.UI.TEXT_INACTIVE,\n                    card.ability.extra.attributes[\"DARK\"] and G.C.JOY.DARK or G.C.UI.TEXT_INACTIVE,\n                    card.ability.extra.attributes[\"DARK\"] and G.C.FILTER or G.C.UI.TEXT_INACTIVE,\n                    card.ability.extra.attributes[\"DARK\"] and G.C.SECONDARY_SET.Spectral or G.C.UI.TEXT_INACTIVE,\n                    card.ability.extra.attributes[\"DARK\"] and G.C.UI.TEXT_DARK or G.C.UI.TEXT_INACTIVE,\n                    card.ability.extra.attributes[\"WATER\"] and G.C.JOY.WATER or G.C.UI.TEXT_INACTIVE,\n                    card.ability.extra.attributes[\"WATER\"] and G.C.CHIPS or G.C.UI.TEXT_INACTIVE,\n                    card.ability.extra.attributes[\"WATER\"] and G.C.UI.TEXT_DARK or G.C.UI.TEXT_INACTIVE,\n                    card.ability.extra.attributes[\"FIRE\"] and G.C.JOY.FIRE or G.C.UI.TEXT_INACTIVE,\n                    card.ability.extra.attributes[\"FIRE\"] and G.C.MULT or G.C.UI.TEXT_INACTIVE,\n                    card.ability.extra.attributes[\"FIRE\"] and G.C.UI.TEXT_DARK or G.C.UI.TEXT_INACTIVE,\n                    card.ability.extra.attributes[\"WIND\"] and G.C.JOY.WIND or G.C.UI.TEXT_INACTIVE,\n                    card.ability.extra.attributes[\"WIND\"] and G.C.GREEN or G.C.UI.TEXT_INACTIVE,\n                    card.ability.extra.attributes[\"WIND\"] and G.C.DARK_EDITION or G.C.UI.TEXT_INACTIVE,\n                    card.ability.extra.attributes[\"WIND\"] and G.C.UI.TEXT_DARK or G.C.UI.TEXT_INACTIVE,\n                    card.ability.extra.attributes[\"WIND\"] and G.C.SECONDARY_SET.Spectral or G.C.UI.TEXT_INACTIVE,\n                    card.ability.extra.attributes[\"EARTH\"] and G.C.JOY.EARTH or G.C.UI.TEXT_INACTIVE,\n                    card.ability.extra.attributes[\"EARTH\"] and G.C.FILTER or G.C.UI.TEXT_INACTIVE,\n                    card.ability.extra.attributes[\"EARTH\"] and G.C.UI.TEXT_DARK or G.C.UI.TEXT_INACTIVE,\n                }\n            },\n            main_end = card.ability.extra.attributes[\"DIVINE\"] and {\n                {\n                    n = G.UIT.C,\n                    config = { align = \"bm\", minh = 0.3 },\n                    nodes = {\n                        {\n                            n = G.UIT.T,\n                            config = {\n                                text = localize(\"k_joy_DIVINE\"),\n                                colour = G.C.JOY.DIVINE,\n                                scale = 0.32,\n                            }\n                        },\n                        {\n                            n = G.UIT.T,\n                            config = {\n                                text = localize(\"k_joy_arrival_text1\"),\n                                colour = G.C.UI.TEXT_DARK,\n                                scale = 0.32,\n                            }\n                        },\n                        {\n                            n = G.UIT.T,\n                            config = {\n                                text = localize(\"k_joy_arrival_text2\"),\n                                colour = G.C.FILTER,\n                                scale = 0.32,\n                            }\n                        },\n                        {\n                            n = G.UIT.T,\n                            config = {\n                                text = localize(\"k_joy_arrival_text3\"),\n                                colour = G.C.UI.TEXT_DARK,\n                                scale = 0.32,\n                            }\n                        },\n                        {\n                            n = G.UIT.T,\n                            config = {\n                                text = localize(\"k_joy_arrival_text4\"),\n                                colour = G.C.RED,\n                                scale = 0.32,\n                            }\n                        },\n                    }\n                }\n            } or nil\n        }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_ignis_ailand\", properties = { { monster_archetypes = { \"Ignister\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"LINK\",\n                attribute = \"DARK\",\n                monster_type = \"Cyberse\",\n                monster_archetypes = { [\"Ignister\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"LINK\",\n                        materials = {\n                            { min = 5, monster_type = \"Cyberse\" },\n                        },\n                    }\n                }\n            },\n            attributes = {},\n            xmult = 6,\n            money = 25,\n            creates = 1,\n            chips = 1000,\n            mult = 250,\n            odds = 3,\n            h_size = 5,\n            percent = 0.5\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.setting_blind and context.main_eval and card.ability.extra.attributes[\"DIVINE\"] then\n                G.GAME.blind.chips = math.floor(G.GAME.blind.chips - G.GAME.blind.chips * card.ability.extra.percent)\n                G.GAME.blind.chip_text = number_format(G.GAME.blind.chips)\n                return {\n                    message = localize(\"k_active_ex\")\n                }\n            end\n            if context.joker_main then\n                local current_xmult = card.ability.extra.xmult *\n                    JoyousSpring.get_attribute_count(JoyousSpring.get_materials(card))\n                return {\n                    chips = card.ability.extra.attributes[\"WATER\"] and card.ability.extra.chips or nil,\n                    mult = card.ability.extra.attributes[\"FIRE\"] and card.ability.extra.mult or nil,\n                    xmult = current_xmult > 0 and current_xmult or nil\n                }\n            end\n            if context.using_consumeable and context.main_eval and card.ability.extra.attributes[\"WIND\"] then\n                if context.consumeable.ability.set == \"Spectral\" and\n                    pseudorandom(\"j_joy_ignis_arrival\") < G.GAME.probabilities.normal / card.ability.extra.odds then\n                    SMODS.add_card({\n                        key = context.consumeable.config.center.key,\n                        edition = \"e_negative\"\n                    })\n                end\n            end\n            if context.end_of_round and context.main_eval and context.game_over == false then\n                for i = 1, card.ability.extra.creates do\n                    if #G.consumeables.cards < G.consumeables.config.card_limit then\n                        SMODS.add_card({\n                            set = 'Spectral'\n                        })\n                    end\n                end\n            end\n        end\n    end,\n    calc_dollar_bonus = function(self, card)\n        if JoyousSpring.can_use_abilities(card) and card.ability.extra.attributes[\"LIGHT\"] then\n            return card.ability.extra.money\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        card.ability.extra.attributes = JoyousSpring.get_material_attributes(JoyousSpring.get_materials(card))\n\n        if card.ability.extra.attributes[\"EARTH\"] then\n            G.hand:change_size(card.ability.extra.h_size)\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        if card.ability.extra.attributes[\"EARTH\"] then\n            G.hand:change_size(-card.ability.extra.h_size)\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "ignis_ailand",
      "atlas": "ignis",
      "pos": {
        "x": 3,
        "y": 2
      },
      "raw": "key = \"ignis_ailand\",\n    atlas = 'ignis',\n    pos = { x = 3, y = 2 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 12,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_main_deck_joker\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_banish\" }\n        end\n        return { vars = { card.ability.extra.creates, card.ability.extra.attributes } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_ignis_ailand\", properties = { { monster_archetypes = { \"Ignister\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_field_spell = true,\n            },\n            creates = 1,\n            attributes = 6\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joy_summon and context.main_eval and not context.blueprint_card then\n                for _, joker in ipairs(context.joy_summon_materials) do\n                    if (type(joker) == \"string\" and JoyousSpring.is_material_center(joker, { monster_archetypes = { \"Ignister\" } })) or JoyousSpring.is_monster_archetype(joker, \"Ignister\") then\n                        local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Ignister\" }, is_main_deck = true } })\n                        for i = 1, card.ability.extra.creates do\n                            key_to_add = pseudorandom_element(choices, 'j_joy_ignis_ailand')\n                            JoyousSpring.add_monster_tag(key_to_add or \"j_joy_ignis_achichi\")\n                        end\n                        break\n                    end\n                end\n            end\n            if context.end_of_round and context.main_eval and context.game_over == false then\n                local count = JoyousSpring.get_attribute_count(G.jokers.cards)\n                if count >= card.ability.extra.attributes then\n                    for i, joker in ipairs(G.jokers.cards) do\n                        if JoyousSpring.is_monster_type(joker, \"Cyberse\") then\n                            JoyousSpring.banish(joker, \"blind_selected\")\n                        else\n                            SMODS.debuff_card(joker, true, \"j_joy_ignis_ailand\")\n                        end\n                    end\n                end\n            end\n        end\n    end"
    },
    {
      "type": "Atlas",
      "key": "solfa",
      "atlas": null,
      "pos": null,
      "raw": "key = \"solfa\",\n    path = \"16Solfachord.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Joker",
      "key": "solfa_cutia",
      "atlas": "solfa",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"solfa_cutia\",\n    atlas = 'solfa',\n    pos = { x = 1, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.change, card.ability.extra.mult, card.ability.extra.mult * solfa_count(), card.ability.extra.creates, card.ability.extra.consumed, card.ability.extra.consumed_this_round } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Solfachord\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_pendulum = true,\n                attribute = \"EARTH\",\n                monster_type = \"Fairy\",\n                monster_archetypes = { [\"Solfachord\"] = true }\n            },\n            change = 1,\n            rank = '8',\n            mult = 8,\n            creates = 1,\n            consumed = 3,\n            activated = false,\n            consumed_this_round = 0\n        },\n    },\n    use = solfa_use,\n    can_use = function(self, card)\n        return true\n    end,\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.individual then\n                local count_all_scored, count_hand = count_all_cards(context.scoring_hand)\n\n                if context.cardarea == G.play then\n                    if count_all_scored or is_even(context.other_card) then\n                        return {\n                            mult = card.ability.extra.mult * solfa_count()\n                        }\n                    end\n                end\n                if context.cardarea == G.hand and count_hand then\n                    if is_even(context.other_card) then\n                        return {\n                            mult = card.ability.extra.mult * solfa_count()\n                        }\n                    end\n                end\n            end\n            if context.using_consumeable and JoyousSpring.is_pendulum_monster(context.consumeable) then\n                card.ability.extra.consumed_this_round = card.ability.extra.consumed_this_round + 1\n                if not card.ability.extra.activated and card.ability.extra.consumed_this_round >= card.ability.extra.consumed then\n                    card.ability.extra.activated = true\n                    for i = 1, card.ability.extra.creates do\n                        JoyousSpring.create_pseudorandom(\n                            { { monster_archetypes = { \"Solfachord\" }, is_pendulum = true } },\n                            'j_joy_solfa_cutia', true)\n                    end\n                end\n            end\n            if context.end_of_round and context.main_eval and context.game_over == false then\n                card.ability.extra.activated = false\n                card.ability.extra.consumed_this_round = 0\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "solfa_dreamia",
      "atlas": "solfa",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"solfa_dreamia\",\n    atlas = 'solfa',\n    pos = { x = 2, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.change, card.ability.extra.mult, card.ability.extra.mult * solfa_count() } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Solfachord\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_pendulum = true,\n                attribute = \"WIND\",\n                monster_type = \"Fairy\",\n                monster_archetypes = { [\"Solfachord\"] = true }\n            },\n            change = 2,\n            rank = '7',\n            mult = 7\n        },\n    },\n    use = solfa_use,\n    can_use = function(self, card)\n        return true\n    end,\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.individual then\n                local count_all_scored, count_hand = count_all_cards(context.scoring_hand)\n\n                if context.cardarea == G.play then\n                    if count_all_scored or is_odd(context.other_card) then\n                        return {\n                            mult = card.ability.extra.mult * solfa_count()\n                        }\n                    end\n                end\n                if context.cardarea == G.hand and count_hand then\n                    if is_odd(context.other_card) then\n                        return {\n                            mult = card.ability.extra.mult * solfa_count()\n                        }\n                    end\n                end\n            end\n        end\n    end,\n    joy_set_cost = function(card)\n        if JoyousSpring.count_materials_owned({ { is_pendulum = true } }) > 0 then\n            card.cost = 0\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "solfa_eliteia",
      "atlas": "solfa",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"solfa_eliteia\",\n    atlas = 'solfa',\n    pos = { x = 3, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.change, card.ability.extra.chips, card.ability.extra.current_chips, card.ability.extra.adds, card.ability.extra.scored, card.ability.extra.currently_scored } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Solfachord\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_pendulum = true,\n                attribute = \"WATER\",\n                monster_type = \"Fairy\",\n                monster_archetypes = { [\"Solfachord\"] = true }\n            },\n            change = 3,\n            rank = '6',\n            chips = 6,\n            current_chips = 0,\n            adds = 1,\n            scored = 20,\n            currently_scored = 0\n        },\n    },\n    use = solfa_use,\n    can_use = function(self, card)\n        return true\n    end,\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.individual then\n                local count_all_scored, count_hand = count_all_cards(context.scoring_hand)\n\n                if context.cardarea == G.play then\n                    if count_all_scored or is_even(context.other_card) then\n                        card.ability.extra.currently_scored = card.ability.extra.currently_scored + 1\n                        card.ability.extra.current_chips = card.ability.extra.current_chips + card.ability.extra.chips\n                    end\n                end\n                if context.cardarea == G.hand and count_hand then\n                    if is_even(context.other_card) then\n                        card.ability.extra.currently_scored = card.ability.extra.currently_scored + 1\n                        card.ability.extra.current_chips = card.ability.extra.current_chips + card.ability.extra.chips\n                    end\n                end\n\n                if card.ability.extra.currently_scored >= card.ability.extra.scored then\n                    card.ability.extra.currently_scored = card.ability.extra.currently_scored - card.ability.extra\n                        .scored\n                    local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Solfachord\" }, is_extra_deck = true } })\n                    for i = 1, card.ability.extra.adds do\n                        local key_to_add, _ = pseudorandom_element(choices, 'j_joy_solfa_eliteia')\n                        if key_to_add and #JoyousSpring.extra_deck_area.cards < JoyousSpring.extra_deck_area.config.card_limit then\n                            JoyousSpring.add_to_extra_deck(key_to_add)\n                        end\n                    end\n                end\n            end\n            if context.joker_main then\n                return {\n                    chips = card.ability.extra.current_chips\n                }\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "solfa_fancia",
      "atlas": "solfa",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"solfa_fancia\",\n    atlas = 'solfa',\n    pos = { x = 0, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.change, card.ability.extra.chips, card.ability.extra.current_chips, card.ability.extra.creates, card.ability.extra.scored, card.ability.extra.currently_scored } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Solfachord\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_pendulum = true,\n                attribute = \"FIRE\",\n                monster_type = \"Fairy\",\n                monster_archetypes = { [\"Solfachord\"] = true }\n            },\n            change = 4,\n            rank = '5',\n            chips = 5,\n            current_chips = 0,\n            creates = 1,\n            scored = 21,\n            currently_scored = 0\n        },\n    },\n    use = solfa_use,\n    can_use = function(self, card)\n        return true\n    end,\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.individual then\n                local count_all_scored, count_hand = count_all_cards(context.scoring_hand)\n\n                if context.cardarea == G.play then\n                    if count_all_scored or is_odd(context.other_card) then\n                        card.ability.extra.currently_scored = card.ability.extra.currently_scored + 1\n                        card.ability.extra.current_chips = card.ability.extra.current_chips + card.ability.extra.chips\n                    end\n                end\n                if context.cardarea == G.hand and count_hand then\n                    if is_odd(context.other_card) then\n                        card.ability.extra.currently_scored = card.ability.extra.currently_scored + 1\n                        card.ability.extra.current_chips = card.ability.extra.current_chips + card.ability.extra.chips\n                    end\n                end\n\n                if card.ability.extra.currently_scored >= card.ability.extra.scored then\n                    card.ability.extra.currently_scored = card.ability.extra.currently_scored - card.ability.extra\n                        .scored\n                    for i = 1, card.ability.extra.creates do\n                        JoyousSpring.create_pseudorandom(\n                            { { monster_archetypes = { \"Solfachord\" }, is_pendulum = true } },\n                            'j_joy_solfa_fancia', true)\n                    end\n                end\n            end\n            if context.joker_main then\n                return {\n                    chips = card.ability.extra.current_chips\n                }\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "solfa_gracia",
      "atlas": "solfa",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"solfa_gracia\",\n    atlas = 'solfa',\n    pos = { x = 1, y = 1 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 9,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.change, card.ability.extra.repetitions, card.ability.extra.creates, card.ability.extra.scored, card.ability.extra.currently_scored } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_solfa_harmonia\",                                     name = \"k_joy_creates\" },\n        { properties = { { monster_archetypes = { \"Solfachord\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_pendulum = true,\n                attribute = \"WATER\",\n                monster_type = \"Fairy\",\n                monster_archetypes = { [\"Solfachord\"] = true }\n            },\n            change = 5,\n            rank = '4',\n            repetitions = 1,\n            creates = 1,\n            scored = 80,\n            currently_scored = 0\n        },\n    },\n    use = solfa_use,\n    can_use = function(self, card)\n        return true\n    end,\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.individual then\n                local count_all_scored, count_hand = count_all_cards(context.scoring_hand)\n\n                if context.cardarea == G.play then\n                    if count_all_scored or is_even(context.other_card) then\n                        card.ability.extra.currently_scored = card.ability.extra.currently_scored + 1\n                    end\n                end\n                if context.cardarea == G.hand and count_hand then\n                    if is_even(context.other_card) then\n                        card.ability.extra.currently_scored = card.ability.extra.currently_scored + 1\n                    end\n                end\n\n                if card.ability.extra.currently_scored >= card.ability.extra.scored then\n                    card.ability.extra.currently_scored = card.ability.extra.currently_scored - card.ability.extra\n                        .scored\n                    for i = 1, card.ability.extra.creates do\n                        if #JoyousSpring.field_spell_area.cards < JoyousSpring.field_spell_area.config.card_limit then\n                            JoyousSpring.add_to_extra_deck(\"j_joy_solfa_harmonia\")\n                        end\n                    end\n                end\n            end\n            if context.repetition then\n                local count_all_scored, count_hand = count_all_cards(context.scoring_hand)\n\n                if context.cardarea == G.play then\n                    if count_all_scored or is_even(context.other_card) then\n                        return {\n                            repetitions = card.ability.extra.repetitions\n                        }\n                    end\n                end\n                if context.cardarea == G.hand and count_hand then\n                    if is_even(context.other_card) then\n                        return {\n                            repetitions = card.ability.extra.repetitions\n                        }\n                    end\n                end\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "solfa_angelia",
      "atlas": "solfa",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"solfa_angelia\",\n    atlas = 'solfa',\n    pos = { x = 2, y = 1 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 8,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n        end\n        return { vars = { card.ability.extra.change, card.ability.extra.repetitions, card.ability.extra.revives, card.ability.extra.scored, card.ability.extra.currently_scored } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Solfachord\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_pendulum = true,\n                attribute = \"FIRE\",\n                monster_type = \"Fairy\",\n                monster_archetypes = { [\"Solfachord\"] = true }\n            },\n            change = 6,\n            rank = '3',\n            repetitions = 1,\n            revives = 1,\n            scored = 41,\n            currently_scored = 0\n        },\n    },\n    add_to_deck = function(self, card, from_debuff)\n        JoyousSpring.calculate_hand_highlight_limit(card)\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        JoyousSpring.calculate_hand_highlight_limit(nil, card)\n    end,\n    joy_set_hand_highlight_limit = function(card)\n        return 6\n    end,\n    use = solfa_use,\n    can_use = function(self, card)\n        return true\n    end,\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.individual then\n                local count_all_scored, count_hand = count_all_cards(context.scoring_hand)\n\n                if context.cardarea == G.play then\n                    if count_all_scored or is_odd(context.other_card) then\n                        card.ability.extra.currently_scored = card.ability.extra.currently_scored + 1\n                    end\n                end\n                if context.cardarea == G.hand and count_hand then\n                    if is_odd(context.other_card) then\n                        card.ability.extra.currently_scored = card.ability.extra.currently_scored + 1\n                    end\n                end\n\n                if card.ability.extra.currently_scored >= card.ability.extra.scored then\n                    card.ability.extra.currently_scored = card.ability.extra.currently_scored - card.ability.extra\n                        .scored\n                    for i = 1, card.ability.extra.revives do\n                        JoyousSpring.revive_pseudorandom({ { monster_archetypes = { \"Solfachord\" } } },\n                            'j_joy_solfa_angelia', true)\n                    end\n                end\n            end\n            if context.repetition then\n                local count_all_scored, count_hand = count_all_cards(context.scoring_hand)\n\n                if context.cardarea == G.play then\n                    if count_all_scored or is_odd(context.other_card) then\n                        return {\n                            repetitions = card.ability.extra.repetitions\n                        }\n                    end\n                end\n                if context.cardarea == G.hand and count_hand then\n                    if is_odd(context.other_card) then\n                        return {\n                            repetitions = card.ability.extra.repetitions\n                        }\n                    end\n                end\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "solfa_beautia",
      "atlas": "solfa",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"solfa_beautia\",\n    atlas = 'solfa',\n    pos = { x = 3, y = 1 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 9,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_banish\" }\n        end\n        return { vars = { card.ability.extra.change, card.ability.extra.xchips, 1 + card.ability.extra.xchips * solfa_count(), card.ability.extra.banishes } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Solfachord\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_pendulum = true,\n                attribute = \"EARTH\",\n                monster_type = \"Fairy\",\n                monster_archetypes = { [\"Solfachord\"] = true }\n            },\n            change = 7,\n            rank = '2',\n            xchips = 0.1,\n            banishes = 2\n        },\n    },\n    add_to_deck = function(self, card, from_debuff)\n        JoyousSpring.calculate_hand_highlight_limit(card)\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        JoyousSpring.calculate_hand_highlight_limit(nil, card)\n    end,\n    joy_set_hand_highlight_limit = function(card)\n        return 7\n    end,\n    use = solfa_use,\n    can_use = function(self, card)\n        return true\n    end,\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.individual then\n                local count_all_scored, count_hand = count_all_cards(context.scoring_hand)\n\n                if context.cardarea == G.play then\n                    if count_all_scored or is_even(context.other_card) then\n                        return {\n                            xchips = 1 + card.ability.extra.xchips * solfa_count()\n                        }\n                    end\n                end\n                if context.cardarea == G.hand and count_hand then\n                    if is_even(context.other_card) then\n                        return {\n                            xchips = 1 + card.ability.extra.xchips * solfa_count()\n                        }\n                    end\n                end\n            end\n            if context.end_of_round and context.main_eval and context.game_over == false then\n                local choices = JoyousSpring.get_materials_owned({ { is_pendulum = true } })\n                for i = 1, card.ability.extra.banishes do\n                    local to_banish, index = pseudorandom_element(choices, 'j_joy_solfa_beautia')\n                    if to_banish then\n                        JoyousSpring.banish(to_banish, \"blind_selected\")\n                        table.remove(choices, index)\n                    end\n                end\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "solfa_coolia",
      "atlas": "solfa",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = \"solfa_coolia\",\n    atlas = 'solfa',\n    pos = { x = 0, y = 2 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 8,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.change, card.ability.extra.xmult, 1 + card.ability.extra.xmult * solfa_count() } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Solfachord\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_pendulum = true,\n                attribute = \"WIND\",\n                monster_type = \"Fairy\",\n                monster_archetypes = { [\"Solfachord\"] = true }\n            },\n            change = 8,\n            rank = 'Ace',\n            xmult = 0.1,\n        },\n    },\n    add_to_deck = function(self, card, from_debuff)\n        JoyousSpring.calculate_hand_highlight_limit(card)\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        JoyousSpring.calculate_hand_highlight_limit(nil, card)\n    end,\n    joy_set_hand_highlight_limit = function(card)\n        return 8\n    end,\n    use = solfa_use,\n    can_use = function(self, card)\n        return true\n    end,\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.individual then\n                local count_all_scored, count_hand = count_all_cards(context.scoring_hand)\n\n                if context.cardarea == G.play then\n                    if count_all_scored or is_odd(context.other_card) then\n                        return {\n                            xmult = 1 + card.ability.extra.xmult * solfa_count()\n                        }\n                    end\n                end\n                if context.cardarea == G.hand and count_hand then\n                    if is_odd(context.other_card) then\n                        return {\n                            xmult = 1 + card.ability.extra.xmult * solfa_count()\n                        }\n                    end\n                end\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "solfa_musecia",
      "atlas": "solfa",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "key = \"solfa_musecia\",\n    atlas = 'solfa',\n    pos = { x = 2, y = 2 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.creates, card.ability.extra.consumed, card.ability.extra.consumed - card.ability.extra.consumed_this_ante, card.ability.extra.consumed_increase } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Solfachord\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"LINK\",\n                attribute = \"LIGHT\",\n                monster_type = \"Fairy\",\n                monster_archetypes = { [\"Solfachord\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"LINK\",\n                        materials = {\n                            { is_pendulum = true },\n                            { is_pendulum = true },\n                        },\n                    }\n                }\n            },\n            creates = 1,\n            consumed = 4,\n            consumed_increase = 2,\n            consumed_this_ante = 0,\n            activated = false\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.using_consumeable and JoyousSpring.is_pendulum_monster(context.consumeable) and not card.ability.extra.activated then\n                card.ability.extra.consumed_this_ante = card.ability.extra.consumed_this_ante + 1\n                if card.ability.extra.consumed_this_ante >= card.ability.extra.consumed then\n                    card.ability.extra.activated = true\n                    for i = 1, card.ability.extra.creates do\n                        JoyousSpring.create_pseudorandom(\n                            { { monster_archetypes = { \"Solfachord\" }, is_pendulum = true } },\n                            \"j_joy_solfa_cutia\", false, false, \"e_negative\")\n                    end\n                    card.ability.extra.consumed = card.ability.extra.consumed + card.ability.extra.consumed_increase\n                end\n            end\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval and G.GAME.blind.boss then\n            card.ability.extra.consumed_this_ante = 0\n            card.ability.extra.activated = false\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "solfa_grancoolia",
      "atlas": "solfa",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "key = \"solfa_grancoolia\",\n    atlas = 'solfa',\n    pos = { x = 1, y = 2 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.chips, card.ability.extra.chips * pend_count(), card.ability.extra.money, card.ability.extra.consumed, card.ability.extra.consumed_this_round } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Solfachord\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"LINK\",\n                attribute = \"LIGHT\",\n                monster_type = \"Fairy\",\n                monster_archetypes = { [\"Solfachord\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"LINK\",\n                        materials = {\n                            { is_pendulum = true },\n                            {},\n                            {},\n                        },\n                    }\n                }\n            },\n            chips = 100,\n            money = 50,\n            consumed = 3,\n            consumed_this_round = 0\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    chips = card.ability.extra.chips * pend_count()\n                }\n            end\n            if context.using_consumeable and JoyousSpring.is_pendulum_monster(context.consumeable) then\n                card.ability.extra.consumed_this_round = card.ability.extra.consumed_this_round + 1\n                if card.ability.extra.consumed_this_round >= card.ability.extra.consumed then\n                    card.ability.extra.consumed_this_round = card.ability.extra.consumed_this_round -\n                        card.ability.extra.consumed\n                    return {\n                        dollars = card.ability.extra.money\n                    }\n                end\n            end\n            if context.end_of_round and context.main_eval and context.game_over == false then\n                card.ability.extra.consumed_this_round = 0\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "solfa_harmonia",
      "atlas": "solfa",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"solfa_harmonia\",\n    atlas = 'solfa',\n    pos = { x = 0, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 12,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n        end\n        return { vars = { card.ability.extra.revives, card.ability.extra.creates, card.ability.extra.solfa_owned } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Solfachord\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_field_spell = true,\n                monster_archetypes = { [\"Solfachord\"] = true }\n            },\n            revives = 1,\n            creates = 1,\n            solfa_owned = 5\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.setting_blind and context.main_eval then\n                for i = 1, card.ability.extra.revives do\n                    local revived_card = JoyousSpring.revive_pseudorandom({ { monster_archetypes = { \"Solfachord\" } } },\n                        'j_joy_solfa_harmonia', true)\n\n                    if not revived_card then\n                        JoyousSpring.revive_pseudorandom({ { is_pendulum = true } }, 'j_joy_solfa_harmonia',\n                            true)\n                    end\n                end\n            end\n            if context.using_consumeable and JoyousSpring.is_pendulum_monster(context.consumeable) then\n                for i = 1, card.ability.extra.creates do\n                    if #G.consumeables.cards < G.consumeables.config.card_limit then\n                        SMODS.add_card({\n                            key = 'c_strength'\n                        })\n                    end\n                end\n            end\n            if context.after and context.main_eval and JoyousSpring.count_materials_owned({ { monster_archetypes = { \"Solfachord\" } } }, true) >= 5 then\n                return {\n                    func = function()\n                        for _, playing_card in ipairs(context.scoring_hand) do\n                            if not next(SMODS.get_enhancements(playing_card)) then\n                                if is_even(playing_card) then\n                                    playing_card:set_ability(G.P_CENTERS.m_gold, nil, true)\n                                end\n                                if is_odd(playing_card) then\n                                    playing_card:set_ability(G.P_CENTERS.m_steel, nil, true)\n                                end\n                            end\n                            playing_card:juice_up()\n                        end\n                    end\n                }\n            end\n        end\n    end"
    },
    {
      "type": "Atlas",
      "key": "witch",
      "atlas": null,
      "pos": null,
      "raw": "key = \"witch\",\n    path = \"17Witchcrafter.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Joker",
      "key": "witch_genni",
      "atlas": "witch",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"witch_genni\",\n    atlas = 'witch',\n    pos = { x = 1, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 4,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_tribute\" }\n        end\n        return { vars = { card.ability.extra.creates_tarot, card.ability.extra.tributes, card.ability.extra.creates } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_witch_potterie\",                                       name = \"k_joy_creates\" },\n        { properties = { { monster_archetypes = { \"Witchcrafter\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"WIND\",\n                monster_type = \"Spellcaster\",\n                monster_archetypes = { [\"Witchcrafter\"] = true }\n            },\n            creates_tarot = 1,\n            tributes = 1,\n            creates = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) and not context.blueprint_card then\n            if context.joy_activate_effect and context.joy_activated_card == card then\n                local materials = JoyousSpring.get_consumable_set(\"Tarot\")\n                if #materials >= card.ability.extra.tributes then\n                    JoyousSpring.create_overlay_effect_selection(card, materials, card.ability.extra.tributes,\n                        card.ability.extra.tributes)\n                end\n            end\n            if context.joy_exit_effect_selection and context.joy_card == card and\n                #context.joy_selection == card.ability.extra.tributes then\n                JoyousSpring.tribute(card, context.joy_selection)\n                JoyousSpring.tribute(card, { card })\n\n                for i = 1, card.ability.extra.creates do\n                    JoyousSpring.create_summon({\n                        key = \"j_joy_witch_potterie\"\n                    }, true)\n                end\n            end\n        end\n    end,\n    joy_can_activate = function(card)\n        if not (#G.jokers.cards + G.GAME.joker_buffer - ((card.edition and card.edition.negative) and 0 or 1) < G.jokers.config.card_limit) then\n            return false\n        end\n        local materials = JoyousSpring.get_consumable_count(\"Tarot\")\n        return materials >= card.ability.extra.tributes\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff then\n            for i = 1, card.ability.extra.creates_tarot do\n                if #G.consumeables.cards < G.consumeables.config.card_limit then\n                    SMODS.add_card({\n                        set = 'Tarot'\n                    })\n                end\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "witch_potterie",
      "atlas": "witch",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = \"witch_potterie\",\n    atlas = 'witch',\n    pos = { x = 0, y = 2 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 4,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_tribute\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_banish\" }\n        end\n        return { vars = { card.ability.extra.creates_tarot, card.ability.extra.banishes, card.ability.extra.tributes, card.ability.extra.creates } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_witch_pittore\",                                        name = \"k_joy_creates\" },\n        { properties = { { monster_archetypes = { \"Witchcrafter\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"EARTH\",\n                monster_type = \"Spellcaster\",\n                monster_archetypes = { [\"Witchcrafter\"] = true }\n            },\n            creates_tarot = 1,\n            banishes = 2,\n            tributes = 1,\n            creates = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) and not context.blueprint_card then\n            if context.joy_activate_effect and context.joy_activated_card == card then\n                local materials = JoyousSpring.get_consumable_set(\"Tarot\")\n                if #materials >= card.ability.extra.tributes then\n                    JoyousSpring.create_overlay_effect_selection(card, materials, card.ability.extra.tributes,\n                        card.ability.extra.tributes)\n                end\n            end\n            if context.joy_exit_effect_selection and context.joy_card == card and\n                #context.joy_selection == card.ability.extra.tributes then\n                JoyousSpring.tribute(card, context.joy_selection)\n                JoyousSpring.tribute(card, { card })\n\n                for i = 1, card.ability.extra.creates do\n                    JoyousSpring.create_summon({\n                        key = \"j_joy_witch_pittore\"\n                    }, true)\n                end\n            end\n            if not context.blueprint_card and context.end_of_round and context.game_over == false and context.main_eval then\n                JoyousSpring.banish(card, \"blind_selected\")\n                local choices = {}\n                for _, consumable in ipairs(G.consumeables.cards) do\n                    if consumable.ability.set == \"Tarot\" then\n                        table.insert(choices, consumable)\n                    end\n                end\n                for i = 1, card.ability.extra.banishes do\n                    if #choices > 0 then\n                        local to_banish, pos = pseudorandom_element(choices, 'j_joy_witch_potterie')\n                        if to_banish then\n                            JoyousSpring.banish(to_banish, \"blind_selected\")\n                        end\n                        table.remove(choices, pos)\n                    end\n                end\n            end\n        end\n    end,\n    joy_can_activate = function(card)\n        if not (#G.jokers.cards + G.GAME.joker_buffer - ((card.edition and card.edition.negative) and 0 or 1) < G.jokers.config.card_limit) then\n            return false\n        end\n        local materials = JoyousSpring.get_consumable_count(\"Tarot\")\n        return materials >= card.ability.extra.tributes\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff then\n            for i = 1, card.ability.extra.creates_tarot do\n                if #G.consumeables.cards == 0 and #G.consumeables.cards < G.consumeables.config.card_limit then\n                    SMODS.add_card({\n                        set = 'Tarot'\n                    })\n                end\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "witch_pittore",
      "atlas": "witch",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"witch_pittore\",\n    atlas = 'witch',\n    pos = { x = 2, y = 1 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_tribute\" }\n        end\n        return { vars = { card.ability.extra.chips, card.ability.extra.current_chips, card.ability.extra.creates_tarot, card.ability.extra.consumables, card.ability.extra.consumables_used, card.ability.extra.tributes, card.ability.extra.creates } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_witch_schmietta\",                                      name = \"k_joy_creates\" },\n        { properties = { { monster_archetypes = { \"Witchcrafter\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"WATER\",\n                monster_type = \"Spellcaster\",\n                monster_archetypes = { [\"Witchcrafter\"] = true }\n            },\n            chips = 100,\n            current_chips = 0,\n            creates_tarot = 1,\n            consumables = 2,\n            consumables_used = 0,\n            tributes = 1,\n            creates = 1,\n            activated = false\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card then\n                if context.joy_activate_effect and context.joy_activated_card == card then\n                    local materials = JoyousSpring.get_consumable_set(\"Tarot\")\n                    if #materials >= card.ability.extra.tributes then\n                        JoyousSpring.create_overlay_effect_selection(card, materials, card.ability.extra.tributes,\n                            card.ability.extra.tributes)\n                    end\n                end\n                if context.joy_exit_effect_selection and context.joy_card == card and\n                    #context.joy_selection == card.ability.extra.tributes then\n                    JoyousSpring.tribute(card, context.joy_selection)\n                    JoyousSpring.tribute(card, { card })\n\n                    for i = 1, card.ability.extra.creates do\n                        JoyousSpring.create_summon({\n                            key = \"j_joy_witch_schmietta\"\n                        }, true)\n                    end\n                end\n                if not card.ability.extra.activated and context.using_consumeable then\n                    card.ability.extra.consumables_used = card.ability.extra.consumables_used + 1\n                    if card.ability.extra.consumables_used >= card.ability.extra.consumables then\n                        for i = 1, card.ability.extra.creates_tarot do\n                            if #G.consumeables.cards < G.consumeables.config.card_limit then\n                                SMODS.add_card({\n                                    set = 'Tarot'\n                                })\n                            end\n                        end\n                        card.ability.extra.activated = true\n                    end\n                end\n                if (context.joy_tributed and context.joy_card.ability.set == \"Tarot\") or (context.using_consumeable and context.consumeable.ability.set == 'Tarot' and next(SMODS.find_card(\"j_joy_witch_aruru\"))) then\n                    if next(SMODS.find_card(\"j_joy_witch_vicemadame\")) then\n                        card.ability.extra.current_chips = card.ability.extra.current_chips + card.ability.extra.chips\n                    else\n                        card.ability.extra.current_chips = card.ability.extra.chips *\n                            (JoyousSpring.count_set_tributed(\"Tarot\") + (next(SMODS.find_card(\"j_joy_witch_aruru\")) and 1 or 0))\n                    end\n                end\n                if context.end_of_round and context.game_over == false and context.main_eval then\n                    card.ability.extra.activated = false\n                    card.ability.extra.consumables_used = 0\n                end\n            end\n            if context.joker_main then\n                return {\n                    chips = card.ability.extra.current_chips\n                }\n            end\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval then\n            if not next(SMODS.find_card(\"j_joy_witch_vicemadame\")) then\n                card.ability.extra.current_chips = 0\n            end\n        end\n    end,\n    joy_can_activate = function(card)\n        if not (#G.jokers.cards + G.GAME.joker_buffer - ((card.edition and card.edition.negative) and 0 or 1) < G.jokers.config.card_limit) then\n            return false\n        end\n        local materials = JoyousSpring.get_consumable_count(\"Tarot\")\n        return materials >= card.ability.extra.tributes\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        card.ability.extra.current_chips = card.ability.extra.chips * JoyousSpring.count_set_tributed(\"Tarot\")\n    end"
    },
    {
      "type": "Joker",
      "key": "witch_schmietta",
      "atlas": "witch",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "key = \"witch_schmietta\",\n    atlas = 'witch',\n    pos = { x = 1, y = 2 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_tribute\" }\n        end\n        return { vars = { card.ability.extra.mult, card.ability.extra.current_mult, card.ability.extra.creates_tarot, card.ability.extra.tributes, card.ability.extra.creates } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_witch_edel\",                                           name = \"k_joy_creates\" },\n        { properties = { { monster_archetypes = { \"Witchcrafter\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"FIRE\",\n                monster_type = \"Spellcaster\",\n                monster_archetypes = { [\"Witchcrafter\"] = true }\n            },\n            mult = 25,\n            current_mult = 0,\n            creates_tarot = 1,\n            tributes = 1,\n            creates = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card then\n                if context.joy_activate_effect and context.joy_activated_card == card then\n                    local materials = JoyousSpring.get_consumable_set(\"Tarot\")\n                    if #materials >= card.ability.extra.tributes then\n                        JoyousSpring.create_overlay_effect_selection(card, materials, card.ability.extra.tributes,\n                            card.ability.extra.tributes)\n                    end\n                end\n                if context.joy_exit_effect_selection and context.joy_card == card and\n                    #context.joy_selection == card.ability.extra.tributes then\n                    JoyousSpring.tribute(card, context.joy_selection)\n                    JoyousSpring.tribute(card, { card })\n\n                    for i = 1, card.ability.extra.creates do\n                        JoyousSpring.create_summon({\n                            key = \"j_joy_witch_edel\"\n                        }, true)\n                    end\n                end\n                if context.before and context.main_eval and G.GAME.current_round.hands_played == 0 then\n                    for i = 1, card.ability.extra.creates_tarot do\n                        if #G.consumeables.cards < G.consumeables.config.card_limit then\n                            SMODS.add_card({\n                                set = 'Tarot'\n                            })\n                        end\n                    end\n                end\n                if (context.joy_tributed and context.joy_card.ability.set == \"Tarot\") or (context.using_consumeable and context.consumeable.ability.set == 'Tarot' and next(SMODS.find_card(\"j_joy_witch_aruru\"))) then\n                    if next(SMODS.find_card(\"j_joy_witch_vicemadame\")) then\n                        card.ability.extra.current_mult = card.ability.extra.current_mult + card.ability.extra.mult\n                    else\n                        card.ability.extra.current_mult = card.ability.extra.mult *\n                            (JoyousSpring.count_set_tributed(\"Tarot\") + (next(SMODS.find_card(\"j_joy_witch_aruru\")) and 1 or 0))\n                    end\n                end\n            end\n            if context.joker_main then\n                return {\n                    mult = card.ability.extra.current_mult\n                }\n            end\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval then\n            if not next(SMODS.find_card(\"j_joy_witch_vicemadame\")) then\n                card.ability.extra.current_mult = 0\n            end\n        end\n    end,\n    joy_can_activate = function(card)\n        if not (#G.jokers.cards + G.GAME.joker_buffer - ((card.edition and card.edition.negative) and 0 or 1) < G.jokers.config.card_limit) then\n            return false\n        end\n        local materials = JoyousSpring.get_consumable_count(\"Tarot\")\n        return materials >= card.ability.extra.tributes\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        card.ability.extra.current_mult = card.ability.extra.mult * JoyousSpring.count_set_tributed(\"Tarot\")\n    end"
    },
    {
      "type": "Joker",
      "key": "witch_edel",
      "atlas": "witch",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"witch_edel\",\n    atlas = 'witch',\n    pos = { x = 0, y = 0 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 7,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_tribute\" }\n        end\n        return { vars = { card.ability.extra.creates_genni, card.ability.extra.hands_to_play, card.ability.extra.hands_played, card.ability.extra.tributes, card.ability.extra.creates } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_witch_genni\",                                          \"j_joy_witch_haine\",     name = \"k_joy_creates\" },\n        { properties = { { monster_archetypes = { \"Witchcrafter\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"LIGHT\",\n                monster_type = \"Spellcaster\",\n                monster_archetypes = { [\"Witchcrafter\"] = true }\n            },\n            creates_genni = 1,\n            hands_to_play = 2,\n            hands_played = 0,\n            tributes = 1,\n            creates = 1,\n            activated = false\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) and not context.blueprint_card then\n            if context.joy_activate_effect and context.joy_activated_card == card then\n                local materials = JoyousSpring.get_consumable_set(\"Tarot\")\n                if #materials >= card.ability.extra.tributes then\n                    JoyousSpring.create_overlay_effect_selection(card, materials, card.ability.extra.tributes,\n                        card.ability.extra.tributes)\n                end\n            end\n            if context.joy_exit_effect_selection and context.joy_card == card and\n                #context.joy_selection == card.ability.extra.tributes then\n                JoyousSpring.tribute(card, context.joy_selection)\n                JoyousSpring.tribute(card, { card })\n\n                for i = 1, card.ability.extra.creates do\n                    JoyousSpring.create_summon({\n                        key = \"j_joy_witch_haine\"\n                    }, true)\n                end\n            end\n            if not card.ability.extra.activated and context.before and context.main_eval then\n                card.ability.extra.hands_played = card.ability.extra.hands_played + 1\n                if card.ability.extra.hands_played >= card.ability.extra.hands_to_play then\n                    card.ability.extra.activated = true\n                    for i = 1, card.ability.extra.creates_genni do\n                        JoyousSpring.create_summon({\n                            key = \"j_joy_witch_genni\"\n                        }, true)\n                    end\n                end\n            end\n            if context.end_of_round and context.game_over == false and context.main_eval then\n                card.ability.extra.activated = false\n                card.ability.extra.hands_played = 0\n            end\n        end\n    end,\n    joy_can_activate = function(card)\n        if not (#G.jokers.cards + G.GAME.joker_buffer - ((card.edition and card.edition.negative) and 0 or 1) < G.jokers.config.card_limit) then\n            return false\n        end\n        local materials = JoyousSpring.get_consumable_count(\"Tarot\")\n        return materials >= card.ability.extra.tributes\n    end,"
    },
    {
      "type": "Joker",
      "key": "witch_haine",
      "atlas": "witch",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"witch_haine\",\n    atlas = 'witch',\n    pos = { x = 0, y = 1 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 7,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_tribute\" }\n        end\n        return { vars = { card.ability.extra.money, card.ability.extra.creates_tarot, card.ability.extra.tributes, card.ability.extra.creates } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_witch_verre\",                                          name = \"k_joy_creates\" },\n        { properties = { { monster_archetypes = { \"Witchcrafter\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Spellcaster\",\n                monster_archetypes = { [\"Witchcrafter\"] = true }\n            },\n            money = 5,\n            creates_tarot = 1,\n            tributes = 1,\n            creates = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) and not context.blueprint_card then\n            if context.joy_activate_effect and context.joy_activated_card == card then\n                local materials = JoyousSpring.get_consumable_set(\"Tarot\")\n                if #materials >= card.ability.extra.tributes then\n                    JoyousSpring.create_overlay_effect_selection(card, materials, card.ability.extra.tributes,\n                        card.ability.extra.tributes)\n                end\n            end\n            if context.joy_exit_effect_selection and context.joy_card == card and\n                #context.joy_selection == card.ability.extra.tributes then\n                JoyousSpring.tribute(card, context.joy_selection)\n                JoyousSpring.tribute(card, { card })\n\n                for i = 1, card.ability.extra.creates do\n                    JoyousSpring.create_summon({\n                        key = \"j_joy_witch_verre\"\n                    }, true)\n                end\n            end\n            if context.after and G.GAME.current_round.hands_left == 0 then\n                for i = 1, card.ability.extra.creates_tarot do\n                    SMODS.add_card({\n                        set = 'Tarot',\n                        edition = \"e_negative\"\n                    })\n                end\n            end\n        end\n    end,\n    joy_can_activate = function(card)\n        if not (#G.jokers.cards + G.GAME.joker_buffer - ((card.edition and card.edition.negative) and 0 or 1) < G.jokers.config.card_limit) then\n            return false\n        end\n        local materials = JoyousSpring.get_consumable_count(\"Tarot\")\n        return materials >= card.ability.extra.tributes\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not from_debuff and JoyousSpring.count_set_tributed(\"Tarot\") > 0 then\n            ease_dollars(card.ability.extra.money * JoyousSpring.count_set_tributed(\"Tarot\"))\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "witch_verre",
      "atlas": "witch",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"witch_verre\",\n    atlas = 'witch',\n    pos = { x = 1, y = 1 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 8,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_tribute\" }\n        end\n        return { vars = { card.ability.extra.xmult, (card.ability.extra.current_xmult > 1 and card.ability.extra.current_xmult) or 1 } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Witchcrafter\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"LIGHT\",\n                monster_type = \"Spellcaster\",\n                monster_archetypes = { [\"Witchcrafter\"] = true }\n            },\n            xmult = 1.5,\n            current_xmult = 0\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card then\n                if (context.joy_tributed and context.joy_card.ability.set == \"Tarot\") or (context.using_consumeable and context.consumeable.ability.set == 'Tarot' and next(SMODS.find_card(\"j_joy_witch_aruru\"))) then\n                    if next(SMODS.find_card(\"j_joy_witch_vicemadame\")) then\n                        card.ability.extra.current_xmult = card.ability.extra.current_xmult + card.ability.extra.xmult\n                    else\n                        card.ability.extra.current_xmult = card.ability.extra.xmult *\n                            (JoyousSpring.count_set_tributed(\"Tarot\") + (next(SMODS.find_card(\"j_joy_witch_aruru\")) and 1 or 0))\n                    end\n                end\n            end\n            if context.joker_main then\n                return {\n                    xmult = (card.ability.extra.current_xmult > 1 and card.ability.extra.current_xmult) or 1\n                }\n            end\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval then\n            if not next(SMODS.find_card(\"j_joy_witch_vicemadame\")) then\n                card.ability.extra.current_xmult = 0\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        card.ability.extra.current_xmult = card.ability.extra.xmult * JoyousSpring.count_set_tributed(\"Tarot\")\n        if not card.debuff and not from_debuff then\n            local tarots = JoyousSpring.get_set_tributed(\"Tarot\")\n\n            for _, key in ipairs(tarots) do\n                SMODS.add_card({\n                    key = key,\n                    edition = \"e_negative\"\n                })\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "witch_aruru",
      "atlas": "witch",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"witch_aruru\",\n    atlas = 'witch',\n    pos = { x = 2, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 7,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_tribute\" }\n        end\n        return { vars = { card.ability.extra.mult, card.ability.extra.current_mult } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Witchcrafter\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"LIGHT\",\n                monster_type = \"Spellcaster\",\n                monster_archetypes = { [\"Witchcrafter\"] = true }\n            },\n            mult = 5,\n            current_mult = 0\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card then\n                if (context.joy_tributed and context.joy_card.ability.set == \"Tarot\") or (context.using_consumeable and context.consumeable.ability.set == 'Tarot') then\n                    if context.using_consumeable then\n                        JoyousSpring.count_as_tributed(context.consumeable)\n                    end\n                    if next(SMODS.find_card(\"j_joy_witch_vicemadame\")) then\n                        card.ability.extra.current_mult = card.ability.extra.current_mult + card.ability.extra.mult\n                    else\n                        card.ability.extra.current_mult = card.ability.extra.mult *\n                            JoyousSpring.count_set_tributed(\"Tarot\")\n                    end\n                end\n            end\n            if context.joker_main then\n                return {\n                    mult = card.ability.extra.current_mult\n                }\n            end\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval then\n            if not next(SMODS.find_card(\"j_joy_witch_vicemadame\")) then\n                card.ability.extra.current_mult = 0\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        card.ability.extra.current_mult = card.ability.extra.mult * JoyousSpring.count_set_tributed(\"Tarot\")\n    end,\n    joy_set_cost = function(card)\n        if JoyousSpring.count_materials_owned({ { monster_archetypes = { \"Witchcrafter\" } } }) > 0 then\n            card.cost = 0\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "witch_vicemadame",
      "atlas": "witch",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "key = \"witch_vicemadame\",\n    atlas = 'witch',\n    pos = { x = 2, y = 2 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 8,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.creates, card.ability.extra.consumables, card.ability.extra.consumables_used } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_witch_genni\",                                          name = \"k_joy_creates\" },\n        { properties = { { monster_archetypes = { \"Witchcrafter\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"FUSION\",\n                attribute = \"DARK\",\n                monster_type = \"Spellcaster\",\n                monster_archetypes = { [\"Witchcrafter\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"FUSION\",\n                        materials = {\n                            { monster_type = \"Spellcaster\" },\n                            { monster_type = \"Spellcaster\" }\n                        }\n                    }\n                },\n            },\n            creates = 1,\n            consumables = 5,\n            consumables_used = 0\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card then\n                if not card.ability.extra.activated and context.using_consumeable and context.consumeable.ability.set == 'Tarot' then\n                    card.ability.extra.consumables_used = card.ability.extra.consumables_used + 1\n                    if card.ability.extra.consumables_used >= card.ability.extra.consumables then\n                        for i = 1, card.ability.extra.creates do\n                            JoyousSpring.create_summon({\n                                key = \"j_joy_witch_genni\"\n                            }, true)\n                        end\n                        card.ability.extra.activated = true\n                    end\n                end\n                if context.end_of_round and context.game_over == false and context.main_eval then\n                    card.ability.extra.activated = false\n                    card.ability.extra.consumables_used = 0\n                end\n            end\n        end\n    end,\n    joy_modify_cost = function(card, other_card)\n        if other_card.ability.set == \"Booster\" and other_card.config.center.kind == \"Arcana\" then\n            other_card.cost = 0\n        end\n    end"
    },
    {
      "type": "Atlas",
      "key": "shaddoll",
      "atlas": null,
      "pos": null,
      "raw": "key = \"shaddoll\",\n    path = \"18Shaddoll.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Joker",
      "key": "shaddoll_beast",
      "atlas": "shaddoll",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"shaddoll_beast\",\n    atlas = 'shaddoll',\n    pos = { x = 0, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 3,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_main_deck_joker\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return { vars = { card.ability.extra.h_size, card.ability.extra.revives, card.ability.extra.mills, card.ability.extra.turns } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_shaddoll_prison\", properties = { { monster_archetypes = { \"Shaddoll\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_flip = true,\n                attribute = \"DARK\",\n                monster_type = \"Spellcaster\",\n                monster_archetypes = { [\"Shaddoll\"] = true }\n            },\n            h_size = 1,\n            revives = 1,\n            mills = 1,\n            turns = 3,\n            activated = false\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.calculate_flip_effect(card, context) then\n            if not card.ability.extra.activated then\n                card.ability.extra.activated = true\n                G.hand:change_size(card.ability.extra.h_size)\n            end\n            for i = 1, card.ability.extra.revives do\n                JoyousSpring.revive_pseudorandom({ { monster_archetypes = { \"Shaddoll\" } } },\n                    'j_joy_shaddoll_beast', true)\n            end\n            local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Shaddoll\" }, is_main_deck = true } })\n\n            for i = 1, card.ability.extra.mills do\n                JoyousSpring.send_to_graveyard(pseudorandom_element(choices, 'j_joy_shaddoll_beast'))\n            end\n        end\n        if JoyousSpring.used_as_material(card, context) and JoyousSpring.is_summon_type(context.joy_card, \"FUSION\") then\n            local choices = {}\n            for _, pcard in ipairs(G.playing_cards) do\n                if pcard.ability.set == \"Default\" then\n                    table.insert(choices, pcard)\n                end\n            end\n            for _ = 1, card.ability.extra.turns do\n                local card_to_turn, index = pseudorandom_element(choices, 'j_joy_shaddoll_beast')\n                if card_to_turn then\n                    table.remove(choices, index)\n                    card_to_turn:set_seal(\"Blue\", true, true)\n                    card_to_turn:set_ability(\"m_wild\")\n                end\n            end\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval then\n            if card.ability.extra.activated then\n                card.ability.extra.activated = false\n                G.hand:change_size(-card.ability.extra.h_size)\n            end\n            if shaddoll_should_flip(card) then card:flip() end\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        if card.ability.extra.activated then\n            card.ability.extra.activated = false\n            G.hand:change_size(-card.ability.extra.h_size)\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "shaddoll_dragon",
      "atlas": "shaddoll",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"shaddoll_dragon\",\n    atlas = 'shaddoll',\n    pos = { x = 1, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 3,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_main_deck_joker\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return { vars = { card.ability.extra.hands, card.ability.extra.revives, card.ability.extra.mills, card.ability.extra.turns } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_shaddoll_prison\", properties = { { monster_archetypes = { \"Shaddoll\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_flip = true,\n                attribute = \"DARK\",\n                monster_type = \"Spellcaster\",\n                monster_archetypes = { [\"Shaddoll\"] = true }\n            },\n            hands = 1,\n            revives = 1,\n            mills = 1,\n            turns = 3\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.calculate_flip_effect(card, context) then\n            if not card.ability.extra.activated then\n                card.ability.extra.activated = true\n                G.GAME.round_resets.hands = G.GAME.round_resets.hands + card.ability.extra.hands\n                ease_hands_played(card.ability.extra.hands)\n            end\n            for i = 1, card.ability.extra.revives do\n                JoyousSpring.revive_pseudorandom({ { monster_archetypes = { \"Shaddoll\" } } },\n                    'j_joy_shaddoll_dragon', true)\n            end\n            local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Shaddoll\" }, is_main_deck = true } })\n\n            for i = 1, card.ability.extra.mills do\n                JoyousSpring.send_to_graveyard(pseudorandom_element(choices, 'j_joy_shaddoll_dragon'))\n            end\n        end\n        if JoyousSpring.used_as_material(card, context) and JoyousSpring.is_summon_type(context.joy_card, \"FUSION\") then\n            local choices = {}\n            for _, pcard in ipairs(G.playing_cards) do\n                if pcard.ability.set == \"Default\" then\n                    table.insert(choices, pcard)\n                end\n            end\n            for _ = 1, card.ability.extra.turns do\n                local card_to_turn, index = pseudorandom_element(choices, 'j_joy_shaddoll_dragon')\n                if card_to_turn then\n                    table.remove(choices, index)\n                    card_to_turn:set_seal(\"Gold\", true, true)\n                    card_to_turn:set_ability(\"m_glass\")\n                end\n            end\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval then\n            if card.ability.extra.activated then\n                card.ability.extra.activated = false\n                G.GAME.round_resets.hands = G.GAME.round_resets.hands - card.ability.extra.hands\n                ease_hands_played(-card.ability.extra.hands)\n            end\n            if shaddoll_should_flip(card) then card:flip() end\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        if card.ability.extra.activated then\n            card.ability.extra.activated = false\n            G.GAME.round_resets.hands = G.GAME.round_resets.hands - card.ability.extra.hands\n            ease_hands_played(-card.ability.extra.hands)\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "shaddoll_falco",
      "atlas": "shaddoll",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"shaddoll_falco\",\n    atlas = 'shaddoll',\n    pos = { x = 2, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 3,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_main_deck_joker\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return { vars = { card.ability.extra.revives_flip, card.ability.extra.revives, card.ability.extra.mills, card.ability.extra.creates } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_shaddoll_prison\", properties = { { monster_archetypes = { \"Shaddoll\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_flip = true,\n                is_tuner = true,\n                attribute = \"DARK\",\n                monster_type = \"Spellcaster\",\n                monster_archetypes = { [\"Shaddoll\"] = true }\n            },\n            revives_flip = 1,\n            revives = 1,\n            mills = 1,\n            creates = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.calculate_flip_effect(card, context) then\n            for i = 1, card.ability.extra.revives_flip do\n                local revived_card = JoyousSpring.revive_pseudorandom({ { is_flip = true } },\n                    'j_joy_shaddoll_falco', true)\n                if revived_card then\n                    revived_card:flip()\n                end\n            end\n            for i = 1, card.ability.extra.revives do\n                JoyousSpring.revive_pseudorandom({ { monster_archetypes = { \"Shaddoll\" } } },\n                    'j_joy_shaddoll_falco', true)\n            end\n            local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Shaddoll\" }, is_main_deck = true } })\n\n            for i = 1, card.ability.extra.mills do\n                JoyousSpring.send_to_graveyard(pseudorandom_element(choices, 'j_joy_shaddoll_falco'))\n            end\n        end\n        if JoyousSpring.used_as_material(card, context) and JoyousSpring.is_summon_type(context.joy_card, \"FUSION\") then\n            for i = 1, card.ability.extra.creates do\n                local added_card = JoyousSpring.create_summon({\n                    key = \"j_joy_shaddoll_falco\",\n                    edition = \"e_negative\"\n                })\n                added_card:flip()\n            end\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval then\n            if shaddoll_should_flip(card) then card:flip() end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "shaddoll_hedgehog",
      "atlas": "shaddoll",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"shaddoll_hedgehog\",\n    atlas = 'shaddoll',\n    pos = { x = 3, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 3,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_main_deck_joker\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return { vars = { card.ability.extra.creates_tarot, card.ability.extra.revives, card.ability.extra.mills, card.ability.extra.creates_spectral } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_shaddoll_prison\", properties = { { monster_archetypes = { \"Shaddoll\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_flip = true,\n                attribute = \"DARK\",\n                monster_type = \"Spellcaster\",\n                monster_archetypes = { [\"Shaddoll\"] = true }\n            },\n            creates_tarot = 1,\n            revives = 1,\n            mills = 1,\n            creates_spectral = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.calculate_flip_effect(card, context) then\n            for i = 1, card.ability.extra.creates_tarot do\n                if #G.consumeables.cards < G.consumeables.config.card_limit then\n                    SMODS.add_card({\n                        set = 'Tarot'\n                    })\n                end\n            end\n            for i = 1, card.ability.extra.revives do\n                JoyousSpring.revive_pseudorandom({ { monster_archetypes = { \"Shaddoll\" } } },\n                    'j_joy_shaddoll_hedgehog', true)\n            end\n            local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Shaddoll\" }, is_main_deck = true } })\n\n            for i = 1, card.ability.extra.mills do\n                JoyousSpring.send_to_graveyard(pseudorandom_element(choices, 'j_joy_shaddoll_hedgehog'))\n            end\n        end\n        if JoyousSpring.used_as_material(card, context) and JoyousSpring.is_summon_type(context.joy_card, \"FUSION\") then\n            for i = 1, card.ability.extra.creates_spectral do\n                if #G.consumeables.cards < G.consumeables.config.card_limit then\n                    SMODS.add_card({\n                        set = 'Spectral'\n                    })\n                end\n            end\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval then\n            if shaddoll_should_flip(card) then card:flip() end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "shaddoll_hound",
      "atlas": "shaddoll",
      "pos": {
        "x": 4,
        "y": 1
      },
      "raw": "key = \"shaddoll_hound\",\n    atlas = 'shaddoll',\n    pos = { x = 4, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_main_deck_joker\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return { vars = { card.ability.extra.money, card.ability.extra.revives, card.ability.extra.mills } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_shaddoll_prison\", properties = { { monster_archetypes = { \"Shaddoll\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_flip = true,\n                attribute = \"DARK\",\n                monster_type = \"Spellcaster\",\n                monster_archetypes = { [\"Shaddoll\"] = true }\n            },\n            money = 5,\n            revives = 1,\n            mills = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.calculate_flip_effect(card, context) then\n            for i = 1, card.ability.extra.revives do\n                JoyousSpring.revive_pseudorandom({ { monster_archetypes = { \"Shaddoll\" } } },\n                    'j_joy_shaddoll_hound', true)\n            end\n            local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Shaddoll\" }, is_main_deck = true } })\n\n            for i = 1, card.ability.extra.mills do\n                JoyousSpring.send_to_graveyard(pseudorandom_element(choices, 'j_joy_shaddoll_hound'))\n            end\n            return {\n                dollars = card.ability.extra.money\n            }\n        end\n        if JoyousSpring.used_as_material(card, context) and JoyousSpring.is_summon_type(context.joy_card, \"FUSION\") then\n            JoyousSpring.flip_all_cards(card, 'front', { G.jokers })\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval then\n            if shaddoll_should_flip(card) then card:flip() end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "shaddoll_squamata",
      "atlas": "shaddoll",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = \"shaddoll_squamata\",\n    atlas = 'shaddoll',\n    pos = { x = 0, y = 2 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 3,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_main_deck_joker\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return { vars = { card.ability.extra.discards, card.ability.extra.revives, card.ability.extra.mills, card.ability.extra.turns } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_shaddoll_prison\", properties = { { monster_archetypes = { \"Shaddoll\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_flip = true,\n                attribute = \"DARK\",\n                monster_type = \"Spellcaster\",\n                monster_archetypes = { [\"Shaddoll\"] = true }\n            },\n            discards = 1,\n            revives = 1,\n            mills = 1,\n            turns = 3\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.calculate_flip_effect(card, context) then\n            if not card.ability.extra.activated then\n                card.ability.extra.activated = true\n                G.GAME.round_resets.discards = G.GAME.round_resets.discards + card.ability.extra.discards\n                ease_discard(card.ability.extra.discards)\n            end\n            for i = 1, card.ability.extra.revives do\n                JoyousSpring.revive_pseudorandom({ { monster_archetypes = { \"Shaddoll\" } } },\n                    'j_joy_shaddoll_squamata', true)\n            end\n            local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Shaddoll\" }, is_main_deck = true } })\n\n            for i = 1, card.ability.extra.mills do\n                JoyousSpring.send_to_graveyard(pseudorandom_element(choices, 'j_joy_shaddoll_squamata'))\n            end\n        end\n        if JoyousSpring.used_as_material(card, context) and JoyousSpring.is_summon_type(context.joy_card, \"FUSION\") then\n            local choices = {}\n            for _, pcard in ipairs(G.playing_cards) do\n                if pcard.ability.set == \"Default\" then\n                    table.insert(choices, pcard)\n                end\n            end\n            for _ = 1, card.ability.extra.turns do\n                local card_to_turn, index = pseudorandom_element(choices, 'j_joy_shaddoll_squamata')\n                if card_to_turn then\n                    table.remove(choices, index)\n                    card_to_turn:set_seal(\"Purple\", true, true)\n                    card_to_turn:set_ability(\"m_steel\")\n                end\n            end\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval then\n            if card.ability.extra.activated then\n                card.ability.extra.activated = false\n                G.GAME.round_resets.discards = G.GAME.round_resets.discards - card.ability.extra.discards\n                ease_discard(-card.ability.extra.discards)\n            end\n            if shaddoll_should_flip(card) then card:flip() end\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        if card.ability.extra.activated then\n            card.ability.extra.activated = false\n            G.GAME.round_resets.discards = G.GAME.round_resets.discards - card.ability.extra.discards\n            ease_discard(-card.ability.extra.discards)\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "shaddoll_core",
      "atlas": "shaddoll",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "key = \"shaddoll_core\",\n    atlas = 'shaddoll',\n    pos = { x = 2, y = 2 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_main_deck_joker\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return { vars = { card.ability.extra.xmult, card.ability.extra.revives, card.ability.extra.mills, card.ability.extra.creates } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_shaddoll_prison\", name = \"k_joy_creates\" },\n        { \"j_joy_shaddoll_prison\", properties = { { monster_archetypes = { \"Shaddoll\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_flip = true,\n                is_trap = true,\n                is_all_materials = { FUSION = true },\n                attribute = \"DARK\",\n                monster_type = \"Spellcaster\",\n                monster_archetypes = { [\"Shaddoll\"] = true }\n            },\n            xmult = 2,\n            revives = 1,\n            mills = 1,\n            creates = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.calculate_flip_effect(card, context) then\n            for i = 1, card.ability.extra.revives do\n                JoyousSpring.revive_pseudorandom({ { monster_archetypes = { \"Shaddoll\" } } },\n                    'j_joy_shaddoll_core', true)\n            end\n            local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Shaddoll\" }, is_main_deck = true } })\n\n            for i = 1, card.ability.extra.mills do\n                JoyousSpring.send_to_graveyard(pseudorandom_element(choices, 'j_joy_shaddoll_core'))\n            end\n        end\n        if JoyousSpring.used_as_material(card, context) and JoyousSpring.is_summon_type(context.joy_card, \"FUSION\") then\n            if #JoyousSpring.field_spell_area.cards < JoyousSpring.field_spell_area.config.card_limit then\n                JoyousSpring.add_to_extra_deck(\"j_joy_shaddoll_prison\")\n            end\n        end\n        if context.joker_main and JoyousSpring.can_use_abilities(card) and JoyousSpring.is_flip_active(card) then\n            return {\n                xmult = card.ability.extra.xmult\n            }\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff and JoyousSpring.should_trap_flip(card) then\n            card:flip(card)\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "shaddoll_ariel",
      "atlas": "shaddoll",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"shaddoll_ariel\",\n    atlas = 'shaddoll',\n    pos = { x = 1, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_banish\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return { vars = { card.ability.extra.banishes } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_shaddoll_prison\", properties = { { monster_archetypes = { \"Shaddoll\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_flip = true,\n                attribute = \"WATER\",\n                monster_type = \"Psychic\",\n                monster_archetypes = { [\"Shaddoll\"] = true }\n            },\n            banishes = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if context.end_of_round and context.game_over == false and context.main_eval then\n            if JoyousSpring.can_use_abilities(card) and JoyousSpring.is_flip_active(card) then\n                local choices = JoyousSpring.get_materials_owned({ { exclude_keys = { \"j_joy_shaddoll_ariel\" } } })\n                local to_banish = pseudorandom_element(choices, 'j_joy_shaddoll_ariel')\n                if to_banish then\n                    JoyousSpring.banish(to_banish, \"blind_selected\")\n                end\n            end\n        end\n        JoyousSpring.calculate_flip_effect(card, context)\n        if context.end_of_round and context.game_over == false and context.main_eval then\n            if shaddoll_should_flip(card) then card:flip() end\n        end\n    end,\n    joy_can_transfer_ability = function(self, other_card, card)\n        return JoyousSpring.is_summon_type(other_card, \"FUSION\")\n    end,\n    joy_transfer_ability_calculate = function(self, other_card, context, config)\n        if JoyousSpring.can_use_abilities(other_card) then\n            if context.end_of_round and context.game_over == false and context.main_eval then\n                JoyousSpring.banish(other_card, \"blind_selected\")\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "shaddoll_genius",
      "atlas": "shaddoll",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"shaddoll_genius\",\n    atlas = 'shaddoll',\n    pos = { x = 2, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return { vars = { card.ability.extra.flips } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_shaddoll_prison\", properties = { { monster_archetypes = { \"Shaddoll\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_flip = true,\n                attribute = \"EARTH\",\n                monster_type = \"Machine\",\n                monster_archetypes = { [\"Shaddoll\"] = true }\n            },\n            flips = 1,\n            activated = false\n        },\n    },\n    calculate = function(self, card, context)\n        JoyousSpring.calculate_flip_effect(card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if JoyousSpring.is_flip_active(card) and not context.blueprint_card then\n                if not card.ability.extra.activated and context.joy_activate_effect and context.joy_activated_card == card then\n                    local materials = JoyousSpring.get_materials_owned({ { can_flip = true }, { facedown = true } })\n                    if next(materials) then\n                        JoyousSpring.create_overlay_effect_selection(card, materials, card.ability.extra.flips,\n                            card.ability.extra.flips, localize(\"k_joy_select\"))\n                    end\n                end\n                if not card.ability.extra.activated and context.joy_exit_effect_selection and context.joy_card == card and\n                    #context.joy_selection == card.ability.extra.flips then\n                    for _, selected_card in ipairs(context.joy_selection) do\n                        selected_card:flip(card)\n                    end\n                    card.ability.extra.activated = true\n                end\n            end\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval then\n            card.ability.extra.activated = false\n            if shaddoll_should_flip(card) then card:flip() end\n        end\n    end,\n    joy_can_activate = function(card)\n        if card.ability.extra.activated or not JoyousSpring.is_flip_active(card) then\n            return false\n        end\n        local targets = JoyousSpring.get_materials_owned({ { can_flip = true }, { facedown = true } })\n        return next(targets) and true or false\n    end,\n    joy_can_transfer_ability = function(self, other_card, card)\n        return JoyousSpring.is_summon_type(other_card, \"FUSION\")\n    end,\n    joy_transfer_add_to_deck = function(self, other_card, config, card, from_debuff, materials, was_material)\n        other_card.ability.extra.joyous_spring.cannot_flip = true\n        SMODS.debuff_card(other_card, 'prevent_debuff', 'j_joy_shaddoll_genius')\n    end,"
    },
    {
      "type": "Joker",
      "key": "shaddoll_keios",
      "atlas": "shaddoll",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"shaddoll_keios\",\n    atlas = 'shaddoll',\n    pos = { x = 3, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return { vars = { card.ability.extra.adds, card.ability.extra.mult } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_shaddoll_prison\", properties = { { monster_archetypes = { \"Shaddoll\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_flip = true,\n                attribute = \"LIGHT\",\n                monster_type = \"Spellcaster\",\n                monster_archetypes = { [\"Shaddoll\"] = true }\n            },\n            adds = 1,\n            mult = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.calculate_flip_effect(card, context) then\n            local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Shaddoll\" }, is_extra_deck = true } })\n            for _ = 1, card.ability.extra.adds do\n                local key_to_add, _ = pseudorandom_element(choices, 'j_joy_shaddoll_keios')\n                if key_to_add and #JoyousSpring.extra_deck_area.cards < JoyousSpring.extra_deck_area.config.card_limit then\n                    JoyousSpring.add_to_extra_deck(key_to_add)\n                end\n            end\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval then\n            if shaddoll_should_flip(card) then card:flip() end\n        end\n    end,\n    joy_can_transfer_ability = function(self, other_card, card)\n        return JoyousSpring.is_summon_type(other_card, \"FUSION\")\n    end,\n    joy_transfer_config = function(self, other_card)\n        return { mult = 1 }\n    end,\n    joy_transfer_loc_vars = function(self, info_queue, card, config)\n        return {\n            vars = { config.mult, config.mult *\n            JoyousSpring.count_materials_in_graveyard({ { monster_archetypes = { \"Shaddoll\" } }, { monster_type = \"Spellcaster\" } }) }\n        }\n    end,\n    joy_transfer_ability_calculate = function(self, other_card, context, config)\n        if JoyousSpring.can_use_abilities(other_card) then\n            if context.joker_main then\n                return {\n                    mult = config.mult *\n                        JoyousSpring.count_materials_in_graveyard({ { monster_archetypes = { \"Shaddoll\" } }, { monster_type = \"Spellcaster\" } })\n                }\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "shaddoll_wendi",
      "atlas": "shaddoll",
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "key = \"shaddoll_wendi\",\n    atlas = 'shaddoll',\n    pos = { x = 4, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_main_deck_joker\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return { vars = { card.ability.extra.creates, card.ability.extra.revives } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_shaddoll_prison\", properties = { { monster_archetypes = { \"Shaddoll\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_flip = true,\n                attribute = \"WIND\",\n                monster_type = \"Psychic\",\n                monster_archetypes = { [\"Shaddoll\"] = true }\n            },\n            creates = 1,\n            revives = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.calculate_flip_effect(card, context) then\n            for _ = 1, card.ability.extra.creates do\n                JoyousSpring.create_pseudorandom({ { monster_archetypes = { \"Shaddoll\" }, is_main_deck = true } },\n                    'j_joy_shaddoll_wendi', true)\n            end\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval then\n            if shaddoll_should_flip(card) then card:flip() end\n        end\n    end,\n    joy_can_transfer_ability = function(self, other_card, card)\n        return JoyousSpring.is_summon_type(other_card, \"FUSION\")\n    end,\n    joy_transfer_config = function(self, other_card)\n        return { revives = 1 }\n    end,\n    joy_transfer_loc_vars = function(self, info_queue, card, config)\n        return {\n            vars = { config.revives }\n        }\n    end,\n    joy_transfer_ability_calculate = function(self, other_card, context, config)\n        if JoyousSpring.can_use_abilities(other_card) then\n            if context.setting_blind and context.main_eval and G.GAME.blind.boss then\n                for i = 1, config.revives do\n                    JoyousSpring.revive_pseudorandom({ { is_flip = true } }, 'j_joy_shaddoll_wendi', true,\n                        \"e_negative\")\n                end\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "shaddoll_hollow",
      "atlas": "shaddoll",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"shaddoll_hollow\",\n    atlas = 'shaddoll',\n    pos = { x = 0, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_main_deck_joker\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return { vars = { card.ability.extra.mills, card.ability.extra.mills_transfer } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_shaddoll_prison\", properties = { { monster_archetypes = { \"Shaddoll\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_flip = true,\n                attribute = \"FIRE\",\n                monster_type = \"Fiend\",\n                monster_archetypes = { [\"Shaddoll\"] = true }\n            },\n            mills = 3,\n            mills_transfer = 3\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.calculate_flip_effect(card, context) then\n            local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Shaddoll\" }, is_main_deck = true } })\n\n            for i = 1, card.ability.extra.mills do\n                JoyousSpring.send_to_graveyard(pseudorandom_element(choices, 'j_joy_shaddoll_hollow'))\n            end\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval then\n            if shaddoll_should_flip(card) then card:flip() end\n        end\n    end,\n    joy_can_transfer_ability = function(self, other_card, card)\n        return JoyousSpring.is_summon_type(other_card, \"FUSION\")\n    end,\n    joy_transfer_config = function(self, other_card)\n        return { mills = 3 }\n    end,\n    joy_transfer_loc_vars = function(self, info_queue, card, config)\n        return {\n            vars = { config.mills }\n        }\n    end,\n    joy_transfer_ability_calculate = function(self, other_card, context, config)\n        if JoyousSpring.can_use_abilities(other_card) then\n            if context.setting_blind and context.main_eval then\n                local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Shaddoll\" }, is_main_deck = true } })\n\n                for i = 1, config.mills do\n                    JoyousSpring.send_to_graveyard(pseudorandom_element(choices, 'j_joy_shaddoll_hollow'))\n                end\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "shaddoll_anoya",
      "atlas": "shaddoll",
      "pos": {
        "x": 3,
        "y": 2
      },
      "raw": "key = \"shaddoll_anoya\",\n    atlas = 'shaddoll',\n    pos = { x = 3, y = 2 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return {\n            vars = { card.ability.extra.chips, card.ability.extra.chips *\n            JoyousSpring.count_materials_in_graveyard({ { monster_archetypes = { \"Shaddoll\" } } }), card.ability.extra\n                .adds }\n        }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_shaddoll_prison\", properties = { { monster_archetypes = { \"Shaddoll\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"FUSION\",\n                attribute = \"WATER\",\n                monster_type = \"Fiend\",\n                monster_archetypes = { [\"Shaddoll\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"FUSION\",\n                        materials = {\n                            { monster_type = \"Spellcaster\" },\n                            { monster_attribute = \"WATER\" },\n                        },\n                    },\n                    {\n                        type = \"FUSION\",\n                        materials = {\n                            { monster_archetypes = { \"Shaddoll\" } },\n                            { monster_attribute = \"WATER\" },\n                        },\n                    },\n                }\n            },\n            chips = 10,\n            adds = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.used_as_material(card, context) then\n            local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Shaddoll\" }, is_extra_deck = true } })\n            for _ = 1, card.ability.extra.adds do\n                local key_to_add, _ = pseudorandom_element(choices, card.config.center.key)\n                if key_to_add and #JoyousSpring.extra_deck_area.cards < JoyousSpring.extra_deck_area.config.card_limit then\n                    JoyousSpring.add_to_extra_deck(key_to_add)\n                end\n            end\n        end\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    chips = card.ability.extra.chips *\n                        JoyousSpring.count_materials_in_graveyard({ { monster_archetypes = { \"Shaddoll\" } } })\n                }\n            end\n        end\n    end,\n    joy_can_transfer_ability = function(self, other_card, card)\n        return JoyousSpring.is_summon_type(other_card, \"FUSION\")\n    end,\n    joy_transfer_config = function(self, other_card)\n        return { chips = 40 }\n    end,\n    joy_transfer_loc_vars = function(self, info_queue, card, config)\n        return {\n            vars = { config.chips, config.chips *\n            JoyousSpring.count_materials_in_graveyard({ { monster_archetypes = { \"Shaddoll\" } } }) }\n        }\n    end,\n    joy_transfer_ability_calculate = function(self, other_card, context, config)\n        if JoyousSpring.can_use_abilities(other_card) then\n            if context.joker_main then\n                return {\n                    chips = config.chips *\n                        JoyousSpring.count_materials_in_graveyard({ { monster_archetypes = { \"Shaddoll\" } } })\n                }\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "shaddoll_apka",
      "atlas": "shaddoll",
      "pos": {
        "x": 4,
        "y": 2
      },
      "raw": "key = \"shaddoll_apka\",\n    atlas = 'shaddoll',\n    pos = { x = 4, y = 2 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 8,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return { vars = { card.ability.extra.adds } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_shaddoll_prison\", properties = { { monster_archetypes = { \"Shaddoll\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"FUSION\",\n                attribute = \"DARK\",\n                monster_type = \"Spellcaster\",\n                monster_archetypes = { [\"Shaddoll\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"FUSION\",\n                        materials = {\n                            { monster_type = \"Spellcaster\" },\n                            { monster_type = \"Spellcaster\" },\n                        },\n                        restrictions = {\n                            different_attributes = true\n                        }\n                    },\n                    {\n                        type = \"FUSION\",\n                        materials = {\n                            { monster_type = \"Spellcaster\" },\n                            { monster_archetypes = { \"Shaddoll\" } },\n                        },\n                        restrictions = {\n                            different_attributes = true\n                        }\n                    },\n                    {\n                        type = \"FUSION\",\n                        materials = {\n                            { monster_archetypes = { \"Shaddoll\" } },\n                            { monster_archetypes = { \"Shaddoll\" } },\n                        },\n                        restrictions = {\n                            different_attributes = true\n                        }\n                    },\n                }\n            },\n            adds = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.used_as_material(card, context) then\n            local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Shaddoll\" }, is_extra_deck = true } })\n            for _ = 1, card.ability.extra.adds do\n                local key_to_add, _ = pseudorandom_element(choices, card.config.center.key)\n                if key_to_add and #JoyousSpring.extra_deck_area.cards < JoyousSpring.extra_deck_area.config.card_limit then\n                    JoyousSpring.add_to_extra_deck(key_to_add)\n                end\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff then\n            for _, joker in ipairs(G.jokers.cards) do\n                if JoyousSpring.is_summon_type(joker, \"FUSION\") and not JoyousSpring.is_perma_debuffed(joker) then\n                    SMODS.debuff_card(joker, \"prevent_debuff\", \"j_joy_shaddoll_apka\")\n                end\n            end\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        for _, joker in ipairs(G.jokers.cards) do\n            SMODS.debuff_card(joker, false, \"j_joy_shaddoll_apka\")\n        end\n    end,\n    joy_apply_to_jokers_added = function(card, added_card)\n        if JoyousSpring.is_summon_type(added_card, \"FUSION\") and not JoyousSpring.is_perma_debuffed(added_card) then\n            SMODS.debuff_card(added_card, \"prevent_debuff\", \"j_joy_shaddoll_apka\")\n        end\n    end,\n    joy_prevent_flip = function(card, other_card)\n        return JoyousSpring.is_summon_type(other_card, \"FUSION\")\n    end,\n    joy_can_transfer_ability = function(self, other_card, card)\n        return JoyousSpring.is_summon_type(other_card, \"FUSION\")\n    end,\n    joy_transfer_add_to_deck = function(self, other_card, config, card, from_debuff, materials, was_material)\n        if not other_card.debuff then\n            for _, joker in ipairs(G.jokers.cards) do\n                if JoyousSpring.is_summon_type(joker, \"FUSION\") and not JoyousSpring.is_perma_debuffed(joker) then\n                    SMODS.debuff_card(joker, \"prevent_debuff\", other_card.config.center.key .. \"_shaddoll_apka\")\n                end\n            end\n        end\n    end,\n    joy_transfer_remove_from_deck = function(self, other_card, config, from_debuff)\n        for _, joker in ipairs(G.jokers.cards) do\n            SMODS.debuff_card(joker, false, other_card.config.center.key .. \"_shaddoll_apka\")\n        end\n    end,\n    joy_transfer_prevent_flip = function(self, ability_card, other_card, config)\n        return JoyousSpring.is_summon_type(other_card, \"FUSION\")\n    end,\n    joy_transfer_apply_to_jokers_added = function(self, ability_card, added_card, config)\n        if JoyousSpring.is_summon_type(added_card, \"FUSION\") and not JoyousSpring.is_perma_debuffed(added_card) then\n            SMODS.debuff_card(added_card, \"prevent_debuff\", ability_card.config.center.key .. \"_shaddoll_apka\")\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "shaddoll_winda",
      "atlas": "shaddoll",
      "pos": {
        "x": 4,
        "y": 3
      },
      "raw": "key = \"shaddoll_winda\",\n    atlas = 'shaddoll',\n    pos = { x = 4, y = 3 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 12,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        local empty_spaces = G.jokers and math.max(0, G.jokers.config.card_limit - #G.jokers.cards + G.GAME.joker_buffer) or\n            0\n        local mult_count = empty_spaces +\n            JoyousSpring.count_materials_owned({ { facedown = true }, { monster_archetypes = { \"Shaddoll\" } } })\n        return { vars = { card.ability.extra.xmult, math.max(1, card.ability.extra.xmult * mult_count), card.ability.extra.adds } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_shaddoll_prison\", properties = { { monster_archetypes = { \"Shaddoll\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"FUSION\",\n                attribute = \"DARK\",\n                monster_type = \"Spellcaster\",\n                monster_archetypes = { [\"Shaddoll\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"FUSION\",\n                        materials = {\n                            { monster_type = \"Spellcaster\" },\n                            { monster_attribute = \"DARK\" },\n                        },\n                    },\n                    {\n                        type = \"FUSION\",\n                        materials = {\n                            { monster_archetypes = { \"Shaddoll\" } },\n                            { monster_attribute = \"DARK\" },\n                        },\n                    },\n                }\n            },\n            xmult = 2,\n            adds = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.used_as_material(card, context) then\n            local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Shaddoll\" }, is_extra_deck = true } })\n            for _ = 1, card.ability.extra.adds do\n                local key_to_add, _ = pseudorandom_element(choices, card.config.center.key)\n                if key_to_add and #JoyousSpring.extra_deck_area.cards < JoyousSpring.extra_deck_area.config.card_limit then\n                    JoyousSpring.add_to_extra_deck(key_to_add)\n                end\n            end\n        end\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                local empty_spaces = math.max(0, G.jokers.config.card_limit - #G.jokers.cards + G.GAME.joker_buffer)\n                local mult_count = empty_spaces +\n                    JoyousSpring.count_materials_owned({ { facedown = true }, { monster_archetypes = { \"Shaddoll\" } } })\n                if mult_count > 0 then\n                    return {\n                        xmult = card.ability.extra.xmult * mult_count\n                    }\n                end\n            end\n        end\n    end,\n    joy_can_transfer_ability = function(self, other_card, card)\n        return JoyousSpring.is_summon_type(other_card, \"FUSION\")\n    end,\n    joy_transfer_config = function(self, other_card)\n        return { xmult = 2 }\n    end,\n    joy_transfer_loc_vars = function(self, info_queue, card, config)\n        local empty_spaces = G.jokers and math.max(0, G.jokers.config.card_limit - #G.jokers.cards + G.GAME.joker_buffer) or\n            0\n        local mult_count = empty_spaces +\n            JoyousSpring.count_materials_owned({ { facedown = true }, { monster_archetypes = { \"Shaddoll\" } } })\n        return { vars = { config.xmult, math.max(1, config.xmult * mult_count) } }\n    end,\n    joy_transfer_ability_calculate = function(self, other_card, context, config)\n        if JoyousSpring.can_use_abilities(other_card) then\n            if context.joker_main then\n                local empty_spaces = math.max(0, G.jokers.config.card_limit - #G.jokers.cards + G.GAME.joker_buffer)\n                local mult_count = empty_spaces +\n                    JoyousSpring.count_materials_owned({ { facedown = true }, { monster_archetypes = { \"Shaddoll\" } } })\n                if mult_count > 0 then\n                    return {\n                        xmult = config.xmult * mult_count\n                    }\n                end\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "shaddoll_elconstruct",
      "atlas": "shaddoll",
      "pos": {
        "x": 0,
        "y": 3
      },
      "raw": "key = \"shaddoll_elconstruct\",\n    atlas = 'shaddoll',\n    pos = { x = 0, y = 3 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 8,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return { vars = { card.ability.extra.mills, card.ability.extra.adds } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_shaddoll_prison\", properties = { { monster_archetypes = { \"Shaddoll\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"FUSION\",\n                attribute = \"LIGHT\",\n                monster_type = \"Fairy\",\n                monster_archetypes = { [\"Shaddoll\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"FUSION\",\n                        materials = {\n                            { monster_type = \"Spellcaster\" },\n                            { monster_attribute = \"LIGHT\" },\n                        },\n                    },\n                    {\n                        type = \"FUSION\",\n                        materials = {\n                            { monster_archetypes = { \"Shaddoll\" } },\n                            { monster_attribute = \"LIGHT\" },\n                        },\n                    },\n                }\n            },\n            mills = 10,\n            adds = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.used_as_material(card, context) then\n            local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Shaddoll\" }, is_extra_deck = true } })\n            for _ = 1, card.ability.extra.adds do\n                local key_to_add, _ = pseudorandom_element(choices, card.config.center.key)\n                if key_to_add and #JoyousSpring.extra_deck_area.cards < JoyousSpring.extra_deck_area.config.card_limit then\n                    JoyousSpring.add_to_extra_deck(key_to_add)\n                end\n            end\n        end\n        if JoyousSpring.can_use_abilities(card) then\n            if context.setting_blind and context.main_eval then\n                local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Shaddoll\" } } })\n\n                for i = 1, card.ability.extra.mills do\n                    JoyousSpring.send_to_graveyard(pseudorandom_element(choices, 'j_joy_shaddoll_elconstruct'))\n                end\n            end\n        end\n    end,\n    joy_can_transfer_ability = function(self, other_card, card)\n        return JoyousSpring.is_summon_type(other_card, \"FUSION\")\n    end,\n    joy_transfer_config = function(self, other_card)\n        return { mills = 10 }\n    end,\n    joy_transfer_loc_vars = function(self, info_queue, card, config)\n        return { vars = { config.mills } }\n    end,\n    joy_transfer_ability_calculate = function(self, other_card, context, config)\n        if JoyousSpring.can_use_abilities(other_card) then\n            if context.setting_blind and context.main_eval then\n                local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Shaddoll\" } } })\n\n                for i = 1, config.mills do\n                    JoyousSpring.send_to_graveyard(pseudorandom_element(choices, 'j_joy_shaddoll_elconstruct'))\n                end\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "shaddoll_grysta",
      "atlas": "shaddoll",
      "pos": {
        "x": 1,
        "y": 3
      },
      "raw": "key = \"shaddoll_grysta\",\n    atlas = 'shaddoll',\n    pos = { x = 1, y = 3 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 12,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return {\n            vars = { tostring(card.ability.extra.xchips), 1 + card.ability.extra.xchips *\n            JoyousSpring.count_materials_in_graveyard({ { monster_archetypes = { \"Shaddoll\" } } }), card.ability\n                .extra.adds }\n        }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_shaddoll_prison\", properties = { { monster_archetypes = { \"Shaddoll\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"FUSION\",\n                attribute = \"FIRE\",\n                monster_type = \"Rock\",\n                monster_archetypes = { [\"Shaddoll\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"FUSION\",\n                        materials = {\n                            { monster_type = \"Spellcaster\" },\n                            { monster_attribute = \"FIRE\" },\n                        },\n                    },\n                    {\n                        type = \"FUSION\",\n                        materials = {\n                            { monster_archetypes = { \"Shaddoll\" } },\n                            { monster_attribute = \"FIRE\" },\n                        },\n                    },\n                }\n            },\n            xchips = 0.01,\n            adds = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.used_as_material(card, context) then\n            local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Shaddoll\" }, is_extra_deck = true } })\n            for _ = 1, card.ability.extra.adds do\n                local key_to_add, _ = pseudorandom_element(choices, card.config.center.key)\n                if key_to_add and #JoyousSpring.extra_deck_area.cards < JoyousSpring.extra_deck_area.config.card_limit then\n                    JoyousSpring.add_to_extra_deck(key_to_add)\n                end\n            end\n        end\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    xchips = 1 + card.ability.extra.xchips *\n                        JoyousSpring.count_materials_in_graveyard({ { monster_archetypes = { \"Shaddoll\" } } })\n                }\n            end\n        end\n    end,\n    joy_can_transfer_ability = function(self, other_card, card)\n        return JoyousSpring.is_summon_type(other_card, \"FUSION\")\n    end,\n    joy_transfer_config = function(self, other_card)\n        return { xchips = 0.01 }\n    end,\n    joy_transfer_loc_vars = function(self, info_queue, card, config)\n        return {\n            vars = { config.xchips, 1 + config.xchips *\n            JoyousSpring.count_materials_in_graveyard({ { monster_archetypes = { \"Shaddoll\" } } }) }\n        }\n    end,\n    joy_transfer_ability_calculate = function(self, other_card, context, config)\n        if JoyousSpring.can_use_abilities(other_card) then\n            if context.joker_main then\n                return {\n                    xchips = 1 + config.xchips *\n                        JoyousSpring.count_materials_in_graveyard({ { monster_archetypes = { \"Shaddoll\" } } })\n                }\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "shaddoll_shekh",
      "atlas": "shaddoll",
      "pos": {
        "x": 2,
        "y": 3
      },
      "raw": "key = \"shaddoll_shekh\",\n    atlas = 'shaddoll',\n    pos = { x = 2, y = 3 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 15,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return { vars = { card.ability.extra.adds } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_shaddoll_prison\", properties = { { monster_archetypes = { \"Shaddoll\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"FUSION\",\n                attribute = \"EARTH\",\n                monster_type = \"Machine\",\n                monster_archetypes = { [\"Shaddoll\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"FUSION\",\n                        materials = {\n                            { monster_type = \"Spellcaster\" },\n                            { monster_attribute = \"EARTH\" },\n                        },\n                    },\n                    {\n                        type = \"FUSION\",\n                        materials = {\n                            { monster_archetypes = { \"Shaddoll\" } },\n                            { monster_attribute = \"EARTH\" },\n                        },\n                    },\n                }\n            },\n            adds = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.used_as_material(card, context) then\n            local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Shaddoll\" }, is_extra_deck = true } })\n            for _ = 1, card.ability.extra.adds do\n                local key_to_add, _ = pseudorandom_element(choices, card.config.center.key)\n                if key_to_add and #JoyousSpring.extra_deck_area.cards < JoyousSpring.extra_deck_area.config.card_limit then\n                    JoyousSpring.add_to_extra_deck(key_to_add)\n                end\n            end\n        end\n        if (JoyousSpring.can_use_abilities(card) or card.joy_faceup_before_blind) and not context.blueprint_card and context.setting_blind and context.main_eval and G.GAME.blind and ((not G.GAME.blind.disabled) and (G.GAME.blind.boss)) then\n            G.GAME.blind:disable()\n        end\n    end,\n    joy_can_transfer_ability = function(self, other_card, card)\n        return JoyousSpring.is_summon_type(other_card, \"FUSION\")\n    end,\n    joy_transfer_ability_calculate = function(self, other_card, context, config)\n        if (JoyousSpring.can_use_abilities(other_card) or other_card.joy_faceup_before_blind) and not context.blueprint_card and context.setting_blind and context.main_eval and G.GAME.blind and ((not G.GAME.blind.disabled) and (G.GAME.blind.boss)) then\n            G.GAME.blind:disable()\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "shaddoll_wendigo",
      "atlas": "shaddoll",
      "pos": {
        "x": 3,
        "y": 3
      },
      "raw": "key = \"shaddoll_wendigo\",\n    atlas = 'shaddoll',\n    pos = { x = 3, y = 3 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 8,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return { vars = { card.ability.extra.adds } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_shaddoll_prison\", properties = { { monster_archetypes = { \"Shaddoll\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"FUSION\",\n                attribute = \"WIND\",\n                monster_type = \"Psychic\",\n                monster_archetypes = { [\"Shaddoll\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"FUSION\",\n                        materials = {\n                            { monster_type = \"Spellcaster\" },\n                            { monster_attribute = \"WIND\" },\n                        },\n                    },\n                    {\n                        type = \"FUSION\",\n                        materials = {\n                            { monster_archetypes = { \"Shaddoll\" } },\n                            { monster_attribute = \"WIND\" },\n                        },\n                    },\n                }\n            },\n            adds = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.used_as_material(card, context) then\n            local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Shaddoll\" }, is_extra_deck = true } })\n            for _ = 1, card.ability.extra.adds do\n                local key_to_add, _ = pseudorandom_element(choices, card.config.center.key)\n                if key_to_add and #JoyousSpring.extra_deck_area.cards < JoyousSpring.extra_deck_area.config.card_limit then\n                    JoyousSpring.add_to_extra_deck(key_to_add)\n                end\n            end\n        end\n    end,\n    joy_flip_effect_active = function(card, other_card)\n        return JoyousSpring.is_monster_archetype(other_card, \"Shaddoll\")\n    end,\n    joy_can_transfer_ability = function(self, other_card, card)\n        return JoyousSpring.is_summon_type(other_card, \"FUSION\")\n    end,\n    joy_transfer_flip_effect_active = function(self, ability_card, other_card, config)\n        return JoyousSpring.is_monster_archetype(other_card, \"Shaddoll\")\n    end"
    },
    {
      "type": "Joker",
      "key": "shaddoll_construct",
      "atlas": "shaddoll",
      "pos": {
        "x": 0,
        "y": 4
      },
      "raw": "key = \"shaddoll_construct\",\n    atlas = 'shaddoll',\n    pos = { x = 0, y = 4 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return { vars = { card.ability.extra.adds } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_shaddoll_prison\", properties = { { monster_archetypes = { \"Shaddoll\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"LINK\",\n                is_all_materials = { FUSION = true },\n                attribute = \"LIGHT\",\n                monster_type = \"Spellcaster\",\n                monster_archetypes = { [\"Shaddoll\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"LINK\",\n                        materials = {\n                            { facedown = true },\n                            { facedown = true },\n                        },\n                    },\n                    {\n                        type = \"LINK\",\n                        materials = {\n                            { is_flip = true },\n                            { is_flip = true },\n                        },\n                    },\n                    {\n                        type = \"LINK\",\n                        materials = {\n                            { facedown = true },\n                            { is_flip = true },\n                        },\n                    }\n                }\n            },\n            adds = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.used_as_material(card, context) then\n            local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Shaddoll\" }, is_extra_deck = true } })\n            for _ = 1, card.ability.extra.adds do\n                local key_to_add, _ = pseudorandom_element(choices, card.config.center.key)\n                if key_to_add and #JoyousSpring.extra_deck_area.cards < JoyousSpring.extra_deck_area.config.card_limit then\n                    JoyousSpring.add_to_extra_deck(key_to_add)\n                end\n            end\n        end\n    end,\n    joy_can_transfer_ability = function(self, other_card, card)\n        return JoyousSpring.is_summon_type(other_card, \"FUSION\")\n    end,\n    joy_transfer_add_to_deck = function(self, other_card, config, card, from_debuff, materials, was_material)\n        other_card.ability.extra.joyous_spring.is_all_materials.FUSION = true\n    end,"
    },
    {
      "type": "Joker",
      "key": "shaddoll_prison",
      "atlas": "shaddoll",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "key = \"shaddoll_prison\",\n    atlas = 'shaddoll',\n    pos = { x = 1, y = 2 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 7,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n        end\n        return { vars = { card.ability.extra.add_counter, card.ability.extra.counters, card.ability.extra.chips, card.ability.extra.chips * card.ability.extra.counters, card.ability.extra.remove, card.ability.extra.revives } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_shaddoll_prison\", properties = { { monster_archetypes = { \"Shaddoll\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_field_spell = true,\n            },\n            add_counter = 1,\n            chips = 5,\n            remove = 20,\n            revives = 1,\n            counters = 0\n        },\n    },\n    calculate = function(self, card, context)\n        if context.joy_sent_to_gy and (JoyousSpring.is_material_center(context.joy_key, { monster_archetypes = { \"Shaddoll\" } }) or JoyousSpring.is_material_center(context.joy_key, { is_flip = true }) or JoyousSpring.is_material_center(context.joy_key, { monster_type = \"Spellcaster\" })) then\n            card.ability.extra.counters = card.ability.extra.counters + card.ability.extra.add_counter\n        end\n        if context.joker_main then\n            return {\n                chips = card.ability.extra.chips * card.ability.extra.counters\n            }\n        end\n        if context.joy_activate_effect and context.joy_activated_card == card and card.ability.extra.counters >= card.ability.extra.remove and (#G.jokers.cards + G.GAME.joker_buffer < G.jokers.config.card_limit) then\n            card.ability.extra.counters = card.ability.extra.counters - card.ability.extra.remove\n            JoyousSpring.revive_pseudorandom({ { summon_type = \"FUSION\" } }, 'j_joy_shaddoll_prison', true)\n        end\n    end,\n    joy_can_activate = function(card)\n        if (card.ability.extra.counters < card.ability.extra.remove) or (#G.jokers.cards + G.GAME.joker_buffer >= G.jokers.config.card_limit) then\n            return false\n        end\n        return JoyousSpring.count_materials_in_graveyard({ { summon_type = \"FUSION\" } }, true) > 0\n    end,"
    },
    {
      "type": "Atlas",
      "key": "paleo",
      "atlas": null,
      "pos": null,
      "raw": "key = \"paleo\",\n    path = \"19Paleozoic.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Joker",
      "key": "paleo_canadia",
      "atlas": "paleo",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"paleo_canadia\",\n    atlas = 'paleo',\n    pos = { x = 0, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n        end\n        return { vars = { card.ability.extra.mult, card.ability.extra.current_mult, card.ability.extra.revives } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Paleozoic\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_flip = true,\n                is_trap = true,\n                attribute = \"WATER\",\n                monster_type = \"Aqua\",\n                monster_archetypes = { [\"Paleozoic\"] = true }\n            },\n            mult = 5,\n            current_mult = 0,\n            revives = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main and JoyousSpring.is_flip_active(card) then\n                return {\n                    mult = card.ability.extra.current_mult\n                }\n            end\n        end\n        if JoyousSpring.calculate_flip_effect(card, context) then\n            for i = 1, card.ability.extra.revives do\n                local has_cambro = next(SMODS.find_card(\"j_joy_paleo_cambro\")) and true or false\n                JoyousSpring.revive_pseudorandom({ { is_trap = true, monster_archetypes = { \"Paleozoic\" } } },\n                    'j_joy_paleo_canadia', not has_cambro, has_cambro and \"e_negative\" or nil)\n            end\n        end\n        if context.joy_card_flipped and context.joy_card_flipped.ability.set == \"Joker\" then\n            card.ability.extra.current_mult = card.ability.extra.current_mult + card.ability.extra.mult\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not JoyousSpring.is_perma_debuffed(card) then\n            if not from_debuff and JoyousSpring.should_trap_flip(card) then\n                card:flip(card)\n            end\n            SMODS.debuff_card(card, \"prevent_debuff\", \"j_joy_paleo_canadia\")\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "paleo_dino",
      "atlas": "paleo",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"paleo_dino\",\n    atlas = 'paleo',\n    pos = { x = 1, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_banish\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n        end\n        return { vars = { card.ability.extra.banishes, card.ability.extra.revives } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Paleozoic\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_flip = true,\n                is_trap = true,\n                attribute = \"WATER\",\n                monster_type = \"Aqua\",\n                monster_archetypes = { [\"Paleozoic\"] = true }\n            },\n            banishes = 1,\n            revives = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if JoyousSpring.is_flip_active(card) and not context.blueprint_card and context.end_of_round and context.game_over == false and context.main_eval then\n                JoyousSpring.banish(card, \"blind_selected\")\n                local choices = JoyousSpring.get_materials_owned({ { is_trap = true } })\n                local choices_exclude = {}\n\n                for _, joker in ipairs(choices) do\n                    if joker ~= card then\n                        table.insert(choices_exclude, joker)\n                    end\n                end\n\n                local to_banish = pseudorandom_element(choices_exclude, 'j_joy_paleo_dino')\n                if to_banish then\n                    JoyousSpring.banish(to_banish, \"blind_selected\")\n                end\n            end\n        end\n        if JoyousSpring.calculate_flip_effect(card, context) then\n            for i = 1, card.ability.extra.revives do\n                local has_cambro = next(SMODS.find_card(\"j_joy_paleo_cambro\")) and true or false\n                JoyousSpring.revive_pseudorandom({ { is_trap = true, monster_archetypes = { \"Paleozoic\" } } },\n                    'j_joy_paleo_dino', not has_cambro, has_cambro and \"e_negative\" or nil)\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not JoyousSpring.is_perma_debuffed(card) then\n            if not from_debuff and JoyousSpring.should_trap_flip(card) then\n                card:flip(card)\n            end\n            SMODS.debuff_card(card, \"prevent_debuff\", \"j_joy_paleo_dino\")\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "paleo_eldonia",
      "atlas": "paleo",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"paleo_eldonia\",\n    atlas = 'paleo',\n    pos = { x = 2, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 3,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n        end\n        return { vars = { card.ability.extra.chips, card.ability.extra.revives } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Paleozoic\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_flip = true,\n                is_trap = true,\n                attribute = \"WATER\",\n                monster_type = \"Aqua\",\n                monster_archetypes = { [\"Paleozoic\"] = true }\n            },\n            chips = 300,\n            revives = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main and JoyousSpring.is_flip_active(card) then\n                return {\n                    chips = card.ability.extra.chips\n                }\n            end\n        end\n        if JoyousSpring.calculate_flip_effect(card, context) then\n            for i = 1, card.ability.extra.revives do\n                local has_cambro = next(SMODS.find_card(\"j_joy_paleo_cambro\")) and true or false\n                JoyousSpring.revive_pseudorandom({ { is_trap = true, monster_archetypes = { \"Paleozoic\" } } },\n                    'j_joy_paleo_eldonia', not has_cambro, has_cambro and \"e_negative\" or nil)\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not JoyousSpring.is_perma_debuffed(card) then\n            if not from_debuff and JoyousSpring.should_trap_flip(card) then\n                card:flip(card)\n            end\n            SMODS.debuff_card(card, \"prevent_debuff\", \"j_joy_paleo_eldonia\")\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "paleo_hallu",
      "atlas": "paleo",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"paleo_hallu\",\n    atlas = 'paleo',\n    pos = { x = 3, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 3,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n        end\n        return { vars = { card.ability.extra.mult, card.ability.extra.revives } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Paleozoic\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_flip = true,\n                is_trap = true,\n                attribute = \"WATER\",\n                monster_type = \"Aqua\",\n                monster_archetypes = { [\"Paleozoic\"] = true }\n            },\n            mult = 50,\n            revives = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main and JoyousSpring.is_flip_active(card) then\n                return {\n                    mult = card.ability.extra.mult\n                }\n            end\n        end\n        if JoyousSpring.calculate_flip_effect(card, context) then\n            for i = 1, card.ability.extra.revives do\n                local has_cambro = next(SMODS.find_card(\"j_joy_paleo_cambro\")) and true or false\n                JoyousSpring.revive_pseudorandom({ { is_trap = true, monster_archetypes = { \"Paleozoic\" } } },\n                    'j_joy_paleo_hallu', not has_cambro, has_cambro and \"e_negative\" or nil)\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not JoyousSpring.is_perma_debuffed(card) then\n            if not from_debuff and JoyousSpring.should_trap_flip(card) then\n                card:flip(card)\n            end\n            SMODS.debuff_card(card, \"prevent_debuff\", \"j_joy_paleo_hallu\")\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "paleo_lean",
      "atlas": "paleo",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"paleo_lean\",\n    atlas = 'paleo',\n    pos = { x = 0, y = 1 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n        end\n        return { vars = { card.ability.extra.chips, card.ability.extra.current_chips, card.ability.extra.revives } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Paleozoic\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_flip = true,\n                is_trap = true,\n                attribute = \"WATER\",\n                monster_type = \"Aqua\",\n                monster_archetypes = { [\"Paleozoic\"] = true }\n            },\n            chips = 20,\n            current_chips = 0,\n            revives = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main and JoyousSpring.is_flip_active(card) then\n                return {\n                    chips = card.ability.extra.current_chips\n                }\n            end\n        end\n        if JoyousSpring.calculate_flip_effect(card, context) then\n            for i = 1, card.ability.extra.revives do\n                local has_cambro = next(SMODS.find_card(\"j_joy_paleo_cambro\")) and true or false\n                JoyousSpring.revive_pseudorandom({ { is_trap = true, monster_archetypes = { \"Paleozoic\" } } },\n                    'j_joy_paleo_lean', not has_cambro, has_cambro and \"e_negative\" or nil)\n            end\n        end\n        if context.joy_card_flipped and context.joy_card_flipped.ability.set == \"Joker\" then\n            card.ability.extra.current_chips = card.ability.extra.current_chips + card.ability.extra.chips\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not JoyousSpring.is_perma_debuffed(card) then\n            if not from_debuff and JoyousSpring.should_trap_flip(card) then\n                card:flip(card)\n            end\n            SMODS.debuff_card(card, \"prevent_debuff\", \"j_joy_paleo_lean\")\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "paleo_marrella",
      "atlas": "paleo",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"paleo_marrella\",\n    atlas = 'paleo',\n    pos = { x = 1, y = 1 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 7,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n        end\n        return { vars = { card.ability.extra.revives, card.ability.extra.mills } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Paleozoic\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_flip = true,\n                is_trap = true,\n                attribute = \"WATER\",\n                monster_type = \"Aqua\",\n                monster_archetypes = { [\"Paleozoic\"] = true }\n            },\n            revives = 1,\n            mills = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.calculate_flip_effect(card, context) then\n            for i = 1, card.ability.extra.revives do\n                local has_cambro = next(SMODS.find_card(\"j_joy_paleo_cambro\")) and true or false\n                JoyousSpring.revive_pseudorandom({ { is_trap = true, monster_archetypes = { \"Paleozoic\" } } },\n                    'j_joy_paleo_marrella', not has_cambro, has_cambro and \"e_negative\" or nil)\n            end\n            local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Paleozoic\" }, is_main_deck = true } })\n\n            for i = 1, card.ability.extra.mills do\n                JoyousSpring.send_to_graveyard(pseudorandom_element(choices, 'j_joy_paleo_marrella'))\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not JoyousSpring.is_perma_debuffed(card) then\n            if not from_debuff and JoyousSpring.should_trap_flip(card) then\n                card:flip(card)\n            end\n            SMODS.debuff_card(card, \"prevent_debuff\", \"j_joy_paleo_marrella\")\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "paleo_oleno",
      "atlas": "paleo",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"paleo_oleno\",\n    atlas = 'paleo',\n    pos = { x = 2, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 3,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n        end\n        return { vars = { card.ability.extra.discards, card.ability.extra.revives } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Paleozoic\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_flip = true,\n                is_trap = true,\n                attribute = \"WATER\",\n                monster_type = \"Aqua\",\n                monster_archetypes = { [\"Paleozoic\"] = true }\n            },\n            discards = 1,\n            revives = 1,\n            activated = false\n        },\n    },\n    calculate = function(self, card, context)\n        if card.ability.extra.activated and context.end_of_round and context.game_over == false and context.main_eval then\n            card.ability.extra.activated = false\n            G.GAME.round_resets.discards = G.GAME.round_resets.discards - card.ability.extra.discards\n            ease_discard(-card.ability.extra.discards)\n        end\n        if JoyousSpring.calculate_flip_effect(card, context) then\n            for i = 1, card.ability.extra.revives do\n                local has_cambro = next(SMODS.find_card(\"j_joy_paleo_cambro\")) and true or false\n                JoyousSpring.revive_pseudorandom({ { is_trap = true, monster_archetypes = { \"Paleozoic\" } } },\n                    'j_joy_paleo_oleno', not has_cambro, has_cambro and \"e_negative\" or nil)\n            end\n            if not card.ability.extra.activated then\n                card.ability.extra.activated = true\n                G.GAME.round_resets.discards = G.GAME.round_resets.discards + card.ability.extra.discards\n                ease_discard(card.ability.extra.discards)\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not JoyousSpring.is_perma_debuffed(card) then\n            if not from_debuff and JoyousSpring.should_trap_flip(card) then\n                card:flip(card)\n            end\n            SMODS.debuff_card(card, \"prevent_debuff\", \"j_joy_paleo_oleno\")\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        if card.ability.extra.activated then\n            card.ability.extra.activated = false\n            G.GAME.round_resets.discards = G.GAME.round_resets.discards - card.ability.extra.discards\n            ease_discard(-card.ability.extra.discards)\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "paleo_pikaia",
      "atlas": "paleo",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"paleo_pikaia\",\n    atlas = 'paleo',\n    pos = { x = 3, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 3,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n        end\n        return { vars = { card.ability.extra.h_size, card.ability.extra.revives } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Paleozoic\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_flip = true,\n                is_trap = true,\n                attribute = \"WATER\",\n                monster_type = \"Aqua\",\n                monster_archetypes = { [\"Paleozoic\"] = true }\n            },\n            h_size = 2,\n            revives = 1,\n            activated = false\n        },\n    },\n    calculate = function(self, card, context)\n        if card.ability.extra.activated and context.end_of_round and context.game_over == false and context.main_eval then\n            card.ability.extra.activated = false\n            G.hand:change_size(-card.ability.extra.h_size)\n        end\n        if JoyousSpring.calculate_flip_effect(card, context) then\n            for i = 1, card.ability.extra.revives do\n                local has_cambro = next(SMODS.find_card(\"j_joy_paleo_cambro\")) and true or false\n                JoyousSpring.revive_pseudorandom({ { is_trap = true, monster_archetypes = { \"Paleozoic\" } } },\n                    'j_joy_paleo_pikaia', not has_cambro, has_cambro and \"e_negative\" or nil)\n            end\n            if not card.ability.extra.activated then\n                card.ability.extra.activated = true\n                G.hand:change_size(card.ability.extra.h_size)\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not JoyousSpring.is_perma_debuffed(card) then\n            if not from_debuff and JoyousSpring.should_trap_flip(card) then\n                card:flip(card)\n            end\n            SMODS.debuff_card(card, \"prevent_debuff\", \"j_joy_paleo_pikaia\")\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        if card.ability.extra.activated then\n            card.ability.extra.activated = false\n            G.hand:change_size(-card.ability.extra.h_size)\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "paleo_cambro",
      "atlas": "paleo",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "key = \"paleo_cambro\",\n    atlas = 'paleo',\n    pos = { x = 2, y = 2 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n        end\n        return { vars = { card.ability.extra.adds } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Paleozoic\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"LINK\",\n                attribute = \"WATER\",\n                monster_type = \"Aqua\",\n                monster_archetypes = { [\"Paleozoic\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"LINK\",\n                        materials = {\n                            { monster_archetypes = { \"Paleozoic\" } },\n                            { monster_archetypes = { \"Paleozoic\" } },\n                        },\n                    }\n                }\n            },\n            adds = 1,\n        },\n    },\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff then\n            SMODS.debuff_card(card, \"prevent_debuff\", \"j_joy_paleo_cambro\")\n        end\n        if not card.debuff and not from_debuff then\n            for i = 1, card.ability.extra.adds do\n                local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Paleozoic\" }, summon_type = \"XYZ\" } })\n                for i = 1, card.ability.extra.adds do\n                    local key_to_add, _ = pseudorandom_element(choices, 'j_joy_paleo_cambro')\n                    if key_to_add and #JoyousSpring.extra_deck_area.cards < JoyousSpring.extra_deck_area.config.card_limit then\n                        JoyousSpring.add_to_extra_deck(key_to_add)\n                    end\n                end\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "paleo_anomalo",
      "atlas": "paleo",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "key = \"paleo_anomalo\",\n    atlas = 'paleo',\n    pos = { x = 1, y = 2 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 8,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_detach\" }\n        end\n        return { vars = { card.ability.extra.detach, card.ability.extra.xmult, card.ability.extra.current_xmult, card.ability.extra.attach } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Paleozoic\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    update = JoyousSpring.update_counter,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"XYZ\",\n                attribute = \"WATER\",\n                monster_type = \"Aqua\",\n                monster_archetypes = { [\"Paleozoic\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"XYZ\",\n                        materials = {\n                            { min = 3, is_trap = true },\n                        },\n                    }\n                }\n            },\n            detach = 3,\n            xmult = 5,\n            current_xmult = 1,\n            attach = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.joy_detach and context.joy_detaching_card == card then\n                JoyousSpring.ease_detach(card)\n\n                card.ability.extra.current_xmult = card.ability.extra.current_xmult + card.ability.extra.xmult\n            end\n            if context.joy_card_flipped and JoyousSpring.is_trap_monster(context.joy_card_flipped) and context.joy_card_flipped.facing == \"front\" then\n                card.ability.extra.joyous_spring.xyz_materials = card.ability.extra.joyous_spring.xyz_materials + 1\n            end\n            if context.joker_main then\n                return {\n                    xmult = card.ability.extra.current_xmult\n                }\n            end\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval then\n            card.ability.extra.current_xmult = 1\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff then\n            SMODS.debuff_card(card, \"prevent_debuff\", \"j_joy_paleo_anomalo\")\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "paleo_opa",
      "atlas": "paleo",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = \"paleo_opa\",\n    atlas = 'paleo',\n    pos = { x = 0, y = 2 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 7,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_detach\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_main_deck_joker\" }\n        end\n        return { vars = { card.ability.extra.detach, card.ability.extra.creates } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Paleozoic\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    update = JoyousSpring.update_counter,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"XYZ\",\n                attribute = \"WATER\",\n                monster_type = \"Aqua\",\n                monster_archetypes = { [\"Paleozoic\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"XYZ\",\n                        materials = {\n                            { monster_attribute = \"WATER\", exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                            { monster_attribute = \"WATER\", exclude_summon_types = { \"XYZ\", \"LINK\" } }\n                        },\n                    }\n                }\n            },\n            detach = 1,\n            creates = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.joy_detach and context.joy_detaching_card == card then\n                if #G.jokers.cards + G.GAME.joker_buffer < G.jokers.config.card_limit then\n                    JoyousSpring.ease_detach(card)\n                end\n\n                JoyousSpring.create_pseudorandom({ { is_main_deck = true, monster_archetypes = { \"Paleozoic\" } } },\n                    'j_joy_paleo_opa', true)\n            end\n            if context.setting_blind and context.main_eval then\n                for _, joker in ipairs(G.jokers.cards) do\n                    if JoyousSpring.is_trap_monster(joker) and joker.facing == \"back\" then\n                        joker:flip()\n                    end\n                end\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff then\n            SMODS.debuff_card(card, \"prevent_debuff\", \"j_joy_paleo_opa\")\n        end\n    end"
    },
    {
      "type": "Atlas",
      "key": "invoked",
      "atlas": null,
      "pos": null,
      "raw": "key = \"invoked\",\n    path = \"20Invoked.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Joker",
      "key": "invoked_aleister",
      "atlas": "invoked",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"invoked_aleister\",\n    atlas = 'invoked',\n    pos = { x = 0, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 8,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_tribute\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_transform\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return { vars = { card.ability.extra.tributes, card.ability.extra.chips } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_invoked_meltdown\", properties = { { monster_archetypes = { \"Aleister\" } }, { monster_archetypes = { \"Invoked\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Spellcaster\",\n                monster_archetypes = { [\"Aleister\"] = true }\n            },\n            tributes = 1,\n            chips = 50\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card then\n                if context.joy_activate_effect and context.joy_activated_card == card then\n                    local materials = {}\n                    for i, joker in ipairs(G.jokers.cards) do\n                        if joker ~= card and not joker.ability.eternal then\n                            materials[#materials + 1] = joker\n                        end\n                    end\n                    if next(materials) then\n                        JoyousSpring.create_overlay_effect_selection(card, materials, card.ability.extra.tributes,\n                            card.ability.extra.tributes)\n                    end\n                end\n                if context.joy_exit_effect_selection and context.joy_card == card and\n                    #context.joy_selection >= 1 then\n                    aleister_transform(card, context.joy_selection[1])\n                end\n            end\n        end\n    end,\n    joy_can_activate = function(card)\n        for i, joker in ipairs(G.jokers.cards) do\n            if joker ~= card and not joker.ability.eternal then\n                return true\n            end\n        end\n        return false\n    end,\n    joy_can_transfer_ability = function(self, other_card, card)\n        return JoyousSpring.is_summon_type(other_card, \"FUSION\")\n    end,\n    joy_transfer_ability_calculate = function(self, other_card, context, config)\n        if JoyousSpring.can_use_abilities(other_card) and context.joker_main then\n            return {\n                chips = config.chips * JoyousSpring.get_summoned_count(\"FUSION\")\n            }\n        end\n    end,\n    joy_transfer_config = function(self, other_card)\n        return { chips = 50 }\n    end,\n    joy_transfer_loc_vars = function(self, info_queue, card, config)\n        return { vars = { config.chips, config.chips * JoyousSpring.get_summoned_count(\"FUSION\") } }\n    end"
    },
    {
      "type": "Joker",
      "key": "invoked_madness",
      "atlas": "invoked",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "key = \"invoked_madness\",\n    atlas = 'invoked',\n    pos = { x = 2, y = 2 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_tribute\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_transform\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return { vars = { card.ability.extra.tributes, card.ability.extra.creates, card.ability.extra.mult } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_invoked_meltdown\", properties = { { monster_archetypes = { \"Aleister\" } }, { monster_archetypes = { \"Invoked\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"LINK\",\n                attribute = \"DARK\",\n                monster_type = \"Spellcaster\",\n                monster_archetypes = { [\"Aleister\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"LINK\",\n                        materials = {\n                            {},\n                            {},\n                        },\n                        restrictions = {\n                            different_attributes = true,\n                            different_types = true\n                        }\n                    }\n                }\n            },\n            tributes = 1,\n            creates = 1,\n            mult = 15\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card then\n                if context.joy_activate_effect and context.joy_activated_card == card then\n                    local materials = {}\n                    for i, joker in ipairs(G.jokers.cards) do\n                        if joker ~= card and not joker.ability.eternal then\n                            materials[#materials + 1] = joker\n                        end\n                    end\n                    if next(materials) then\n                        JoyousSpring.create_overlay_effect_selection(card, materials, card.ability.extra.tributes,\n                            card.ability.extra.tributes)\n                    end\n                end\n                if context.joy_exit_effect_selection and context.joy_card == card and\n                    #context.joy_selection >= 1 then\n                    aleister_transform(card, context.joy_selection[1])\n                end\n            end\n        end\n        if (JoyousSpring.used_as_material(card, context) and JoyousSpring.is_summon_type(context.joy_card, \"FUSION\")) or\n            (context.joy_transform_summon and context.joy_card == card) then\n            if #JoyousSpring.field_spell_area.cards < JoyousSpring.field_spell_area.config.card_limit then\n                JoyousSpring.add_to_extra_deck(\"j_joy_invoked_meltdown\")\n            end\n        end\n    end,\n    joy_can_activate = function(card)\n        for i, joker in ipairs(G.jokers.cards) do\n            if joker ~= card and not joker.ability.eternal then\n                return true\n            end\n        end\n        return false\n    end,\n    joy_can_transfer_ability = function(self, other_card, card)\n        return JoyousSpring.is_summon_type(other_card, \"FUSION\")\n    end,\n    joy_transfer_ability_calculate = function(self, other_card, context, config)\n        if JoyousSpring.can_use_abilities(other_card) and context.joker_main then\n            return {\n                mult = config.mult * JoyousSpring.get_summoned_count(\"FUSION\")\n            }\n        end\n    end,\n    joy_transfer_config = function(self, other_card)\n        return { mult = 15 }\n    end,\n    joy_transfer_loc_vars = function(self, info_queue, card, config)\n        return { vars = { config.mult, config.mult * JoyousSpring.get_summoned_count(\"FUSION\") } }\n    end"
    },
    {
      "type": "Joker",
      "key": "invoked_caliga",
      "atlas": "invoked",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"invoked_caliga\",\n    atlas = 'invoked',\n    pos = { x = 3, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 8,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_tribute\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_transform\" }\n        end\n        return { vars = { card.ability.extra.tributes, card.ability.extra.xmult, 1 + card.ability.extra.xmult * JoyousSpring.count_set_tributed(\"Joker\", true), card.ability.extra.reduces } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_invoked_meltdown\", properties = { { monster_archetypes = { \"Aleister\" } }, { monster_archetypes = { \"Invoked\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"FUSION\",\n                attribute = \"DARK\",\n                monster_type = \"Beast\",\n                monster_archetypes = { [\"Invoked\"] = true }\n            },\n            tributes = 1,\n            xmult = 0.1,\n            reduces = 2\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card then\n                if context.joy_activate_effect and context.joy_activated_card == card and not card.ability.eternal then\n                    local materials = {}\n                    for i, joker in ipairs(G.jokers.cards) do\n                        if joker ~= card and not joker.ability.eternal then\n                            materials[#materials + 1] = joker\n                        end\n                    end\n                    if next(materials) then\n                        JoyousSpring.create_overlay_effect_selection(card, materials, card.ability.extra.tributes,\n                            card.ability.extra.tributes)\n                    end\n                end\n                if context.joy_exit_effect_selection and context.joy_card == card and\n                    #context.joy_selection >= 1 then\n                    invoked_detransform(card, context.joy_selection[1])\n                end\n            end\n            if context.joker_main then\n                return {\n                    xmult = 1 + card.ability.extra.xmult * JoyousSpring.count_set_tributed(\"Joker\", true)\n                }\n            end\n        end\n    end,\n    joy_can_activate = function(card)\n        for i, joker in ipairs(G.jokers.cards) do\n            if joker ~= card and not joker.ability.eternal then\n                return true\n            end\n        end\n        return false\n    end,\n    joy_modify_cost = function(card, other_card)\n        if other_card.ability.set == \"Booster\" and other_card.config.center.kind == \"JoyousSpring\" then\n            other_card.cost = math.max(0, other_card.cost - card.ability.extra.reduces)\n        end\n    end,\n    joy_transfer_modify_cost = function(self, ability_card, other_card, config)\n        if other_card.ability.set == \"Booster\" and other_card.config.center.kind == \"JoyousSpring\" then\n            other_card.cost = math.max(0, other_card.cost - config.reduces)\n        end\n    end,\n    in_pool = function(self, args)\n        return args and args.source and args.source == \"JoyousSpring\" or false\n    end,\n    joy_can_transfer_ability = function(self, other_card, card)\n        return other_card.config.center.key == \"j_joy_invoked_elysium\"\n    end,\n    joy_transfer_ability_calculate = function(self, other_card, context, config)\n        if JoyousSpring.can_use_abilities(other_card) and context.joker_main then\n            return {\n                xmult = 1 + config.xmult * JoyousSpring.count_set_tributed(\"Joker\", true)\n            }\n        end\n    end,\n    joy_transfer_config = function(self, other_card)\n        return {\n            xmult = 0.1,\n            reduces = 2\n        }\n    end,\n    joy_transfer_loc_vars = function(self, info_queue, card, config)\n        return { vars = { config.xmult, config.xmult * JoyousSpring.count_set_tributed(\"Joker\", true), config.reduces } }\n    end"
    },
    {
      "type": "Joker",
      "key": "invoked_raidjin",
      "atlas": "invoked",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "key = \"invoked_raidjin\",\n    atlas = 'invoked',\n    pos = { x = 1, y = 2 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 8,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_tribute\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_transform\" }\n        end\n        return { vars = { card.ability.extra.tributes, card.ability.extra.xmult, 1 + card.ability.extra.xmult * JoyousSpring.get_flipped_count(\"Joker\"), card.ability.extra.flips } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_invoked_meltdown\", properties = { { monster_archetypes = { \"Aleister\" } }, { monster_archetypes = { \"Invoked\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"FUSION\",\n                attribute = \"WIND\",\n                monster_type = \"Warrior\",\n                monster_archetypes = { [\"Invoked\"] = true }\n            },\n            tributes = 1,\n            xmult = 0.1,\n            flips = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card then\n                if context.joy_activate_effect and context.joy_activated_card == card and not card.ability.eternal then\n                    local materials = {}\n                    for i, joker in ipairs(G.jokers.cards) do\n                        if joker ~= card and not joker.ability.eternal then\n                            materials[#materials + 1] = joker\n                        end\n                    end\n                    if next(materials) then\n                        JoyousSpring.create_overlay_effect_selection(card, materials, card.ability.extra.tributes,\n                            card.ability.extra.tributes)\n                    end\n                end\n                if context.joy_exit_effect_selection and context.joy_card == card and\n                    #context.joy_selection >= 1 then\n                    invoked_detransform(card, context.joy_selection[1])\n                end\n            end\n            if (context.setting_blind or (context.end_of_round and context.game_over == false)) and context.main_eval then\n                local cards = {}\n                local facing = context.end_of_round and \"front\" or \"back\"\n                for _, joker in ipairs(G.jokers.cards) do\n                    if joker ~= card and joker.facing == facing then\n                        table.insert(cards, joker)\n                    end\n                end\n                local card_to_flip = pseudorandom_element(cards, 'j_joy_invoked_raidjin')\n                if card_to_flip then card_to_flip:flip() end\n            end\n            if context.joker_main then\n                return {\n                    xmult = 1 + card.ability.extra.xmult * JoyousSpring.get_flipped_count(\"Joker\")\n                }\n            end\n        end\n    end,\n    joy_can_activate = function(card)\n        for i, joker in ipairs(G.jokers.cards) do\n            if joker ~= card and not joker.ability.eternal then\n                return true\n            end\n        end\n        return false\n    end,\n    in_pool = function(self, args)\n        return args and args.source and args.source == \"JoyousSpring\" or false\n    end,\n    joy_can_transfer_ability = function(self, other_card, card)\n        return other_card.config.center.key == \"j_joy_invoked_elysium\"\n    end,\n    joy_transfer_ability_calculate = function(self, other_card, context, config)\n        if JoyousSpring.can_use_abilities(other_card) then\n            if context.joker_main then\n                return {\n                    xmult = 1 + config.xmult * JoyousSpring.get_flipped_count(\"Joker\")\n                }\n            end\n            if (context.setting_blind or (context.end_of_round and context.game_over == false)) and context.main_eval then\n                local cards = {}\n                local facing = context.end_of_round and \"front\" or \"back\"\n                for _, joker in ipairs(G.jokers.cards) do\n                    if joker ~= other_card and joker.facing == facing then\n                        table.insert(cards, joker)\n                    end\n                end\n                local card_to_flip = pseudorandom_element(cards, 'j_joy_invoked_raidjin')\n                if card_to_flip then card_to_flip:flip() end\n            end\n        end\n    end,\n    joy_transfer_config = function(self, other_card)\n        return {\n            xmult = 0.1,\n            flips = 1\n        }\n    end,\n    joy_transfer_loc_vars = function(self, info_queue, card, config)\n        return { vars = { config.xmult, 1 + config.xmult * JoyousSpring.get_flipped_count(\"Joker\"), config.flips } }\n    end"
    },
    {
      "type": "Joker",
      "key": "invoked_cocytus",
      "atlas": "invoked",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"invoked_cocytus\",\n    atlas = 'invoked',\n    pos = { x = 0, y = 1 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 8,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_tribute\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_transform\" }\n        end\n        return { vars = { card.ability.extra.tributes, card.ability.extra.percent * 100 } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_invoked_meltdown\", properties = { { monster_archetypes = { \"Aleister\" } }, { monster_archetypes = { \"Invoked\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"FUSION\",\n                attribute = \"WATER\",\n                monster_type = \"Dragon\",\n                monster_archetypes = { [\"Invoked\"] = true }\n            },\n            tributes = 1,\n            percent = 0.1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card then\n                if context.joy_activate_effect and context.joy_activated_card == card and not card.ability.eternal then\n                    local materials = {}\n                    for i, joker in ipairs(G.jokers.cards) do\n                        if joker ~= card and not joker.ability.eternal then\n                            materials[#materials + 1] = joker\n                        end\n                    end\n                    if next(materials) then\n                        JoyousSpring.create_overlay_effect_selection(card, materials, card.ability.extra.tributes,\n                            card.ability.extra.tributes)\n                    end\n                end\n                if context.joy_exit_effect_selection and context.joy_card == card and\n                    #context.joy_selection >= 1 then\n                    invoked_detransform(card, context.joy_selection[1])\n                end\n            end\n            if context.setting_blind and context.main_eval then\n                G.GAME.blind.chips = math.floor(G.GAME.blind.chips - G.GAME.blind.chips * card.ability.extra.percent)\n                G.GAME.blind.chip_text = number_format(G.GAME.blind.chips)\n                return {\n                    message = localize(\"k_active_ex\")\n                }\n            end\n        end\n    end,\n    joy_can_activate = function(card)\n        for i, joker in ipairs(G.jokers.cards) do\n            if joker ~= card and not joker.ability.eternal then\n                return true\n            end\n        end\n        return false\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and G.GAME.blind.in_blind then\n            G.GAME.blind.chips = math.floor(G.GAME.blind.chips -\n                G.GAME.blind.chips * card.ability.extra.percent)\n            G.GAME.blind.chip_text = number_format(G.GAME.blind.chips)\n        end\n    end,\n    in_pool = function(self, args)\n        return args and args.source and args.source == \"JoyousSpring\" or false\n    end,\n    joy_can_transfer_ability = function(self, other_card, card)\n        return other_card.config.center.key == \"j_joy_invoked_elysium\"\n    end,\n    joy_transfer_ability_calculate = function(self, other_card, context, config)\n        if JoyousSpring.can_use_abilities(other_card) then\n            if context.setting_blind and context.main_eval then\n                G.GAME.blind.chips = math.floor(G.GAME.blind.chips - G.GAME.blind.chips * config.percent)\n                G.GAME.blind.chip_text = number_format(G.GAME.blind.chips)\n                return {\n                    message = localize(\"k_active_ex\")\n                }\n            end\n        end\n    end,\n    joy_transfer_config = function(self, other_card)\n        return {\n            percent = 0.1\n        }\n    end,\n    joy_transfer_loc_vars = function(self, info_queue, card, config)\n        return { vars = { config.percent * 100 } }\n    end"
    },
    {
      "type": "Joker",
      "key": "invoked_purgatorio",
      "atlas": "invoked",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = \"invoked_purgatorio\",\n    atlas = 'invoked',\n    pos = { x = 0, y = 2 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 8,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_tribute\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_transform\" }\n        end\n        return { vars = { card.ability.extra.tributes, card.ability.extra.xmult } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_invoked_meltdown\", properties = { { monster_archetypes = { \"Aleister\" } }, { monster_archetypes = { \"Invoked\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"FUSION\",\n                attribute = \"FIRE\",\n                monster_type = \"Fiend\",\n                monster_archetypes = { [\"Invoked\"] = true }\n            },\n            tributes = 1,\n            xmult = 2\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card then\n                if context.joy_activate_effect and context.joy_activated_card == card and not card.ability.eternal then\n                    local materials = {}\n                    for i, joker in ipairs(G.jokers.cards) do\n                        if joker ~= card and not joker.ability.eternal then\n                            materials[#materials + 1] = joker\n                        end\n                    end\n                    if next(materials) then\n                        JoyousSpring.create_overlay_effect_selection(card, materials, card.ability.extra.tributes,\n                            card.ability.extra.tributes)\n                    end\n                end\n                if context.joy_exit_effect_selection and context.joy_card == card and\n                    #context.joy_selection >= 1 then\n                    invoked_detransform(card, context.joy_selection[1])\n                end\n            end\n            if context.other_joker and context.other_joker.facing == \"front\" and JoyousSpring.is_summon_type(context.other_joker, \"FUSION\") then\n                return {\n                    xmult = card.ability.extra.xmult,\n                    message_card = context.other_joker\n                }\n            end\n        end\n    end,\n    joy_can_activate = function(card)\n        for i, joker in ipairs(G.jokers.cards) do\n            if joker ~= card and not joker.ability.eternal then\n                return true\n            end\n        end\n        return false\n    end,\n    in_pool = function(self, args)\n        return args and args.source and args.source == \"JoyousSpring\" or false\n    end,\n    joy_can_transfer_ability = function(self, other_card, card)\n        return other_card.config.center.key == \"j_joy_invoked_elysium\"\n    end,\n    joy_transfer_ability_calculate = function(self, other_card, context, config)\n        if JoyousSpring.can_use_abilities(other_card) and context.other_joker and context.other_joker.facing == \"front\" and JoyousSpring.is_summon_type(context.other_joker, \"FUSION\") then\n            return {\n                xmult = config.xmult,\n                message_card = context.other_joker\n            }\n        end\n    end,\n    joy_transfer_config = function(self, other_card)\n        return {\n            xmult = 2,\n        }\n    end,\n    joy_transfer_loc_vars = function(self, info_queue, card, config)\n        return { vars = { config.xmult } }\n    end"
    },
    {
      "type": "Joker",
      "key": "invoked_mage",
      "atlas": "invoked",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"invoked_mage\",\n    atlas = 'invoked',\n    pos = { x = 2, y = 1 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 8,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_tribute\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_transform\" }\n        end\n        return { vars = { card.ability.extra.tributes, card.ability.extra.mult } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_invoked_meltdown\", properties = { { monster_archetypes = { \"Aleister\" } }, { monster_archetypes = { \"Invoked\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"FUSION\",\n                attribute = \"EARTH\",\n                monster_type = \"Rock\",\n                monster_archetypes = { [\"Invoked\"] = true }\n            },\n            tributes = 1,\n            mult = 50\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card then\n                if context.joy_activate_effect and context.joy_activated_card == card and not card.ability.eternal then\n                    local materials = {}\n                    for i, joker in ipairs(G.jokers.cards) do\n                        if joker ~= card and not joker.ability.eternal then\n                            materials[#materials + 1] = joker\n                        end\n                    end\n                    if next(materials) then\n                        JoyousSpring.create_overlay_effect_selection(card, materials, card.ability.extra.tributes,\n                            card.ability.extra.tributes)\n                    end\n                end\n                if context.joy_exit_effect_selection and context.joy_card == card and\n                    #context.joy_selection >= 1 then\n                    invoked_detransform(card, context.joy_selection[1])\n                end\n            end\n            if context.joker_main then\n                return {\n                    mult = card.ability.extra.mult\n                }\n            end\n        end\n    end,\n    joy_can_activate = function(card)\n        for i, joker in ipairs(G.jokers.cards) do\n            if joker ~= card and not joker.ability.eternal then\n                return true\n            end\n        end\n        return false\n    end,\n    in_pool = function(self, args)\n        return args and args.source and args.source == \"JoyousSpring\" or false\n    end,\n    joy_can_transfer_ability = function(self, other_card, card)\n        return other_card.config.center.key == \"j_joy_invoked_elysium\"\n    end,\n    joy_transfer_ability_calculate = function(self, other_card, context, config)\n        if JoyousSpring.can_use_abilities(other_card) and context.joker_main then\n            return {\n                mult = config.mult\n            }\n        end\n    end,\n    joy_transfer_config = function(self, other_card)\n        return {\n            mult = 100,\n        }\n    end,\n    joy_transfer_loc_vars = function(self, info_queue, card, config)\n        return { vars = { config.mult } }\n    end"
    },
    {
      "type": "Joker",
      "key": "invoked_mechaba",
      "atlas": "invoked",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"invoked_mechaba\",\n    atlas = 'invoked',\n    pos = { x = 3, y = 1 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 8,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_tribute\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_transform\" }\n        end\n        return { vars = { card.ability.extra.tributes, card.ability.extra.sell, card.ability.extra.sold } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_invoked_meltdown\", properties = { { monster_archetypes = { \"Aleister\" } }, { monster_archetypes = { \"Invoked\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"FUSION\",\n                attribute = \"LIGHT\",\n                monster_type = \"Machine\",\n                monster_archetypes = { [\"Invoked\"] = true }\n            },\n            tributes = 1,\n            sell = 3,\n            sold = 0,\n            activated = false\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card then\n                if context.joy_activate_effect and context.joy_activated_card == card and not card.ability.eternal then\n                    local materials = {}\n                    for i, joker in ipairs(G.jokers.cards) do\n                        if joker ~= card and not joker.ability.eternal then\n                            materials[#materials + 1] = joker\n                        end\n                    end\n                    if next(materials) then\n                        JoyousSpring.create_overlay_effect_selection(card, materials, card.ability.extra.tributes,\n                            card.ability.extra.tributes)\n                    end\n                end\n                if context.joy_exit_effect_selection and context.joy_card == card and\n                    #context.joy_selection >= 1 then\n                    invoked_detransform(card, context.joy_selection[1])\n                end\n            end\n            if context.selling_card and context.card ~= card then\n                card.ability.extra.sold = card.ability.extra.sold + 1\n                if not card.ability.extra.activated and card.ability.extra.sold >= card.ability.extra.sell then\n                    card.ability.extra.activated = true\n                    G.GAME.blind:disable()\n                    return { message = localize('ph_boss_disabled') }\n                end\n            end\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval then\n            card.ability.extra.sold = 0\n            card.ability.extra.activated = false\n        end\n    end,\n    joy_can_activate = function(card)\n        for i, joker in ipairs(G.jokers.cards) do\n            if joker ~= card and not joker.ability.eternal then\n                return true\n            end\n        end\n        return false\n    end,\n    in_pool = function(self, args)\n        return args and args.source and args.source == \"JoyousSpring\" or false\n    end,\n    joy_can_transfer_ability = function(self, other_card, card)\n        return other_card.config.center.key == \"j_joy_invoked_elysium\"\n    end,\n    joy_transfer_ability_calculate = function(self, other_card, context, config)\n        if JoyousSpring.can_use_abilities(other_card) then\n            if context.selling_card and context.card ~= card then\n                config.sold = config.sold + 1\n                if not config.activated and config.sold >= config.sell then\n                    config.activated = true\n                    G.GAME.blind:disable()\n                    return { message = localize('ph_boss_disabled') }\n                end\n            end\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval then\n            config.sold = 0\n            config.activated = false\n        end\n    end,\n    joy_transfer_config = function(self, other_card)\n        return {\n            sell = 3,\n            sold = 0,\n            activated = false\n        }\n    end,\n    joy_transfer_loc_vars = function(self, info_queue, card, config)\n        return { vars = { config.sell, config.sold } }\n    end"
    },
    {
      "type": "Joker",
      "key": "invoked_augo",
      "atlas": "invoked",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"invoked_augo\",\n    atlas = 'invoked',\n    pos = { x = 2, y = 0 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_tribute\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_transform\" }\n        end\n        return { vars = { card.ability.extra.tributes, card.ability.extra.xmult, 1 + card.ability.extra.xmult * JoyousSpring.count_materials_in_graveyard({ { summon_type = \"FUSION\" } }), card.ability.extra.mills } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_invoked_meltdown\", properties = { { monster_archetypes = { \"Aleister\" } }, { monster_archetypes = { \"Invoked\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"FUSION\",\n                attribute = \"LIGHT\",\n                monster_type = \"Fairy\",\n                monster_archetypes = { [\"Invoked\"] = true }\n            },\n            tributes = 1,\n            xmult = 0.1,\n            mills = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card then\n                if context.joy_activate_effect and context.joy_activated_card == card and not card.ability.eternal then\n                    local materials = {}\n                    for i, joker in ipairs(G.jokers.cards) do\n                        if joker ~= card and not joker.ability.eternal then\n                            materials[#materials + 1] = joker\n                        end\n                    end\n                    if next(materials) then\n                        JoyousSpring.create_overlay_effect_selection(card, materials, card.ability.extra.tributes,\n                            card.ability.extra.tributes)\n                    end\n                end\n                if context.joy_exit_effect_selection and context.joy_card == card and\n                    #context.joy_selection >= 1 then\n                    invoked_detransform(card, context.joy_selection[1])\n                end\n            end\n            if context.setting_blind and context.main_eval then\n                local choices = JoyousSpring.get_materials_in_collection({ { summon_type = \"FUSION\", exclude_monster_archetypes = { \"Invoked\" } } })\n\n                for i = 1, card.ability.extra.mills do\n                    JoyousSpring.send_to_graveyard(pseudorandom_element(choices, 'j_joy_invoked_augo'))\n                end\n                return { message = localize(\"k_joy_mill\") }\n            end\n            if context.joker_main then\n                return {\n                    xmult = 1 +\n                        card.ability.extra.xmult *\n                        JoyousSpring.count_materials_in_graveyard({ { summon_type = \"FUSION\" } })\n                }\n            end\n        end\n    end,\n    joy_can_activate = function(card)\n        for i, joker in ipairs(G.jokers.cards) do\n            if joker ~= card and not joker.ability.eternal then\n                return true\n            end\n        end\n        return false\n    end,\n    in_pool = function(self, args)\n        return args and args.source and args.source == \"JoyousSpring\" or false\n    end,\n    joy_can_transfer_ability = function(self, other_card, card)\n        return other_card.config.center.key == \"j_joy_invoked_elysium\"\n    end,\n    joy_transfer_ability_calculate = function(self, other_card, context, config)\n        if JoyousSpring.can_use_abilities(other_card) then\n            if context.joker_main then\n                return {\n                    xmult = 1 +\n                        config.xmult *\n                        JoyousSpring.count_materials_in_graveyard({ { summon_type = \"FUSION\" } })\n                }\n            end\n            if context.setting_blind and context.main_eval then\n                local choices = JoyousSpring.get_materials_in_collection({ { summon_type = \"FUSION\", exclude_monster_archetypes = { \"Invoked\" } } })\n\n                for i = 1, config.mills do\n                    JoyousSpring.send_to_graveyard(pseudorandom_element(choices, 'j_joy_invoked_augo'))\n                end\n                return { message = localize(\"k_joy_mill\") }\n            end\n        end\n    end,\n    joy_transfer_config = function(self, other_card)\n        return {\n            xmult = 0.1,\n            mills = 1\n        }\n    end,\n    joy_transfer_loc_vars = function(self, info_queue, card, config)\n        return {\n            vars = { config.xmult, 1 +\n            config.xmult *\n            JoyousSpring.count_materials_in_graveyard({ { summon_type = \"FUSION\" } }), config.mills }\n        }\n    end"
    },
    {
      "type": "Joker",
      "key": "invoked_elysium",
      "atlas": "invoked",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"invoked_elysium\",\n    atlas = 'invoked',\n    pos = { x = 1, y = 1 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 12,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_tribute\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_transform\" }\n        end\n        return { vars = { card.ability.extra.tributes } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_invoked_meltdown\", properties = { { monster_archetypes = { \"Aleister\" } }, { monster_archetypes = { \"Invoked\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_all_attributes = true,\n                is_all_materials = { FUSION = true },\n                summon_type = \"FUSION\",\n                attribute = \"LIGHT\",\n                monster_type = \"Fairy\",\n                monster_archetypes = { [\"Invoked\"] = true }\n            },\n            tributes = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card then\n                if context.joy_activate_effect and context.joy_activated_card == card and not card.ability.eternal then\n                    local materials = {}\n                    for i, joker in ipairs(G.jokers.cards) do\n                        if joker ~= card and not joker.ability.eternal then\n                            materials[#materials + 1] = joker\n                        end\n                    end\n                    if next(materials) then\n                        JoyousSpring.create_overlay_effect_selection(card, materials, card.ability.extra.tributes,\n                            card.ability.extra.tributes)\n                    end\n                end\n                if context.joy_exit_effect_selection and context.joy_card == card and\n                    #context.joy_selection >= 1 then\n                    invoked_detransform(card, context.joy_selection[1])\n                end\n            end\n        end\n        if context.joy_sent_to_gy and JoyousSpring.is_material_center(context.joy_key, { monster_archetypes = { \"Invoked\" }, summon_type = \"FUSION\" }) then\n            JoyousSpring.transfer_abilities(card, context.joy_key)\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        local fusions = JoyousSpring.get_materials_in_graveyard(\n            { { monster_archetypes = { \"Invoked\" }, summon_type = \"FUSION\" } }, false, true)\n        for _, key in ipairs(fusions) do\n            JoyousSpring.transfer_abilities(card, key)\n        end\n    end,\n    joy_can_activate = function(card)\n        for i, joker in ipairs(G.jokers.cards) do\n            if joker ~= card and not joker.ability.eternal then\n                return true\n            end\n        end\n        return false\n    end,\n    in_pool = function(self, args)\n        return args and args.source and args.source == \"JoyousSpring\" or false\n    end,"
    },
    {
      "type": "Joker",
      "key": "invoked_meltdown",
      "atlas": "invoked",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"invoked_meltdown\",\n    atlas = 'invoked',\n    pos = { x = 1, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_tribute\" }\n        end\n        return { vars = { card.ability.extra.tributes, card.ability.extra.creates, card.ability.extra.xmult, 1 + card.ability.extra.xmult * JoyousSpring.get_summoned_count(\"FUSION\") } }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_invoked_meltdown\", properties = { { monster_archetypes = { \"Aleister\" } }, { monster_archetypes = { \"Invoked\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_field_spell = true\n            },\n            tributes = 2,\n            creates = 1,\n            xmult = 0.1,\n        },\n    },\n    calculate = function(self, card, context)\n        if context.joy_activate_effect and context.joy_activated_card == card then\n            local materials = JoyousSpring.get_materials_owned({ { summon_type = \"FUSION\" } })\n            if #materials >= card.ability.extra.tributes then\n                JoyousSpring.create_overlay_effect_selection(card, materials, card.ability.extra.tributes,\n                    card.ability.extra.tributes)\n            end\n        end\n        if context.joy_exit_effect_selection and context.joy_card == card and\n            #context.joy_selection == card.ability.extra.tributes then\n            JoyousSpring.tribute(card, context.joy_selection)\n\n            for i = 1, card.ability.extra.creates do\n                JoyousSpring.create_summon({ key = \"j_joy_invoked_aleister\" }, true)\n            end\n        end\n        if context.joker_main then\n            return {\n                xmult = 1 + card.ability.extra.xmult * JoyousSpring.get_summoned_count(\"FUSION\")\n            }\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff then\n            for _, joker in ipairs(G.jokers.cards) do\n                if JoyousSpring.is_summon_type(joker, \"FUSION\") and not JoyousSpring.is_perma_debuffed(joker) then\n                    SMODS.debuff_card(joker, \"prevent_debuff\", \"j_joy_invoked_meltdown\")\n                end\n            end\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        for _, joker in ipairs(G.jokers.cards) do\n            SMODS.debuff_card(joker, false, \"j_joy_invoked_meltdown\")\n        end\n    end,\n    joy_can_activate = function(card)\n        local materials = JoyousSpring.get_materials_owned({ { summon_type = \"FUSION\" } })\n        return not card.debuff and\n            (#G.jokers.cards + G.GAME.joker_buffer - card.ability.extra.tributes < G.jokers.config.card_limit and #materials >= card.ability.extra.tributes) and\n            true or false\n    end,\n    joy_apply_to_jokers_added = function(card, added_card)\n        if JoyousSpring.is_summon_type(added_card, \"FUSION\") and not JoyousSpring.is_perma_debuffed(added_card) then\n            SMODS.debuff_card(added_card, \"prevent_debuff\", \"j_joy_invoked_meltdown\")\n        end\n    end,\n    joy_prevent_flip = function(card, other_card)\n        return JoyousSpring.is_summon_type(other_card, \"FUSION\")\n    end"
    },
    {
      "type": "Atlas",
      "key": "danger",
      "atlas": null,
      "pos": null,
      "raw": "key = \"danger\",\n    path = \"21Danger.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Joker",
      "key": "danger_jack",
      "atlas": "danger",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"danger_jack\",\n    atlas = 'danger',\n    pos = { x = 3, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 3,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.dest_chips, card.ability.extra.chips, card.ability.extra.current_chips + (card.ability.extra.dest_chips * get_danger_count()), card.ability.extra.creates } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Danger\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Beast\",\n                monster_archetypes = { [\"Danger\"] = true }\n            },\n            dest_chips = 10,\n            chips = 100,\n            current_chips = 0,\n            creates = 1,\n            activated = false\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and context.setting_blind and context.main_eval then\n                local joker_to_destroy = danger_destroy(card, context)\n                if joker_to_destroy ~= card then\n                    card.ability.extra.current_chips = card.ability.extra.current_chips + card.ability.extra.chips\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            if not card.getting_sliced then\n                                SMODS.calculate_effect({ message = localize('k_upgrade_ex') }, card)\n                            end\n                            return true\n                        end\n                    }))\n                end\n            end\n            if context.joker_main then\n                return {\n                    chips = card.ability.extra.current_chips + (card.ability.extra.dest_chips * get_danger_count())\n                }\n            end\n        end\n        if context.joy_danger == card and not card.ability.extra.activated then\n            card.ability.extra.activated = true\n            inc_danger_count()\n\n            for i = 1, card.ability.extra.creates do\n                JoyousSpring.create_pseudorandom({ { monster_archetypes = { \"Danger\" }, is_main_deck = true } },\n                    'j_joy_danger_jack', true, nil,\n                    next(SMODS.find_card(\"j_joy_danger_realm\")) and \"e_polychrome\" or nil)\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "danger_tsuch",
      "atlas": "danger",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = \"danger_tsuch\",\n    atlas = 'danger',\n    pos = { x = 0, y = 2 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 3,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.dest_mult, card.ability.extra.mult, card.ability.extra.current_mult + (card.ability.extra.dest_mult * get_danger_count()), card.ability.extra.creates } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Danger\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Reptile\",\n                monster_archetypes = { [\"Danger\"] = true }\n            },\n            dest_mult = 5,\n            mult = 50,\n            current_mult = 0,\n            creates = 1,\n            activated = false\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and context.setting_blind and context.main_eval then\n                local joker_to_destroy = danger_destroy(card, context)\n                if joker_to_destroy ~= card then\n                    card.ability.extra.current_mult = card.ability.extra.current_mult + card.ability.extra.mult\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            if not card.getting_sliced then\n                                SMODS.calculate_effect({ message = localize('k_upgrade_ex') }, card)\n                            end\n                            return true\n                        end\n                    }))\n                end\n            end\n            if context.joker_main then\n                return {\n                    mult = card.ability.extra.current_mult + (card.ability.extra.dest_mult * get_danger_count())\n                }\n            end\n        end\n        if context.joy_danger == card and not card.ability.extra.activated then\n            card.ability.extra.activated = true\n            inc_danger_count()\n            for i = 1, card.ability.extra.creates do\n                JoyousSpring.create_pseudorandom({ { monster_archetypes = { \"Danger\" }, is_main_deck = true } },\n                    'j_joy_danger_tsuch', true, nil,\n                    next(SMODS.find_card(\"j_joy_danger_realm\")) and \"e_polychrome\" or nil)\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "danger_chup",
      "atlas": "danger",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"danger_chup\",\n    atlas = 'danger',\n    pos = { x = 1, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.current_money, card.ability.extra.money, card.ability.extra.revives } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Danger\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Fiend\",\n                monster_archetypes = { [\"Danger\"] = true }\n            },\n            money = 2,\n            current_money = 2,\n            revives = 1,\n            activated = false\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and context.setting_blind and context.main_eval then\n                local joker_to_destroy = danger_destroy(card, context)\n                if joker_to_destroy ~= card then\n                    card.ability.extra.current_money = card.ability.extra.current_money + card.ability.extra.money\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            if not card.getting_sliced then\n                                SMODS.calculate_effect({ message = localize('k_upgrade_ex') }, card)\n                            end\n                            return true\n                        end\n                    }))\n                end\n            end\n        end\n        if context.joy_danger == card and not card.ability.extra.activated then\n            card.ability.extra.activated = true\n            inc_danger_count()\n            for i = 1, card.ability.extra.revives do\n                JoyousSpring.revive_pseudorandom({ { monster_archetypes = { \"Danger\" }, is_main_deck = true } },\n                    'j_joy_danger_chup', true,\n                    next(SMODS.find_card(\"j_joy_danger_realm\")) and \"e_polychrome\" or nil)\n            end\n        end\n    end,\n    calc_dollar_bonus = function(self, card)\n        return JoyousSpring.can_use_abilities(card) and\n            card.ability.extra.current_money or nil\n    end,"
    },
    {
      "type": "Joker",
      "key": "danger_moth",
      "atlas": "danger",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"danger_moth\",\n    atlas = 'danger',\n    pos = { x = 3, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.current_discards, card.ability.extra.discards, card.ability.extra.revives } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Danger\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Insect\",\n                monster_archetypes = { [\"Danger\"] = true }\n            },\n            discards = 1,\n            current_discards = 0,\n            revives = 1,\n            activated = false\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and context.setting_blind and context.main_eval then\n                local joker_to_destroy = danger_destroy(card, context)\n                if joker_to_destroy ~= card then\n                    card.ability.extra.current_discards = card.ability.extra.current_discards +\n                        card.ability.extra.discards\n                    G.GAME.round_resets.discards = G.GAME.round_resets.discards + card.ability.extra.discards\n                    ease_discard(card.ability.extra.discards)\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            if not card.getting_sliced then\n                                SMODS.calculate_effect({ message = localize('k_upgrade_ex') }, card)\n                            end\n                            return true\n                        end\n                    }))\n                end\n            end\n        end\n        if context.joy_danger == card and not card.ability.extra.activated then\n            card.ability.extra.activated = true\n            inc_danger_count()\n            for i = 1, card.ability.extra.revives do\n                JoyousSpring.revive_pseudorandom({ { monster_archetypes = { \"Danger\" }, is_main_deck = true } },\n                    'j_joy_danger_moth', true,\n                    next(SMODS.find_card(\"j_joy_danger_realm\")) and \"e_polychrome\" or nil)\n            end\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        if not JoyousSpring.is_perma_debuffed(card) then\n            G.GAME.round_resets.discards = G.GAME.round_resets.discards - card.ability.extra.current_discards\n            ease_discard(-card.ability.extra.current_discards)\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "danger_dog",
      "atlas": "danger",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"danger_dog\",\n    atlas = 'danger',\n    pos = { x = 2, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.current_percent * 100, card.ability.extra.percent * 100, card.ability.extra.adds } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Danger\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"BeastWarrior\",\n                monster_archetypes = { [\"Danger\"] = true }\n            },\n            percent = 0.005,\n            current_percent = 0.02,\n            adds = 2,\n            activated = false\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and context.setting_blind and context.main_eval then\n                local joker_to_destroy = danger_destroy(card, context)\n                if joker_to_destroy ~= card then\n                    card.ability.extra.current_percent = math.min(0.25,\n                        card.ability.extra.current_percent + card.ability.extra.percent)\n                    G.GAME.blind.chips = math.floor(G.GAME.blind.chips -\n                        G.GAME.blind.chips * card.ability.extra.current_percent)\n                    G.GAME.blind.chip_text = number_format(G.GAME.blind.chips)\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            if not card.getting_sliced then\n                                SMODS.calculate_effect({ message = localize('k_upgrade_ex') }, card)\n                            end\n                            return true\n                        end\n                    }))\n                end\n            end\n        end\n        if context.joy_danger == card and not card.ability.extra.activated then\n            card.ability.extra.activated = true\n            inc_danger_count()\n            local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Danger\" } } })\n            for i = 1, card.ability.extra.adds do\n                key_to_add = pseudorandom_element(choices, 'j_joy_danger_dog')\n                JoyousSpring.add_monster_tag(key_to_add or \"j_joy_danger_jack\")\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and G.GAME.blind.in_blind then\n            G.GAME.blind.chips = math.floor(G.GAME.blind.chips -\n                G.GAME.blind.chips * card.ability.extra.current_percent)\n            G.GAME.blind.chip_text = number_format(G.GAME.blind.chips)\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "danger_ness",
      "atlas": "danger",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"danger_ness\",\n    atlas = 'danger',\n    pos = { x = 0, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.current_h_size, card.ability.extra.h_size, card.ability.extra.adds } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Danger\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Aqua\",\n                monster_archetypes = { [\"Danger\"] = true }\n            },\n            h_size = 1,\n            current_h_size = 0,\n            adds = 2,\n            activated = false\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and context.setting_blind and context.main_eval then\n                local joker_to_destroy = danger_destroy(card, context)\n                if joker_to_destroy ~= card then\n                    card.ability.extra.current_h_size = card.ability.extra.current_h_size +\n                        card.ability.extra.h_size\n                    G.hand:change_size(card.ability.extra.h_size)\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            if not card.getting_sliced then\n                                SMODS.calculate_effect({ message = localize('k_upgrade_ex') }, card)\n                            end\n                            return true\n                        end\n                    }))\n                end\n            end\n        end\n        if context.joy_danger == card and not card.ability.extra.activated then\n            card.ability.extra.activated = true\n            inc_danger_count()\n            local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Danger\" } } })\n            for i = 1, card.ability.extra.adds do\n                key_to_add = pseudorandom_element(choices, 'j_joy_danger_ness')\n                JoyousSpring.add_monster_tag(key_to_add or \"j_joy_danger_jack\")\n            end\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        if not JoyousSpring.is_perma_debuffed(card) then\n            G.hand:change_size(-card.ability.extra.current_h_size)\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "danger_big",
      "atlas": "danger",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"danger_big\",\n    atlas = 'danger',\n    pos = { x = 0, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 7,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.dest_xmult, card.ability.extra.xmult, card.ability.extra.current_xmult + (card.ability.extra.dest_xmult * get_danger_count()) } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Danger\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Beast\",\n                monster_archetypes = { [\"Danger\"] = true }\n            },\n            dest_xmult = 0.2,\n            xmult = 1,\n            current_xmult = 1,\n            activated = false\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and context.setting_blind and context.main_eval then\n                local joker_to_destroy = danger_destroy(card, context)\n                if joker_to_destroy ~= card then\n                    card.ability.extra.current_xmult = card.ability.extra.current_xmult + card.ability.extra.xmult\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            if not card.getting_sliced then\n                                SMODS.calculate_effect({ message = localize('k_upgrade_ex') }, card)\n                            end\n                            return true\n                        end\n                    }))\n                end\n            end\n            if context.joker_main then\n                return {\n                    xmult = card.ability.extra.current_xmult + (card.ability.extra.dest_xmult * get_danger_count())\n                }\n            end\n        end\n        if context.joy_danger == card and not card.ability.extra.activated then\n            card.ability.extra.activated = true\n            inc_danger_count()\n            for i = 1, #G.jokers.cards do\n                if G.jokers.cards[i] ~= card and not G.jokers.cards[i].ability.eternal and not G.jokers.cards[i].getting_sliced then\n                    G.jokers.cards[i]:start_dissolve()\n                    SMODS.calculate_context({ joy_danger = G.jokers.cards[i] })\n                    G.jokers.cards[i].getting_sliced = true\n                end\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "danger_ogo",
      "atlas": "danger",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"danger_ogo\",\n    atlas = 'danger',\n    pos = { x = 1, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 7,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.chips, card.ability.extra.chips * JoyousSpring.count_materials_in_graveyard({ { monster_archetypes = { \"Danger\" } } }), card.ability.extra.mills } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Danger\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"SeaSerpent\",\n                monster_archetypes = { [\"Danger\"] = true }\n            },\n            chips = 50,\n            mills = 3,\n            activated = false\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and context.setting_blind and context.main_eval then\n                danger_destroy(card, context)\n            end\n            if context.joker_main then\n                return {\n                    chips = card.ability.extra.chips *\n                        JoyousSpring.count_materials_in_graveyard({ { monster_archetypes = { \"Danger\" } } })\n                }\n            end\n        end\n        if context.joy_danger == card and not card.ability.extra.activated then\n            card.ability.extra.activated = true\n            inc_danger_count()\n            local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"Danger\" } } })\n\n            for i = 1, card.ability.extra.mills do\n                JoyousSpring.send_to_graveyard(pseudorandom_element(choices, 'j_joy_danger_ogo'))\n            end\n            return { message = localize(\"k_joy_mill\") }\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "danger_thunder",
      "atlas": "danger",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"danger_thunder\",\n    atlas = 'danger',\n    pos = { x = 2, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 7,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.dest_xchips, card.ability.extra.xchips, card.ability.extra.current_xchips + (card.ability.extra.dest_xchips * get_danger_count()), card.ability.extra.destroys } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Danger\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"WingedBeast\",\n                monster_archetypes = { [\"Danger\"] = true }\n            },\n            dest_xchips = 0.1,\n            xchips = 1,\n            current_xchips = 1,\n            destroys = 1,\n            activated = false\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and context.setting_blind and context.main_eval then\n                local joker_to_destroy = danger_destroy(card, context)\n                if joker_to_destroy ~= card then\n                    card.ability.extra.current_xchips = card.ability.extra.current_xchips + card.ability.extra.xchips\n                    G.E_MANAGER:add_event(Event({\n                        func = function()\n                            if not card.getting_sliced then\n                                SMODS.calculate_effect({ message = localize('k_upgrade_ex') }, card)\n                            end\n                            return true\n                        end\n                    }))\n                end\n            end\n            if context.joker_main then\n                return {\n                    xchips = card.ability.extra.current_xchips + (card.ability.extra.dest_xchips * get_danger_count())\n                }\n            end\n        end\n        if context.joy_danger == card and not card.ability.extra.activated then\n            card.ability.extra.activated = true\n            inc_danger_count()\n            for _ = 1, card.ability.extra.destroys do\n                local destructable_jokers = {}\n                for i = 1, #G.jokers.cards do\n                    if G.jokers.cards[i] ~= card and not G.jokers.cards[i].ability.eternal and not G.jokers.cards[i].getting_sliced then\n                        destructable_jokers[#destructable_jokers + 1] = G.jokers.cards[i]\n                    end\n                end\n                local joker_to_destroy = #destructable_jokers > 0 and\n                    pseudorandom_element(destructable_jokers, card.config.center.key) or nil\n\n                if joker_to_destroy and not (context.blueprint_card or card).getting_sliced then\n                    joker_to_destroy:start_dissolve()\n                    SMODS.calculate_context({ joy_danger = joker_to_destroy })\n                    joker_to_destroy.getting_sliced = true\n                end\n            end\n            for i = 1, #G.consumeables.cards do\n                if not G.consumeables.cards[i].ability.eternal and not G.consumeables.cards[i].getting_sliced then\n                    G.consumeables.cards[i].getting_sliced = true\n                    G.consumeables.cards[i]:start_dissolve()\n                end\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "danger_realm",
      "atlas": "danger",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "key = \"danger_realm\",\n    atlas = 'danger',\n    pos = { x = 1, y = 2 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.money } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Danger\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_field_spell = true,\n                monster_archetypes = { [\"Danger\"] = true }\n            },\n            money = 8\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and context.setting_blind and context.main_eval then\n                danger_destroy(card, context)\n                return {\n                    dollars = card.ability.extra.money\n                }\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "danger_disorder",
      "atlas": "danger",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "key = \"danger_disorder\",\n    atlas = 'danger',\n    pos = { x = 2, y = 2 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        return {\n            vars = {\n                card.ability.extra.mult, card.ability.extra.mult *\n            JoyousSpring.count_materials_in_graveyard({ { monster_archetypes = { \"Danger\" } } }),\n                card.ability.extra.creates,\n            }\n        }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Danger\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_field_spell = true,\n                monster_archetypes = { [\"Danger\"] = true }\n            },\n            creates = 1,\n            mult = 10\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and context.setting_blind and context.main_eval then\n                for i = 1, card.ability.extra.creates do\n                    JoyousSpring.create_pseudorandom({ { monster_archetypes = { \"Danger\" }, is_main_deck = true } },\n                        'j_joy_danger_disorder', true)\n                end\n            end\n            if context.joker_main then\n                return {\n                    mult = card.ability.extra.mult *\n                        JoyousSpring.count_materials_in_graveyard({ { monster_archetypes = { \"Danger\" } } })\n                }\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff then\n            for i = 1, #G.jokers.cards do\n                if not JoyousSpring.is_monster_archetype(G.jokers.cards[i], \"Danger\") then\n                    SMODS.debuff_card(G.jokers.cards[i], true, 'j_joy_danger_disorder')\n                end\n            end\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        for i = 1, #G.jokers.cards do\n            SMODS.debuff_card(G.jokers.cards[i], false, 'j_joy_danger_disorder')\n        end\n    end,\n    joy_apply_to_jokers_added = function(card, added_card)\n        if not card.debuff and not JoyousSpring.is_monster_archetype(added_card, \"Danger\") then\n            SMODS.debuff_card(added_card, true, \"j_joy_danger_disorder\")\n        end\n    end,"
    },
    {
      "type": "Atlas",
      "key": "adaman",
      "atlas": null,
      "pos": null,
      "raw": "key = \"adaman\",\n    path = \"22Adamancipator.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Joker",
      "key": "adaman_analyzer",
      "atlas": "adaman",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"adaman_analyzer\",\n    atlas = 'adaman',\n    pos = { x = 0, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 7,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.excavates, card.ability.extra.chips, card.ability.extra.chips * card.ability.extra.excavated, card.ability.extra.creates, card.ability.extra.hands, card.ability.extra.hands - card.ability.extra.hands_played } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Adamancipator\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_tuner = true,\n                attribute = \"EARTH\",\n                monster_type = \"Rock\",\n                monster_archetypes = { [\"Adamancipator\"] = true }\n            },\n            excavates = 3,\n            chips = 50,\n            excavated = 0,\n            creates = 1,\n            hands = 3,\n            hands_played = 0,\n            activated = false\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.before and next(context.poker_hands[\"Flush\"]) and\n                not card.ability.extra.activated then\n                local is_diamond_flush = false\n                for _, hand in ipairs(context.poker_hands[\"Flush\"]) do\n                    if hand[1] and hand[1]:is_suit(\"Diamonds\", nil, true) then\n                        is_diamond_flush = true\n                        break\n                    end\n                end\n                if is_diamond_flush then\n                    card.ability.extra.hands_played = card.ability.extra.hands_played + 1\n                end\n                if card.ability.extra.hands_played >= card.ability.extra.hands then\n                    for _ = 1, card.ability.extra.creates do\n                        JoyousSpring.create_pseudorandom(\n                            { { monster_type = \"Rock\", is_main_deck = true }, },\n                            'j_joy_adaman_analyzer', true)\n                    end\n                    card.ability.extra.activated = true\n                end\n            end\n            if context.individual and context.cardarea == G.play and context.other_card:is_suit(\"Diamonds\") and card.ability.extra.excavated > 0 then\n                return {\n                    chips = card.ability.extra.chips * card.ability.extra.excavated\n                }\n            end\n            if context.joy_excavated and (SMODS.find_card(\"j_joy_adaman_laputite\") or context.joy_number <= card.ability.extra.excavates) and context.joy_other_context.setting_blind then\n                if context.joy_excavated:is_suit(\"Diamonds\") then\n                    card.ability.extra.excavated = card.ability.extra.excavated + 1\n                end\n            end\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval then\n            card.ability.extra.excavated = 0\n            if G.GAME.blind.boss then\n                card.ability.extra.activated = false\n                card.ability.extra.hands_played = 0\n            end\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        card.ability.extra.excavated = 0\n    end,\n    joy_set_cost = function(card)\n        if JoyousSpring.count_materials_owned({ { monster_type = \"Rock\" } }) > 0 then\n            card.cost = 0\n        end\n    end,\n    joy_calculate_excavate = adaman_excavate,"
    },
    {
      "type": "Joker",
      "key": "adaman_researcher",
      "atlas": "adaman",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"adaman_researcher\",\n    atlas = 'adaman',\n    pos = { x = 1, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 7,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.excavates, card.ability.extra.money, card.ability.extra.money * card.ability.extra.excavated, card.ability.extra.creates, card.ability.extra.hands, card.ability.extra.hands - card.ability.extra.hands_played } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Adamancipator\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_tuner = true,\n                attribute = \"EARTH\",\n                monster_type = \"Rock\",\n                monster_archetypes = { [\"Adamancipator\"] = true }\n            },\n            excavates = 3,\n            money = 1,\n            excavated = 0,\n            creates = 1,\n            hands = 3,\n            hands_played = 0,\n            activated = false\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.before and next(context.poker_hands[\"Flush\"]) and\n                not card.ability.extra.activated then\n                local is_diamond_flush = false\n                for _, hand in ipairs(context.poker_hands[\"Flush\"]) do\n                    if hand[1] and hand[1]:is_suit(\"Diamonds\", nil, true) then\n                        is_diamond_flush = true\n                        break\n                    end\n                end\n                if is_diamond_flush then\n                    card.ability.extra.hands_played = card.ability.extra.hands_played + 1\n                end\n                if card.ability.extra.hands_played >= card.ability.extra.hands then\n                    for _ = 1, card.ability.extra.creates do\n                        JoyousSpring.create_pseudorandom(\n                            { { monster_type = \"Rock\", is_main_deck = true }, },\n                            'j_joy_adaman_researcher', true)\n                    end\n                    card.ability.extra.activated = true\n                end\n            end\n            if context.individual and context.cardarea == G.play and context.other_card:is_suit(\"Diamonds\") and card.ability.extra.excavated > 0 then\n                return {\n                    dollars = card.ability.extra.money * card.ability.extra.excavated\n                }\n            end\n            if context.joy_excavated and (SMODS.find_card(\"j_joy_adaman_laputite\") or context.joy_number <= card.ability.extra.excavates) and context.joy_other_context.setting_blind then\n                if context.joy_excavated:is_suit(\"Diamonds\") then\n                    card.ability.extra.excavated = card.ability.extra.excavated + 1\n                end\n            end\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval then\n            card.ability.extra.excavated = 0\n            if G.GAME.blind.boss then\n                card.ability.extra.activated = false\n                card.ability.extra.hands_played = 0\n            end\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        card.ability.extra.excavated = 0\n    end,\n    joy_set_cost = function(card)\n        if JoyousSpring.count_materials_owned({ { monster_type = \"Rock\" } }) > 0 then\n            card.cost = 0\n        end\n    end,\n    joy_calculate_excavate = adaman_excavate,"
    },
    {
      "type": "Joker",
      "key": "adaman_seeker",
      "atlas": "adaman",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"adaman_seeker\",\n    atlas = 'adaman',\n    pos = { x = 2, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 7,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.excavates, card.ability.extra.mult, card.ability.extra.mult * card.ability.extra.excavated, card.ability.extra.creates, card.ability.extra.hands, card.ability.extra.hands - card.ability.extra.hands_played } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Adamancipator\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_tuner = true,\n                attribute = \"EARTH\",\n                monster_type = \"Rock\",\n                monster_archetypes = { [\"Adamancipator\"] = true }\n            },\n            excavates = 3,\n            mult = 10,\n            excavated = 0,\n            creates = 1,\n            hands = 3,\n            hands_played = 0,\n            activated = false\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.before and next(context.poker_hands[\"Flush\"]) and\n                not card.ability.extra.activated then\n                local is_diamond_flush = false\n                for _, hand in ipairs(context.poker_hands[\"Flush\"]) do\n                    if hand[1] and hand[1]:is_suit(\"Diamonds\", nil, true) then\n                        is_diamond_flush = true\n                        break\n                    end\n                end\n                if is_diamond_flush then\n                    card.ability.extra.hands_played = card.ability.extra.hands_played + 1\n                end\n                if card.ability.extra.hands_played >= card.ability.extra.hands then\n                    for _ = 1, card.ability.extra.creates do\n                        JoyousSpring.create_pseudorandom(\n                            { { monster_type = \"Rock\", is_main_deck = true }, },\n                            'j_joy_adaman_seeker', true)\n                    end\n                    card.ability.extra.activated = true\n                end\n            end\n            if context.individual and context.cardarea == G.play and context.other_card:is_suit(\"Diamonds\") and card.ability.extra.excavated > 0 then\n                return {\n                    mult = card.ability.extra.mult * card.ability.extra.excavated\n                }\n            end\n            if context.joy_excavated and (SMODS.find_card(\"j_joy_adaman_laputite\") or context.joy_number <= card.ability.extra.excavates) and context.joy_other_context.setting_blind then\n                if context.joy_excavated:is_suit(\"Diamonds\") then\n                    card.ability.extra.excavated = card.ability.extra.excavated + 1\n                end\n            end\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval then\n            card.ability.extra.excavated = 0\n            if G.GAME.blind.boss then\n                card.ability.extra.activated = false\n                card.ability.extra.hands_played = 0\n            end\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        card.ability.extra.excavated = 0\n    end,\n    joy_set_cost = function(card)\n        if JoyousSpring.count_materials_owned({ { monster_type = \"Rock\" } }) > 0 then\n            card.cost = 0\n        end\n    end,\n    joy_calculate_excavate = adaman_excavate,"
    },
    {
      "type": "Joker",
      "key": "adaman_crysdragite",
      "atlas": "adaman",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"adaman_crysdragite\",\n    atlas = 'adaman',\n    pos = { x = 3, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 4,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.chips, card.ability.extra.chips * JoyousSpring.count_materials_owned({ { monster_type = \"Rock\" } }) } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Adamancipator\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"WATER\",\n                monster_type = \"Rock\",\n                monster_archetypes = { [\"Adamancipator\"] = true }\n            },\n            chips = 3,\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.individual and context.cardarea == G.hand and not context.end_of_round\n                and context.other_card:is_suit(\"Diamonds\") then\n                return {\n                    chips = card.ability.extra.chips * JoyousSpring.count_materials_owned({ { monster_type = \"Rock\" } })\n                }\n            end\n        end\n    end,\n    joy_can_transfer_ability = function(self, other_card, card)\n        return JoyousSpring.is_summon_type(other_card, \"SYNCHRO\")\n    end,\n    joy_transfer_ability_calculate = function(self, other_card, context, config)\n        if JoyousSpring.can_use_abilities(other_card) and context.joker_main then\n            local diamonds = 0\n            for _, pcard in ipairs(G.deck.cards) do\n                if pcard:is_suit(\"Diamonds\") then\n                    diamonds = diamonds + 1\n                end\n            end\n            return {\n                chips = config.chips * diamonds\n            }\n        end\n    end,\n    joy_transfer_config = function(self, other_card)\n        return { chips = 3 }\n    end,\n    joy_transfer_loc_vars = function(self, info_queue, card, config)\n        local diamonds = 0\n        for _, pcard in ipairs(G.deck.cards) do\n            if pcard:is_suit(\"Diamonds\") then\n                diamonds = diamonds + 1\n            end\n        end\n        return { vars = { config.chips, config.chips * diamonds } }\n    end"
    },
    {
      "type": "Joker",
      "key": "adaman_crysraptite",
      "atlas": "adaman",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"adaman_crysraptite\",\n    atlas = 'adaman',\n    pos = { x = 0, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 4,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.money, card.ability.extra.money * JoyousSpring.count_materials_owned({ { monster_type = \"Rock\" } }) } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Adamancipator\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"WIND\",\n                monster_type = \"Rock\",\n                monster_archetypes = { [\"Adamancipator\"] = true }\n            },\n            money = 0.1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.individual and context.cardarea == G.hand and not context.end_of_round\n                and context.other_card:is_suit(\"Diamonds\") then\n                return {\n                    dollars = card.ability.extra.money *\n                        JoyousSpring.count_materials_owned({ { monster_type = \"Rock\" } })\n                }\n            end\n        end\n    end,\n    joy_can_transfer_ability = function(self, other_card, card)\n        return JoyousSpring.is_summon_type(other_card, \"SYNCHRO\")\n    end,\n    joy_transfer_calc_dollar_bonus = function(self, other_card, config)\n        local diamonds = 0\n        for _, pcard in ipairs(G.deck.cards) do\n            if pcard:is_suit(\"Diamonds\") then\n                diamonds = diamonds + 1\n            end\n        end\n        return diamonds > 0 and config.money * diamonds or nil\n    end,\n    joy_transfer_config = function(self, other_card)\n        return { money = 0.1 }\n    end,\n    joy_transfer_loc_vars = function(self, info_queue, card, config)\n        local diamonds = 0\n        for _, pcard in ipairs(G.deck.cards) do\n            if pcard:is_suit(\"Diamonds\") then\n                diamonds = diamonds + 1\n            end\n        end\n        return { vars = { config.money, config.money * diamonds } }\n    end"
    },
    {
      "type": "Joker",
      "key": "adaman_crysleonite",
      "atlas": "adaman",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"adaman_crysleonite\",\n    atlas = 'adaman',\n    pos = { x = 1, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 4,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.mult, card.ability.extra.mult * JoyousSpring.count_materials_owned({ { monster_type = \"Rock\" } }) } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Adamancipator\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"FIRE\",\n                monster_type = \"Rock\",\n                monster_archetypes = { [\"Adamancipator\"] = true }\n            },\n            mult = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.individual and context.cardarea == G.hand and not context.end_of_round\n                and context.other_card:is_suit(\"Diamonds\") then\n                return {\n                    mult = card.ability.extra.mult * JoyousSpring.count_materials_owned({ { monster_type = \"Rock\" } })\n                }\n            end\n        end\n    end,\n    joy_can_transfer_ability = function(self, other_card, card)\n        return JoyousSpring.is_summon_type(other_card, \"SYNCHRO\")\n    end,\n    joy_transfer_ability_calculate = function(self, other_card, context, config)\n        if JoyousSpring.can_use_abilities(other_card) and context.joker_main then\n            local diamonds = 0\n            for _, pcard in ipairs(G.deck.cards) do\n                if pcard:is_suit(\"Diamonds\") then\n                    diamonds = diamonds + 1\n                end\n            end\n            return {\n                mult = config.mult * diamonds\n            }\n        end\n    end,\n    joy_transfer_config = function(self, other_card)\n        return { mult = 1 }\n    end,\n    joy_transfer_loc_vars = function(self, info_queue, card, config)\n        local diamonds = 0\n        for _, pcard in ipairs(G.deck.cards) do\n            if pcard:is_suit(\"Diamonds\") then\n                diamonds = diamonds + 1\n            end\n        end\n        return { vars = { config.mult, config.mult * diamonds } }\n    end"
    },
    {
      "type": "Joker",
      "key": "adaman_dragite",
      "atlas": "adaman",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"adaman_dragite\",\n    atlas = 'adaman',\n    pos = { x = 3, y = 1 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 12,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.excavates, card.ability.extra.xchips, card.ability.extra.creates, 1 + card.ability.extra.xchips * card.ability.extra.excavated, card.ability.extra.chips } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Adamancipator\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"WATER\",\n                monster_type = \"Rock\",\n                monster_archetypes = { [\"Adamancipator\"] = true },\n                summon_type = \"SYNCHRO\",\n                summon_conditions = {\n                    {\n                        type = \"SYNCHRO\",\n                        materials = {\n                            { monster_type = \"Rock\", is_tuner = true,                         exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                            { exclude_tuners = true, exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                        },\n                    }\n                }\n            },\n            excavates = 5,\n            xchips = 1,\n            excavated = 0,\n            creates = 1,\n            chips = 10,\n            activated = false\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    xchips = 1 + card.ability.extra.xchips * card.ability.extra.excavated\n                }\n            end\n            if context.individual and context.cardarea == G.play and context.other_card:is_suit(\"Diamonds\") then\n                context.other_card.ability.perma_h_chips = (context.other_card.ability.perma_h_chips or 1) +\n                    card.ability.extra.chips\n                return {\n                    message = localize('k_upgrade_ex'), colour = G.C.CHIPS\n                }\n            end\n            if context.joy_excavated and (SMODS.find_card(\"j_joy_adaman_laputite\") or context.joy_number <= card.ability.extra.excavates) and context.joy_other_context.setting_blind then\n                if context.joy_excavated:is_suit(\"Diamonds\") then\n                    card.ability.extra.excavated = card.ability.extra.excavated + 1\n                end\n                if not card.ability.extra.activated and card.ability.extra.excavated >= card.ability.extra.excavates then\n                    card.ability.extra.activated = true\n                    for _ = 1, card.ability.extra.creates do\n                        JoyousSpring.create_pseudorandom(\n                            { { monster_type = \"Rock\", is_main_deck = true }, },\n                            'j_joy_adaman_dragite', false)\n                    end\n                end\n            end\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval then\n            card.ability.extra.excavated = 0\n            card.ability.extra.activated = false\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        card.ability.extra.excavated = 0\n        card.ability.extra.activated = false\n    end,\n    joy_calculate_excavate = adaman_excavate,"
    },
    {
      "type": "Joker",
      "key": "adaman_raptite",
      "atlas": "adaman",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = \"adaman_raptite\",\n    atlas = 'adaman',\n    pos = { x = 0, y = 2 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 12,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.excavates, card.ability.extra.money, card.ability.extra.creates, card.ability.extra.held_money } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Adamancipator\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"WIND\",\n                monster_type = \"Rock\",\n                monster_archetypes = { [\"Adamancipator\"] = true },\n                summon_type = \"SYNCHRO\",\n                summon_conditions = {\n                    {\n                        type = \"SYNCHRO\",\n                        materials = {\n                            { monster_type = \"Rock\", is_tuner = true,                         exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                            { exclude_tuners = true, exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                        },\n                    }\n                }\n            },\n            excavates = 5,\n            money = 5,\n            excavated = 0,\n            creates = 1,\n            held_money = 0.1,\n            activated = false\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.individual and context.cardarea == G.play and context.other_card:is_suit(\"Diamonds\") then\n                context.other_card.ability.perma_h_dollars = (context.other_card.ability.perma_h_dollars or 1) +\n                    card.ability.extra.held_money\n                return {\n                    message = localize('k_upgrade_ex'), colour = G.C.MONEY\n                }\n            end\n            if context.joy_excavated and (SMODS.find_card(\"j_joy_adaman_laputite\") or context.joy_number <= card.ability.extra.excavates) and context.joy_other_context.setting_blind then\n                if context.joy_excavated:is_suit(\"Diamonds\") then\n                    card.ability.extra.excavated = card.ability.extra.excavated + 1\n                end\n                if not card.ability.extra.activated and card.ability.extra.excavated >= card.ability.extra.excavates then\n                    card.ability.extra.activated = true\n                    for _ = 1, card.ability.extra.creates do\n                        JoyousSpring.create_pseudorandom(\n                            { { monster_type = \"Rock\", is_main_deck = true }, },\n                            'j_joy_adaman_raptite', false)\n                    end\n                end\n                return {\n                    dollars = context.joy_excavated:is_suit(\"Diamonds\") and card.ability.extra.money or nil\n                }\n            end\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval then\n            card.ability.extra.excavated = 0\n            card.ability.extra.activated = false\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        card.ability.extra.excavated = 0\n        card.ability.extra.activated = false\n    end,\n    joy_calculate_excavate = adaman_excavate,"
    },
    {
      "type": "Joker",
      "key": "adaman_leonite",
      "atlas": "adaman",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "key = \"adaman_leonite\",\n    atlas = 'adaman',\n    pos = { x = 1, y = 2 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 12,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.excavates, card.ability.extra.xmult, card.ability.extra.creates, 1 + card.ability.extra.xmult * card.ability.extra.excavated, card.ability.extra.mult } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Adamancipator\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"FIRE\",\n                monster_type = \"Rock\",\n                monster_archetypes = { [\"Adamancipator\"] = true },\n                summon_type = \"SYNCHRO\",\n                summon_conditions = {\n                    {\n                        type = \"SYNCHRO\",\n                        materials = {\n                            { monster_type = \"Rock\", is_tuner = true,                         exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                            { exclude_tuners = true, exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                        },\n                    }\n                }\n            },\n            excavates = 5,\n            xmult = 1,\n            excavated = 0,\n            creates = 1,\n            mult = 1,\n            activated = false\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    xmult = 1 + card.ability.extra.xmult * card.ability.extra.excavated\n                }\n            end\n            if context.individual and context.cardarea == G.play and context.other_card:is_suit(\"Diamonds\") then\n                context.other_card.ability.perma_h_mult = (context.other_card.ability.perma_h_mult or 1) +\n                    card.ability.extra.mult\n                return {\n                    message = localize('k_upgrade_ex'), colour = G.C.MULT\n                }\n            end\n            if context.joy_excavated and (SMODS.find_card(\"j_joy_adaman_laputite\") or context.joy_number <= card.ability.extra.excavates) and context.joy_other_context.setting_blind then\n                if context.joy_excavated:is_suit(\"Diamonds\") then\n                    card.ability.extra.excavated = card.ability.extra.excavated + 1\n                end\n                if not card.ability.extra.activated and card.ability.extra.excavated >= card.ability.extra.excavates then\n                    card.ability.extra.activated = true\n                    for _ = 1, card.ability.extra.creates do\n                        JoyousSpring.create_pseudorandom(\n                            { { monster_type = \"Rock\", is_main_deck = true }, },\n                            'j_joy_adaman_leonite', false)\n                    end\n                end\n            end\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval then\n            card.ability.extra.excavated = 0\n            card.ability.extra.activated = false\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        card.ability.extra.excavated = 0\n        card.ability.extra.activated = false\n    end,\n    joy_calculate_excavate = adaman_excavate,"
    },
    {
      "type": "Joker",
      "key": "adaman_laputite",
      "atlas": "adaman",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"adaman_laputite\",\n    atlas = 'adaman',\n    pos = { x = 2, y = 1 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 15,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.mult } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"Adamancipator\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_field_spell = true,\n                monster_archetypes = { [\"Adamancipator\"] = true }\n            },\n            mult = 10,\n        },\n    },\n    calculate = function(self, card, context)\n        if context.other_joker and context.other_joker.facing == \"front\" and JoyousSpring.is_monster_type(context.other_joker, \"Rock\") then\n            return {\n                mult = card.ability.extra.mult,\n                message_card = context.other_joker\n            }\n        end\n        if context.first_hand_drawn then\n            local cen_pool = {}\n            for _, enhancement_center in pairs(G.P_CENTER_POOLS[\"Enhanced\"]) do\n                if enhancement_center.key ~= 'm_stone' and not enhancement_center.overrides_base_rank then\n                    cen_pool[#cen_pool + 1] = enhancement_center.key\n                end\n            end\n            local enhancement = pseudorandom_element(cen_pool, 'spe_card')\n            SMODS.add_card { set = \"Base\", suit = \"D\", enhancement = enhancement }\n            return {\n                message = localize(\"k_joy_activated_ex\")\n            }\n        end\n    end"
    },
    {
      "type": "Atlas",
      "key": "vw",
      "atlas": null,
      "pos": null,
      "raw": "key = \"vw\",\n    path = \"23VirtualWorld.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Joker",
      "key": "vw_lulu",
      "atlas": "vw",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"vw_lulu\",\n    atlas = 'vw',\n    pos = { x = 2, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 0,\n    loc_vars = function(self, info_queue, card)\n        return { vars = {} }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"VirtualWorld\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_tuner = true,\n                attribute = \"WIND\",\n                monster_type = \"Psychic\",\n                monster_archetypes = { [\"VirtualWorld\"] = true }\n            },\n        },\n    },"
    },
    {
      "type": "Joker",
      "key": "vw_nyannyan",
      "atlas": "vw",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"vw_nyannyan\",\n    atlas = 'vw',\n    pos = { x = 0, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 0,\n    loc_vars = function(self, info_queue, card)\n        return { vars = {} }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"VirtualWorld\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"WIND\",\n                monster_type = \"Psychic\",\n                monster_archetypes = { [\"VirtualWorld\"] = true }\n            },\n        },\n    },"
    },
    {
      "type": "Joker",
      "key": "vw_jiji",
      "atlas": "vw",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"vw_jiji\",\n    atlas = 'vw',\n    pos = { x = 1, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 0,\n    loc_vars = function(self, info_queue, card)\n        return { vars = {} }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"VirtualWorld\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"EARTH\",\n                monster_type = \"Wyrm\",\n                monster_archetypes = { [\"VirtualWorld\"] = true }\n            },\n        },\n    },"
    },
    {
      "type": "Joker",
      "key": "vw_toutou",
      "atlas": "vw",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"vw_toutou\",\n    atlas = 'vw',\n    pos = { x = 3, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 0,\n    loc_vars = function(self, info_queue, card)\n        return { vars = {} }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"VirtualWorld\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"EARTH\",\n                monster_type = \"Wyrm\",\n                monster_archetypes = { [\"VirtualWorld\"] = true }\n            },\n        },\n    },"
    },
    {
      "type": "Joker",
      "key": "vw_lili",
      "atlas": "vw",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"vw_lili\",\n    atlas = 'vw',\n    pos = { x = 1, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 0,\n    loc_vars = function(self, info_queue, card)\n        return { vars = {} }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"VirtualWorld\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"EARTH\",\n                monster_type = \"Wyrm\",\n                monster_archetypes = { [\"VirtualWorld\"] = true }\n            },\n        },\n    },"
    },
    {
      "type": "Joker",
      "key": "vw_laolao",
      "atlas": "vw",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"vw_laolao\",\n    atlas = 'vw',\n    pos = { x = 0, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 0,\n    loc_vars = function(self, info_queue, card)\n        return { vars = {} }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"VirtualWorld\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_tuner = true,\n                attribute = \"WIND\",\n                monster_type = \"Psychic\",\n                monster_archetypes = { [\"VirtualWorld\"] = true }\n            },\n        },\n    },"
    },
    {
      "type": "Joker",
      "key": "vw_longlong",
      "atlas": "vw",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = \"vw_longlong\",\n    atlas = 'vw',\n    pos = { x = 0, y = 2 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 0,\n    loc_vars = function(self, info_queue, card)\n        return { vars = {} }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"VirtualWorld\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"EARTH\",\n                monster_type = \"Wyrm\",\n                monster_archetypes = { [\"VirtualWorld\"] = true }\n            },\n        },\n    },"
    },
    {
      "type": "Joker",
      "key": "vw_jaja",
      "atlas": "vw",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "key = \"vw_jaja\",\n    atlas = 'vw',\n    pos = { x = 2, y = 2 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 0,\n    loc_vars = function(self, info_queue, card)\n        return { vars = {} }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"VirtualWorld\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"EARTH\",\n                monster_type = \"Wyrm\",\n                monster_archetypes = { [\"VirtualWorld\"] = true }\n            },\n        },\n    },"
    },
    {
      "type": "Joker",
      "key": "vw_fanfan",
      "atlas": "vw",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "key = \"vw_fanfan\",\n    atlas = 'vw',\n    pos = { x = 1, y = 2 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 0,\n    loc_vars = function(self, info_queue, card)\n        return { vars = {} }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"VirtualWorld\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"EARTH\",\n                monster_type = \"Wyrm\",\n                monster_archetypes = { [\"VirtualWorld\"] = true }\n            },\n        },\n    },"
    },
    {
      "type": "Joker",
      "key": "vw_fufu",
      "atlas": "vw",
      "pos": {
        "x": 3,
        "y": 2
      },
      "raw": "key = \"vw_fufu\",\n    atlas = 'vw',\n    pos = { x = 3, y = 2 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 0,\n    loc_vars = function(self, info_queue, card)\n        return { vars = {} }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"VirtualWorld\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"EARTH\",\n                monster_type = \"Wyrm\",\n                monster_archetypes = { [\"VirtualWorld\"] = true }\n            },\n        },\n    },"
    },
    {
      "type": "Joker",
      "key": "vw_jiujiu",
      "atlas": "vw",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"vw_jiujiu\",\n    atlas = 'vw',\n    pos = { x = 2, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 0,\n    loc_vars = function(self, info_queue, card)\n        return { vars = {} }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"VirtualWorld\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"WIND\",\n                monster_type = \"Psychic\",\n                monster_archetypes = { [\"VirtualWorld\"] = true }\n            },\n        },\n    },"
    },
    {
      "type": "Joker",
      "key": "vw_shenshen",
      "atlas": "vw",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"vw_shenshen\",\n    atlas = 'vw',\n    pos = { x = 3, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 0,\n    loc_vars = function(self, info_queue, card)\n        return { vars = {} }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"VirtualWorld\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"WIND\",\n                monster_type = \"Psychic\",\n                monster_archetypes = { [\"VirtualWorld\"] = true }\n            },\n        },\n    },"
    },
    {
      "type": "Atlas",
      "key": "cardian",
      "atlas": null,
      "pos": null,
      "raw": "key = \"cardian\",\n    path = \"24FlowerCardian.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Joker",
      "key": "cardian_pine",
      "atlas": "cardian",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"cardian_pine\",\n    atlas = 'cardian',\n    pos = { x = 3, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 3,\n    loc_vars = function(self, info_queue, card)\n        return {\n            vars = {\n                card.ability.extra.mult,\n                card.ability.extra.mult *\n                JoyousSpring.count_all_materials({ { monster_archetypes = { \"FlowerCardian\" } } }),\n                card.ability.extra.excavates,\n                card.ability.extra.draws,\n                card.ability.extra.creates,\n            }\n        }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"FlowerCardian\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Warrior\",\n                monster_archetypes = { [\"FlowerCardian\"] = true }\n            },\n            mult = 1,\n            excavates = 3,\n            draws = 1,\n            creates = 1,\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.individual and context.cardarea == G.play then\n                if cardian_is_hanafuda_month(context.other_card, { \"january\", \"february\" }) then\n                    return {\n                        mult = card.ability.extra.mult *\n                            JoyousSpring.count_all_materials({ { monster_archetypes = { \"FlowerCardian\" } } })\n                    }\n                end\n            end\n            if context.joy_excavated and context.joy_number <= card.ability.extra.excavates and context.joy_other_context.setting_blind then\n                local hit\n                if context.joy_excavated:is_suit(\"Spades\") then\n                    if not next(SMODS.get_enhancements(context.joy_excavated)) then\n                        context.joy_excavated:set_ability(\"m_joy_hanafuda\")\n                    end\n                    hit = true\n                end\n                if cardian_is_hanafuda_month(context.joy_excavated, { \"january\", \"february\" }) then\n                    card.joy_draw = true\n                    hit = true\n                end\n                card.joy_hit = card.joy_hit or hit\n                return {\n                    message = hit and localize(\"k_joy_hit\") or nil\n                }\n            end\n            if context.setting_blind then\n                if not card.joy_hit then\n                    local added_card = JoyousSpring.create_summon({\n                        key = \"j_joy_cardian_crane\"\n                    }, false)\n\n                    JoyousSpring.banish(added_card, \"boss_selected\")\n                    G.E_MANAGER:add_event(Event({\n                        func = (function()\n                            card.getting_sliced = true\n                            card:start_dissolve()\n                            return true\n                        end),\n                    }))\n                end\n                card.joy_hit = nil\n            end\n            if context.first_hand_drawn and card.joy_draw then\n                card.joy_draw = nil\n                SMODS.draw_cards(card.ability.extra.draws)\n            end\n            if context.end_of_round and context.game_over == false and context.main_eval then\n                if JoyousSpring.count_materials_owned({ { monster_archetypes = { \"FlowerCardian\" } } }) > 1 then\n                    SMODS.add_card({\n                        key = \"c_joy_cardian_gathering\"\n                    })\n                end\n            end\n        end\n    end,\n    joy_calculate_excavate = cardian_excavate,\n    joy_bypass_room_check = cardian_bypass_room_check"
    },
    {
      "type": "Joker",
      "key": "cardian_crane",
      "atlas": "cardian",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"cardian_crane\",\n    atlas = 'cardian',\n    pos = { x = 2, y = 1 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.mult, card.ability.extra.excavates, card.ability.extra.draws, card.ability.extra.creates } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"FlowerCardian\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Warrior\",\n                monster_archetypes = { [\"FlowerCardian\"] = true }\n            },\n            mult = 20,\n            excavates = 5,\n            draws = 1,\n            creates = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.individual and context.cardarea == G.hand and not context.end_of_round then\n                if cardian_is_hanafuda_month(context.other_card, { \"january\", \"february\" }) then\n                    return {\n                        mult = card.ability.extra.mult\n                    }\n                end\n            end\n            if context.joy_excavated and context.joy_number <= card.ability.extra.excavates and context.joy_other_context.setting_blind then\n                local hit\n                if context.joy_excavated:is_suit(\"Spades\") then\n                    if not next(SMODS.get_enhancements(context.joy_excavated)) then\n                        context.joy_excavated:set_ability(\"m_joy_hanafuda\")\n                    end\n                    hit = true\n                end\n                if cardian_is_hanafuda_month(context.joy_excavated, { \"january\", \"february\" }) then\n                    card.joy_draw = true\n                    hit = true\n                end\n                card.joy_hit = card.joy_hit or hit\n                return {\n                    message = hit and localize(\"k_joy_hit\") or nil\n                }\n            end\n            if context.setting_blind then\n                if not card.joy_hit then\n                    local added_card = JoyousSpring.create_summon({\n                        key = \"j_joy_cardian_pine\"\n                    }, false)\n\n                    JoyousSpring.banish(added_card, \"end_of_round\")\n                    G.E_MANAGER:add_event(Event({\n                        func = (function()\n                            card.getting_sliced = true\n                            card:start_dissolve()\n                            return true\n                        end),\n                    }))\n                end\n                card.joy_hit = nil\n            end\n            if context.first_hand_drawn and card.joy_draw then\n                card.joy_draw = nil\n                SMODS.draw_cards(card.ability.extra.draws)\n            end\n            if context.end_of_round and context.game_over == false and context.main_eval then\n                if JoyousSpring.count_materials_owned({ { monster_archetypes = { \"FlowerCardian\" } } }) > 1 then\n                    SMODS.add_card({\n                        key = \"c_joy_cardian_gathering\"\n                    })\n                end\n            end\n        end\n    end,\n    joy_calculate_excavate = cardian_excavate,\n    joy_bypass_room_check = cardian_bypass_room_check"
    },
    {
      "type": "Joker",
      "key": "cardian_cherry",
      "atlas": "cardian",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"cardian_cherry\",\n    atlas = 'cardian',\n    pos = { x = 1, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 3,\n    loc_vars = function(self, info_queue, card)\n        return {\n            vars = { card.ability.extra.mult, card.ability.extra.mult *\n            JoyousSpring.count_all_materials({ { monster_archetypes = { \"FlowerCardian\" } } }), card.ability.extra\n                .excavates, card.ability.extra.draws, card.ability.extra.creates }\n        }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"FlowerCardian\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Warrior\",\n                monster_archetypes = { [\"FlowerCardian\"] = true }\n            },\n            mult = 1,\n            excavates = 3,\n            draws = 1,\n            creates = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.individual and context.cardarea == G.play then\n                if cardian_is_hanafuda_month(context.other_card, { \"march\", \"april\" }) then\n                    return {\n                        mult = card.ability.extra.mult *\n                            JoyousSpring.count_all_materials({ { monster_archetypes = { \"FlowerCardian\" } } })\n                    }\n                end\n            end\n            if context.joy_excavated and context.joy_number <= card.ability.extra.excavates and context.joy_other_context.setting_blind then\n                local hit\n                if context.joy_excavated:is_suit(\"Hearts\") then\n                    if not next(SMODS.get_enhancements(context.joy_excavated)) then\n                        context.joy_excavated:set_ability(\"m_joy_hanafuda\")\n                    end\n                    hit = true\n                end\n                if cardian_is_hanafuda_month(context.joy_excavated, { \"march\", \"april\" }) then\n                    card.joy_draw = true\n                    hit = true\n                end\n                card.joy_hit = card.joy_hit or hit\n                return {\n                    message = hit and localize(\"k_joy_hit\") or nil\n                }\n            end\n            if context.setting_blind then\n                if not card.joy_hit then\n                    local added_card = JoyousSpring.create_summon({\n                        key = \"j_joy_cardian_curtain\"\n                    }, false)\n\n                    JoyousSpring.banish(added_card, \"boss_selected\")\n                    G.E_MANAGER:add_event(Event({\n                        func = (function()\n                            card.getting_sliced = true\n                            card:start_dissolve()\n                            return true\n                        end),\n                    }))\n                end\n                card.joy_hit = nil\n            end\n            if context.first_hand_drawn and card.joy_draw then\n                card.joy_draw = nil\n                SMODS.draw_cards(card.ability.extra.draws)\n            end\n            if context.end_of_round and context.game_over == false and context.main_eval then\n                if JoyousSpring.count_materials_owned({ { monster_archetypes = { \"FlowerCardian\" } } }) > 1 then\n                    SMODS.add_card({\n                        key = \"c_joy_cardian_gathering\"\n                    })\n                end\n            end\n        end\n    end,\n    joy_calculate_excavate = cardian_excavate,\n    joy_bypass_room_check = cardian_bypass_room_check"
    },
    {
      "type": "Joker",
      "key": "cardian_curtain",
      "atlas": "cardian",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"cardian_curtain\",\n    atlas = 'cardian',\n    pos = { x = 0, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.mult, card.ability.extra.excavates, card.ability.extra.draws, card.ability.extra.creates } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"FlowerCardian\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Warrior\",\n                monster_archetypes = { [\"FlowerCardian\"] = true }\n            },\n            mult = 20,\n            excavates = 5,\n            draws = 1,\n            creates = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.individual and context.cardarea == G.hand and not context.end_of_round then\n                if cardian_is_hanafuda_month(context.other_card, { \"march\", \"april\" }) then\n                    return {\n                        mult = card.ability.extra.mult\n                    }\n                end\n            end\n            if context.joy_excavated and context.joy_number <= card.ability.extra.excavates and context.joy_other_context.setting_blind then\n                local hit\n                if context.joy_excavated:is_suit(\"Hearts\") then\n                    if not next(SMODS.get_enhancements(context.joy_excavated)) then\n                        context.joy_excavated:set_ability(\"m_joy_hanafuda\")\n                    end\n                    hit = true\n                end\n                if cardian_is_hanafuda_month(context.joy_excavated, { \"march\", \"april\" }) then\n                    card.joy_draw = true\n                    hit = true\n                end\n                card.joy_hit = card.joy_hit or hit\n                return {\n                    message = hit and localize(\"k_joy_hit\") or nil\n                }\n            end\n            if context.setting_blind then\n                if not card.joy_hit then\n                    local added_card = JoyousSpring.create_summon({\n                        key = \"j_joy_cardian_cherry\"\n                    }, false)\n\n                    JoyousSpring.banish(added_card, \"end_of_round\")\n                    G.E_MANAGER:add_event(Event({\n                        func = (function()\n                            card.getting_sliced = true\n                            card:start_dissolve()\n                            return true\n                        end),\n                    }))\n                end\n                card.joy_hit = nil\n            end\n            if context.first_hand_drawn and card.joy_draw then\n                card.joy_draw = nil\n                SMODS.draw_cards(card.ability.extra.draws)\n            end\n            if context.end_of_round and context.game_over == false and context.main_eval then\n                if JoyousSpring.count_materials_owned({ { monster_archetypes = { \"FlowerCardian\" } } }) > 1 then\n                    SMODS.add_card({\n                        key = \"c_joy_cardian_gathering\"\n                    })\n                end\n            end\n        end\n    end,\n    joy_calculate_excavate = cardian_excavate,\n    joy_bypass_room_check = cardian_bypass_room_check"
    },
    {
      "type": "Joker",
      "key": "cardian_butterfly",
      "atlas": "cardian",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"cardian_butterfly\",\n    atlas = 'cardian',\n    pos = { x = 1, y = 1 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 7,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.xmult, card.ability.extra.excavates, card.ability.extra.draws, card.ability.extra.adds, card.ability.extra.creates } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"FlowerCardian\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_tuner = true,\n                attribute = \"DARK\",\n                monster_type = \"Warrior\",\n                monster_archetypes = { [\"FlowerCardian\"] = true }\n            },\n            xmult = 1.1,\n            excavates = 5,\n            draws = 1,\n            adds = 1,\n            creates = 1,\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.individual and context.cardarea == G.play then\n                if cardian_is_hanafuda_month(context.other_card, { \"june\" }) then\n                    return {\n                        xmult = card.ability.extra.xmult\n                    }\n                end\n            end\n            if context.joy_excavated and context.joy_number <= card.ability.extra.excavates and context.joy_other_context.setting_blind then\n                local hit\n                if cardian_is_hanafuda_month(context.joy_excavated, { \"june\" }) then\n                    card.joy_draw = true\n                    hit = true\n                end\n                if JoyousSpring.get_hanafuda(context.joy_excavated) and (next(SMODS.find_card(\"j_joy_cardian_lightflare\")) or JoyousSpring.get_hanafuda(context.joy_excavated).type == \"light\") then\n                    local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"FlowerCardian\" }, is_extra_deck = true } })\n                    for i = 1, card.ability.extra.adds do\n                        local key_to_add, _ = pseudorandom_element(choices, 'j_joy_cardian_butterfly')\n                        if key_to_add and #JoyousSpring.extra_deck_area.cards < JoyousSpring.extra_deck_area.config.card_limit then\n                            JoyousSpring.add_to_extra_deck(key_to_add)\n                        end\n                    end\n                    hit = true\n                end\n                card.joy_hit = card.joy_hit or hit\n                return {\n                    message = hit and localize(\"k_joy_hit\") or nil\n                }\n            end\n            if context.setting_blind then\n                if not card.joy_hit then\n                    local added_card = JoyousSpring.create_pseudorandom({ { monster_archetypes = { \"FlowerCardian\" } } },\n                        \"j_joy_cardian_butterfly\", false)\n\n                    JoyousSpring.banish(added_card, \"end_of_round\")\n                    G.E_MANAGER:add_event(Event({\n                        func = (function()\n                            card.getting_sliced = true\n                            card:start_dissolve()\n                            return true\n                        end),\n                    }))\n                end\n                card.joy_hit = nil\n            end\n            if context.first_hand_drawn and card.joy_draw then\n                card.joy_draw = nil\n                SMODS.draw_cards(card.ability.extra.draws)\n            end\n            if context.end_of_round and context.game_over == false and context.main_eval then\n                if JoyousSpring.count_materials_owned({ { monster_archetypes = { \"FlowerCardian\" } } }) > 1 then\n                    SMODS.add_card({\n                        key = \"c_joy_cardian_gathering\"\n                    })\n                end\n            end\n        end\n    end,\n    joy_calculate_excavate = cardian_excavate,\n    joy_bypass_room_check = cardian_bypass_room_check"
    },
    {
      "type": "Joker",
      "key": "cardian_boar",
      "atlas": "cardian",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"cardian_boar\",\n    atlas = 'cardian',\n    pos = { x = 2, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 7,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.xmult, card.ability.extra.excavates, card.ability.extra.draws, card.ability.extra.adds, card.ability.extra.creates } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"FlowerCardian\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Warrior\",\n                monster_archetypes = { [\"FlowerCardian\"] = true }\n            },\n            xmult = 1.1,\n            excavates = 5,\n            draws = 1,\n            adds = 1,\n            creates = 1,\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.individual and context.cardarea == G.play then\n                if cardian_is_hanafuda_month(context.other_card, { \"july\" }) then\n                    return {\n                        xmult = card.ability.extra.xmult\n                    }\n                end\n            end\n            if context.joy_excavated and context.joy_number <= card.ability.extra.excavates and context.joy_other_context.setting_blind then\n                local hit\n                if cardian_is_hanafuda_month(context.joy_excavated, { \"july\" }) then\n                    card.joy_draw = true\n                    hit = true\n                end\n                if JoyousSpring.get_hanafuda(context.joy_excavated) and (next(SMODS.find_card(\"j_joy_cardian_lightflare\")) or JoyousSpring.get_hanafuda(context.joy_excavated).type == \"light\") then\n                    local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"FlowerCardian\" }, is_extra_deck = true } })\n                    for i = 1, card.ability.extra.adds do\n                        local key_to_add, _ = pseudorandom_element(choices, 'j_joy_cardian_boar')\n                        if key_to_add and #JoyousSpring.extra_deck_area.cards < JoyousSpring.extra_deck_area.config.card_limit then\n                            JoyousSpring.add_to_extra_deck(key_to_add)\n                        end\n                    end\n                    hit = true\n                end\n                card.joy_hit = card.joy_hit or hit\n                return {\n                    message = hit and localize(\"k_joy_hit\") or nil\n                }\n            end\n            if context.setting_blind then\n                if not card.joy_hit then\n                    local added_card = JoyousSpring.create_pseudorandom({ { monster_archetypes = { \"FlowerCardian\" } } },\n                        \"j_joy_cardian_boar\", false)\n\n                    JoyousSpring.banish(added_card, \"end_of_round\")\n                    G.E_MANAGER:add_event(Event({\n                        func = (function()\n                            card.getting_sliced = true\n                            card:start_dissolve()\n                            return true\n                        end),\n                    }))\n                end\n                card.joy_hit = nil\n            end\n            if context.first_hand_drawn and card.joy_draw then\n                card.joy_draw = nil\n                SMODS.draw_cards(card.ability.extra.draws)\n            end\n            if context.end_of_round and context.game_over == false and context.main_eval then\n                if JoyousSpring.count_materials_owned({ { monster_archetypes = { \"FlowerCardian\" } } }) > 1 then\n                    SMODS.add_card({\n                        key = \"c_joy_cardian_gathering\"\n                    })\n                end\n            end\n        end\n    end,\n    joy_calculate_excavate = cardian_excavate,\n    joy_bypass_room_check = cardian_bypass_room_check"
    },
    {
      "type": "Joker",
      "key": "cardian_zebra",
      "atlas": "cardian",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "key = \"cardian_zebra\",\n    atlas = 'cardian',\n    pos = { x = 2, y = 2 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 3,\n    loc_vars = function(self, info_queue, card)\n        return {\n            vars = { card.ability.extra.money, card.ability.extra.money *\n            JoyousSpring.count_all_materials({ { monster_archetypes = { \"FlowerCardian\" } } }), card.ability.extra\n                .excavates, card.ability.extra.draws, card.ability.extra.creates }\n        }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"FlowerCardian\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Warrior\",\n                monster_archetypes = { [\"FlowerCardian\"] = true }\n            },\n            money = 1,\n            excavates = 3,\n            draws = 1,\n            creates = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.individual and context.cardarea == G.play then\n                if cardian_is_hanafuda_month(context.other_card, { \"august\", \"september\" }) then\n                    return {\n                        dollars = card.ability.extra.money *\n                            JoyousSpring.count_all_materials({ { monster_archetypes = { \"FlowerCardian\" } } })\n                    }\n                end\n            end\n            if context.joy_excavated and context.joy_number <= card.ability.extra.excavates and context.joy_other_context.setting_blind then\n                local hit\n                if context.joy_excavated:is_suit(\"Clubs\") then\n                    if not next(SMODS.get_enhancements(context.joy_excavated)) then\n                        context.joy_excavated:set_ability(\"m_joy_hanafuda\")\n                    end\n                    hit = true\n                end\n                if cardian_is_hanafuda_month(context.joy_excavated, { \"august\", \"september\" }) then\n                    card.joy_draw = true\n                    hit = true\n                end\n                card.joy_hit = card.joy_hit or hit\n                return {\n                    message = hit and localize(\"k_joy_hit\") or nil\n                }\n            end\n            if context.setting_blind then\n                if not card.joy_hit then\n                    local added_card = JoyousSpring.create_summon({\n                        key = \"j_joy_cardian_moon\"\n                    }, false)\n\n                    JoyousSpring.banish(added_card, \"boss_selected\")\n                    G.E_MANAGER:add_event(Event({\n                        func = (function()\n                            card.getting_sliced = true\n                            card:start_dissolve()\n                            return true\n                        end),\n                    }))\n                end\n                card.joy_hit = nil\n            end\n            if context.first_hand_drawn and card.joy_draw then\n                card.joy_draw = nil\n                SMODS.draw_cards(card.ability.extra.draws)\n            end\n            if context.end_of_round and context.game_over == false and context.main_eval then\n                if JoyousSpring.count_materials_owned({ { monster_archetypes = { \"FlowerCardian\" } } }) > 1 then\n                    SMODS.add_card({\n                        key = \"c_joy_cardian_gathering\"\n                    })\n                end\n            end\n        end\n    end,\n    joy_calculate_excavate = cardian_excavate,\n    joy_bypass_room_check = cardian_bypass_room_check"
    },
    {
      "type": "Joker",
      "key": "cardian_moon",
      "atlas": "cardian",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "key = \"cardian_moon\",\n    atlas = 'cardian',\n    pos = { x = 1, y = 2 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.excavates, card.ability.extra.draws, card.ability.extra.creates } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"FlowerCardian\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Warrior\",\n                monster_archetypes = { [\"FlowerCardian\"] = true }\n            },\n            excavates = 7,\n            draws = 1,\n            creates = 1,\n            hanafuda_count = 0\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joy_excavated and context.joy_number <= card.ability.extra.excavates and context.joy_other_context.setting_blind then\n                local hit\n                if context.joy_excavated:is_suit(\"Clubs\") then\n                    if not next(SMODS.get_enhancements(context.joy_excavated)) then\n                        context.joy_excavated:set_ability(\"m_joy_hanafuda\")\n                    end\n                    hit = true\n                end\n                if cardian_is_hanafuda_month(context.joy_excavated, { \"august\", \"september\" }) then\n                    card.joy_draw = true\n                    hit = true\n                end\n                if JoyousSpring.get_hanafuda(context.joy_excavated) then\n                    card.ability.extra.hanafuda_count = card.ability.extra.hanafuda_count + 1\n                end\n                card.joy_hit = card.joy_hit or hit\n                return {\n                    message = hit and localize(\"k_joy_hit\") or nil\n                }\n            end\n            if context.setting_blind then\n                if not card.joy_hit then\n                    local added_card = JoyousSpring.create_summon({\n                        key = \"j_joy_cardian_zebra\"\n                    }, false)\n\n                    JoyousSpring.banish(added_card, \"end_of_round\")\n                    G.E_MANAGER:add_event(Event({\n                        func = (function()\n                            card.getting_sliced = true\n                            card:start_dissolve()\n                            return true\n                        end),\n                    }))\n                end\n                card.joy_hit = nil\n            end\n            if context.first_hand_drawn then\n                if card.joy_draw then\n                    card.joy_draw = nil\n                    SMODS.draw_cards(card.ability.extra.draws * card.ability.extra.hanafuda_count)\n                end\n                card.ability.extra.hanafuda_count = 0\n            end\n            if context.end_of_round and context.game_over == false and context.main_eval then\n                if JoyousSpring.count_materials_owned({ { monster_archetypes = { \"FlowerCardian\" } } }) > 1 then\n                    SMODS.add_card({\n                        key = \"c_joy_cardian_gathering\"\n                    })\n                end\n            end\n        end\n    end,\n    joy_calculate_excavate = cardian_excavate,\n    joy_bypass_room_check = cardian_bypass_room_check"
    },
    {
      "type": "Joker",
      "key": "cardian_deer",
      "atlas": "cardian",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"cardian_deer\",\n    atlas = 'cardian',\n    pos = { x = 3, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 7,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.xmult, card.ability.extra.excavates, card.ability.extra.draws, card.ability.extra.adds, card.ability.extra.creates } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"FlowerCardian\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Warrior\",\n                monster_archetypes = { [\"FlowerCardian\"] = true }\n            },\n            xmult = 1.1,\n            excavates = 5,\n            draws = 1,\n            adds = 1,\n            creates = 1,\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.individual and context.cardarea == G.play then\n                if cardian_is_hanafuda_month(context.other_card, { \"october\" }) then\n                    return {\n                        xmult = card.ability.extra.xmult\n                    }\n                end\n            end\n            if context.joy_excavated and context.joy_number <= card.ability.extra.excavates and context.joy_other_context.setting_blind then\n                local hit\n                if cardian_is_hanafuda_month(context.joy_excavated, { \"october\" }) then\n                    card.joy_draw = true\n                    hit = true\n                end\n                if JoyousSpring.get_hanafuda(context.joy_excavated) and (next(SMODS.find_card(\"j_joy_cardian_lightflare\")) or JoyousSpring.get_hanafuda(context.joy_excavated).type == \"light\") then\n                    local choices = JoyousSpring.get_materials_in_collection({ { monster_archetypes = { \"FlowerCardian\" } } })\n                    for i = 1, card.ability.extra.adds do\n                        local key_to_add = pseudorandom_element(choices, 'j_joy_moissa')\n                        JoyousSpring.add_monster_tag(key_to_add or \"j_joy_eccentrick\")\n                    end\n                    hit = true\n                end\n                card.joy_hit = card.joy_hit or hit\n                return {\n                    message = hit and localize(\"k_joy_hit\") or nil\n                }\n            end\n            if context.setting_blind then\n                if not card.joy_hit then\n                    local added_card = JoyousSpring.create_pseudorandom({ { monster_archetypes = { \"FlowerCardian\" } } },\n                        \"j_joy_cardian_deer\", false)\n\n                    JoyousSpring.banish(added_card, \"end_of_round\")\n                    G.E_MANAGER:add_event(Event({\n                        func = (function()\n                            card.getting_sliced = true\n                            card:start_dissolve()\n                            return true\n                        end),\n                    }))\n                end\n                card.joy_hit = nil\n            end\n            if context.first_hand_drawn and card.joy_draw then\n                card.joy_draw = nil\n                SMODS.draw_cards(card.ability.extra.draws)\n            end\n            if context.end_of_round and context.game_over == false and context.main_eval then\n                if JoyousSpring.count_materials_owned({ { monster_archetypes = { \"FlowerCardian\" } } }) > 1 then\n                    SMODS.add_card({\n                        key = \"c_joy_cardian_gathering\"\n                    })\n                end\n            end\n        end\n    end,\n    joy_calculate_excavate = cardian_excavate,\n    joy_bypass_room_check = cardian_bypass_room_check"
    },
    {
      "type": "Joker",
      "key": "cardian_willow",
      "atlas": "cardian",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = \"cardian_willow\",\n    atlas = 'cardian',\n    pos = { x = 0, y = 2 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 3,\n    loc_vars = function(self, info_queue, card)\n        return {\n            vars = { card.ability.extra.money, card.ability.extra.money *\n            JoyousSpring.count_all_materials({ { monster_archetypes = { \"FlowerCardian\" } } }), card.ability.extra\n                .excavates, card.ability.extra.draws, card.ability.extra.creates }\n        }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"FlowerCardian\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Warrior\",\n                monster_archetypes = { [\"FlowerCardian\"] = true }\n            },\n            money = 1,\n            excavates = 3,\n            draws = 1,\n            creates = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.individual and context.cardarea == G.play then\n                if cardian_is_hanafuda_month(context.other_card, { \"november\" }) then\n                    return {\n                        dollars = card.ability.extra.money *\n                            JoyousSpring.count_all_materials({ { monster_archetypes = { \"FlowerCardian\" } } })\n                    }\n                end\n            end\n            if context.joy_excavated and context.joy_number <= card.ability.extra.excavates and context.joy_other_context.setting_blind then\n                local hit\n                if context.joy_excavated:is_face() then\n                    if not next(SMODS.get_enhancements(context.joy_excavated)) then\n                        context.joy_excavated:set_ability(\"m_joy_hanafuda\")\n                    end\n                    hit = true\n                end\n                if cardian_is_hanafuda_month(context.joy_excavated, { \"november\" }) then\n                    card.joy_draw = true\n                    hit = true\n                end\n                card.joy_hit = card.joy_hit or hit\n                return {\n                    message = hit and localize(\"k_joy_hit\") or nil\n                }\n            end\n            if context.setting_blind then\n                if not card.joy_hit then\n                    local added_card = JoyousSpring.create_summon({\n                        key = \"j_joy_cardian_calligrapher\"\n                    }, false)\n\n                    JoyousSpring.banish(added_card, \"boss_selected\")\n                    G.E_MANAGER:add_event(Event({\n                        func = (function()\n                            card.getting_sliced = true\n                            card:start_dissolve()\n                            return true\n                        end),\n                    }))\n                end\n                card.joy_hit = nil\n            end\n            if context.first_hand_drawn and card.joy_draw then\n                card.joy_draw = nil\n                SMODS.draw_cards(card.ability.extra.draws)\n            end\n            if context.end_of_round and context.game_over == false and context.main_eval then\n                if JoyousSpring.count_materials_owned({ { monster_archetypes = { \"FlowerCardian\" } } }) > 1 then\n                    SMODS.add_card({\n                        key = \"c_joy_cardian_gathering\"\n                    })\n                end\n            end\n        end\n    end,\n    joy_calculate_excavate = cardian_excavate,\n    joy_bypass_room_check = cardian_bypass_room_check"
    },
    {
      "type": "Joker",
      "key": "cardian_calligrapher",
      "atlas": "cardian",
      "pos": {
        "x": 4,
        "y": 1
      },
      "raw": "key = \"cardian_calligrapher\",\n    atlas = 'cardian',\n    pos = { x = 4, y = 1 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.excavates, card.ability.extra.revives, card.ability.extra.creates } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"FlowerCardian\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_tuner = true,\n                attribute = \"DARK\",\n                monster_type = \"Warrior\",\n                monster_archetypes = { [\"FlowerCardian\"] = true }\n            },\n            excavates = 5,\n            revives = 1,\n            creates = 1,\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joy_excavated and context.joy_number <= card.ability.extra.excavates and context.joy_other_context.setting_blind then\n                local hit\n                if context.joy_excavated:is_face() then\n                    if not next(SMODS.get_enhancements(context.joy_excavated)) then\n                        context.joy_excavated:set_ability(\"m_joy_hanafuda\")\n                    end\n                    hit = true\n                end\n                if cardian_is_hanafuda_month(context.joy_excavated, { \"november\" }) then\n                    for i = 1, card.ability.extra.revives do\n                        local revived_card = JoyousSpring.revive_pseudorandom(\n                            { { monster_archetypes = { \"FlowerCardian\" } } },\n                            'j_joy_cardian_calligrapher',\n                            true\n                        )\n                    end\n                    hit = true\n                end\n                card.joy_hit = card.joy_hit or hit\n                return {\n                    message = hit and localize(\"k_joy_hit\") or nil\n                }\n            end\n            if context.setting_blind then\n                if not card.joy_hit then\n                    local added_card = JoyousSpring.create_summon({\n                        key = \"j_joy_cardian_willow\"\n                    }, false)\n\n                    JoyousSpring.banish(added_card, \"end_of_round\")\n                    G.E_MANAGER:add_event(Event({\n                        func = (function()\n                            card.getting_sliced = true\n                            card:start_dissolve()\n                            return true\n                        end),\n                    }))\n                end\n                card.joy_hit = nil\n            end\n            if context.end_of_round and context.game_over == false and context.main_eval then\n                if JoyousSpring.count_materials_owned({ { monster_archetypes = { \"FlowerCardian\" } } }) > 1 then\n                    SMODS.add_card({\n                        key = \"c_joy_cardian_gathering\"\n                    })\n                end\n            end\n        end\n    end,\n    joy_calculate_excavate = cardian_excavate,\n    joy_bypass_room_check = cardian_bypass_room_check"
    },
    {
      "type": "Joker",
      "key": "cardian_paulownia",
      "atlas": "cardian",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"cardian_paulownia\",\n    atlas = 'cardian',\n    pos = { x = 0, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 3,\n    loc_vars = function(self, info_queue, card)\n        return {\n            vars = { card.ability.extra.mult, card.ability.extra.mult *\n            JoyousSpring.count_all_materials({ { monster_archetypes = { \"FlowerCardian\" } } }), card.ability.extra\n                .excavates, card.ability.extra.draws, card.ability.extra.creates }\n        }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"FlowerCardian\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Warrior\",\n                monster_archetypes = { [\"FlowerCardian\"] = true }\n            },\n            mult = 1,\n            excavates = 3,\n            draws = 1,\n            creates = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.individual and context.cardarea == G.play then\n                if cardian_is_hanafuda_month(context.other_card, { \"may\", \"december\" }) then\n                    return {\n                        mult = card.ability.extra.mult *\n                            JoyousSpring.count_all_materials({ { monster_archetypes = { \"FlowerCardian\" } } })\n                    }\n                end\n            end\n            if context.joy_excavated and context.joy_number <= card.ability.extra.excavates and context.joy_other_context.setting_blind then\n                local hit\n                if context.joy_excavated:is_suit(\"Diamonds\") then\n                    if not next(SMODS.get_enhancements(context.joy_excavated)) then\n                        context.joy_excavated:set_ability(\"m_joy_hanafuda\")\n                    end\n                    hit = true\n                end\n                if cardian_is_hanafuda_month(context.joy_excavated, { \"may\", \"december\" }) then\n                    card.joy_draw = true\n                    hit = true\n                end\n                card.joy_hit = card.joy_hit or hit\n                return {\n                    message = hit and localize(\"k_joy_hit\") or nil\n                }\n            end\n            if context.setting_blind then\n                if not card.joy_hit then\n                    local added_card = JoyousSpring.create_summon({\n                        key = \"j_joy_cardian_phoenix\"\n                    }, false)\n\n                    JoyousSpring.banish(added_card, \"boss_selected\")\n                    G.E_MANAGER:add_event(Event({\n                        func = (function()\n                            card.getting_sliced = true\n                            card:start_dissolve()\n                            return true\n                        end),\n                    }))\n                end\n                card.joy_hit = nil\n            end\n            if context.first_hand_drawn and card.joy_draw then\n                card.joy_draw = nil\n                SMODS.draw_cards(card.ability.extra.draws)\n            end\n            if context.end_of_round and context.game_over == false and context.main_eval then\n                if JoyousSpring.count_materials_owned({ { monster_archetypes = { \"FlowerCardian\" } } }) > 1 then\n                    SMODS.add_card({\n                        key = \"c_joy_cardian_gathering\"\n                    })\n                end\n            end\n        end\n    end,\n    joy_calculate_excavate = cardian_excavate,\n    joy_bypass_room_check = cardian_bypass_room_check"
    },
    {
      "type": "Joker",
      "key": "cardian_phoenix",
      "atlas": "cardian",
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "key = \"cardian_phoenix\",\n    atlas = 'cardian',\n    pos = { x = 4, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.mult, card.ability.extra.excavates, card.ability.extra.draws, card.ability.extra.creates } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"FlowerCardian\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Warrior\",\n                monster_archetypes = { [\"FlowerCardian\"] = true }\n            },\n            mult = 20,\n            excavates = 5,\n            draws = 1,\n            creates = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.individual and context.cardarea == G.hand and not context.end_of_round then\n                if cardian_is_hanafuda_month(context.other_card, { \"may\", \"december\" }) then\n                    return {\n                        mult = card.ability.extra.mult\n                    }\n                end\n            end\n            if context.joy_excavated and context.joy_number <= card.ability.extra.excavates and context.joy_other_context.setting_blind then\n                local hit\n                if context.joy_excavated:is_suit(\"Diamonds\") then\n                    if not next(SMODS.get_enhancements(context.joy_excavated)) then\n                        context.joy_excavated:set_ability(\"m_joy_hanafuda\")\n                    end\n                    hit = true\n                end\n                if cardian_is_hanafuda_month(context.joy_excavated, { \"may\", \"december\" }) then\n                    card.joy_draw = true\n                    hit = true\n                end\n                card.joy_hit = card.joy_hit or hit\n                return {\n                    message = hit and localize(\"k_joy_hit\") or nil\n                }\n            end\n            if context.setting_blind then\n                if not card.joy_hit then\n                    local added_card = JoyousSpring.create_summon({\n                        key = \"j_joy_cardian_paulownia\"\n                    }, false)\n\n                    JoyousSpring.banish(added_card, \"end_of_round\")\n                    G.E_MANAGER:add_event(Event({\n                        func = (function()\n                            card.getting_sliced = true\n                            card:start_dissolve()\n                            return true\n                        end),\n                    }))\n                end\n                card.joy_hit = nil\n            end\n            if context.first_hand_drawn and card.joy_draw then\n                card.joy_draw = nil\n                SMODS.draw_cards(card.ability.extra.draws)\n            end\n            if context.end_of_round and context.game_over == false and context.main_eval then\n                if JoyousSpring.count_materials_owned({ { monster_archetypes = { \"FlowerCardian\" } } }) > 1 then\n                    SMODS.add_card({\n                        key = \"c_joy_cardian_gathering\"\n                    })\n                end\n            end\n        end\n    end,\n    joy_calculate_excavate = cardian_excavate,\n    joy_bypass_room_check = cardian_bypass_room_check"
    },
    {
      "type": "Joker",
      "key": "cardian_boardefly",
      "atlas": "cardian",
      "pos": {
        "x": 3,
        "y": 2
      },
      "raw": "key = \"cardian_boardefly\",\n    atlas = 'cardian',\n    pos = { x = 3, y = 2 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.banish } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"FlowerCardian\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Warrior\",\n                summon_type = \"SYNCHRO\",\n                monster_archetypes = { [\"FlowerCardian\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"SYNCHRO\",\n                        materials = {\n                            { is_tuner = true, exclude_summon_types = { \"XYZ\", \"LINK\" },\n                                func = \"hanafuda_type_played_this_run\", func_vars = { type = \"animal\", min = 5 } },\n                            { exclude_tuners = true, exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                        },\n                    }\n                }\n            },\n            banish = 1,\n            animals_scored = 0\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.after and SMODS.PokerHands[context.scoring_name].joy_koi_koi then\n                for _, pcard in ipairs(context.scoring_hand) do\n                    if JoyousSpring.get_hanafuda(pcard) and (next(SMODS.find_card(\"j_joy_cardian_lightflare\")) or JoyousSpring.get_hanafuda(pcard).type == \"animal\") then\n                        card.ability.extra.animals_scored = card.ability.extra.animals_scored + 1\n                    end\n                    pcard:set_seal(SMODS.poll_seal({ guaranteed = true }))\n                end\n            end\n            if context.end_of_round and context.game_over == false and context.main_eval then\n                local choices = JoyousSpring.get_materials_owned()\n                for i = 1, card.ability.extra.animals_scored do\n                    local to_banish, index = pseudorandom_element(choices, 'j_joy_cardian_boardefly')\n                    if to_banish then\n                        JoyousSpring.banish(to_banish, \"blind_selected\")\n                    end\n                    table.remove(choices, index)\n                end\n                card.ability.extra.animals_scored = 0\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "cardian_moonflower",
      "atlas": "cardian",
      "pos": {
        "x": 1,
        "y": 3
      },
      "raw": "key = \"cardian_moonflower\",\n    atlas = 'cardian',\n    pos = { x = 1, y = 3 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.draws } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"FlowerCardian\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_tuner = true,\n                attribute = \"DARK\",\n                monster_type = \"Warrior\",\n                is_all_materials = { SYNCHRO = true },\n                summon_type = \"SYNCHRO\",\n                monster_archetypes = { [\"FlowerCardian\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"SYNCHRO\",\n                        materials = {\n                            { is_tuner = true, exclude_summon_types = { \"XYZ\", \"LINK\" },\n                                func = \"hanafuda_played_this_run\", func_vars = { key = \"Chrysanthemum with Sake\", min = 3 } },\n                            { exclude_tuners = true, exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                        },\n                    }\n                }\n            },\n            draws = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.first_hand_drawn then\n                SMODS.draw_cards(JoyousSpring.count_materials_owned({ { monster_archetypes = { \"FlowerCardian\" } } }))\n            end\n            if context.modify_scoring_hand and (SMODS.PokerHands[context.scoring_name] or {}).joy_koi_koi and JoyousSpring.get_hanafuda(context.other_card) then\n                return {\n                    add_to_hand = true\n                }\n            end\n            if context.before and SMODS.PokerHands[context.scoring_name].joy_koi_koi then\n                SMODS.draw_cards(#context.scoring_hand)\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "cardian_lightshower",
      "atlas": "cardian",
      "pos": {
        "x": 0,
        "y": 3
      },
      "raw": "key = \"cardian_lightshower\",\n    atlas = 'cardian',\n    pos = { x = 0, y = 3 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.xmult, card.ability.extra.scored_xmult, card.ability.extra.turns } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"FlowerCardian\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Warrior\",\n                summon_type = \"SYNCHRO\",\n                monster_archetypes = { [\"FlowerCardian\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"SYNCHRO\",\n                        materials = {\n                            { is_tuner = true, exclude_summon_types = { \"XYZ\", \"LINK\" },\n                                func = \"hanafuda_type_played_this_run\", func_vars = { type = \"light\", min = 3 } },\n                            { exclude_tuners = true, exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                        },\n                    }\n                }\n            },\n            xmult = 1.1,\n            scored_xmult = 5,\n            turns = 2\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.other_joker and context.other_joker.facing == \"front\" and JoyousSpring.is_monster_archetype(context.other_joker, \"FlowerCardian\") then\n                return {\n                    xmult = card.ability.extra.xmult,\n                    message_card = context.other_joker\n                }\n            end\n            if context.modify_scoring_hand then\n                local _, key = JoyousSpring.get_hanafuda(context.other_card)\n                if key == \"Willow with Calligrapher\" or key == \"Chrysanthemum with Sake\" then\n                    return {\n                        add_to_hand = true\n                    }\n                end\n            end\n            if context.individual and context.cardarea == G.play then\n                local _, key = JoyousSpring.get_hanafuda(context.other_card)\n                if key == \"Willow with Calligrapher\" or key == \"Chrysanthemum with Sake\" then\n                    return {\n                        xmult = card.ability.extra.scoring_xmult\n                    }\n                end\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "cardian_lightflare",
      "atlas": "cardian",
      "pos": {
        "x": 4,
        "y": 2
      },
      "raw": "key = \"cardian_lightflare\",\n    atlas = 'cardian',\n    pos = { x = 4, y = 2 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.mult, card.ability.extra.current_mult, card.ability.extra.revives } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_archetypes = { \"FlowerCardian\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Warrior\",\n                summon_type = \"SYNCHRO\",\n                monster_archetypes = { [\"FlowerCardian\"] = true },\n                summon_conditions = {\n                    {\n                        type = \"SYNCHRO\",\n                        materials = {\n                            { is_tuner = true, exclude_summon_types = { \"XYZ\", \"LINK\" },\n                                func = \"hanafuda_type_played_this_run\", func_vars = { type = \"light\", min = 5 } },\n                            { exclude_tuners = true, exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                        },\n                    }\n                }\n            },\n            mult = 10,\n            current_mult = 0,\n            revives = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joy_excavated and JoyousSpring.get_hanafuda(context.joy_excavated) then\n                card.ability.extra.current_mult = card.ability.extra.current_mult + card.ability.extra.mult\n                return { message = localize('k_upgrade_ex'), message_card = card }\n            end\n            if context.debuff_card and JoyousSpring.get_hanafuda(context.debuff_card) then\n                return {\n                    prevent_debuff = true\n                }\n            end\n            if context.before and (context.scoring_name == \"joy_cardian_lightflare\" or context.scoring_name == \"joy_cardian_moonflowerviewing\" or context.scoring_name == \"joy_cardian_redpoemblueribbon\") then\n                for i = 1, card.ability.extra.revives do\n                    local revived_card = JoyousSpring.revive_pseudorandom(\n                        { { monster_archetypes = { \"FlowerCardian\" } } },\n                        'j_joy_cardian_lightflare',\n                        false, \"e_negative\"\n                    )\n                end\n            end\n            if context.joker_main then\n                return {\n                    mult = card.ability.extra.current_mult\n                }\n            end\n        end\n    end"
    },
    {
      "type": "Atlas",
      "key": "spy",
      "atlas": null,
      "pos": null,
      "raw": "key = \"spy\",\n    path = \"25SPYRAL.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Joker",
      "key": "spy_drone",
      "atlas": "spy",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"spy_drone\",\n    atlas = 'spy',\n    pos = { x = 2, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 0,\n    loc_vars = function(self, info_queue, card)\n        return { vars = {} }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_spy_staff\", \"j_joy_spy_misty\", properties = { { monster_archetypes = { \"SPYRAL\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"WIND\",\n                monster_type = \"Machine\",\n                monster_archetypes = { [\"SPYRAL\"] = true }\n            },\n        },\n    },"
    },
    {
      "type": "Joker",
      "key": "spy_lastresort",
      "atlas": "spy",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"spy_lastresort\",\n    atlas = 'spy',\n    pos = { x = 3, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 0,\n    loc_vars = function(self, info_queue, card)\n        return { vars = {} }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_spy_staff\", \"j_joy_spy_misty\", properties = { { monster_archetypes = { \"SPYRAL\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"EARTH\",\n                monster_type = \"Machine\",\n                monster_archetypes = { [\"SPYRAL\"] = true }\n            },\n        },\n    },"
    },
    {
      "type": "Joker",
      "key": "spy_double",
      "atlas": "spy",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "key = \"spy_double\",\n    atlas = 'spy',\n    pos = { x = 1, y = 2 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 0,\n    loc_vars = function(self, info_queue, card)\n        return { vars = {} }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_spy_staff\", \"j_joy_spy_misty\", properties = { { monster_archetypes = { \"SPYRAL\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"LIGHT\",\n                monster_type = \"Fiend\",\n                monster_archetypes = { [\"SPYRAL\"] = true }\n            },\n        },\n    },"
    },
    {
      "type": "Joker",
      "key": "spy_masterplan",
      "atlas": "spy",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"spy_masterplan\",\n    atlas = 'spy',\n    pos = { x = 0, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 0,\n    loc_vars = function(self, info_queue, card)\n        return { vars = {} }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_spy_staff\", \"j_joy_spy_misty\", properties = { { monster_archetypes = { \"SPYRAL\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Spellcaster\",\n                monster_archetypes = { [\"SPYRAL\"] = true }\n            },\n        },\n    },"
    },
    {
      "type": "Joker",
      "key": "spy_quik",
      "atlas": "spy",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"spy_quik\",\n    atlas = 'spy',\n    pos = { x = 1, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 0,\n    loc_vars = function(self, info_queue, card)\n        return { vars = {} }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_spy_staff\", \"j_joy_spy_misty\", properties = { { monster_archetypes = { \"SPYRAL\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"EARTH\",\n                monster_type = \"Machine\",\n                monster_archetypes = { [\"SPYRAL\"] = true }\n            },\n        },\n    },"
    },
    {
      "type": "Joker",
      "key": "spy_sleeper",
      "atlas": "spy",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"spy_sleeper\",\n    atlas = 'spy',\n    pos = { x = 2, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 0,\n    loc_vars = function(self, info_queue, card)\n        return { vars = {} }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_spy_staff\", \"j_joy_spy_misty\", properties = { { monster_archetypes = { \"SPYRAL\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"LIGHT\",\n                monster_type = \"Fiend\",\n                monster_archetypes = { [\"SPYRAL\"] = true }\n            },\n        },\n    },"
    },
    {
      "type": "Joker",
      "key": "spy_tough",
      "atlas": "spy",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = \"spy_tough\",\n    atlas = 'spy',\n    pos = { x = 0, y = 2 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 0,\n    loc_vars = function(self, info_queue, card)\n        return { vars = {} }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_spy_staff\", \"j_joy_spy_misty\", properties = { { monster_archetypes = { \"SPYRAL\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"WIND\",\n                monster_type = \"Warrior\",\n                monster_archetypes = { [\"SPYRAL\"] = true }\n            },\n        },\n    },"
    },
    {
      "type": "Joker",
      "key": "spy_super",
      "atlas": "spy",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"spy_super\",\n    atlas = 'spy',\n    pos = { x = 3, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 0,\n    loc_vars = function(self, info_queue, card)\n        return { vars = {} }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_spy_staff\", \"j_joy_spy_misty\", properties = { { monster_archetypes = { \"SPYRAL\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"EARTH\",\n                monster_type = \"Warrior\",\n                monster_archetypes = { [\"SPYRAL\"] = true }\n            },\n        },\n    },"
    },
    {
      "type": "Joker",
      "key": "spy_misty",
      "atlas": "spy",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"spy_misty\",\n    atlas = 'spy',\n    pos = { x = 1, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 0,\n    loc_vars = function(self, info_queue, card)\n        return { vars = {} }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_spy_staff\", \"j_joy_spy_misty\", properties = { { monster_archetypes = { \"SPYRAL\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Spellcaster\",\n            },\n        },\n    },"
    },
    {
      "type": "Joker",
      "key": "spy_staff",
      "atlas": "spy",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"spy_staff\",\n    atlas = 'spy',\n    pos = { x = 0, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 0,\n    loc_vars = function(self, info_queue, card)\n        return { vars = {} }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_spy_staff\", \"j_joy_spy_misty\", properties = { { monster_archetypes = { \"SPYRAL\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"LIGHT\",\n                monster_type = \"Fairy\",\n            },\n        },\n    },"
    },
    {
      "type": "Joker",
      "key": "spy_helix",
      "atlas": "spy",
      "pos": {
        "x": 3,
        "y": 2
      },
      "raw": "key = \"spy_helix\",\n    atlas = 'spy',\n    pos = { x = 3, y = 2 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 0,\n    loc_vars = function(self, info_queue, card)\n        return { vars = {} }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_spy_staff\", \"j_joy_spy_misty\", properties = { { monster_archetypes = { \"SPYRAL\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"EARTH\",\n                monster_type = \"Warrior\",\n                monster_archetypes = { [\"SPYRAL\"] = true }\n            },\n        },\n    },"
    },
    {
      "type": "Joker",
      "key": "spy_resort",
      "atlas": "spy",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "key = \"spy_resort\",\n    atlas = 'spy',\n    pos = { x = 2, y = 2 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 0,\n    loc_vars = function(self, info_queue, card)\n        return { vars = {} }\n    end,\n    joy_desc_cards = {\n        { \"j_joy_spy_staff\", \"j_joy_spy_misty\", properties = { { monster_archetypes = { \"SPYRAL\" } } }, name = \"k_joy_archetype\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_field_spell = true,\n                monster_archetypes = { [\"SPYRAL\"] = true }\n            },\n        },\n    },"
    },
    {
      "type": "Joker",
      "key": "zenoguitar",
      "atlas": "Misc02",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "--     key = \"zenoguitar\",\n--     atlas = 'Misc02',\n--     pos = { x = 1, y = 1 },\n--     rarity = 1,\n--     discovered = true,\n--     blueprint_compat = false,\n--     eternal_compat = true,\n--     cost = 0,\n--     loc_vars = function(self, info_queue, card)\n--         return { vars = {} }\n--     end,\n--     generate_ui = JoyousSpring.generate_info_ui,\n--     set_sprites = JoyousSpring.set_back_sprite,\n--     config = {\n--         extra = {\n--             joyous_spring = JoyousSpring.init_joy_table {\n--                 attribute = \"EARTH\",\n--                 monster_type = \"Rock\",\n--             },\n--         },\n--     },\n--"
    },
    {
      "type": "Joker",
      "key": "revgolem",
      "atlas": "Misc02",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "--     key = \"revgolem\",\n--     atlas = 'Misc02',\n--     pos = { x = 0, y = 1 },\n--     rarity = 1,\n--     discovered = true,\n--     blueprint_compat = false,\n--     eternal_compat = true,\n--     cost = 0,\n--     loc_vars = function(self, info_queue, card)\n--         return { vars = {} }\n--     end,\n--     generate_ui = JoyousSpring.generate_info_ui,\n--     set_sprites = JoyousSpring.set_back_sprite,\n--     config = {\n--         extra = {\n--             joyous_spring = JoyousSpring.init_joy_table {\n--                 attribute = \"EARTH\",\n--                 monster_type = \"Rock\",\n--             },\n--         },\n--     },\n--"
    },
    {
      "type": "Joker",
      "key": "tackcrusader",
      "atlas": "Misc02",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "--     key = \"tackcrusader\",\n--     atlas = 'Misc02',\n--     pos = { x = 2, y = 1 },\n--     rarity = 1,\n--     discovered = true,\n--     blueprint_compat = false,\n--     eternal_compat = true,\n--     cost = 0,\n--     loc_vars = function(self, info_queue, card)\n--         return { vars = {} }\n--     end,\n--     generate_ui = JoyousSpring.generate_info_ui,\n--     set_sprites = JoyousSpring.set_back_sprite,\n--     config = {\n--         extra = {\n--             joyous_spring = JoyousSpring.init_joy_table {\n--                 attribute = \"EARTH\",\n--                 monster_type = \"Rock\",\n--             },\n--         },\n--     },\n--"
    },
    {
      "type": "Joker",
      "key": "doki",
      "atlas": "Misc02",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "--     key = \"doki\",\n--     atlas = 'Misc02',\n--     pos = { x = 2, y = 0 },\n--     rarity = 1,\n--     discovered = true,\n--     blueprint_compat = false,\n--     eternal_compat = true,\n--     cost = 0,\n--     loc_vars = function(self, info_queue, card)\n--         return { vars = {} }\n--     end,\n--     generate_ui = JoyousSpring.generate_info_ui,\n--     set_sprites = JoyousSpring.set_back_sprite,\n--     config = {\n--         extra = {\n--             joyous_spring = JoyousSpring.init_joy_table {\n--                 attribute = \"EARTH\",\n--                 monster_type = \"Rock\",\n--             },\n--         },\n--     },\n--"
    },
    {
      "type": "Joker",
      "key": "blockdragon",
      "atlas": "Misc02",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "--     key = \"blockdragon\",\n--     atlas = 'Misc02',\n--     pos = { x = 1, y = 0 },\n--     rarity = 1,\n--     discovered = true,\n--     blueprint_compat = false,\n--     eternal_compat = true,\n--     cost = 0,\n--     loc_vars = function(self, info_queue, card)\n--         return { vars = {} }\n--     end,\n--     generate_ui = JoyousSpring.generate_info_ui,\n--     set_sprites = JoyousSpring.set_back_sprite,\n--     config = {\n--         extra = {\n--             joyous_spring = JoyousSpring.init_joy_table {\n--                 attribute = \"EARTH\",\n--                 monster_type = \"Rock\",\n--             },\n--         },\n--     },\n--"
    },
    {
      "type": "Atlas",
      "key": "Misc01",
      "atlas": null,
      "pos": null,
      "raw": "key = \"Misc01\",\n    path = \"99Misc01.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Atlas",
      "key": "Misc02",
      "atlas": null,
      "pos": null,
      "raw": "key = \"Misc02\",\n    path = \"99Misc02.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Atlas",
      "key": "Misc03",
      "atlas": null,
      "pos": null,
      "raw": "key = \"Misc03\",\n    path = \"99Misc03.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Atlas",
      "key": "Misc04",
      "atlas": null,
      "pos": null,
      "raw": "key = \"Misc04\",\n    path = \"99Misc04.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Joker",
      "key": "boarder",
      "atlas": "Misc01",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"boarder\",\n    atlas = 'Misc01',\n    pos = { x = 0, y = 0 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 7,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_extra_deck_joker\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_main_deck_joker\" }\n        end\n        return {\n            vars = {\n                card.ability.extra.xmult,\n                1 + card.ability.extra.xmult * JoyousSpring.count_materials_owned({ { is_extra_deck = true } })\n            }\n        }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"LIGHT\",\n                monster_type = \"Machine\",\n            },\n            xmult = 5,\n            hands = {}\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    xmult = 1 +\n                        card.ability.extra.xmult *\n                        JoyousSpring.count_materials_owned({ { is_extra_deck = true } })\n                }\n            end\n            if context.setting_blind and context.main_eval then\n                local types_owned = JoyousSpring.extra_deck_types_owned() + 1\n                ease_hands_played(types_owned - G.GAME.current_round.hands_left, true)\n                card.ability.extra.hands = {}\n            end\n            if context.debuff_hand and context.main_eval then\n                if card.ability.extra.hands[context.scoring_name] then\n                    return {\n                        debuff = true\n                    }\n                end\n            end\n            if context.after and context.main_eval then\n                card.ability.extra.hands[context.scoring_name] = true\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not from_debuff then\n            card.ability.extra.unique_count = #SMODS.find_card(\"j_joy_spright_sprind\", true)\n        end\n        if not card.debuff then\n            for _, joker in ipairs(JoyousSpring.get_materials_owned({ { is_main_deck = true, exclude_keys = { \"j_joy_boarder\" } } })) do\n                SMODS.debuff_card(joker, true, \"j_joy_boarder\" .. (card.ability.extra.unique_count or 0))\n            end\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        if not next(SMODS.find_card(\"j_joy_boarder\")) then\n            for _, joker in ipairs(G.jokers.cards) do\n                SMODS.debuff_card(joker, false, \"j_joy_boarder\" .. (card.ability.extra.unique_count or 0))\n            end\n        end\n    end,\n    joy_apply_to_jokers_added = function(card, added_card)\n        if not card.debuff and JoyousSpring.is_main_deck_monster(added_card) and added_card.config.center.key ~= \"j_joy_boarder\" then\n            SMODS.debuff_card(added_card, true, \"j_joy_boarder\" .. (card.ability.extra.unique_count or 0))\n        end\n    end,\n    joker_display_def = function(JokerDisplay)\n        return {\n            text = {\n                {\n                    border_nodes = {\n                        { text = \"X\" },\n                        { ref_table = \"card.joker_display_values\", ref_value = \"xmult\", retrigger_type = \"exp\" }\n                    }\n                }\n            },\n            calc_function = function(card)\n                card.joker_display_values.xmult = 1 +\n                    card.ability.extra.xmult * JoyousSpring.count_materials_owned({ { is_extra_deck = true } })\n            end\n        }\n    end"
    },
    {
      "type": "Joker",
      "key": "grenmaju",
      "atlas": "Misc02",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"grenmaju\",\n    atlas = 'Misc02',\n    pos = { x = 0, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 3,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_banish\" }\n        end\n        return { vars = { card.ability.extra.chips, card.ability.extra.chips * (G.GAME.joy_cards_banished or 0) } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"FIRE\",\n                monster_type = \"Fiend\",\n            },\n            chips = 20,\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    chips = card.ability.extra.chips * (G.GAME.joy_cards_banished or 0)\n                }\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "rhino",
      "atlas": "Misc03",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"rhino\",\n    atlas = 'Misc03',\n    pos = { x = 2, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 4,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return { vars = { card.ability.extra.mills, card.ability.extra.revives } }\n    end,\n    joy_desc_cards = {\n        { properties = { { monster_type = \"Fiend\" } }, name = \"Sends\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"EARTH\",\n                monster_type = \"Fiend\",\n            },\n            mills = 5,\n            revives = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.used_as_material(card, context) then\n            local choices = JoyousSpring.get_materials_in_collection({ { monster_type = \"Fiend\" } })\n            for _ = 1, card.ability.extra.mills do\n                local key_to_send = pseudorandom_element(choices, 'j_joy_rhino')\n                JoyousSpring.send_to_graveyard(key_to_send or \"j_joy_ba_cagna\")\n            end\n            JoyousSpring.revive_pseudorandom({ { monster_type = \"Fiend\" } }, 'j_joy_rhino')\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "tourguide",
      "atlas": "Misc03",
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "key = \"tourguide\",\n    atlas = 'Misc03',\n    pos = { x = 4, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_main_deck_joker\" }\n        end\n        return { vars = { card.ability.extra.adds } }\n    end,\n    joy_desc_cards = {\n        { properties = { { is_main_deck = true, monster_type = \"Fiend\" } }, name = \"Creates\" },\n    },\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Fiend\",\n            },\n            adds = 1\n        },\n    },\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff then\n            for _ = 1, card.ability.extra.adds do\n                JoyousSpring.create_pseudorandom(\n                    { { monster_type = \"Fiend\", rarity = 1, is_main_deck = true }, { monster_type = \"Fiend\", rarity = 2, is_main_deck = true } },\n                    \"j_joy_tourguide\", false, false, \"e_negative\")\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "heavenlyprison",
      "atlas": "Misc03",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"heavenlyprison\",\n    atlas = 'Misc03',\n    pos = { x = 3, y = 0 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.xmult, card.ability.extra.xmult_gain, card.ability.extra.xmult + (card.ability.extra.xmult_gain * JoyousSpring.count_materials_owned({ { is_trap = true } })) } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Rock\",\n            },\n            xmult = 2,\n            xmult_gain = 2\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    xmult = card.ability.extra.xmult +\n                        (card.ability.extra.xmult_gain * JoyousSpring.count_materials_owned({ { is_trap = true } }))\n                }\n            end\n        end\n    end,\n    joy_prevent_trap_flip = function(card, other_card)\n        return other_card.facing == 'front'\n    end,\n    joy_flip_effect_active = function(card, other_card)\n        return JoyousSpring.is_trap_monster(other_card)\n    end"
    },
    {
      "type": "Joker",
      "key": "backup",
      "atlas": "Misc03",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"backup\",\n    atlas = 'Misc03',\n    pos = { x = 0, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return { vars = { card.ability.extra.adds } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"LIGHT\",\n                monster_type = \"Cyberse\",\n            },\n            adds = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.used_as_material(card, context) then\n            local choices = JoyousSpring.get_materials_in_collection({ { monster_type = \"Cyberse\", is_extra_deck = true } })\n            for _ = 1, card.ability.extra.adds do\n                local key_to_add, _ = pseudorandom_element(choices, card.config.center.key)\n                if key_to_add and #JoyousSpring.extra_deck_area.cards < JoyousSpring.extra_deck_area.config.card_limit then\n                    JoyousSpring.add_to_extra_deck(key_to_add)\n                end\n            end\n        end\n    end,\n    joy_set_cost = function(card)\n        if JoyousSpring.count_materials_owned({ { monster_type = \"Cyberse\" } }) > 0 then\n            card.cost = 0\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "wizard",
      "atlas": "Misc03",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"wizard\",\n    atlas = 'Misc03',\n    pos = { x = 1, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 4,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.chips, card.ability.extra.chips * JoyousSpring.count_materials_owned({ { monster_type = \"Cyberse\" } }) } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"LIGHT\",\n                monster_type = \"Cyberse\",\n            },\n            chips = 50,\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    chips = card.ability.extra.chips *\n                        JoyousSpring.count_materials_owned({ { monster_type = \"Cyberse\" } })\n                }\n            end\n        end\n    end,\n    joy_set_cost = function(card)\n        if JoyousSpring.count_materials_owned({ { monster_type = \"Cyberse\" } }) > 0 then\n            card.cost = 0\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "formud",
      "atlas": "Misc04",
      "pos": {
        "x": 7,
        "y": 0
      },
      "raw": "key = \"formud\",\n    atlas = 'Misc04',\n    pos = { x = 7, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_main_deck_joker\" }\n        end\n        return { vars = { card.ability.extra.creates } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_all_materials = { LINK = true },\n                attribute = \"LIGHT\",\n                monster_type = \"Cyberse\",\n            },\n            creates = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.used_as_material(card, context) and JoyousSpring.is_monster_type(context.joy_card, \"Cyberse\") then\n            for i = 1, card.ability.extra.creates do\n                JoyousSpring.create_pseudorandom({ { monster_type = \"Cyberse\", rarity = 3, is_main_deck = true } },\n                    'j_joy_formud')\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "procession",
      "atlas": "Misc04",
      "pos": {
        "x": 6,
        "y": 1
      },
      "raw": "key = \"procession\",\n    atlas = 'Misc04',\n    pos = { x = 6, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 4,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.xmult } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_tuner = true,\n                attribute = \"DARK\",\n                monster_type = \"Zombie\",\n            },\n            xmult = 2\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.setting_blind and context.main_eval then\n                for _, joker in ipairs(G.jokers.cards) do\n                    if joker.config.center.key ~= \"j_joy_procession\" and joker.facing == \"front\" then\n                        joker:flip(card)\n                    end\n                end\n            end\n            if context.other_joker and context.other_joker.facing == \"back\" then\n                return {\n                    xmult = card.ability.extra.xmult,\n                    message_card = context.other_joker\n                }\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "darkcat",
      "atlas": "Misc04",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"darkcat\",\n    atlas = 'Misc04',\n    pos = { x = 3, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.mult, card.ability.extra.adds } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_flip = true,\n                attribute = \"EARTH\",\n                monster_type = \"Beast\",\n            },\n            mult = 22,\n            adds = 2\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    mult = card.ability.extra.mult\n                }\n            end\n        end\n        if JoyousSpring.calculate_flip_effect(card, context) then\n            for i = 1, card.ability.extra.adds do\n                SMODS.add_card { set = \"Base\", enhancement = \"m_lucky\", edition = \"e_negative\", rank = 2, area = G.GAME.blind.in_blind and G.hand or G.deck }\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "dekoichi",
      "atlas": "Misc04",
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "key = \"dekoichi\",\n    atlas = 'Misc04',\n    pos = { x = 4, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 4,\n    loc_vars = function(self, info_queue, card)\n        return {\n            vars = {\n                card.ability.extra.mult,\n                card.ability.extra.mult_normal,\n                card.ability.extra.mult +\n                card.ability.extra.mult_normal * JoyousSpring.count_materials_owned({ { is_normal = true } }),\n                card.ability.extra.h_size,\n                card.ability.extra.h_size_normal,\n                card.ability.extra.creates\n            },\n        }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_flip = true,\n                attribute = \"DARK\",\n                monster_type = \"Machine\",\n            },\n            mult = 10,\n            mult_normal = 25,\n            h_size = 1,\n            h_size_normal = 1,\n            creates = 1,\n            h_size_change = 0\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    mult = card.ability.extra.mult +\n                        card.ability.extra.mult_normal * JoyousSpring.count_materials_owned({ { is_normal = true } })\n                }\n            end\n        end\n        if JoyousSpring.calculate_flip_effect(card, context) then\n            local h_size_change = card.ability.extra.h_size +\n                card.ability.extra.h_size_normal * JoyousSpring.count_materials_owned({ { is_normal = true } })\n            G.hand:change_size(h_size_change)\n            card.ability.extra.h_size_change = card.ability.extra.h_size_change + h_size_change\n            for i = 1, card.ability.extra.creates do\n                JoyousSpring.create_summon({\n                    key = \"j_joy_bokoichi\",\n                    edition = \"e_negative\"\n                })\n            end\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval then\n            if card.ability.extra.h_size_change > 0 then\n                G.hand:change_size(-card.ability.extra.h_size_change)\n                card.ability.extra.h_size_change = 0\n            end\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        if card.ability.extra.h_size_change > 0 then\n            G.hand:change_size(-card.ability.extra.h_size_change)\n            card.ability.extra.h_size_change = 0\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "bokoichi",
      "atlas": "Misc04",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"bokoichi\",\n    atlas = 'Misc04',\n    pos = { x = 0, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 1,\n    loc_vars = function(self, info_queue, card)\n        return { vars = {} }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_effect = false,\n                attribute = \"DARK\",\n                monster_type = \"Machine\",\n            },\n        },\n    },\n    in_pool = function(self, args)\n        return args and args.source and args.source == \"JoyousSpring\" or false\n    end,"
    },
    {
      "type": "Joker",
      "key": "desertapir",
      "atlas": "Misc04",
      "pos": {
        "x": 5,
        "y": 0
      },
      "raw": "key = \"desertapir\",\n    atlas = 'Misc04',\n    pos = { x = 5, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 4,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.money, card.ability.extra.flips } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_flip = true,\n                attribute = \"EARTH\",\n                monster_type = \"Beast\",\n            },\n            money = 4,\n            flips = 2\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.calculate_flip_effect(card, context) then\n            for i = 1, card.ability.extra.flips do\n                local choices = JoyousSpring.get_materials_owned({ { facedown = true } })\n                local joker = pseudorandom_element(choices, 'j_joy_desertapir')\n                if joker then\n                    joker:flip(card)\n                end\n            end\n        end\n    end,\n    calc_dollar_bonus = function(self, card)\n        return JoyousSpring.can_use_abilities(card) and\n            card.ability.extra.money or nil\n    end"
    },
    {
      "type": "Joker",
      "key": "searchlight",
      "atlas": "Misc04",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = \"searchlight\",\n    atlas = 'Misc04',\n    pos = { x = 0, y = 2 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.mult, card.ability.extra.extra_mult, card.ability.extra.mult + card.ability.extra.current_mult, G.GAME.probabilities.normal or 1, card.ability.extra.odds } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_flip = true,\n                attribute = \"LIGHT\",\n                monster_type = \"Machine\",\n            },\n            mult = 10,\n            extra_mult = 10,\n            current_mult = 0,\n            odds = 2\n        },\n    },\n    calculate = function(self, card, context)\n        if context.setting_blind and context.main_eval then\n            if pseudorandom(\"j_joy_searchlight\") < G.GAME.probabilities.normal / card.ability.extra.odds then\n                card:flip(card)\n            end\n        end\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    mult = card.ability.extra.mult + card.ability.extra.current_mult\n                }\n            end\n        end\n        if JoyousSpring.calculate_flip_effect(card, context) then\n            JoyousSpring.flip_all_cards(card, 'front', { G.jokers })\n        end\n        if context.joy_card_flipped and context.joy_card_flipped.ability.set == \"Joker\" and context.joy_card_flipped.facing == \"front\" then\n            card.ability.extra.current_mult = card.ability.extra.current_mult + card.ability.extra.extra_mult\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "sternmystic",
      "atlas": "Misc04",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "key = \"sternmystic\",\n    atlas = 'Misc04',\n    pos = { x = 2, y = 2 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 7,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.chips, card.ability.extra.extra_chips, card.ability.extra.chips + card.ability.extra.current_chips, G.GAME.probabilities.normal or 1, card.ability.extra.odds } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_flip = true,\n                attribute = \"LIGHT\",\n                monster_type = \"Spellcaster\",\n            },\n            chips = 50,\n            extra_chips = 5,\n            current_chips = 0,\n            odds = 2\n        },\n    },\n    calculate = function(self, card, context)\n        if context.setting_blind and context.main_eval then\n            if pseudorandom(\"j_joy_sternmystic\") < G.GAME.probabilities.normal / card.ability.extra.odds then\n                card:flip(card)\n            end\n        end\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    chips = card.ability.extra.chips + card.ability.extra.current_chips\n                }\n            end\n        end\n        if JoyousSpring.calculate_flip_effect(card, context) and G.GAME.blind.in_blind then\n            JoyousSpring.flip_all_cards(card, nil, { G.hand })\n        end\n        if context.joy_card_flipped and JoyousSpring.is_playing_card(context.joy_card_flipped) then\n            card.ability.extra.current_chips = card.ability.extra.current_chips + card.ability.extra.extra_chips\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "mof",
      "atlas": "Misc04",
      "pos": {
        "x": 4,
        "y": 1
      },
      "raw": "key = \"mof\",\n    atlas = 'Misc04',\n    pos = { x = 4, y = 1 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 7,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.chips, card.ability.extra.chips * JoyousSpring.count_materials_in_graveyard({ { is_field_spell = true } }), card.ability.extra.creates } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_flip = true,\n                attribute = \"LIGHT\",\n                monster_type = \"Spellcaster\",\n            },\n            chips = 200,\n            creates = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    chips = card.ability.extra.chips *\n                        JoyousSpring.count_materials_in_graveyard({ { is_field_spell = true } })\n                }\n            end\n        end\n        if JoyousSpring.calculate_flip_effect(card, context) then\n            local choices = JoyousSpring.get_materials_in_graveyard({ { is_field_spell = true } })\n            for i = 1, card.ability.extra.creates do\n                local spell = pseudorandom_element(choices, pseudorandom(\"j_joy_mof\"))\n                if spell and #JoyousSpring.field_spell_area.cards < JoyousSpring.field_spell_area.config.card_limit then\n                    JoyousSpring.add_to_extra_deck(spell, { edition = \"e_negative\" })\n                end\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "mask",
      "atlas": "Misc04",
      "pos": {
        "x": 5,
        "y": 1
      },
      "raw": "key = \"mask\",\n    atlas = 'Misc04',\n    pos = { x = 5, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n        end\n        return { vars = { card.ability.extra.mult, card.ability.extra.mult * JoyousSpring.count_materials_in_graveyard({ { is_trap = true } }), card.ability.extra.revives } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_flip = true,\n                attribute = \"DARK\",\n                monster_type = \"Fiend\",\n            },\n            mult = 5,\n            revives = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    mult = card.ability.extra.mult * JoyousSpring.count_materials_in_graveyard({ { is_trap = true } })\n                }\n            end\n        end\n        if JoyousSpring.calculate_flip_effect(card, context) then\n            for i = 1, card.ability.extra.revives do\n                JoyousSpring.revive_pseudorandom({ { is_trap = true } }, pseudorandom(\"j_joy_mask\"), true)\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "angraecum",
      "atlas": "Misc04",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"angraecum\",\n    atlas = 'Misc04',\n    pos = { x = 1, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 7,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n        end\n        return { vars = { card.ability.extra.revives, card.ability.extra.adds } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_tuner = true,\n                attribute = \"WATER\",\n                monster_type = \"Spellcaster\",\n            },\n            revives = 1,\n            adds = 1,\n        },\n    },\n    add_to_deck = function(self, card, from_debuff)\n        if not from_debuff then\n            for i = 1, card.ability.extra.revives do\n                JoyousSpring.revive_pseudorandom({ { exclude_tuners = true } }, 'j_joy_angraecum', false,\n                    \"e_negative\", nil, nil, \"j_joy_angraecum\")\n            end\n            local choices = JoyousSpring.get_materials_in_collection({ { summon_type = \"SYNCHRO\" } })\n            for i = 1, card.ability.extra.adds do\n                local key_to_add = pseudorandom_element(choices, 'j_joy_angraecum')\n                JoyousSpring.add_monster_tag(key_to_add or \"j_joy_psy_zeta\")\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "eater",
      "atlas": "Misc04",
      "pos": {
        "x": 6,
        "y": 0
      },
      "raw": "key = \"eater\",\n    atlas = 'Misc04',\n    pos = { x = 6, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 8,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_banish\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_extra_deck_joker\" }\n        end\n        return { vars = { card.ability.extra.xmult, card.ability.extra.current_xmult, card.ability.extra.banishes } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Fiend\",\n            },\n            xmult = 0.1,\n            current_xmult = 1,\n            banishes = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    xmult = card.ability.extra.current_xmult\n                }\n            end\n            if context.joy_banished and JoyousSpring.is_extra_deck_monster(context.joy_banished_card) then\n                card.ability.extra.current_xmult = card.ability.extra.current_xmult + card.ability.extra.xmult\n            end\n            if context.end_of_round and context.game_over == false and context.main_eval then\n                local choices = JoyousSpring.get_materials_owned({ { exclude_debuffed = true, is_extra_deck = true } })\n                local joker = pseudorandom_element(choices, 'j_joy_eater')\n                if joker then\n                    JoyousSpring.banish(joker, \"boss_selected\")\n                end\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "miradora",
      "atlas": "Misc04",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"miradora\",\n    atlas = 'Misc04',\n    pos = { x = 1, y = 1 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_extra_deck_joker\" }\n        end\n        return { vars = { card.ability.extra.turns, card.ability.extra.xmult } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"WIND\",\n                monster_type = \"Dragon\",\n            },\n            turns = 1,\n            xmult = 1.1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.other_joker and JoyousSpring.is_extra_deck_monster(context.other_joker) and context.other_joker.debuff then\n                return {\n                    xmult = card.ability.extra.xmult,\n                    message_card = context.other_joker\n                }\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not from_debuff then\n            local choices = JoyousSpring.get_materials_owned({ { exclude_debuffed = true, is_extra_deck = true } })\n            local joker = pseudorandom_element(choices, 'j_joy_miradora')\n            if joker then\n                SMODS.debuff_card(joker, true, \"j_joy_miradora\")\n                joker:set_edition(\"e_negative\")\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "beautunaful",
      "atlas": "Misc04",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"beautunaful\",\n    atlas = 'Misc04',\n    pos = { x = 2, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_banish\" }\n        end\n        return { vars = { card.ability.extra.creates } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"WATER\",\n                monster_type = \"Fish\",\n            },\n            creates = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and context.joy_returned and context.joy_returned_card == card then\n                for _ = 1, card.ability.extra.creates do\n                    JoyousSpring.create_pseudorandom(\n                        { { monster_type = \"Fish\", is_main_deck = true } },\n                        'j_joy_beautunaful', true)\n                end\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not from_debuff then\n            for _ = 1, card.ability.extra.creates do\n                JoyousSpring.create_pseudorandom(\n                    { { monster_type = \"Fish\", is_main_deck = true } },\n                    'j_joy_beautunaful', true)\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "leaffish",
      "atlas": "Misc04",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"leaffish\",\n    atlas = 'Misc04',\n    pos = { x = 3, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_main_deck_joker\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n        end\n        return { vars = { card.ability.extra.mills, card.ability.extra.revives } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"WATER\",\n                monster_type = \"Fish\",\n            },\n            mills = 1,\n            revives = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.setting_blind and context.main_eval then\n                local choices = JoyousSpring.get_materials_in_collection({ { monster_type = \"Fish\", is_main_deck = true } })\n                for _ = 1, card.ability.extra.mills do\n                    local key_to_send = pseudorandom_element(choices, 'j_joy_ba_leaffish')\n                    JoyousSpring.send_to_graveyard(key_to_send or \"j_joy_beautunaful\")\n                end\n            end\n            if context.selling_self then\n                for i = 1, card.ability.extra.revives do\n                    JoyousSpring.revive_pseudorandom({ { monster_type = \"Fish\", exclude_keys = { \"j_joy_leaffish\" } } },\n                        'j_joy_leaffish', true, nil, (card.edition and card.edition.negative and 0 or 1))\n                end\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "ringowurm",
      "atlas": "Misc04",
      "pos": {
        "x": 7,
        "y": 1
      },
      "raw": "key = \"ringowurm\",\n    atlas = 'Misc04',\n    pos = { x = 7, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 4,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return { vars = { card.ability.extra.creates } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_tuner = true,\n                attribute = \"LIGHT\",\n                monster_type = \"Dragon\",\n            },\n            creates = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.used_as_material(card, context) and JoyousSpring.is_summon_type(context.joy_card, \"SYNCHRO\") then\n            for i = 1, card.ability.extra.creates do\n                JoyousSpring.summon_token(\"ringo\", \"e_negative\")\n            end\n        end\n    end,\n    joy_set_cost = function(card)\n        if JoyousSpring.count_materials_owned({ { is_non_effect = true } }) > 0 then\n            card.cost = 0\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "stormshooter",
      "atlas": "Misc04",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "key = \"stormshooter\",\n    atlas = 'Misc04',\n    pos = { x = 1, y = 2 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 8,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.column, JoyousSpring.get_joker_column(card) } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"WIND\",\n                monster_type = \"WingedBeast\",\n            },\n            column = 2\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.after and JoyousSpring.get_joker_column(card) == card.ability.extra.column and\n                #context.full_hand >= card.ability.extra.column and #context.scoring_hand < card.ability.extra.column and\n                #G.consumeables.cards + G.GAME.consumeable_buffer < G.consumeables.config.card_limit then\n                local planet\n                for _, center in pairs(G.P_CENTER_POOLS.Planet) do\n                    if center.config.hand_type == context.scoring_name then\n                        planet = center.key\n                    end\n                end\n                if planet then\n                    local amount = G.consumeables.config.card_limit - #G.consumeables.cards\n                    for i = 1, amount do\n                        SMODS.add_card({\n                            key = planet\n                        })\n                    end\n                end\n            end\n            if context.end_of_round and context.game_over == false and context.main_eval then\n                card.ability.extra.column = pseudorandom(\"j_joy_stormshooter\", 2, 5)\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        card.ability.extra.column = pseudorandom(\"j_joy_stormshooter\", 2, 5)\n    end"
    },
    {
      "type": "Joker",
      "key": "ghostbird",
      "atlas": "Misc04",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"ghostbird\",\n    atlas = 'Misc04',\n    pos = { x = 0, y = 1 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        return {\n            vars = {\n                JoyousSpring.get_joker_column(card),\n                card.ability.extra.chips,\n                colours = {\n                    (JoyousSpring.get_joker_column(card) == 1) and G.C.UI.TEXT_DARK or\n                    G.C.UI.TEXT_INACTIVE,\n                    (JoyousSpring.get_joker_column(card) == 3) and G.C.UI.TEXT_DARK or\n                    G.C.UI.TEXT_INACTIVE,\n                    (JoyousSpring.get_joker_column(card) == 5) and G.C.UI.TEXT_DARK or\n                    G.C.UI.TEXT_INACTIVE\n                }\n            },\n        }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"WingedBeast\",\n            },\n            chips = 50\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.individual and context.cardarea == G.play and JoyousSpring.get_joker_column(card) == 1 and JoyousSpring.get_joker_column(card) == (JoyousSpring.index_of(context.full_hand, context.other_card)) then\n                context.other_card.ability.perma_bonus = (context.other_card.ability.perma_bonus or 0) +\n                    card.ability.extra.chips\n                return { message = localize('k_upgrade_ex'), colour = G.C.CHIPS }\n            end\n            if ((context.destroying_card and JoyousSpring.get_joker_column(card) ~= 1) or\n                    (context.destroy_card and context.cardarea == 'unscored')) and\n                JoyousSpring.get_joker_column(card) ==\n                (JoyousSpring.index_of(context.full_hand, context.destroy_card)) then\n                return { remove = true }\n            end\n            if context.repetition and context.cardarea == G.play and JoyousSpring.get_joker_column(card) == 3 then\n                if JoyousSpring.get_joker_column(card) == (JoyousSpring.index_of(context.full_hand, context.other_card)) then\n                    return {\n                        repetitions = 2\n                    }\n                end\n            end\n            if context.modify_scoring_hand and JoyousSpring.get_joker_column(card) == 5 then\n                if JoyousSpring.get_joker_column(card) == (JoyousSpring.index_of(context.full_hand, context.other_card)) then\n                    return {\n                        add_to_hand = true,\n                        message = context.in_scoring and localize(\"k_joy_splash\")\n                    }\n                end\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "tiamaton",
      "atlas": "Misc04",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"tiamaton\",\n    atlas = 'Misc04',\n    pos = { x = 2, y = 1 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 9,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.xmult, card.ability.extra.current_xmult, JoyousSpring.get_joker_column(card) } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Dragon\",\n            },\n            xmult = 0.05,\n            current_xmult = 1,\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    xmult = card.ability.extra.current_xmult\n                }\n            end\n            if context.remove_playing_cards then\n                card.ability.extra.current_xmult = card.ability.extra.current_xmult +\n                    card.ability.extra.xmult * #context.removed\n            end\n            if (context.destroying_card or (context.destroy_card and context.cardarea == 'unscored')) and (JoyousSpring.get_joker_column(card) > 5 or JoyousSpring.get_joker_column(card) == (JoyousSpring.index_of(context.full_hand, context.destroying_card or context.destroy_card))) then\n                return { remove = true }\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "quantumcat",
      "atlas": "Misc03",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"quantumcat\",\n    atlas = 'Misc03',\n    pos = { x = 3, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 4,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.chips } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_all_attributes = true,\n                is_all_types = true,\n                is_trap = true,\n                attribute = \"LIGHT\",\n                monster_type = \"Beast\",\n            },\n            chips = 200\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    chips = card.ability.extra.chips\n                }\n            end\n        end\n        JoyousSpring.calculate_flip_effect(card, context)\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff and JoyousSpring.should_trap_flip(card) then\n            card:flip(card)\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "anguish",
      "atlas": "Misc03",
      "pos": {
        "x": 4,
        "y": 1
      },
      "raw": "key = \"anguish\",\n    atlas = 'Misc03',\n    pos = { x = 4, y = 1 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.money } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_flip = true,\n                is_trap = true,\n                attribute = \"EARTH\",\n                monster_type = \"Rock\",\n            },\n            money = 5\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.calculate_flip_effect(card, context) then\n            return {\n                dollars = card.ability.extra.money * JoyousSpring.count_materials_owned({ { is_trap = true } })\n            }\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff and JoyousSpring.should_trap_flip(card) then\n            card:flip(card)\n        end\n        if not card.debuff then\n            for _, joker in ipairs(G.jokers.cards) do\n                if JoyousSpring.is_trap_monster(joker) and not JoyousSpring.is_perma_debuffed(joker) then\n                    SMODS.debuff_card(joker, \"prevent_debuff\", \"j_joy_anguish\")\n                end\n            end\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        for _, joker in ipairs(G.jokers.cards) do\n            SMODS.debuff_card(joker, false, \"j_joy_anguish\")\n        end\n    end,\n    joy_apply_to_jokers_added = function(card, added_card)\n        if JoyousSpring.is_trap_monster(added_card) and not JoyousSpring.is_perma_debuffed(added_card) then\n            SMODS.debuff_card(added_card, \"prevent_debuff\", \"j_joy_anguish\")\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "tiki_curse",
      "atlas": "Misc03",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = \"tiki_curse\",\n    atlas = 'Misc03',\n    pos = { x = 0, y = 2 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.chips, card.ability.extra.chips * JoyousSpring.count_materials_owned({ { is_trap = true } }) } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_trap = true,\n                attribute = \"DARK\",\n                monster_type = \"Rock\",\n            },\n            chips = 100\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    chips = card.ability.extra.chips * JoyousSpring.count_materials_owned({ { is_trap = true } })\n                }\n            end\n        end\n        JoyousSpring.calculate_flip_effect(card, context)\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff and JoyousSpring.should_trap_flip(card) then\n            card:flip(card)\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "tiki_soul",
      "atlas": "Misc03",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "key = \"tiki_soul\",\n    atlas = 'Misc03',\n    pos = { x = 1, y = 2 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.mult, card.ability.extra.mult * JoyousSpring.count_materials_owned({ { is_trap = true } }) } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_trap = true,\n                attribute = \"LIGHT\",\n                monster_type = \"Rock\",\n            },\n            mult = 25\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    mult = card.ability.extra.mult * JoyousSpring.count_materials_owned({ { is_trap = true } })\n                }\n            end\n        end\n        JoyousSpring.calculate_flip_effect(card, context)\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff and JoyousSpring.should_trap_flip(card) then\n            card:flip(card)\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "zoma",
      "atlas": "Misc03",
      "pos": {
        "x": 3,
        "y": 2
      },
      "raw": "key = \"zoma\",\n    atlas = 'Misc03',\n    pos = { x = 3, y = 2 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.percent * 100, card.ability.extra.current_percent * 100 } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_trap = true,\n                attribute = \"DARK\",\n                monster_type = \"Zombie\",\n            },\n            percent = 0.1,\n            current_percent = 0\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.selling_self and G.GAME.blind.in_blind then\n                G.GAME.blind.chips = math.floor(G.GAME.blind.chips -\n                    G.GAME.blind.chips * card.ability.extra.current_percent)\n                G.GAME.blind.chip_text = number_format(G.GAME.blind.chips)\n                G.GAME.joy_zoma_sold = true\n            end\n            if context.joy_card_flipped and context.joy_card_flipped == card and card.facing == \"front\" then\n                card.ability.extra.current_percent = math.min(1, card.ability.extra.current_percent +\n                    card.ability.extra.percent)\n            end\n        end\n        JoyousSpring.calculate_flip_effect(card, context)\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff and JoyousSpring.should_trap_flip(card) then\n            card:flip(card)\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "zoma_earthbound",
      "atlas": "Misc03",
      "pos": {
        "x": 4,
        "y": 2
      },
      "raw": "key = \"zoma_earthbound\",\n    atlas = 'Misc03',\n    pos = { x = 4, y = 2 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 7,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.mult, card.ability.extra.current_mult, card.ability.extra.percent * 100, card.ability.extra.current_percent * 100 } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_trap = true,\n                attribute = \"DARK\",\n                monster_type = \"Zombie\",\n            },\n            mult = 50,\n            current_mult = 0,\n            percent = 0.1,\n            current_percent = 0\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    mult = card.ability.extra.current_mult\n                }\n            end\n            if context.selling_self and G.GAME.blind.in_blind then\n                G.GAME.blind.chips = math.floor(G.GAME.blind.chips -\n                    G.GAME.blind.chips * card.ability.extra.current_percent)\n                G.GAME.blind.chip_text = number_format(G.GAME.blind.chips)\n            end\n            if context.joy_card_flipped and context.joy_card_flipped == card and card.facing == \"front\" then\n                card.ability.extra.current_percent = math.min(1, card.ability.extra.current_percent +\n                    card.ability.extra.percent)\n                card.ability.extra.current_mult = card.ability.extra.current_mult + card.ability.extra.mult\n            end\n        end\n        JoyousSpring.calculate_flip_effect(card, context)\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff and JoyousSpring.should_trap_flip(card) then\n            card:flip(card)\n        end\n    end,\n    in_pool = function(self, args)\n        return G.GAME.joy_zoma_sold\n    end"
    },
    {
      "type": "Joker",
      "key": "finished",
      "atlas": "Misc03",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "key = \"finished\",\n    atlas = 'Misc03',\n    pos = { x = 2, y = 2 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_tribute\" }\n        end\n        return { vars = { card.ability.extra.xmult } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_trap = true,\n                attribute = \"DARK\",\n                monster_type = \"Cyberse\",\n            },\n            xmult = 10\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main and #G.jokers.cards >= 10 then\n                return {\n                    xmult = card.ability.extra.xmult\n                }\n            end\n            if context.joy_activate_effect and context.joy_activated_card == card and not card.ability.eternal and G.GAME.blind.in_blind and G.STATE == G.STATES.SELECTING_HAND then\n                local tributes = {}\n                for _, joker in ipairs(G.jokers.cards) do\n                    if not joker.ability.eternal then\n                        table.insert(tributes, joker)\n                    end\n                end\n                JoyousSpring.tribute(card, tributes)\n                G.GAME.chips = G.GAME.blind.chips\n                G.STATE = G.STATES.HAND_PLAYED\n                G.STATE_COMPLETE = true\n                end_round()\n                return {\n                    message = localize(\"k_joy_defeated\")\n                }\n            end\n        end\n        JoyousSpring.calculate_flip_effect(card, context)\n    end,\n    joy_can_activate = function(card)\n        return not card.ability.eternal and G.GAME.blind.in_blind and G.STATE == G.STATES.SELECTING_HAND\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff and JoyousSpring.should_trap_flip(card) then\n            card:flip(card)\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "apophis",
      "atlas": "Misc03",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"apophis\",\n    atlas = 'Misc03',\n    pos = { x = 2, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 4,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.mult } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_trap = true,\n                attribute = \"EARTH\",\n                monster_type = \"Reptile\",\n            },\n            mult = 50\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    mult = card.ability.extra.mult\n                }\n            end\n        end\n        JoyousSpring.calculate_flip_effect(card, context)\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff and JoyousSpring.should_trap_flip(card) then\n            card:flip(card)\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "azurune",
      "atlas": "Misc03",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"azurune\",\n    atlas = 'Misc03',\n    pos = { x = 0, y = 1 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.xmult, 1 + card.ability.extra.xmult * JoyousSpring.get_summoned_count() } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_trap = true,\n                attribute = \"LIGHT\",\n                monster_type = \"Fairy\",\n            },\n            xmult = 0.05\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    xmult = 1 + card.ability.extra.xmult * JoyousSpring.get_summoned_count()\n                }\n            end\n        end\n        JoyousSpring.calculate_flip_effect(card, context)\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff and JoyousSpring.should_trap_flip(card) then\n            card:flip(card)\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "crukra",
      "atlas": "Misc03",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"crukra\",\n    atlas = 'Misc03',\n    pos = { x = 1, y = 1 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 7,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.xmult } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_trap = true,\n                attribute = \"EARTH\",\n                monster_type = \"Insect\",\n            },\n            xmult = 1.5\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.other_joker and JoyousSpring.is_summon_type(context.other_joker, \"LINK\") then\n                return {\n                    xmult = card.ability.extra.xmult,\n                    message_card = context.other_joker\n                }\n            end\n        end\n        JoyousSpring.calculate_flip_effect(card, context)\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff and not from_debuff and JoyousSpring.should_trap_flip(card) then\n            card:flip(card)\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "foucault",
      "atlas": "Misc04",
      "pos": {
        "x": 2,
        "y": 4
      },
      "raw": "key = \"foucault\",\n    atlas = 'Misc04',\n    pos = { x = 2, y = 4 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 2,\n    loc_vars = function(self, info_queue, card)\n        return { vars = {} }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_effect = false,\n                is_pendulum = true,\n                attribute = \"DARK\",\n                monster_type = \"Spellcaster\",\n            },\n        },\n    },\n    use = function(self, card, area, copier)\n        local amount = G.consumeables.config.card_limit - #G.consumeables.cards\n        for i = 1, amount do\n            SMODS.add_card({\n                key = 'c_earth'\n            })\n        end\n    end,\n    can_use = function(self, card)\n        return #G.consumeables.cards < G.consumeables.config.card_limit\n    end,"
    },
    {
      "type": "Joker",
      "key": "eccentrick",
      "atlas": "Misc01",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"eccentrick\",\n    atlas = 'Misc01',\n    pos = { x = 1, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 3,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.max, card.ability.extra.mult, card.ability.extra.mult * (G.GAME.joy_cards_destroyed or 0) } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_pendulum = true,\n                attribute = \"LIGHT\",\n                monster_type = \"Fiend\",\n                monster_archetypes = { [\"Archfiend\"] = true }\n            },\n            mult = 5,\n            max = 2\n        },\n    },\n    use = function(self, card, area, copier)\n        local destroyed_cards = {}\n        for i = #G.hand.highlighted, 1, -1 do\n            destroyed_cards[#destroyed_cards + 1] = G.hand.highlighted[i]\n        end\n        JoyousSpring.pre_consumable_use(card, true)\n        SMODS.destroy_cards(G.hand.highlighted)\n        JoyousSpring.post_consumable_highlighted_use()\n    end,\n    can_use = function(self, card)\n        return card.ability.extra.max >= #G.hand.highlighted and #G.hand.highlighted >= 1\n    end,\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    mult = card.ability.extra.mult * (G.GAME.joy_cards_destroyed or 0)\n                }\n            end\n        end\n    end,\n    joker_display_def = function(JokerDisplay)\n        return {\n            text = {\n                { text = \"+\" },\n                { ref_table = \"card.joker_display_values\", ref_value = \"mult\", retrigger_type = \"mult\" }\n            },\n            text_config = { colour = G.C.MULT },\n            calc_function = function(card)\n                card.joker_display_values.mult = card.ability.extra.mult * (G.GAME.joy_cards_destroyed or 0)\n            end\n        }\n    end"
    },
    {
      "type": "Joker",
      "key": "pendulumoon",
      "atlas": "Misc03",
      "pos": {
        "x": 3,
        "y": 3
      },
      "raw": "key = \"pendulumoon\",\n    atlas = 'Misc03',\n    pos = { x = 3, y = 3 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 15,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n        end\n        return { vars = { card.ability.extra.revives, card.ability.extra.mills } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_pendulum = true,\n                attribute = \"LIGHT\",\n                monster_type = \"Spellcaster\",\n                cannot_revive = true\n            },\n            revives = 1,\n            mills = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.setting_blind and context.main_eval then\n                local choices = JoyousSpring.get_materials_in_collection({ { is_pendulum = true } })\n\n                for i = 1, card.ability.extra.mills do\n                    JoyousSpring.send_to_graveyard(pseudorandom_element(choices, 'j_joy_pendulumoon'))\n                end\n                return { message = localize(\"k_joy_mill\") }\n            end\n        end\n    end,\n    use = function(self, card, area, copier)\n        for i = 1, card.ability.extra.revives do\n            JoyousSpring.revive_pseudorandom({ { is_pendulum = true } },\n                'j_joy_pendulumoon', false,\n                \"e_negative\")\n        end\n    end,\n    can_use = function(self, card)\n        if card.area and card.area == G.jokers and not (#G.jokers.cards + G.GAME.joker_buffer <\n                G.jokers.config.card_limit + (card.edition and card.edition.negative and 0 or 1)) then\n            return false\n        end\n        return JoyousSpring.count_materials_in_graveyard({ { is_pendulum = true } }, true) > 0\n    end,"
    },
    {
      "type": "Joker",
      "key": "pandora",
      "atlas": "Misc04",
      "pos": {
        "x": 7,
        "y": 4
      },
      "raw": "key = \"pandora\",\n    atlas = 'Misc04',\n    pos = { x = 7, y = 4 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.hands } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_pendulum = true,\n                attribute = \"DARK\",\n                monster_type = \"Wyrm\",\n            },\n            hands = 2\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.setting_blind and context.main_eval and #JoyousSpring.extra_deck_area.cards == 0 then\n                ease_hands_played(card.ability.extra.hands)\n            end\n        end\n    end,\n    use = function(self, card, area, copier)\n        local choices = JoyousSpring.get_materials_owned({ { is_pendulum = true } })\n        local joker = pseudorandom_element(choices, 'j_joy_pandora')\n        if joker then\n            local edition = poll_edition('j_joy_pandora', nil, true, true)\n            joker:set_edition(edition, true)\n        end\n    end,\n    can_use = function(self, card)\n        return JoyousSpring.count_materials_owned({ { is_pendulum = true } }, true) >\n            (card.area and card.area == G.jokers and 1 or 0)\n    end,"
    },
    {
      "type": "Joker",
      "key": "anchamoufrite",
      "atlas": "Misc04",
      "pos": {
        "x": 3,
        "y": 4
      },
      "raw": "key = \"anchamoufrite\",\n    atlas = 'Misc04',\n    pos = { x = 3, y = 4 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.draws, card.ability.extra.h_size } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_pendulum = true,\n                attribute = \"LIGHT\",\n                monster_type = \"Spellcaster\",\n            },\n            draws = 5,\n            h_size = 2,\n            active = false\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not card.ability.extra.active and context.setting_blind and context.main_eval and #JoyousSpring.extra_deck_area.cards == 0 then\n                card.ability.extra.active = true\n                G.hand:change_size(card.ability.extra.h_size)\n            end\n            if card.ability.extra.active and context.end_of_round and context.game_over == false and context.main_eval then\n                card.ability.extra.active = false\n                G.hand:change_size(-card.ability.extra.h_size)\n            end\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        if card.ability.extra.active then\n            card.ability.extra.active = false\n            G.hand:change_size(-card.ability.extra.h_size)\n        end\n    end,\n    use = function(self, card, area, copier)\n        for i = 1, card.ability.extra.draws do\n            draw_card(G.deck, G.hand, i * 100 / card.ability.extra.draws, 'up', false, nil, 0, nil, true)\n        end\n    end,\n    can_use = function(self, card)\n        return G.GAME.blind.in_blind\n    end,"
    },
    {
      "type": "Joker",
      "key": "zany",
      "atlas": "Misc04",
      "pos": {
        "x": 3,
        "y": 5
      },
      "raw": "key = \"zany\",\n    atlas = 'Misc04',\n    pos = { x = 3, y = 5 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 7,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.joker_amount, card.ability.extra.lose, card.ability.extra.xmult } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_pendulum = true,\n                attribute = \"DARK\",\n                monster_type = \"Beast\",\n            },\n            joker_amount = 4,\n            lose = 1,\n            xmult = 4\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main and #G.jokers.cards <= card.ability.extra.joker_amount then\n                return {\n                    xmult = card.ability.extra.xmult\n                }\n            end\n        end\n    end,\n    use = function(self, card, area, copier)\n        G.jokers:change_size(-1)\n        for _, joker in ipairs(G.jokers.cards) do\n            joker:set_edition(\"e_polychrome\")\n        end\n    end,\n    can_use = function(self, card)\n        return G.jokers.config.card_limit > 0 and #G.jokers.cards > (card.area and card.area == G.jokers and 1 or 0) and\n            #G.jokers.cards <= card.ability.extra.joker_amount + (card.area and card.area == G.jokers and 1 or 0)\n    end,"
    },
    {
      "type": "Joker",
      "key": "pendulumucho",
      "atlas": "Misc04",
      "pos": {
        "x": 0,
        "y": 5
      },
      "raw": "key = \"pendulumucho\",\n    atlas = 'Misc04',\n    pos = { x = 0, y = 5 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n        end\n        return { vars = { card.ability.extra.revive_consume, card.ability.extra.revives } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_pendulum = true,\n                attribute = \"EARTH\",\n                monster_type = \"WingedBeast\",\n                cannot_revive = true,\n            },\n            revive_consume = 1,\n            revives = 1\n        },\n    },\n    add_to_deck = function(self, card, from_debuff)\n        if not from_debuff and not card.debuff then\n            local has_revived = false\n            for i = 1, card.ability.extra.revives do\n                local revived_card = JoyousSpring.revive_pseudorandom(\n                    { { is_pendulum = true } },\n                    'j_joy_pendulumucho',\n                    true\n                )\n                has_revived = (revived_card and true) or has_revived\n            end\n\n            if has_revived then\n                SMODS.calculate_effect({ message = localize(\"k_joy_revive\") }, card)\n            end\n        end\n    end,\n    use = function(self, card, area, copier)\n        for i = 1, card.ability.extra.revives do\n            JoyousSpring.revive_pseudorandom({ { is_pendulum = true } },\n                'j_joy_pendulumucho', true)\n        end\n    end,\n    can_use = function(self, card)\n        if not card.area or card.area ~= G.jokers or not (#G.jokers.cards + G.GAME.joker_buffer <\n                G.jokers.config.card_limit + (card.edition and card.edition.negative and 0 or 1)) then\n            return false\n        end\n        return JoyousSpring.count_materials_in_graveyard({ { is_pendulum = true } }, true) > 0\n    end,"
    },
    {
      "type": "Joker",
      "key": "moissa",
      "atlas": "Misc04",
      "pos": {
        "x": 6,
        "y": 4
      },
      "raw": "key = \"moissa\",\n    atlas = 'Misc04',\n    pos = { x = 6, y = 4 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.adds, card.ability.extra.chips, card.ability.extra.current_chips } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_pendulum = true,\n                attribute = \"LIGHT\",\n                monster_type = \"Warrior\",\n            },\n            adds = 2,\n            chips = 50,\n            current_chips = 0\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    chips = card.ability.extra.current_chips\n                }\n            end\n            if context.buying_card and JoyousSpring.is_pendulum_monster(context.card) then\n                card.ability.extra.current_chips = card.ability.extra.current_chips + card.ability.extra.chips\n            end\n        end\n    end,\n    use = function(self, card, area, copier)\n        local choices = JoyousSpring.get_materials_in_collection({ { is_pendulum = true } })\n        for i = 1, card.ability.extra.adds do\n            local key_to_add = pseudorandom_element(choices, 'j_joy_moissa')\n            JoyousSpring.add_monster_tag(key_to_add or \"j_joy_eccentrick\")\n        end\n    end,\n    can_use = function(self, card)\n        return true\n    end,"
    },
    {
      "type": "Joker",
      "key": "pmcaptor",
      "atlas": "Misc04",
      "pos": {
        "x": 1,
        "y": 5
      },
      "raw": "key = \"pmcaptor\",\n    atlas = 'Misc04',\n    pos = { x = 1, y = 5 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n        end\n        return { vars = { card.ability.extra.revives } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_pendulum = true,\n                attribute = \"DARK\",\n                monster_type = \"Zombie\",\n            },\n            revives = 1\n        },\n    },\n    add_to_deck = function(self, card, from_debuff)\n        if not card.debuff then\n            for _, joker in ipairs(G.jokers.cards) do\n                if JoyousSpring.is_monster_type(joker, \"Zombie\") and not JoyousSpring.is_perma_debuffed(joker) then\n                    SMODS.debuff_card(joker, \"prevent_debuff\", \"j_joy_pmcaptor\")\n                end\n            end\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        for _, joker in ipairs(G.jokers.cards) do\n            SMODS.debuff_card(joker, false, \"j_joy_pmcaptor\")\n        end\n    end,\n    joy_apply_to_jokers_added = function(card, added_card)\n        if JoyousSpring.is_monster_type(added_card, \"Zombie\") and not JoyousSpring.is_perma_debuffed(added_card) then\n            SMODS.debuff_card(added_card, \"prevent_debuff\", \"j_joy_pmcaptor\")\n        end\n    end,\n    joy_prevent_flip = function(card, other_card)\n        return JoyousSpring.is_monster_type(other_card, \"Zombie\") and not JoyousSpring.is_trap_monster(other_card)\n    end,\n    use = function(self, card, area, copier)\n        for i = 1, card.ability.extra.revives do\n            JoyousSpring.revive_pseudorandom({ { is_pendulum = true }, exclude_keys = { \"j_joy_pmcaptor\" } },\n                'j_joy_pmcaptor', true)\n        end\n    end,\n    can_use = function(self, card)\n        if card.area and card.area == G.jokers and not (#G.jokers.cards + G.GAME.joker_buffer <\n                G.jokers.config.card_limit + (card.edition and card.edition.negative and 0 or 1)) then\n            return false\n        end\n        return JoyousSpring.count_materials_in_graveyard({ { is_pendulum = true, exclude_keys = { \"j_joy_pmcaptor\" } } },\n            true) > 0\n    end,"
    },
    {
      "type": "Joker",
      "key": "metrognome",
      "atlas": "Misc04",
      "pos": {
        "x": 5,
        "y": 4
      },
      "raw": "key = \"metrognome\",\n    atlas = 'Misc04',\n    pos = { x = 5, y = 4 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.creates, card.ability.extra.mult } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_pendulum = true,\n                attribute = \"EARTH\",\n                monster_type = \"Fairy\",\n            },\n            creates = 1,\n            mult = 25\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.other_joker and context.other_joker.facing == \"front\" and JoyousSpring.is_pendulum_monster(context.other_joker) then\n                local rarities, _ = JoyousSpring.most_owned_rarity()\n                if JoyousSpring.is_card_rarity_from_array(context.other_joker, rarities) then\n                    return {\n                        mult = card.ability.extra.mult,\n                        message_card = context.other_joker\n                    }\n                end\n            end\n        end\n    end,\n    use = function(self, card, area, copier)\n        local rarities, _ = JoyousSpring.most_owned_rarity()\n        local choice = pseudorandom_element(rarities, 'j_joy_metrognome')\n        if choice then\n            for i = 1, card.ability.extra.creates do\n                JoyousSpring.create_pseudorandom({ { is_pendulum = true, rarity = choice } },\n                    'j_joy_metrognome', true)\n            end\n        end\n    end,\n    can_use = function(self, card)\n        if card.area and card.area == G.jokers and not (#G.jokers.cards + G.GAME.joker_buffer <\n                G.jokers.config.card_limit + (card.edition and card.edition.negative and 0 or 1)) then\n            return false\n        end\n        return #G.jokers.cards > (card.area and card.area == G.jokers and 1 or 0)\n    end,"
    },
    {
      "type": "Joker",
      "key": "bozu",
      "atlas": "Misc04",
      "pos": {
        "x": 2,
        "y": 5
      },
      "raw": "key = \"bozu\",\n    atlas = 'Misc04',\n    pos = { x = 2, y = 5 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 7,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.chips, card.ability.extra.mult, card.ability.extra.current_chips, card.ability.extra.current_mult } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_pendulum = true,\n                attribute = \"LIGHT\",\n                monster_type = \"Fairy\",\n            },\n            chips = 25,\n            mult = 1,\n            current_chips = 0,\n            current_mult = 0,\n            transferring = false\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.setting_blind and context.main_eval then\n                card.ability.extra.current_chips = card.ability.extra.current_chips +\n                    card.ability.extra.chips * #JoyousSpring.extra_deck_area.cards\n                card.ability.extra.current_mult = card.ability.extra.current_mult +\n                    card.ability.extra.mult *\n                    math.max(0, JoyousSpring.extra_deck_area.config.card_limit - #JoyousSpring.extra_deck_area.cards)\n            end\n            if context.joker_main then\n                return {\n                    chips = card.ability.extra.current_chips,\n                    mult = card.ability.extra.current_mult\n                }\n            end\n        end\n    end,\n    use = function(self, card, area, copier)\n        local choices = JoyousSpring.get_materials_owned({ { is_monster = true } })\n        local joker = pseudorandom_element(choices, 'j_joy_bozu')\n        if joker then\n            card.ability.extra.transferring = true\n            JoyousSpring.transfer_abilities(joker, card.config.center.key, card)\n            SMODS.calculate_effect({ message = localize(\"k_joy_transferred\") }, joker)\n        end\n    end,\n    can_use = function(self, card)\n        return ((card.ability.extra.current_chips > 0) or (card.ability.extra.current_mult > 0)) and #G.jokers.cards > 1\n    end,\n    joy_can_transfer_ability = function(self, other_card, card)\n        return card and card.ability.extra.transferring or false\n    end,\n    joy_transfer_add_to_deck = function(self, other_card, config, card, from_debuff, materials, was_material)\n        if card then\n            config.mult = (config.mult or 0) + card.ability.extra.current_mult\n            config.chips = (config.chips or 0) + card.ability.extra.current_chips\n        end\n    end,\n    joy_transfer_ability_calculate = function(self, other_card, context, config)\n        if JoyousSpring.can_use_abilities(other_card) then\n            if context.joker_main then\n                return {\n                    chips = config.chips,\n                    mult = config.mult\n                }\n            end\n        end\n    end,\n    joy_transfer_config = function(self, other_card)\n        return {\n            mult = 0,\n            chips = 0,\n        }\n    end,\n    joy_transfer_loc_vars = function(self, info_queue, card, config)\n        return { vars = { config.chips, config.mult } }\n    end"
    },
    {
      "type": "Joker",
      "key": "disablaster",
      "atlas": "Misc04",
      "pos": {
        "x": 4,
        "y": 4
      },
      "raw": "key = \"disablaster\",\n    atlas = 'Misc04',\n    pos = { x = 4, y = 4 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 7,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.money, card.ability.extra.current_money, math.max(1, card.ability.extra.xmult - JoyousSpring.get_joker_column(card)), JoyousSpring.get_joker_column(card) } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_pendulum = true,\n                attribute = \"LIGHT\",\n                monster_type = \"Machine\",\n            },\n            money = 1,\n            current_money = 0,\n            xmult = 7\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main and #context.full_hand < JoyousSpring.get_joker_column(card) then\n                if math.max(1, card.ability.extra.xmult - JoyousSpring.get_joker_column(card)) > 1 then\n                    card.ability.extra.current_money = card.ability.extra.current_money + card.ability.extra.money\n                end\n                return {\n                    xmult = math.max(1, card.ability.extra.xmult - JoyousSpring.get_joker_column(card))\n                }\n            end\n        end\n    end,\n    use = function(self, card, area, copier)\n        ease_dollars(card.ability.extra.current_money)\n    end,\n    can_use = function(self, card)\n        return card.ability.extra.current_money > 0\n    end,"
    },
    {
      "type": "Joker",
      "key": "couverture",
      "atlas": "Misc03",
      "pos": {
        "x": 4,
        "y": 3
      },
      "raw": "key = \"couverture\",\n    atlas = 'Misc03',\n    pos = { x = 4, y = 3 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.creates, card.ability.extra.adds } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"FUSION\",\n                is_pendulum = true,\n                attribute = \"DARK\",\n                monster_type = \"Fairy\",\n\n                summon_conditions = {\n                    {\n                        type = \"FUSION\",\n                        materials = {\n                            { is_pendulum = true },\n                            { is_pendulum = true },\n                        }\n                    }\n                },\n            },\n            creates = 1,\n            adds = 1\n        },\n    },\n    use = function(self, card, area, copier)\n        for i = 1, card.ability.extra.creates do\n            JoyousSpring.create_pseudorandom({ { is_pendulum = true, rarity = 3 } }, 'j_joy_couverture', true)\n        end\n        if #JoyousSpring.extra_deck_area.cards < JoyousSpring.extra_deck_area.config.card_limit then\n            JoyousSpring.add_to_extra_deck(\"j_joy_couverture\")\n        end\n    end,\n    can_use = function(self, card)\n        return JoyousSpring.is_summoned(card) and\n            (#G.jokers.cards + G.GAME.joker_buffer < G.jokers.config.card_limit + (card.edition and card.edition.negative and 0 or 1))\n    end,"
    },
    {
      "type": "Joker",
      "key": "nirvana",
      "atlas": "Misc04",
      "pos": {
        "x": 4,
        "y": 5
      },
      "raw": "key = \"nirvana\",\n    atlas = 'Misc04',\n    pos = { x = 4, y = 5 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.xmult } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_pendulum = true,\n                summon_type = \"SYNCHRO\",\n                attribute = \"DARK\",\n                monster_type = \"Spellcaster\",\n                summon_conditions = {\n                    {\n                        type = \"SYNCHRO\",\n                        materials = {\n                            { is_tuner = true,       exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                            { exclude_tuners = true, summon_type = \"SYNCHRO\" },\n                        },\n                    }\n                }\n            },\n            xmult = 2\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.other_joker and context.other_joker.facing == \"front\" and JoyousSpring.is_pendulum_monster(context.other_joker) then\n                return {\n                    xmult = card.ability.extra.xmult,\n                    message_card = context.other_joker\n                }\n            end\n        end\n    end,\n    use = function(self, card, area, copier)\n        for _, joker in ipairs(G.jokers.cards) do\n            if JoyousSpring.is_pendulum_monster(joker) then\n                joker:set_edition(\"e_polychrome\")\n            end\n        end\n    end,\n    can_use = function(self, card)\n        return JoyousSpring.count_materials_owned({ { is_pendulum = true } }) >\n            (card.area and card.area == G.jokers and 1 or 0)\n    end,"
    },
    {
      "type": "Joker",
      "key": "ooze",
      "atlas": "Misc04",
      "pos": {
        "x": 5,
        "y": 5
      },
      "raw": "key = \"ooze\",\n    atlas = 'Misc04',\n    pos = { x = 5, y = 5 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n        end\n        return { vars = { card.ability.extra.attach, card.ability.extra.detach, card.ability.extra.revives } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    update = JoyousSpring.update_counter,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_pendulum = true,\n                summon_type = \"XYZ\",\n                attribute = \"WATER\",\n                monster_type = \"Zombie\",\n                summon_conditions = {\n                    {\n                        type = \"XYZ\",\n                        materials = {\n                            { is_pendulum = true, exclude_tokens = true, exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                            { is_pendulum = true, exclude_tokens = true, exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                        },\n                    }\n                }\n            },\n            attach = 2,\n            detach = 2,\n            revives = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.joy_detach and context.joy_detaching_card == card then\n                JoyousSpring.ease_detach(card)\n\n                for i = 1, card.ability.extra.revives do\n                    JoyousSpring.revive_pseudorandom({ { is_pendulum = true } }, 'j_joy_ooze', false,\n                        \"e_negative\")\n                end\n            end\n        end\n    end,\n    use = function(self, card, area, copier)\n        local choices = JoyousSpring.get_materials_owned({ { summon_type = \"XYZ\" } })\n        local joker = pseudorandom_element(choices, 'j_joy_ooze')\n\n        if joker then\n            joker.ability.extra.joyous_spring.xyz_materials = joker.ability.extra.joyous_spring.xyz_materials +\n                card.ability.extra.attach\n        end\n    end,\n    can_use = function(self, card)\n        return JoyousSpring.count_materials_owned({ { summon_type = \"XYZ\" } }) >\n            (card.area and card.area == G.jokers and 1 or 0)\n    end,"
    },
    {
      "type": "Joker",
      "key": "sauravis",
      "atlas": "Misc01",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"sauravis\",\n    atlas = 'Misc01',\n    pos = { x = 1, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.xmult, 1 + (card.ability.extra.xmult * (G.GAME.joy_sauravis_uses or 0)) } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"RITUAL\",\n                attribute = \"LIGHT\",\n                monster_type = \"Dragon\",\n                summon_conditions = {\n                    {\n                        type = \"RITUAL\",\n                        materials = {\n                            {},\n                            {},\n                        }\n                    }\n                }\n            },\n            xmult = 2\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    xmult = 1 + (card.ability.extra.xmult * (G.GAME.joy_sauravis_uses or 0))\n                }\n            end\n        end\n        if not context.blueprint_card and context.selling_self then\n            if G.GAME.blind and ((not G.GAME.blind.disabled) and (G.GAME.blind:get_type() == 'Boss')) then\n                G.GAME.blind:disable()\n                JoyousSpring.add_monster_tag(\"j_joy_sauravis\")\n                G.GAME.joy_sauravis_uses = (G.GAME.joy_sauravis_uses or 0) + 1\n                return { message = localize('ph_boss_disabled') }\n            end\n        end\n    end,\n    joker_display_def = function(JokerDisplay)\n        return {\n            reminder_text = {\n                { ref_table = \"card.joker_display_values\", ref_value = \"active_text\" },\n            },\n            calc_function = function(card)\n                local disableable = G.GAME and G.GAME.blind and G.GAME.blind.get_type and\n                    ((not G.GAME.blind.disabled) and (G.GAME.blind:get_type() == 'Boss'))\n                card.joker_display_values.active = disableable\n                card.joker_display_values.active_text = localize(disableable and 'k_active' or 'ph_no_boss_active')\n            end,\n            style_function = function(card, text, reminder_text, extra)\n                if reminder_text and reminder_text.children[1] then\n                    reminder_text.children[1].config.colour = card.joker_display_values.active and G.C.GREEN or G.C.RED\n                    reminder_text.children[1].config.scale = card.joker_display_values.active and 0.35 or 0.3\n                    return true\n                end\n                return false\n            end\n        }\n    end"
    },
    {
      "type": "Joker",
      "key": "lycanthrope",
      "atlas": "Misc04",
      "pos": {
        "x": 3,
        "y": 3
      },
      "raw": "key = \"lycanthrope\",\n    atlas = 'Misc04',\n    pos = { x = 3, y = 3 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.mult, card.ability.extra.mult * JoyousSpring.count_all_materials({ { is_normal = true } }) } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"RITUAL\",\n                attribute = \"EARTH\",\n                monster_type = \"BeastWarrior\",\n                summon_conditions = {\n                    {\n                        type = \"RITUAL\",\n                        materials = {\n                            {},\n                            {},\n                        }\n                    },\n                    {\n                        type = \"RITUAL\",\n                        materials = {\n                            { is_normal = true },\n                        }\n                    }\n                }\n            },\n            mult = 50\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    mult = card.ability.extra.mult * JoyousSpring.count_all_materials({ { is_normal = true } })\n                }\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "mudragon",
      "atlas": "Misc01",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"mudragon\",\n    atlas = 'Misc01',\n    pos = { x = 2, y = 0 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 3,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return {}\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"FUSION\",\n                is_all_attributes = true,\n                is_all_materials = { FUSION = true },\n                attribute = \"WATER\",\n                monster_type = \"Wyrm\",\n                summon_conditions = {\n                    {\n                        type = \"FUSION\",\n                        materials = {\n                            {},\n                            {},\n                        },\n                        restrictions = {\n                            different_rarities = true\n                        }\n                    }\n                },\n            },\n        },\n    },"
    },
    {
      "type": "Joker",
      "key": "garura",
      "atlas": "Misc01",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"garura\",\n    atlas = 'Misc01',\n    pos = { x = 0, y = 1 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return { vars = { card.ability.extra.h_size, card.ability.extra.h_size_gain } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"FUSION\",\n                attribute = \"DARK\",\n                monster_type = \"WingedBeast\",\n\n                summon_conditions = {\n                    {\n                        type = \"FUSION\",\n                        materials = {\n                            {},\n                            {},\n                        },\n                        restrictions = {\n                            same_rarity = true,\n                            different_names = true\n                        }\n                    }\n                }\n            },\n            h_size = 2,\n            h_size_gain = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.used_as_material(card, context) then\n            G.hand:change_size(card.ability.extra.h_size_gain)\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not JoyousSpring.is_perma_debuffed(card) then\n            G.hand:change_size(card.ability.extra.h_size)\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        if not JoyousSpring.is_perma_debuffed(card) then\n            G.hand:change_size(-card.ability.extra.h_size)\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "firewall_saber",
      "atlas": "Misc03",
      "pos": {
        "x": 0,
        "y": 3
      },
      "raw": "key = \"firewall_saber\",\n    atlas = 'Misc03',\n    pos = { x = 0, y = 3 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 8,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_revive\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return { vars = { card.ability.extra.revives, card.ability.extra.creates } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Cyberse\",\n                monster_archetypes = { [\"Firewall\"] = true },\n                summon_type = \"SYNCHRO\",\n                summon_conditions = {\n                    {\n                        type = \"SYNCHRO\",\n                        materials = {\n                            { monster_type = \"Cyberse\", is_tuner = true,                         exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                            { exclude_tuners = true,    exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                        },\n                    }\n                }\n            },\n            revives = 1,\n            creates = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.used_as_material(card, context) and JoyousSpring.is_summon_type(context.joy_card, \"LINK\") then\n            for i = 1, card.ability.extra.creates do\n                SMODS.add_card({\n                    set = \"Spectral\",\n                    edition = \"e_negative\"\n                })\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not from_debuff then\n            for i = 1, card.ability.extra.revives do\n                JoyousSpring.revive_pseudorandom({ { is_extra_deck = true, monster_type = \"Cyberse\" } },\n                    \"j_joy_firewall_saber\", false, \"e_negative\")\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "bishbaalkin",
      "atlas": "Misc04",
      "pos": {
        "x": 6,
        "y": 3
      },
      "raw": "key = \"bishbaalkin\",\n    atlas = 'Misc04',\n    pos = { x = 6, y = 3 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 12,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.mult, card.ability.extra.mult * JoyousSpring.count_materials_owned({ { exclude_debuffed = true } }) } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"SYNCHRO\",\n                attribute = \"DARK\",\n                monster_type = \"Dragon\",\n                summon_conditions = {\n                    {\n                        type = \"SYNCHRO\",\n                        materials = {\n                            { is_tuner = true,       exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                            { exclude_tuners = true, rarity = 3,                              exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                        },\n                    }\n                }\n            },\n            mult = 100\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    mult = card.ability.extra.mult * JoyousSpring.count_materials_owned({ { exclude_debuffed = true } })\n                }\n            end\n            if context.end_of_round and context.game_over == false and context.main_eval then\n                local count = 0\n                for _, joker in ipairs(G.jokers.cards) do\n                    if joker ~= card and not joker.ability.eternal and not joker.getting_sliced and not joker.debuff and joker.config.center.key ~= \"j_joy_token\" then\n                        joker.getting_sliced = true\n                        joker:start_dissolve()\n                        count = count + 1\n                    end\n                end\n                for i = 1, count do\n                    JoyousSpring.summon_token(\"utchatzimime\", \"e_negative\")\n                end\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "fishlamp",
      "atlas": "Misc04",
      "pos": {
        "x": 5,
        "y": 3
      },
      "raw": "key = \"fishlamp\",\n    atlas = 'Misc04',\n    pos = { x = 5, y = 3 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return { vars = { card.ability.extra.adds, card.ability.extra.creates } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_tuner = true,\n                is_all_materials = { SYNCHRO = true },\n                summon_type = \"SYNCHRO\",\n                attribute = \"FIRE\",\n                monster_type = \"Fish\",\n                summon_conditions = {\n                    {\n                        type = \"SYNCHRO\",\n                        materials = {\n                            { is_tuner = true,       exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                            { exclude_tuners = true, exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                        },\n                    }\n                }\n            },\n            adds = 1,\n            creates = 2\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.used_as_material(card, context) then\n            local choices = JoyousSpring.get_materials_in_collection({ { monster_type = \"Fish\", is_extra_deck = true } })\n            for _ = 1, card.ability.extra.adds do\n                local key_to_add, _ = pseudorandom_element(choices, 'j_joy_fishlamp')\n                if key_to_add and #JoyousSpring.extra_deck_area.cards < JoyousSpring.extra_deck_area.config.card_limit then\n                    JoyousSpring.add_to_extra_deck(key_to_add)\n                end\n            end\n            for i = 1, card.ability.extra.creates do\n                JoyousSpring.summon_token(\"lamp\")\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "afd",
      "atlas": "Misc04",
      "pos": {
        "x": 4,
        "y": 3
      },
      "raw": "key = \"afd\",\n    atlas = 'Misc04',\n    pos = { x = 4, y = 3 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.creates, card.ability.extra.destroys_and_creates, card.ability.extra.money } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"SYNCHRO\",\n                attribute = \"LIGHT\",\n                monster_type = \"Dragon\",\n                summon_conditions = {\n                    {\n                        type = \"SYNCHRO\",\n                        materials = {\n                            { is_tuner = true,       exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                            { exclude_tuners = true, exclude_summon_types = { \"XYZ\", \"LINK\" } },\n                        },\n                    }\n                }\n            },\n            creates = 1,\n            destroys_and_creates = 1,\n            money = 10,\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.setting_blind and context.main_eval then\n                local choices = {}\n                for _, field in ipairs(JoyousSpring.field_spell_area.cards) do\n                    if not field.ability.eternal then\n                        table.insert(choices, field)\n                    end\n                end\n                if #choices > 0 then\n                    local destroyed = 0\n                    for i = 1, card.ability.extra.destroys_and_creates do\n                        local chosen, index = pseudorandom_element(choices, 'j_joy_afd')\n                        if chosen then\n                            chosen.getting_sliced = true\n                            chosen:start_dissolve()\n                            destroyed = destroyed + 1\n                            table.remove(choices, index)\n                        end\n                        if #JoyousSpring.field_spell_area.cards < JoyousSpring.field_spell_area.config.card_limit then\n                            local choices_field = JoyousSpring.get_materials_in_collection({ { is_field_spell = true } })\n\n                            local spell = pseudorandom_element(choices_field, pseudorandom(\"j_joy_afd\"))\n                            if spell and #JoyousSpring.field_spell_area.cards < JoyousSpring.field_spell_area.config.card_limit then\n                                JoyousSpring.add_to_extra_deck(spell)\n                            end\n                        end\n                    end\n                    return {\n                        dollars = destroyed * card.ability.extra.money\n                    }\n                end\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        if not from_debuff then\n            for i = 1, card.ability.extra.creates do\n                JoyousSpring.create_pseudorandom({ { is_tuner = true } }, 'j_joy_afd', true)\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "zeus",
      "atlas": "Misc03",
      "pos": {
        "x": 1,
        "y": 3
      },
      "raw": "key = \"zeus\",\n    atlas = 'Misc03',\n    pos = { x = 1, y = 3 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 12,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.detach, card.ability.extra.percent * 100 } }\n    end,\n    update = JoyousSpring.update_counter,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"XYZ\",\n                attribute = \"LIGHT\",\n                monster_type = \"Machine\",\n\n                summon_conditions = {\n                    {\n                        type = \"XYZ\",\n                        materials = {\n                            {\n                                rarity = 3,\n                                exclude_tokens = true,\n                                exclude_summon_types = { \"XYZ\", \"LINK\" },\n                                min = 2,\n                            },\n                        },\n                    },\n                    {\n                        type = \"XYZ\",\n                        materials = {\n                            {\n                                func = \"detached_this_round\",\n                            },\n                        },\n                        transfer_materials = true\n                    },\n                }\n            },\n            detach = 1,\n            percent = 0.75\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.joy_detach and context.joy_detaching_card == card and G.GAME.blind.in_blind then\n                JoyousSpring.ease_detach(card)\n                G.GAME.blind.chips = math.floor(G.GAME.blind.chips - G.GAME.blind.chips * card.ability.extra.percent)\n                G.GAME.blind.chip_text = number_format(G.GAME.blind.chips)\n\n                for _, pcard in ipairs(G.playing_cards) do\n                    pcard:set_ability(\"c_base\")\n                end\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "typhon",
      "atlas": "Misc03",
      "pos": {
        "x": 2,
        "y": 3
      },
      "raw": "key = \"typhon\",\n    atlas = 'Misc03',\n    pos = { x = 2, y = 3 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 12,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.detach, card.ability.extra.percent * 100 } }\n    end,\n    update = JoyousSpring.update_counter,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"XYZ\",\n                attribute = \"DARK\",\n                monster_type = \"Fiend\",\n\n                summon_conditions = {\n                    {\n                        type = \"XYZ\",\n                        materials = {\n                            {\n                                rarity = 3,\n                                exclude_tokens = true,\n                                exclude_summon_types = { \"XYZ\", \"LINK\" },\n                                min = 2,\n                            },\n                        },\n                    },\n                    {\n                        type = \"XYZ\",\n                        materials = {\n                            {\n                                func = \"summoned_this_round\",\n                                func_vars = { more = 2 }\n                            },\n                        },\n                    },\n                }\n            },\n            detach = 1,\n            percent = 0.5,\n            active = false\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if not context.blueprint_card and not context.retrigger_joker and\n                context.joy_detach and context.joy_detaching_card == card and G.GAME.blind.in_blind and not card.ability.extra.active then\n                JoyousSpring.ease_detach(card)\n                card.ability.extra.active = true\n                ease_dollars(-G.GAME.dollars * card.ability.extra.percent)\n            end\n            if context.end_of_round and context.game_over == false and context.main_eval then\n                card.ability.extra.active = false\n            end\n            if context.after and context.main_eval and card.ability.extra.active then\n                return {\n                    func = function()\n                        for _, pcard in ipairs(context.scoring_hand) do\n                            G.E_MANAGER:add_event(Event({\n                                func = (function()\n                                    pcard:set_ability('m_glass')\n                                    pcard:set_edition('e_polychrome')\n                                    pcard:set_seal(\"Red\")\n\n\n                                    return true\n                                end)\n                            }))\n                        end\n                    end\n                }\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "apollousa",
      "atlas": "Misc01",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"apollousa\",\n    atlas = 'Misc01',\n    pos = { x = 2, y = 1 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = true,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        local mult = math.max(0, card.ability.extra.mult_gain * #JoyousSpring.get_materials(card) -\n            card.ability.extra.mult_loss * card.ability.extra.turns)\n        return { vars = { card.ability.extra.mult_gain, card.ability.extra.mult_loss, mult } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"LINK\",\n                attribute = \"WIND\",\n                monster_type = \"Fairy\",\n                summon_conditions = {\n                    {\n                        type = \"LINK\",\n                        materials = {\n                            { min = 2 },\n                        },\n                        restrictions = {\n                            different_names = true\n                        }\n                    }\n                }\n            },\n            mult_gain = 80,\n            mult_loss = 80,\n            turns = 0\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                local mult = math.max(0, card.ability.extra.mult_gain * #JoyousSpring.get_materials(card) -\n                    card.ability.extra.mult_loss * card.ability.extra.turns)\n                return {\n                    mult = mult\n                }\n            end\n            if context.end_of_round and context.game_over == false and context.main_eval then\n                local mult = math.max(0, card.ability.extra.mult_gain * #JoyousSpring.get_materials(card) -\n                    card.ability.extra.mult_loss * card.ability.extra.turns)\n                if mult > 0 then\n                    card.ability.extra.turns = card.ability.extra.turns + 1\n                    return {\n                        message = localize { type = 'variable', key = 'a_mult_minus', vars = { card.ability.extra.mult_loss } },\n                        colour = G.C.MULT\n                    }\n                end\n            end\n        end\n    end,\n    joker_display_def = function(JokerDisplay)\n        return {\n            text = {\n                { text = \"+\" },\n                { ref_table = \"card.joker_display_values\", ref_value = \"mult\", retrigger_type = \"mult\" }\n            },\n            text_config = { colour = G.C.MULT },\n            calc_function = function(card)\n                card.joker_display_values.mult = math.max(0,\n                    card.ability.extra.mult_gain * #JoyousSpring.get_materials(card) -\n                    card.ability.extra.mult_loss * card.ability.extra.turns)\n            end\n        }\n    end"
    },
    {
      "type": "Joker",
      "key": "beyond",
      "atlas": "Misc03",
      "pos": {
        "x": 0,
        "y": 4
      },
      "raw": "key = \"beyond\",\n    atlas = 'Misc03',\n    pos = { x = 0, y = 4 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 7,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.mult, card.ability.extra.mult * JoyousSpring.get_pendulum_count(), card.ability.extra.creates, card.ability.extra.consume, card.ability.extra.consumed } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Spellcaster\",\n                summon_type = \"LINK\",\n                summon_conditions = {\n                    {\n                        type = \"LINK\",\n                        materials = {\n                            {},\n                            { is_pendulum = true },\n                        },\n                    }\n                }\n            },\n            mult = 10,\n            creates = 1,\n            consume = 4,\n            consumed = 0\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    mult = card.ability.extra.mult * JoyousSpring.get_pendulum_count()\n                }\n            end\n            if context.using_consumeable and JoyousSpring.is_pendulum_monster(context.consumeable) then\n                card.ability.extra.consumed = card.ability.extra.consumed + 1\n                if card.ability.extra.consumed >= card.ability.extra.consume then\n                    card.ability.extra.consumed = 0\n                    JoyousSpring.create_pseudorandom({ { is_pendulum = true } }, 'j_joy_beyond', true)\n                end\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "exceed",
      "atlas": "Misc04",
      "pos": {
        "x": 6,
        "y": 5
      },
      "raw": "key = \"exceed\",\n    atlas = 'Misc04',\n    pos = { x = 6, y = 5 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 9,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_main_deck_joker\" }\n        end\n        return { vars = { card.ability.extra.xmult, 1 + card.ability.extra.xmult * JoyousSpring.get_pendulum_count(), card.ability.extra.creates } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"LINK\",\n                attribute = \"LIGHT\",\n                monster_type = \"Spellcaster\",\n                summon_conditions = {\n                    {\n                        type = \"LINK\",\n                        materials = {\n                            { is_pendulum = true },\n                            {},\n                            {},\n                        }\n                    }\n                },\n            },\n            xmult = 0.05,\n            creates = 1,\n            activated = true\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    xmult = 1 + card.ability.extra.xmult * JoyousSpring.get_pendulum_count()\n                }\n            end\n            if context.end_of_round and context.game_over == false and context.main_eval and G.GAME.blind.boss and\n                not card.ability.extra.activated then\n                card.ability.extra.activated = true\n                for i = 1, card.ability.extra.creates do\n                    JoyousSpring.create_pseudorandom({ { is_pendulum = true, is_main_deck = true } },\n                        'j_joy_exceed', false, false,\n                        \"e_negative\")\n                end\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "linkuriboh",
      "atlas": "Misc03",
      "pos": {
        "x": 1,
        "y": 4
      },
      "raw": "key = \"linkuriboh\",\n    atlas = 'Misc03',\n    pos = { x = 1, y = 4 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 7,\n    loc_vars = function(self, info_queue, card)\n        return { vars = {} }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Cyberse\",\n                monster_archetypes = { [\"Kuriboh\"] = true },\n                summon_type = \"LINK\",\n                summon_conditions = {\n                    {\n                        type = \"LINK\",\n                        materials = {\n                            { rarity = 1 },\n                        },\n                    }\n                }\n            },\n        },\n    },\n    calculate = function(self, card, context)\n        if not context.blueprint_card and context.selling_self then\n            if G.GAME.blind and ((not G.GAME.blind.disabled) and (G.GAME.blind:get_type() == 'Boss')) then\n                G.GAME.blind:disable()\n                ease_dollars(-G.GAME.dollars)\n                return { message = localize('ph_boss_disabled') }\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "linguriboh",
      "atlas": "Misc03",
      "pos": {
        "x": 2,
        "y": 4
      },
      "raw": "key = \"linguriboh\",\n    atlas = 'Misc03',\n    pos = { x = 2, y = 4 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 7,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return { vars = { card.ability.extra.h_size } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                attribute = \"DARK\",\n                monster_type = \"Cyberse\",\n\n                summon_type = \"LINK\",\n                summon_conditions = {\n                    {\n                        type = \"LINK\",\n                        materials = {\n                            { monster_type = \"Cyberse\" },\n                        },\n                    }\n                }\n            },\n            h_size = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if not context.blueprint_card and context.selling_self then\n            if G.GAME.blind and ((not G.GAME.blind.disabled) and (G.GAME.blind:get_type() == 'Boss')) then\n                G.GAME.blind:disable()\n                local used_ignister = false\n                for _, material in ipairs(card.ability.extra.joyous_spring.summon_materials) do\n                    if JoyousSpring.is_material_center(material, { monster_archetypes = { \"Ignister\" } }) then\n                        used_ignister = true\n                        break\n                    end\n                end\n                if not used_ignister then\n                    G.hand:change_size(-card.ability.extra.h_size)\n                end\n                return { message = localize('ph_boss_disabled') }\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "ipmasq",
      "atlas": "Misc04",
      "pos": {
        "x": 7,
        "y": 5
      },
      "raw": "key = \"ipmasq\",\n    atlas = 'Misc04',\n    pos = { x = 7, y = 5 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_transform\" }\n        end\n        return { vars = {} }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"LINK\",\n                attribute = \"DARK\",\n                monster_type = \"Cyberse\",\n                summon_conditions = {\n                    {\n                        type = \"LINK\",\n                        materials = {\n                            { is_effect = true },\n                            { is_effect = true },\n                        },\n                    }\n                }\n            },\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.setting_blind and context.main_eval then\n                local choices = JoyousSpring.get_materials_in_collection({ { summon_type = \"LINK\", exclude_keys = { \"j_joy_ipmasq\" } } })\n                local key_to_transform = pseudorandom_element(choices, 'j_joy_ipmasq') or \"j_joy_spknight\"\n                JoyousSpring.transform_card(card, key_to_transform, false, \"Link\", { \"j_joy_ipmasq\" })\n            end\n        end\n    end,\n    joy_can_transfer_ability = function(self, other_card, card)\n        return other_card.joy_transforming == \"j_joy_ipmasq\"\n    end,\n    joy_transfer_ability_calculate = function(self, other_card, context, config)\n        if JoyousSpring.can_use_abilities(other_card) then\n            if context.end_of_round and context.game_over == false and context.main_eval then\n                JoyousSpring.transform_card(other_card, \"j_joy_ipmasq\")\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "spknight",
      "atlas": "Misc04",
      "pos": {
        "x": 0,
        "y": 6
      },
      "raw": "key = \"spknight\",\n    atlas = 'Misc04',\n    pos = { x = 0, y = 6 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 8,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_banish\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_extra_deck_joker\" }\n        end\n        return { vars = { card.ability.extra.banishes } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"LINK\",\n                attribute = \"DARK\",\n                monster_type = \"Warrior\",\n                summon_conditions = {\n                    {\n                        type = \"LINK\",\n                        materials = {\n                            { is_effect = true },\n                            { is_effect = true },\n                        },\n                    }\n                }\n            },\n            banishes = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.end_of_round and context.game_over == false and context.main_eval then\n                local choices = {}\n                for _, joker in ipairs(G.jokers.cards) do\n                    if joker ~= card then\n                        table.insert(choices, joker)\n                    end\n                end\n                local chosen = pseudorandom_element(choices, 'j_joy_spknight')\n                if chosen then\n                    local ed_materials = 0\n                    for _, material in ipairs(JoyousSpring.get_materials(card)) do\n                        if JoyousSpring.is_material_center(material, { is_extra_deck = true }) then\n                            ed_materials = ed_materials + 1\n                            if ed_materials >= 2 then\n                                break\n                            end\n                        end\n                    end\n                    JoyousSpring.banish(card, ed_materials >= 2 and \"blind_selected\" or \"boss_selected\")\n                    JoyousSpring.banish(chosen, ed_materials >= 2 and \"blind_selected\" or \"boss_selected\")\n                end\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "progleo",
      "atlas": "Misc04",
      "pos": {
        "x": 1,
        "y": 6
      },
      "raw": "key = \"progleo\",\n    atlas = 'Misc04',\n    pos = { x = 1, y = 6 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_banish\" }\n        end\n        return { vars = { card.ability.extra.banishes } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"LINK\",\n                attribute = \"LIGHT\",\n                monster_type = \"Cyberse\",\n                summon_conditions = {\n                    {\n                        type = \"LINK\",\n                        materials = {\n                            { exclude_tokens = true },\n                            { exclude_tokens = true },\n                        },\n                    }\n                }\n            },\n            banishes = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.end_of_round and context.game_over == false and context.main_eval then\n                local column = JoyousSpring.get_joker_column(card)\n\n                local choices = {}\n                if G.jokers.cards[column - 1] then\n                    choices[#choices + 1] = G.jokers.cards[column - 1]\n                end\n                if G.jokers.cards[column + 1] then\n                    choices[#choices + 1] = G.jokers.cards[column + 1]\n                end\n                local chosen = pseudorandom_element(choices, 'j_joy_progleo')\n                if chosen then\n                    JoyousSpring.banish(chosen, \"boss_selected\")\n                end\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "raster",
      "atlas": "Misc04",
      "pos": {
        "x": 2,
        "y": 6
      },
      "raw": "key = \"raster\",\n    atlas = 'Misc04',\n    pos = { x = 2, y = 6 },\n    rarity = 3,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 10,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_tribute\" }\n        end\n        return { vars = { card.ability.extra.mult, card.ability.extra.mult * JoyousSpring.count_materials_in_graveyard({ { summon_type = \"LINK\" } }), card.ability.extra.percent * 100 } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                summon_type = \"LINK\",\n                attribute = \"LIGHT\",\n                monster_type = \"Cyberse\",\n                summon_conditions = {\n                    {\n                        type = \"LINK\",\n                        materials = {\n                            { exclude_tokens = true },\n                            { exclude_tokens = true },\n                            { exclude_tokens = true },\n                            { exclude_tokens = true },\n                        },\n                    }\n                }\n            },\n            mult = 50,\n            percent = 0.1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    mult = card.ability.extra.mult *\n                        JoyousSpring.count_materials_in_graveyard({ { summon_type = \"LINK\" } })\n                }\n            end\n            if context.joy_activate_effect and context.joy_activated_card == card and G.GAME.blind.in_blind then\n                local tributes = {}\n                for _, joker in ipairs(G.jokers.cards) do\n                    if joker ~= card and not joker.ability.eternal then\n                        table.insert(tributes, joker)\n                    end\n                end\n                local count = #tributes\n                JoyousSpring.tribute(card, tributes)\n\n                G.GAME.blind.chips = math.floor(G.GAME.blind.chips -\n                    G.GAME.blind.chips * math.min(1, count * card.ability.extra.percent))\n                G.GAME.blind.chip_text = number_format(G.GAME.blind.chips)\n            end\n        end\n    end,\n    joy_can_activate = function(card)\n        if not G.GAME.blind.in_blind or G.GAME.blind.chips <= 0 then\n            return false\n        end\n        for _, joker in ipairs(G.jokers.cards) do\n            if joker ~= card and not joker.ability.eternal then\n                return true\n            end\n        end\n        return false\n    end,"
    },
    {
      "type": "Joker",
      "key": "chickengame",
      "atlas": "Misc04",
      "pos": {
        "x": 3,
        "y": 2
      },
      "raw": "key = \"chickengame\",\n    atlas = 'Misc04',\n    pos = { x = 3, y = 2 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 9,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.percent * 100, card.ability.extra.hands, card.ability.extra.discards } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_field_spell = true,\n            },\n            percent = 0.5,\n            hands = 1,\n            discards = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if context.joy_activate_effect and context.joy_activated_card == card and G.GAME.blind.in_blind then\n            ease_discard(card.ability.extra.discards)\n            ease_hands_played(card.ability.extra.hands)\n            G.GAME.blind.chips = math.floor(G.GAME.blind.chips + G.GAME.blind.chips * card.ability.extra.percent)\n            G.GAME.blind.chip_text = number_format(G.GAME.blind.chips)\n        end\n    end,\n    joy_can_activate = function(card)\n        return G.GAME.blind.in_blind\n    end,"
    },
    {
      "type": "Joker",
      "key": "fusiongate",
      "atlas": "Misc04",
      "pos": {
        "x": 5,
        "y": 2
      },
      "raw": "key = \"fusiongate\",\n    atlas = 'Misc04',\n    pos = { x = 5, y = 2 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 7,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.adds } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_field_spell = true,\n            },\n            adds = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.end_of_round and context.game_over == false and context.main_eval and G.GAME.blind.boss then\n                local choices = JoyousSpring.get_materials_in_collection({ { summon_type = \"FUSION\" } })\n                for _ = 1, card.ability.extra.adds do\n                    local key_to_add, _ = pseudorandom_element(choices, card.config.center.key)\n                    if key_to_add and #JoyousSpring.extra_deck_area.cards < JoyousSpring.extra_deck_area.config.card_limit then\n                        JoyousSpring.add_to_extra_deck(key_to_add)\n                    end\n                end\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "xyzterritory",
      "atlas": "Misc04",
      "pos": {
        "x": 2,
        "y": 3
      },
      "raw": "key = \"xyzterritory\",\n    atlas = 'Misc04',\n    pos = { x = 2, y = 3 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 7,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return { vars = { card.ability.extra.mult, card.ability.extra.current_mult, card.ability.extra.money } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_field_spell = true,\n            },\n            mult = 25,\n            current_mult = 0,\n            money = 5\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.joker_main then\n                return {\n                    mult = card.ability.extra.current_mult\n                }\n            end\n            if context.joy_detached then\n                return {\n                    dollars = card.ability.extra.money\n                }\n            end\n            if context.end_of_round and context.game_over == false and context.main_eval then\n                card.ability.extra.current_mult = card.ability.extra.current_mult +\n                    card.ability.extra.mult * JoyousSpring.count_materials_owned({ { summon_type = \"XYZ\" } })\n            end\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "xyzoverride",
      "atlas": "Misc04",
      "pos": {
        "x": 1,
        "y": 3
      },
      "raw": "key = \"xyzoverride\",\n    atlas = 'Misc04',\n    pos = { x = 1, y = 3 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 5,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_tribute\" }\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_material\" }\n        end\n        return { vars = { card.ability.extra.tributes, card.ability.extra.attach } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_field_spell = true,\n            },\n            tributes = 1,\n            attach = 1,\n            activated = false\n        },\n    },\n    calculate = function(self, card, context)\n        if not card.ability.extra.activated and context.joy_activate_effect and context.joy_activated_card == card then\n            local materials = JoyousSpring.get_materials_owned({ {} }, false, true)\n            if #materials >= card.ability.extra.tributes then\n                JoyousSpring.create_overlay_effect_selection(card, materials, card.ability.extra.tributes,\n                    card.ability.extra.tributes)\n            end\n        end\n        if context.joy_exit_effect_selection and context.joy_card == card and\n            #context.joy_selection == card.ability.extra.tributes then\n            JoyousSpring.tribute(card, context.joy_selection)\n            card.ability.extra.activated = true\n            for _, joker in ipairs(G.jokers.cards) do\n                if JoyousSpring.is_summon_type(joker, \"XYZ\") then\n                    joker.ability.extra.joyous_spring.xyz_materials = joker.ability.extra.joyous_spring.xyz_materials +\n                        card.ability.extra.attach\n                end\n            end\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval then\n            card.ability.extra.activated = false\n        end\n    end,\n    joy_can_activate = function(card)\n        if card.ability.extra.activated then\n            return false\n        end\n        local materials_owned = JoyousSpring.get_materials_owned({ {} }, false, true)\n        local xyz_owned = JoyousSpring.get_materials_owned({ { summon_type = \"XYZ\" } })\n\n        if not next(xyz_owned) or (#materials_owned == 1 and #xyz_owned == 1 and materials_owned[1] == xyz_owned[1]) then\n            return false\n        end\n        return #materials_owned >= card.ability.extra.tributes\n    end,"
    },
    {
      "type": "Joker",
      "key": "summonbreaker",
      "atlas": "Misc04",
      "pos": {
        "x": 0,
        "y": 3
      },
      "raw": "key = \"summonbreaker\",\n    atlas = 'Misc04',\n    pos = { x = 0, y = 3 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 6,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { JoyousSpring.get_summoned_count(nil, true), card.ability.extra.to_summon } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_field_spell = true,\n            },\n            to_summon = 3\n        },\n    },\n    calculate = function(self, card, context)\n        if context.joy_summon and JoyousSpring.get_summoned_count(nil, true) >= card.ability.extra.to_summon then\n            context.joy_card:set_edition(\"e_negative\", true)\n            card.getting_sliced = true\n            card:start_dissolve()\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "extranet",
      "atlas": "Misc04",
      "pos": {
        "x": 4,
        "y": 2
      },
      "raw": "key = \"extranet\",\n    atlas = 'Misc04',\n    pos = { x = 4, y = 2 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 3,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.h_size } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_field_spell = true,\n            },\n            h_size = 1,\n            h_size_change = 0\n        },\n    },\n    calculate = function(self, card, context)\n        if context.joy_summon then\n            card.ability.extra.h_size_change = card.ability.extra.h_size_change + 1\n            G.hand:change_size(1)\n        end\n        if context.end_of_round and context.game_over == false and context.main_eval then\n            if card.ability.extra.h_size_change > 0 then\n                G.hand:change_size(-card.ability.extra.h_size_change)\n                card.ability.extra.h_size_change = 0\n            end\n        end\n    end,\n    add_to_deck = function(self, card, from_debuff)\n        card.ability.extra.h_size_change = JoyousSpring.get_summoned_count(nil, true)\n        G.hand:change_size(card.ability.extra.h_size_change)\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        if card.ability.extra.h_size_change > 0 then\n            G.hand:change_size(-card.ability.extra.h_size_change)\n            card.ability.extra.h_size_change = 0\n        end\n    end,"
    },
    {
      "type": "Joker",
      "key": "futurevisions",
      "atlas": "Misc04",
      "pos": {
        "x": 6,
        "y": 2
      },
      "raw": "key = \"futurevisions\",\n    atlas = 'Misc04',\n    pos = { x = 6, y = 2 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 8,\n    loc_vars = function(self, info_queue, card)\n        if not JoyousSpring.config.disable_tooltips and not card.fake_card and not card.debuff then\n            info_queue[#info_queue + 1] = { set = \"Other\", key = \"joy_tooltip_banish\" }\n        end\n        return { vars = { card.ability.extra.banishes } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_field_spell = true,\n            },\n            banishes = 1\n        },\n    },\n    calculate = function(self, card, context)\n        if JoyousSpring.can_use_abilities(card) then\n            if context.end_of_round and context.game_over == false and context.main_eval then\n                local choices = JoyousSpring.get_materials_owned({ { is_main_deck = true } })\n                local joker = pseudorandom_element(choices, 'j_joy_futurevisions')\n                if joker then\n                    JoyousSpring.banish(joker, \"boss_selected\")\n                end\n            end\n        end\n    end"
    },
    {
      "type": "Joker",
      "key": "midbreaker",
      "atlas": "Misc04",
      "pos": {
        "x": 7,
        "y": 2
      },
      "raw": "key = \"midbreaker\",\n    atlas = 'Misc04',\n    pos = { x = 7, y = 2 },\n    rarity = 2,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 7,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.extra.xmult } }\n    end,\n    generate_ui = JoyousSpring.generate_info_ui,\n    set_sprites = JoyousSpring.set_back_sprite,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_field_spell = true,\n            },\n            xmult = 1.5\n        },\n    },\n    calculate = function(self, card, context)\n        if context.other_joker and G.GAME.blind.boss then\n            return {\n                xmult = card.ability.extra.xmult,\n                message_card = context.other_joker\n            }\n        end\n        if (context.setting_blind or (context.end_of_round and context.game_over == false)) and context.main_eval then\n            if G.GAME.blind.boss then\n                for _, joker in ipairs(G.jokers.cards) do\n                    SMODS.debuff_card(joker, context.setting_blind and \"prevent_debuff\" or false, \"j_joy_midbreaker\")\n                end\n            else\n                JoyousSpring.flip_all_cards(card, context.setting_blind and \"back\" or \"front\", { G.jokers })\n            end\n        end\n        if context.setting_blind and G.GAME.blind.boss then\n            for _, joker in ipairs(G.jokers.cards) do\n                SMODS.debuff_card(joker, \"prevent_debuff\", \"j_joy_midbreaker\")\n            end\n        end\n    end,\n    remove_from_deck = function(self, card, from_debuff)\n        for _, joker in ipairs(G.jokers.cards) do\n            SMODS.debuff_card(joker, false, \"j_joy_midbreaker\")\n        end\n    end,\n    joy_apply_to_jokers_added = function(card, added_card)\n        if G.GAME.blind.boss then\n            SMODS.debuff_card(added_card, \"prevent_debuff\", \"j_joy_midbreaker\")\n        end\n    end,\n    joy_prevent_flip = function(card, other_card)\n        return G.GAME.blind.boss and true or false\n    end"
    },
    {
      "type": "Atlas",
      "key": "Token",
      "atlas": null,
      "pos": null,
      "raw": "key = \"Token\",\n    path = \"99Token00.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Joker",
      "key": "token",
      "atlas": "Token",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"token\",\n    atlas = 'Token',\n    pos = { x = 0, y = 0 },\n    rarity = 1,\n    discovered = true,\n    blueprint_compat = false,\n    eternal_compat = true,\n    cost = 1,\n    generate_ui = JoyousSpring.generate_info_ui,\n    loc_vars = function(self, info_queue, card)\n        return { key = card.ability.extra.joyous_spring.token_name }\n    end,\n    config = {\n        extra = {\n            joyous_spring = JoyousSpring.init_joy_table {\n                is_effect = false,\n                attribute = \"EARTH\",\n                monster_type = \"Beast\",\n                token_name = \"j_joy_token\"\n            },\n        },\n    },\n    set_sprites = function(self, card, front)\n        if card.ability and card.ability.extra then\n            card.children.center.atlas.name = card.ability.extra.joyous_spring.token_atlas or \"joy_Token\"\n            card.children.center.sprite_pos = card.ability.extra.joyous_spring.token_sprite_pos or { x = 0, y = 0 }\n            card.children.center:reset()\n        end\n        JoyousSpring.set_back_sprite(self, card, front)\n    end,\n    in_pool = function(self, args)\n        return false\n    end,"
    },
    {
      "type": "Atlas",
      "key": "modicon",
      "atlas": null,
      "pos": null,
      "raw": "key = \"modicon\",\n    path = \"icon.png\",\n    px = 32,\n    py = 32"
    },
    {
      "type": "Atlas",
      "key": "Back",
      "atlas": null,
      "pos": null,
      "raw": "key = \"Back\",\n    path = \"back.png\",\n    px = 142,\n    py = 190"
    },
    {
      "type": "Atlas",
      "key": "Booster",
      "atlas": null,
      "pos": null,
      "raw": "key = \"Booster\",\n    path = \"boosters.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Booster",
      "key": "monster_pack",
      "atlas": "Booster",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"monster_pack\",\n    atlas = \"Booster\",\n    pos = { x = 0, y = 1 },\n    discovered = true,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.choose, card.ability.extra } }\n    end,\n    config = {\n        choose = 1,\n        extra = 2\n    },\n    cost = 4,\n    weight = 1,\n    kind = \"JoyousSpring\",\n    group_key = \"k_joy_booster_group\",\n    create_card = function(self, card)\n        return SMODS.create_card({\n            set = \"JoyousSpring\",\n            area = G.pack_cards,\n        })\n    end,\n    ease_background_colour = function(self)\n        local choices = {\n            G.C.JOY.NORMAL,\n            G.C.JOY.EFFECT\n        }\n        local color = pseudorandom_element(choices, 'JoyousSpring')\n        ease_colour(G.C.DYN_UI.MAIN, color or G.C.JOY.EFFECT)\n        ease_background_colour({ new_colour = color, special_colour = G.C.BLACK, contrast = 2 })\n    end,"
    },
    {
      "type": "Booster",
      "key": "jumbo_monster_pack",
      "atlas": "Booster",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"jumbo_monster_pack\",\n    atlas = \"Booster\",\n    pos = { x = 1, y = 1 },\n    discovered = true,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.choose, card.ability.extra } }\n    end,\n    config = {\n        choose = 1,\n        extra = 4\n    },\n    cost = 6,\n    weight = 1,\n    kind = \"JoyousSpring\",\n    group_key = \"k_joy_booster_group\",\n    create_card = function(self, card)\n        return SMODS.create_card({\n            set = \"JoyousSpring\",\n            area = G.pack_cards\n        })\n    end,\n    ease_background_colour = function(self)\n        local choices = {\n            G.C.JOY.NORMAL,\n            G.C.JOY.EFFECT\n        }\n        local color = pseudorandom_element(choices, 'JoyousSpring')\n        ease_colour(G.C.DYN_UI.MAIN, color or G.C.JOY.EFFECT)\n        ease_background_colour({ new_colour = color, special_colour = G.C.BLACK, contrast = 2 })\n    end,"
    },
    {
      "type": "Booster",
      "key": "mega_monster_pack",
      "atlas": "Booster",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"mega_monster_pack\",\n    atlas = \"Booster\",\n    pos = { x = 2, y = 1 },\n    discovered = true,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.choose, card.ability.extra } }\n    end,\n    config = {\n        choose = 2,\n        extra = 4\n    },\n    cost = 8,\n    weight = 0.25,\n    kind = \"JoyousSpring\",\n    group_key = \"k_joy_booster_group\",\n    create_card = function(self, card)\n        return SMODS.create_card({\n            set = \"JoyousSpring\",\n            area = G.pack_cards\n        })\n    end,\n    ease_background_colour = function(self)\n        local choices = {\n            G.C.JOY.NORMAL,\n            G.C.JOY.EFFECT\n        }\n        local color = pseudorandom_element(choices, 'JoyousSpring')\n        ease_colour(G.C.DYN_UI.MAIN, color or G.C.JOY.EFFECT)\n        ease_background_colour({ new_colour = color, special_colour = G.C.BLACK, contrast = 2 })\n    end,"
    },
    {
      "type": "Booster",
      "key": "extra_pack",
      "atlas": "Booster",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"extra_pack\",\n    atlas = \"Booster\",\n    pos = { x = 0, y = 0 },\n    discovered = true,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.choose, card.ability.extra } }\n    end,\n    config = {\n        choose = 1,\n        extra = 2\n    },\n    cost = 6,\n    weight = 0.75,\n    kind = \"JoyousSpring\",\n    group_key = \"k_joy_booster_group\",\n    create_card = function(self, card)\n        return SMODS.create_card({\n            set = \"JoyousSpring\",\n            area = G.pack_cards,\n            joy_monster_properties = {\n                {\n                    is_monster = true,\n                    exclude_extra_deck = G.GAME.modifiers[\"joy_no_extra_deck_jokers\"] and true or nil,\n                    exclude_main_deck = true,\n                    exclude_field_spell = true\n                },\n                {\n                    summon_type = \"RITUAL\"\n                }\n            },\n            joy_monster_default = \"j_joy_sauravis\"\n        })\n    end,\n    ease_background_colour = function(self)\n        local choices = {\n            G.C.JOY.RITUAL,\n            G.C.JOY.FUSION,\n            G.C.JOY.SYNCHRO,\n            G.C.JOY.XYZ,\n            G.C.JOY.LINK\n        }\n        local color = pseudorandom_element(choices, 'JoyousSpring')\n        ease_colour(G.C.DYN_UI.MAIN, color or G.C.JOY.FUSION)\n        ease_background_colour({ new_colour = color, special_colour = G.C.BLACK, contrast = 2 })\n    end,"
    },
    {
      "type": "Booster",
      "key": "jumbo_extra_pack",
      "atlas": "Booster",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"jumbo_extra_pack\",\n    atlas = \"Booster\",\n    pos = { x = 1, y = 0 },\n    discovered = true,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.choose, card.ability.extra } }\n    end,\n    config = {\n        choose = 1,\n        extra = 4\n    },\n    cost = 8,\n    weight = 0.5,\n    kind = \"JoyousSpring\",\n    group_key = \"k_joy_booster_group\",\n    create_card = function(self, card)\n        return SMODS.create_card({\n            set = \"JoyousSpring\",\n            area = G.pack_cards,\n            joy_monster_properties = {\n                {\n                    is_monster = true,\n                    exclude_extra_deck = G.GAME.modifiers[\"joy_no_extra_deck_jokers\"] and true or nil,\n                    exclude_main_deck = true,\n                    exclude_field_spell = true\n                },\n                {\n                    summon_type = \"RITUAL\"\n                }\n            },\n            joy_monster_default = \"j_joy_sauravis\"\n        })\n    end,\n    ease_background_colour = function(self)\n        local choices = {\n            G.C.JOY.RITUAL,\n            G.C.JOY.FUSION,\n            G.C.JOY.SYNCHRO,\n            G.C.JOY.XYZ,\n            G.C.JOY.LINK\n        }\n        local color = pseudorandom_element(choices, 'JoyousSpring')\n        ease_colour(G.C.DYN_UI.MAIN, color or G.C.JOY.FUSION)\n        ease_background_colour({ new_colour = color, special_colour = G.C.BLACK, contrast = 2 })\n    end,"
    },
    {
      "type": "Booster",
      "key": "mega_extra_pack",
      "atlas": "Booster",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"mega_extra_pack\",\n    atlas = \"Booster\",\n    pos = { x = 2, y = 0 },\n    discovered = true,\n    loc_vars = function(self, info_queue, card)\n        return { vars = { card.ability.choose, card.ability.extra } }\n    end,\n    config = {\n        choose = 2,\n        extra = 4\n    },\n    cost = 10,\n    weight = 0.25,\n    kind = \"JoyousSpring\",\n    group_key = \"k_joy_booster_group\",\n    create_card = function(self, card)\n        return SMODS.create_card({\n            set = \"JoyousSpring\",\n            area = G.pack_cards,\n            joy_monster_properties = {\n                {\n                    is_monster = true,\n                    exclude_extra_deck = G.GAME.modifiers[\"joy_no_extra_deck_jokers\"] and true or nil,\n                    exclude_main_deck = true,\n                    exclude_field_spell = true\n                },\n                {\n                    summon_type = \"RITUAL\"\n                }\n            },\n            joy_monster_default = \"j_joy_sauravis\"\n        })\n    end,\n    ease_background_colour = function(self)\n        local choices = {\n            G.C.JOY.RITUAL,\n            G.C.JOY.FUSION,\n            G.C.JOY.SYNCHRO,\n            G.C.JOY.XYZ,\n            G.C.JOY.LINK\n        }\n        local color = pseudorandom_element(choices, 'JoyousSpring')\n        ease_colour(G.C.DYN_UI.MAIN, color or G.C.JOY.FUSION)\n        ease_background_colour({ new_colour = color, special_colour = G.C.BLACK, contrast = 2 })\n    end,"
    },
    {
      "type": "Challenge",
      "key": "mystic_wok",
      "atlas": null,
      "pos": null,
      "raw": "key = \"mystic_wok\",\n    rules = {\n        custom = {\n            { id = \"no_interest\" }\n        }\n    },\n    jokers = {\n        { id = \"j_joy_yokai_sister\", eternal = true },\n        { id = \"j_joy_yokai_sister\", eternal = true },\n    },\n    consumeables = {\n        { id = \"c_fool\" },\n        { id = \"c_hermit\" },\n    },\n    restrictions = {\n        banned_cards =\n        {\n            {\n                id = \"j_joy_runick_fountain\",\n                ids = { \"j_joy_runick_munin\", \"j_joy_runick_hugin\", \"j_joy_runick_geri\",\n                    \"j_joy_runick_freki\", \"j_joy_runick_sleipnir\" }\n            },\n            { id = \"j_joy_fish_snopios\" },\n            { id = \"j_joy_psy_zeta\" },\n        }\n    },\n    unlocked = function(self)\n        return true\n    end,\n    joy_colour = G.C.JOY.SPELL"
    },
    {
      "type": "Challenge",
      "key": "mistake",
      "atlas": null,
      "pos": null,
      "raw": "key = \"mistake\",\n    rules = {\n        modifiers = {\n            { id = \"hands\",       value = 3 },\n            { id = \"discards\",    value = 2 },\n            { id = \"joker_slots\", value = 3 },\n            { id = \"dollars\",     value = 8 },\n        }\n    },\n    jokers = {\n        { id = \"j_joy_yokai_ash\", eternal = true },\n        { id = \"j_joy_yokai_ash\", eternal = true },\n        { id = \"j_joy_yokai_ash\", eternal = true },\n    },\n    vouchers = {\n        { id = \"v_planet_merchant\" },\n    },\n    restrictions = {\n        banned_cards =\n        {\n            { id = \"v_wasteful\" },\n            { id = \"v_grabber\" },\n            { id = \"j_merry_andy\" },\n            { id = \"j_drunkard\" },\n            { id = \"j_burglar\" },\n            { id = \"j_juggler\" },\n            { id = \"j_turtle_bean\" },\n        }\n    },\n    unlocked = function(self)\n        return true\n    end,\n    joy_colour = G.C.JOY.TRAP"
    },
    {
      "type": "Challenge",
      "key": "monster_reborn",
      "atlas": null,
      "pos": null,
      "raw": "key = \"monster_reborn\",\n    rules = {\n        custom = {\n            { id = \"joy_gy_start\", value = { j_joy_etwin_lilla = { count = 1, summonable = 1 } } }\n        },\n        modifiers = {\n            { id = \"joker_slots\", value = 4 },\n            { id = \"dollars\",     value = 0 },\n        }\n    },\n    jokers = {\n        { id = \"j_joy_yokai_belle\",   eternal = true },\n        { id = \"j_joy_etwin_kisikil\", joy_summoned = true, joy_revived = true },\n    },\n    unlocked = function(self)\n        return true\n    end,\n    joy_colour = G.C.JOY.SPELL"
    },
    {
      "type": "Challenge",
      "key": "domain",
      "atlas": null,
      "pos": null,
      "raw": "key = \"domain\",\n    rules = {\n        custom = {\n            { id = \"joy_extra_deck_slots\",     value = 0 },\n            { id = \"joy_no_extra_deck_jokers\", value = true }\n        },\n    },\n    unlocked = function(self)\n        return true\n    end,\n    joy_colour = G.C.JOY.SPELL"
    },
    {
      "type": "Back",
      "key": "hanafuda",
      "atlas": "hanafuda",
      "pos": {
        "x": 1,
        "y": 5
      },
      "raw": "key = \"hanafuda\",\n    atlas = \"hanafuda\",\n    pos = { x = 1, y = 5 },\n    apply = function(self, back)\n        G.E_MANAGER:add_event(Event({\n            blockable = false,\n            func = (function()\n                for _, pcard in ipairs(G.playing_cards) do\n                    pcard:set_ability(\"m_joy_hanafuda\")\n                end\n                return true\n            end)\n        }))\n    end"
    },
    {
      "type": "Atlas",
      "key": "hanafuda",
      "atlas": null,
      "pos": null,
      "raw": "key = \"hanafuda\",\n    path = \"hanafuda.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Enhancement",
      "key": "hanafuda",
      "atlas": "hanafuda",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"hanafuda\",\n    atlas = \"hanafuda\",\n    pos = { x = 0, y = 0 },\n    config = { extra = { hanafuda = nil, mult = { light = 20, animal = 10, ribbon = 5, chaff = 1 } } },\n    loc_vars = function(self, info_queue, card)\n        if card.fake_card then\n            return { key = \"m_joy_hanafuda_fake\" }\n        end\n        local hanafuda = JoyousSpring.get_hanafuda(card, \"Willow\")\n        local hanafuda_name = card.ability.extra.hanafuda:match(\"(.+)_%d+$\") or\n            card.ability.extra.hanafuda\n        return {\n            vars = { localize(\"k_joy_hanafuda_\" .. hanafuda_name), localize(\"k_joy_hanafuda_\" .. hanafuda.month), localize(\"k_joy_hanafuda_\" .. hanafuda.type), card.ability.extra.mult[hanafuda.type or \"chaff\"], box_colours = { G.C.UI.BACKGROUND_WHITE, lighten(G.C.JOY.SPELL, 0.9) } },\n            key = hanafuda.type == 'chaff' and \"m_joy_hanafuda_chaff\" or nil\n        }\n    end,\n    calculate = function(self, card, context)\n        if context.main_scoring and context.cardarea == G.play and card.ability.extra.hanafuda then\n            if not SMODS.PokerHands[context.scoring_name].joy_koi_koi and JoyousSpring.get_hanafuda(card).type ~= \"chaff\" then\n                local has_same_month = false\n                for _, pcard in ipairs(context.scoring_hand) do\n                    if card ~= pcard and JoyousSpring.hanafuda_is_same_month(card, pcard) then\n                        has_same_month = true\n                    end\n                end\n                if not has_same_month then\n                    return\n                end\n            end\n            return {\n                mult = card.ability.extra.mult[JoyousSpring.get_hanafuda(card).type]\n            }\n        end\n        if context.modify_scoring_hand and context.other_card == card and\n            JoyousSpring.get_hanafuda(card).type == \"chaff\" then\n            local scoring_name = G.FUNCS.get_poker_hand_info(context.full_hand)\n            return {\n                add_to_hand = SMODS.PokerHands[scoring_name].joy_koi_koi and true or nil\n            }\n        end\n    end,\n    set_ability = function(self, card, initial, delay_sprites)\n        card.ability.extra.hanafuda = card.ability.extra.hanafuda or\n            pseudorandom_element(JoyousSpring.hanafuda_pool, 'joy_hanafuda')\n\n        G.E_MANAGER:add_event(Event({\n            blockable = false,\n            func = (function()\n                card.children.center:set_sprite_pos(JoyousSpring.get_hanafuda(card, \"Willow\").pos)\n                return true\n            end)\n        }))\n    end,\n    set_sprites = function(self, card, front)\n        G.E_MANAGER:add_event(Event({\n            blockable = false,\n            func = (function()\n                card.children.center:set_sprite_pos(JoyousSpring.get_hanafuda(card, \"Willow\").pos)\n                return true\n            end)\n        }))\n    end"
    },
    {
      "type": "Consumable",
      "key": "cardian_gathering",
      "atlas": "cardian",
      "pos": {
        "x": 3,
        "y": 3
      },
      "raw": "key = \"cardian_gathering\",\n    set = \"Tarot\",\n    atlas = \"cardian\",\n    discovered = true,\n    pos = { x = 3, y = 3 },\n    config = { max_highlighted = 3, mod_conv = 'm_joy_hanafuda' },\n    loc_vars = function(self, info_queue, card)\n        info_queue[#info_queue + 1] = G.P_CENTERS[card.ability.mod_conv]\n        return { vars = { card.ability.max_highlighted } }\n    end,"
    },
    {
      "type": "ObjectType",
      "key": "joy_monster",
      "atlas": null,
      "pos": null,
      "raw": "key = \"joy_monster\",\n    default = \"j_joy_fish_paces\",\n    cards = {},"
    },
    {
      "type": "ObjectType",
      "key": "joy_extra",
      "atlas": null,
      "pos": null,
      "raw": "key = \"joy_extra\",\n    default = \"j_joy_sauravis\",\n    cards = {},"
    },
    {
      "type": "ObjectType",
      "key": "joy_field",
      "atlas": null,
      "pos": null,
      "raw": "key = \"joy_field\",\n    default = \"j_joy_psy_circuit\",\n    cards = {},"
    },
    {
      "type": "PokerHand",
      "key": "eldlixir",
      "atlas": null,
      "pos": null,
      "raw": "key = \"eldlixir\",\n    chips = 100,\n    mult = 8,\n    l_chips = 15,\n    l_mult = 2,\n    visible = false,\n    example = {\n        { 'H_K', true, enhancement = 'm_gold' },\n        { 'S_2', true, enhancement = 'm_gold' },\n        { 'S_7', true, enhancement = 'm_gold' },\n        { 'H_9', true, enhancement = 'm_gold' },\n        { 'C_A', true, enhancement = 'm_gold' },\n    },\n    evaluate = function(parts, hand)\n        if #hand == 5 and next(SMODS.find_card(\"j_joy_eld_angel\")) then\n            local all_gold = true\n            for _, card in ipairs(hand) do\n                if not SMODS.has_enhancement(card, 'm_gold') then\n                    all_gold = false\n                    break\n                end\n            end\n            if all_gold then\n                return { hand }\n            end\n        end\n        return {}\n    end"
    },
    {
      "type": "Atlas",
      "key": "p_eldland",
      "atlas": null,
      "pos": null,
      "raw": "key = \"p_eldland\",\n    path = \"14p_eldland.png\",\n    px = 71,\n    py = 95"
    },
    {
      "type": "Consumable",
      "key": "cursed_eldland",
      "atlas": "p_eldland",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = 'cursed_eldland',\n    set = 'Planet',\n    atlas = 'p_eldland',\n    discovered = true,\n    config = { hand_type = 'joy_eldlixir', softlock = true },\n    pos = { x = 0, y = 0 },\n    generate_ui = 0,\n    process_loc_text = function(self)\n        local target_text = G.localization.descriptions[self.set]['c_mercury'].text\n        SMODS.Consumable.process_loc_text(self)\n        G.localization.descriptions[self.set][self.key] = {}\n        G.localization.descriptions[self.set][self.key].text = target_text\n    end"
    },
    {
      "type": "PokerHand",
      "key": "cardian_chaff",
      "atlas": null,
      "pos": null,
      "raw": "key = \"cardian_chaff\",\n    joy_koi_koi = true,\n    chips = 100,\n    mult = 1,\n    l_chips = 15,\n    l_mult = 2,\n    visible = true,\n    is_visible = cardian_is_visible,\n    example = {\n        { 'D_A', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Paulownia\" },\n        { 'S_2', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Paulownia_2\" },\n        { 'S_7', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Cherry Blossom\" },\n        { 'H_9', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Paulownia\" },\n        { 'C_A', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Chrysanthemum with Sake\" },\n    },\n    evaluate = function(parts, hand)\n        if #hand < 5 then return {} end\n        for _, pcard in ipairs(hand) do\n            local hanafuda, name = JoyousSpring.get_hanafuda(pcard)\n            if (hanafuda or {}).type ~= \"chaff\" and name ~= \"Chrysanthemum with Sake\" then\n                return {}\n            end\n        end\n        return { hand }\n    end,"
    },
    {
      "type": "PokerHand",
      "key": "cardian_ribbons",
      "atlas": null,
      "pos": null,
      "raw": "key = \"cardian_ribbons\",\n    joy_koi_koi = true,\n    chips = 100,\n    mult = 1,\n    l_chips = 15,\n    l_mult = 2,\n    visible = true,\n    is_visible = cardian_is_visible,\n    example = {\n        { 'D_A', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Plum Blossom with Ribbon\" },\n        { 'S_2', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Clover with Ribbon\" },\n        { 'S_7', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Willow with Ribbon\" },\n        { 'H_9', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Chrysanthemum with Ribbon\" },\n        { 'C_A', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Plum Blossom with Ribbon\" },\n    },\n    evaluate = function(parts, hand)\n        if #hand < 5 then return {} end\n        for _, pcard in ipairs(hand) do\n            local hanafuda, _ = JoyousSpring.get_hanafuda(pcard)\n            if (hanafuda or {}).type ~= \"ribbon\" then\n                return {}\n            end\n        end\n        return { hand }\n    end,"
    },
    {
      "type": "PokerHand",
      "key": "cardian_blueribbon",
      "atlas": null,
      "pos": null,
      "raw": "key = \"cardian_blueribbon\",\n    joy_koi_koi = true,\n    chips = 100,\n    mult = 5,\n    l_chips = 15,\n    l_mult = 2,\n    visible = true,\n    is_visible = cardian_is_visible,\n    example = {\n        { 'D_A', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Peony with Ribbon\" },\n        { 'S_2', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Chrysanthemum with Ribbon\" },\n        { 'S_7', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Maple with Ribbon\" },\n        { 'H_9', false },\n        { 'C_A', false },\n    },\n    evaluate = function(parts, hand)\n        local has_hanafuda = {\n            [\"Peony with Ribbon\"] = false,\n            [\"Chrysanthemum with Ribbon\"] = false,\n            [\"Maple with Ribbon\"] = false,\n        }\n        return JoyousSpring.hanafuda_get_hand_for_list(hand, has_hanafuda)\n    end"
    },
    {
      "type": "PokerHand",
      "key": "cardian_redpoem",
      "atlas": null,
      "pos": null,
      "raw": "key = \"cardian_redpoem\",\n    joy_koi_koi = true,\n    chips = 100,\n    mult = 5,\n    l_chips = 15,\n    l_mult = 2,\n    visible = true,\n    is_visible = cardian_is_visible,\n    example = {\n        { 'D_A', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Pine with Ribbon\" },\n        { 'S_2', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Plum Blossom with Ribbon\" },\n        { 'S_7', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Cherry Blossom with Ribbon\" },\n        { 'H_9', false },\n        { 'C_A', false },\n    },\n    evaluate = function(parts, hand)\n        local has_hanafuda = {\n            [\"Pine with Ribbon\"] = false,\n            [\"Plum Blossom with Ribbon\"] = false,\n            [\"Cherry Blossom with Ribbon\"] = false,\n        }\n        return JoyousSpring.hanafuda_get_hand_for_list(hand, has_hanafuda)\n    end"
    },
    {
      "type": "PokerHand",
      "key": "cardian_redpoemblueribbon",
      "atlas": null,
      "pos": null,
      "raw": "key = \"cardian_redpoemblueribbon\",\n    joy_koi_koi = true,\n    chips = 100,\n    mult = 10,\n    l_chips = 15,\n    l_mult = 2,\n    visible = true,\n    is_visible = cardian_is_visible,\n    example = {\n        { 'D_A', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Pine with Ribbon\" },\n        { 'S_2', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Chrysanthemum with Ribbon\" },\n        { 'S_7', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Cherry Blossom with Ribbon\" },\n        { 'H_9', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Maple with Ribbon\" },\n        { 'C_A', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Plum Blossom with Ribbon\" },\n    },\n    evaluate = function(parts, hand)\n        local has_hanafuda = {\n            [\"Pine with Ribbon\"] = false,\n            [\"Plum Blossom with Ribbon\"] = false,\n            [\"Cherry Blossom with Ribbon\"] = false,\n            [\"Peony with Ribbon\"] = false,\n            [\"Chrysanthemum with Ribbon\"] = false,\n            [\"Maple with Ribbon\"] = false,\n        }\n        return JoyousSpring.hanafuda_get_hand_for_list(hand, has_hanafuda, 5)\n    end"
    },
    {
      "type": "PokerHand",
      "key": "cardian_animals",
      "atlas": null,
      "pos": null,
      "raw": "key = \"cardian_animals\",\n    joy_koi_koi = true,\n    chips = 100,\n    mult = 1,\n    l_chips = 15,\n    l_mult = 2,\n    visible = true,\n    is_visible = cardian_is_visible,\n    example = {\n        { 'D_A', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Water Iris with Bridge\" },\n        { 'S_2', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Maple with Deer\" },\n        { 'S_7', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Clover with Boar\" },\n        { 'H_9', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Plum Blossom with White-eye\" },\n        { 'C_A', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Wisteria with Cuckoo\" },\n    },\n    evaluate = function(parts, hand)\n        if #hand < 5 then return {} end\n        for _, pcard in ipairs(hand) do\n            local hanafuda, _ = JoyousSpring.get_hanafuda(pcard)\n            if (hanafuda or {}).type ~= \"animal\" then\n                return {}\n            end\n        end\n        return { hand }\n    end"
    },
    {
      "type": "PokerHand",
      "key": "cardian_boardefly",
      "atlas": null,
      "pos": null,
      "raw": "key = \"cardian_boardefly\",\n    joy_koi_koi = true,\n    chips = 100,\n    mult = 5,\n    l_chips = 15,\n    l_mult = 2,\n    visible = true,\n    is_visible = cardian_is_visible,\n    example = {\n        { 'D_A', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Peony with Butterfly\" },\n        { 'S_2', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Maple with Deer\" },\n        { 'S_7', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Clover with Boar\" },\n        { 'H_9', false },\n        { 'C_A', false },\n    },\n    evaluate = function(parts, hand)\n        local has_hanafuda = {\n            [\"Peony with Butterfly\"] = false,\n            [\"Maple with Deer\"] = false,\n            [\"Clover with Boar\"] = false,\n        }\n        local ret = JoyousSpring.hanafuda_get_hand_for_list(hand, has_hanafuda)\n        if not next(ret) then\n            return {}\n        end\n        local animals = {}\n\n        for _, pcard in ipairs(hand) do\n            local hanafuda, _ = JoyousSpring.get_hanafuda(pcard)\n            if (hanafuda or {}).type == \"animal\" then\n                table.insert(animals, pcard)\n            end\n        end\n        return { SMODS.merge_lists(ret, { animals }) }\n    end"
    },
    {
      "type": "PokerHandPart",
      "key": "flowerviewing_part",
      "atlas": null,
      "pos": null,
      "raw": "key = \"flowerviewing_part\",\n    func = function(hand)\n        local has_hanafuda = {\n            [\"Chrysanthemum with Sake\"] = false,\n            [\"Cherry Blossom with Curtain\"] = false\n        }\n        return JoyousSpring.hanafuda_get_hand_for_list(hand, has_hanafuda)\n    end"
    },
    {
      "type": "PokerHand",
      "key": "cardian_flowerviewing",
      "atlas": null,
      "pos": null,
      "raw": "key = \"cardian_flowerviewing\",\n    joy_koi_koi = true,\n    chips = 200,\n    mult = 5,\n    l_chips = 15,\n    l_mult = 2,\n    visible = true,\n    is_visible = cardian_is_visible,\n    example = {\n        { 'D_A', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Chrysanthemum with Sake\" },\n        { 'S_2', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Cherry Blossom with Curtain\" },\n        { 'S_7', false },\n        { 'H_9', false },\n        { 'C_A', false },\n    },\n    evaluate = function(parts, hand)\n        return parts.joy_flowerviewing_part\n    end"
    },
    {
      "type": "PokerHandPart",
      "key": "moonviewing_part",
      "atlas": null,
      "pos": null,
      "raw": "key = \"moonviewing_part\",\n    func = function(hand)\n        local has_hanafuda = {\n            [\"Chrysanthemum with Sake\"] = false,\n            [\"Zebra Grass with Moon\"] = false\n        }\n        return JoyousSpring.hanafuda_get_hand_for_list(hand, has_hanafuda)\n    end"
    },
    {
      "type": "PokerHand",
      "key": "cardian_moonviewing",
      "atlas": null,
      "pos": null,
      "raw": "key = \"cardian_moonviewing\",\n    joy_koi_koi = true,\n    chips = 200,\n    mult = 5,\n    l_chips = 15,\n    l_mult = 2,\n    visible = true,\n    is_visible = cardian_is_visible,\n    example = {\n        { 'D_A', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Chrysanthemum with Sake\" },\n        { 'S_2', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Zebra Grass with Moon\" },\n        { 'S_7', false },\n        { 'H_9', false },\n        { 'C_A', false },\n    },\n    evaluate = function(parts, hand)\n        return parts.joy_moonviewing_part\n    end"
    },
    {
      "type": "PokerHand",
      "key": "cardian_moonflowerviewing",
      "atlas": null,
      "pos": null,
      "raw": "key = \"cardian_moonflowerviewing\",\n    joy_koi_koi = true,\n    chips = 500,\n    mult = 10,\n    l_chips = 15,\n    l_mult = 2,\n    visible = true,\n    is_visible = cardian_is_visible,\n    example = {\n        { 'D_A', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Chrysanthemum with Sake\" },\n        { 'S_2', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Cherry Blossom with Curtain\" },\n        { 'S_2', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Zebra Grass with Moon\" },\n        { 'H_9', false },\n        { 'C_A', false },\n    },\n    evaluate = function(parts, hand)\n        if next(parts.joy_moonviewing_part) and next(parts.joy_flowerviewing_part) then\n            return { SMODS.merge_lists(parts.joy_moonviewing_part, parts.joy_flowerviewing_part) }\n        end\n        return {}\n    end"
    },
    {
      "type": "PokerHandPart",
      "key": "lightwave_part",
      "atlas": null,
      "pos": null,
      "raw": "key = \"lightwave_part\",\n    func = function(hand)\n        local has_hanafuda = {\n            [\"Pine with Crane\"] = false,\n            [\"Cherry Blossom with Curtain\"] = false,\n            [\"Zebra Grass with Moon\"] = false,\n            [\"Paulownia with Phoenix\"] = false\n        }\n        return JoyousSpring.hanafuda_get_hand_for_list(hand, has_hanafuda, 3)\n    end"
    },
    {
      "type": "PokerHand",
      "key": "cardian_lightwave",
      "atlas": null,
      "pos": null,
      "raw": "key = \"cardian_lightwave\",\n    joy_koi_koi = true,\n    chips = 200,\n    mult = 5,\n    l_chips = 15,\n    l_mult = 2,\n    visible = true,\n    is_visible = cardian_is_visible,\n    example = {\n        { 'D_A', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Pine with Crane\" },\n        { 'S_2', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Zebra Grass with Moon\" },\n        { 'S_7', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Paulownia with Phoenix\" },\n        { 'H_9', false },\n        { 'C_A', false },\n    },\n    evaluate = function(parts, hand)\n        return parts.joy_lightwave_part\n    end"
    },
    {
      "type": "PokerHand",
      "key": "cardian_lightshower",
      "atlas": null,
      "pos": null,
      "raw": "key = \"cardian_lightshower\",\n    joy_koi_koi = true,\n    chips = 500,\n    mult = 7,\n    l_chips = 15,\n    l_mult = 2,\n    visible = true,\n    is_visible = cardian_is_visible,\n    example = {\n        { 'D_A', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Pine with Crane\" },\n        { 'S_2', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Cherry Blossom with Curtain\" },\n        { 'S_7', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Paulownia with Phoenix\" },\n        { 'H_9', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Willow with Calligrapher\" },\n        { 'C_A', false },\n    },\n    evaluate = function(parts, hand)\n        if not next(parts.joy_lightwave_part) then\n            return {}\n        end\n        local calligrapher = {}\n\n        for _, pcard in ipairs(hand) do\n            local _, name = JoyousSpring.get_hanafuda(pcard)\n            if name == \"Willow with Calligrapher\" then\n                table.insert(calligrapher, pcard)\n            end\n        end\n        return next(calligrapher) and { SMODS.merge_lists(parts.joy_lightwave_part, { calligrapher }) } or {}\n    end"
    },
    {
      "type": "PokerHand",
      "key": "cardian_lightshow",
      "atlas": null,
      "pos": null,
      "raw": "key = \"cardian_lightshow\",\n    joy_koi_koi = true,\n    chips = 500,\n    mult = 8,\n    l_chips = 15,\n    l_mult = 2,\n    visible = true,\n    is_visible = cardian_is_visible,\n    example = {\n        { 'D_A', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Pine with Crane\" },\n        { 'S_2', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Cherry Blossom with Curtain\" },\n        { 'S_7', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Paulownia with Phoenix\" },\n        { 'H_9', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Zebra Grass with Moon\" },\n        { 'C_A', false },\n    },\n    evaluate = function(parts, hand)\n        local has_hanafuda = {\n            [\"Pine with Crane\"] = false,\n            [\"Cherry Blossom with Curtain\"] = false,\n            [\"Zebra Grass with Moon\"] = false,\n            [\"Paulownia with Phoenix\"] = false\n        }\n        return JoyousSpring.hanafuda_get_hand_for_list(hand, has_hanafuda)\n    end"
    },
    {
      "type": "PokerHand",
      "key": "cardian_lightflare",
      "atlas": null,
      "pos": null,
      "raw": "key = \"cardian_lightflare\",\n    joy_koi_koi = true,\n    chips = 1000,\n    mult = 10,\n    l_chips = 15,\n    l_mult = 2,\n    visible = true,\n    is_visible = cardian_is_visible,\n    example = {\n        { 'D_A', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Pine with Crane\" },\n        { 'S_2', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Cherry Blossom with Curtain\" },\n        { 'S_7', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Paulownia with Phoenix\" },\n        { 'H_9', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Zebra Grass with Moon\" },\n        { 'C_A', true, enhancement = 'm_joy_hanafuda', joy_hanafuda = \"Willow with Calligrapher\" },\n    },\n    evaluate = function(parts, hand)\n        local has_hanafuda = {\n            [\"Pine with Crane\"] = false,\n            [\"Cherry Blossom with Curtain\"] = false,\n            [\"Zebra Grass with Moon\"] = false,\n            [\"Willow with Calligrapher\"] = false,\n            [\"Paulownia with Phoenix\"] = false\n        }\n        return JoyousSpring.hanafuda_get_hand_for_list(hand, has_hanafuda)\n    end"
    },
    {
      "type": "Consumable",
      "key": "cardian_koikoi",
      "atlas": "cardian",
      "pos": {
        "x": 2,
        "y": 3
      },
      "raw": "key = \"cardian_koikoi\",\n    set = \"Planet\",\n    atlas = \"cardian\",\n    discovered = true,\n    pos = { x = 2, y = 3 },\n    config = { joy_hand_types = {\n        \"joy_cardian_chaff\",\n        \"joy_cardian_ribbons\",\n        \"joy_cardian_blueribbon\",\n        \"joy_cardian_redpoem\",\n        \"joy_cardian_redpoemblueribbon\",\n        \"joy_cardian_animals\",\n        \"joy_cardian_boardefly\",\n        \"joy_cardian_flowerviewing\",\n        \"joy_cardian_moonviewing\",\n        \"joy_cardian_moonflowerviewing\",\n        \"joy_cardian_lightwave\",\n        \"joy_cardian_lightshower\",\n        \"joy_cardian_lightshow\",\n        \"joy_cardian_lightflare\",\n    } },\n    use = function(self, card, area, copier)\n        update_hand_text({ sound = 'button', volume = 0.7, pitch = 0.8, delay = 0.3 },\n            { handname = localize('k_joy_all_koikoi_hands'), chips = '...', mult = '...', level = '' })\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.2,\n            func = function()\n                play_sound('tarot1')\n                card:juice_up(0.8, 0.5)\n                G.TAROT_INTERRUPT_PULSE = true\n                return true\n            end\n        }))\n        update_hand_text({ delay = 0 }, { mult = '+', StatusText = true })\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.9,\n            func = function()\n                play_sound('tarot1')\n                card:juice_up(0.8, 0.5)\n                return true\n            end\n        }))\n        update_hand_text({ delay = 0 }, { chips = '+', StatusText = true })\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.9,\n            func = function()\n                play_sound('tarot1')\n                card:juice_up(0.8, 0.5)\n                G.TAROT_INTERRUPT_PULSE = nil\n                return true\n            end\n        }))\n        update_hand_text({ sound = 'button', volume = 0.7, pitch = 0.9, delay = 0 }, { level = '+1' })\n        delay(1.3)\n        for _, poker_hand_key in pairs(card.ability.joy_hand_types) do\n            level_up_hand(card, poker_hand_key, true)\n        end\n        update_hand_text({ sound = 'button', volume = 0.7, pitch = 1.1, delay = 0 },\n            { mult = 0, chips = 0, handname = '', level = '' })\n    end,\n    can_use = function(self, card)\n        return true\n    end,"
    },
    {
      "type": "Shader",
      "key": "glow",
      "atlas": null,
      "pos": null,
      "raw": "key = \"glow\",\n    path = \"glow.fs\","
    },
    {
      "type": "DrawStep",
      "key": "glow_on_active",
      "atlas": null,
      "pos": null,
      "raw": "key = 'glow_on_active',\n    order = 21,\n    func = function(self, layer)\n        if not JoyousSpring.config.disable_glow and self.area and (self.area == G.jokers or self.area == JoyousSpring.field_spell_area) and JoyousSpring.can_activate(self, true) then\n            self.children.center:draw_shader(\"joy_glow\", nil,\n                self.ARGS.send_to_shader or { math.min(self.VT.r * 3, 1) + math.sin(G.TIMERS.REAL / 28) + 1 +\n                (self.juice and self.juice.r * 20 or 0) + self.tilt_var.amt, G.TIMERS.REAL })\n        end\n    end,\n    conditions = { vortex = false, facing = 'front' },"
    },
    {
      "type": "Atlas",
      "key": "Tags",
      "atlas": null,
      "pos": null,
      "raw": "key = \"Tags\",\n    path = \"tags.png\",\n    px = 34,\n    py = 34"
    },
    {
      "type": "Tag",
      "key": "booster",
      "atlas": "Tags",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"booster\",\n    atlas = \"Tags\",\n    pos = { x = 0, y = 0 },\n    discovered = true,\n    apply = function(self, tag, context)\n        if context.type == 'voucher_add' then\n            tag:yep('+', G.C.BOOSTER, function()\n                SMODS.add_booster_to_shop()\n                return true\n            end)\n            self.triggered = true\n        end\n    end,\n    in_pool = function(self, args)\n        return not JoyousSpring.config.disable_booster_tag\n    end,"
    },
    {
      "type": "Tag",
      "key": "monster",
      "atlas": "Tags",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"monster\",\n    atlas = \"Tags\",\n    loc_vars = function(self, info_queue, tag)\n        if tag.ability.monster then\n            info_queue[#info_queue + 1] = G.P_CENTERS[tag.ability.monster]\n        end\n        local name = tag.ability.monster and localize({ type = 'name_text', set = 'Joker', key = tag.ability.monster }) or\n            localize(\"k_joy_monster_tag_default\")\n\n        return { vars = { name, colours = { JoyousSpring.get_name_color(tag.ability.monster) } } }\n    end,\n    pos = { x = 1, y = 0 },\n    discovered = true,\n    set_ability = function(self, tag)\n        tag.ability.monster = G.GAME.joy_last_monster_tag\n    end,\n    apply = function(self, tag, context)\n        if context.type == 'store_joker_create' then\n            local joy_forced_card = SMODS.create_card({\n                key = tag.ability.monster or \"j_joy_token\",\n                area = G.shop_jokers\n            })\n            create_shop_card_ui(joy_forced_card, 'Joker', G.shop_jokers)\n            joy_forced_card.states.visible = false\n            tag:yep('+', JoyousSpring.is_monster_card(joy_forced_card) and\n                joy_forced_card.ability.extra.joyous_spring.summon_type and\n                G.C.JOY[joy_forced_card.ability.extra.joyous_spring.summon_type] or G.C.JOY.EFFECT, function()\n                    joy_forced_card:start_materialize()\n                    return true\n                end)\n            tag.triggered = true\n            joy_forced_card:set_cost()\n            return joy_forced_card\n        end\n    end,\n    in_pool = function(self, args)\n        return false\n    end,"
    }
  ],
  "version": "v0.7.3.1"
}