{
  "locMap": {},
  "atlases": {
    "lst": {
      "path": "lightningstrikesthrice.png",
      "px": 32,
      "py": 32,
      "localPath": "/wiki-data/MoreFluff@notmario/1.5.6/lightningstrikesthrice.png",
      "resolvedGitHubPath": "assets/1x/lightningstrikesthrice.png"
    }
  },
  "cards": [
    {
      "type": "Rarity",
      "key": "token",
      "atlas": null,
      "pos": null,
      "raw": "key = \"token\",\n  badge_colour = HEX(\"474747\"),\n  loc_txt = {\n    name = \"Token\"\n  }",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Mods",
      "key": "music_colourpack",
      "atlas": null,
      "pos": null,
      "raw": "key = \"music_colourpack\",\n\tpath = \"music_colourpack.ogg\",\n\tselect_music_track = function()\n\t\treturn (\n      mf_config[\"Music\"] and \n      (\n        G.pack_cards\n        and G.pack_cards.cards\n        and G.pack_cards.cards[1]\n        and G.pack_cards.cards[1].ability.set == \"Colour\"\n      )\n    )\n\tend,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "music_rotarot",
      "atlas": null,
      "pos": null,
      "raw": "key = \"music_rotarot\",\n\tpath = \"music_rotarot.ogg\",\n\tselect_music_track = function()\n\t\treturn (\n      mf_config[\"Music\"] and \n      (\n        G.pack_cards\n        and G.pack_cards.cards\n        and G.pack_cards.cards[1]\n        and G.pack_cards.cards[1].ability.set == \"Rotarot\"\n      )\n    )\n\tend,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "music_modded",
      "atlas": null,
      "pos": null,
      "raw": "key = \"music_modded\",\n  path = \"music_modded.ogg\",\n  select_music_track = function()\n    return (\n      mf_config[\"Music\"] and\n      (\n        (SMODS.OPENED_BOOSTER or {}).ability or {}).modded_pack \n        and G.booster_pack and not G.booster_pack.REMOVED\n      )\n      and 2\n  end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "music_duelzone",
      "atlas": null,
      "pos": null,
      "raw": "key = \"music_duelzone\",\n  path = \"music_duelzone.ogg\",\n  sync = false,\n  pitch = 1,\n  select_music_track = function()\n    return\n      mf_config[\"Music\"] and G.GAME.superboss_active\n      and 6 -- notably lower than jimball (Funny)\n  end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "gun",
      "atlas": null,
      "pos": null,
      "raw": "key = \"gun\", path = \"gun.ogg\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "treethree",
      "atlas": null,
      "pos": null,
      "raw": "key = \"treethree\", path = \"treethree.ogg\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "buzzer",
      "atlas": null,
      "pos": null,
      "raw": "key = \"buzzer\", path = \"buzzer.ogg\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "lightningstrikesthrice",
      "atlas": null,
      "pos": null,
      "raw": "key = \"lightningstrikesthrice\", path = \"lightningstrikesthrice.ogg\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "horsebounce",
      "atlas": null,
      "pos": null,
      "raw": "key = \"horsebounce\", path = \"horsebounce.ogg\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "mf_jokers",
      "atlas": null,
      "pos": null,
      "raw": "key = \"mf_jokers\", \n  atlas_table = \"ASSET_ATLAS\", \n  path = \"mf_jokers\" .. artpack_suffix, \n  px = 71, \n  py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "mf_mv",
      "atlas": null,
      "pos": null,
      "raw": "key = \"mf_mv\", \n  atlas_table = \"ASSET_ATLAS\", \n  path = \"mf_mv.png\", \n  px = 71, \n  py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Shader",
      "key": "dissolvegreen",
      "atlas": null,
      "pos": null,
      "raw": "key=\"dissolvegreen\",\n  path=\"dissolvegreen.fs\"",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "mf_hyperjimbo",
      "atlas": null,
      "pos": null,
      "raw": "key = \"mf_hyperjimbo\", \n  atlas_table = \"ASSET_ATLAS\", \n  path = \"mf_hyperjimbo.png\", \n  px = 95, \n  py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "mf_srekoj",
      "atlas": null,
      "pos": null,
      "raw": "key = \"mf_srekoj\", \n  atlas_table = \"ASSET_ATLAS\", \n  path = \"mf_srekoj.png\", \n  px = 71, \n  py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "mf_rot_cartomancer",
      "atlas": null,
      "pos": null,
      "raw": "key = \"mf_rot_cartomancer\", \n  atlas_table = \"ASSET_ATLAS\", \n  path = \"mf_rot_cartomancer.png\", \n  px = 112, \n  py = 112",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "mf_colours",
      "atlas": null,
      "pos": null,
      "raw": "key = \"mf_colours\", \n  atlas_table = \"ASSET_ATLAS\", \n  path = \"mf_colours\" .. artpack_suffix, \n  px = 71, \n  py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "mf_shapes",
      "atlas": null,
      "pos": null,
      "raw": "key = \"mf_shapes\", \n    atlas_table = \"ASSET_ATLAS\", \n    path = \"mf_shapes.png\", \n    px = 71, \n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "mf_ascendant_tags",
      "atlas": null,
      "pos": null,
      "raw": "key = \"mf_ascendant_tags\", \n    atlas_table = \"ASSET_ATLAS\", \n    path = \"mf_ascendant_tags.png\", \n    px = 34, \n    py = 34",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "mf_finity_crossmod",
      "atlas": null,
      "pos": null,
      "raw": "key = \"mf_finity_crossmod\", \n    atlas_table = \"ASSET_ATLAS\", \n    path = \"mf_finity_crossmod.png\", \n    px = 71, \n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "mf_stickers",
      "atlas": null,
      "pos": null,
      "raw": "key = \"mf_stickers\", \n  atlas_table = \"ASSET_ATLAS\", \n  path = \"mf_stickers.png\", \n  px = 71, \n  py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "mf_rotarots",
      "atlas": null,
      "pos": null,
      "raw": "key = \"mf_rotarots\", \n  atlas_table = \"ASSET_ATLAS\", \n  path = \"mf_rotarots.png\", \n  px = 107, \n  py = 107",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "mf_rotarotpacks",
      "atlas": null,
      "pos": null,
      "raw": "key = \"mf_rotarotpacks\", \n  atlas_table = \"ASSET_ATLAS\", \n  path = \"mf_rotarotpacks.png\", \n  px = 106, \n  py = 106",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "mf_oddities",
      "atlas": null,
      "pos": null,
      "raw": "key = \"mf_oddities\", \n  atlas_table = \"ASSET_ATLAS\", \n  path = \"mf_oddities.png\", \n  px = 71, \n  py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "mf_packs",
      "atlas": null,
      "pos": null,
      "raw": "key = \"mf_packs\", \n  atlas_table = \"ASSET_ATLAS\", \n  path = \"mf_packs.png\", \n  px = 71, \n  py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "mf_vouchers",
      "atlas": null,
      "pos": null,
      "raw": "key = \"mf_vouchers\", \n  atlas_table = \"ASSET_ATLAS\", \n  path = \"mf_vouchers.png\", \n  px = 71, \n  py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "mf_enhancers",
      "atlas": null,
      "pos": null,
      "raw": "key = \"mf_enhancers\", \n  atlas_table = \"ASSET_ATLAS\", \n  path = \"mf_enhancers.png\", \n  px = 71, \n  py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "modicon",
      "atlas": null,
      "pos": null,
      "raw": "key = \"modicon\",\n  path = \"mf_icon.png\",\n  px = 32,\n  py = 32",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "mf_sleeves",
      "atlas": null,
      "pos": null,
      "raw": "key = \"mf_sleeves\", \n    atlas_table = \"ASSET_ATLAS\", \n    path = \"mf_sleeves.png\", \n    px = 73, \n    py = 95",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "tags",
      "atlas": null,
      "pos": null,
      "raw": "key = \"tags\",\n  path = \"mf_tags.png\",\n  px = 34,\n  py = 34",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "mf_blinds",
      "atlas": null,
      "pos": null,
      "raw": "key = \"mf_blinds\",\n\tatlas_table = \"ANIMATION_ATLAS\",\n\tpath = \"mf_blinds.png\",\n\tpx = 34,\n\tpy = 34,\n\tframes = 21,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "mf_watermark",
      "atlas": null,
      "pos": null,
      "raw": "key = \"mf_watermark\", \n  atlas_table = \"ASSET_ATLAS\", \n  path = \"watermark.png\", \n  px = 336, \n  py = 32",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "mf_ee_nuhuh",
      "atlas": null,
      "pos": null,
      "raw": "key = \"mf_ee_nuhuh\", \n  atlas_table = \"ASSET_ATLAS\", \n  path = \"mf_ee_nuhuh.png\", \n  px = 1920, \n  py = 1080",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Tag",
      "key": "clutch",
      "atlas": "mf_tags",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"clutch\",\n    atlas = \"mf_tags\",\n    config = {\n      extra = 4\n    },\n    pos = { x = 1, y = 1 },\n    unlocked = true,\n    discovered = true,\n    loc_vars = function(self, info_queue)\n      return { vars = { self.config.extra } }\n    end,\n    apply = function(self, tag, context)\n      if context.type == \"final_scoring_step\" then\n        SMODS.calculate_effect({xmult=4}, tag)\n      end\n      if context.type == \"eval\" then\n        tag:yep(\"X\", G.C.RED, function()\n          return true\n        end)\n        tag.triggered = true\n      end\n    end,",
      "config": {
        "extra": 4
      },
      "ability": {
        "extra": 4
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Tag",
      "key": "eclutch",
      "atlas": "mf_ascendant_tags",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"eclutch\",\n      atlas = \"mf_ascendant_tags\",\n      config = {\n        extra = 4\n      },\n      pos = { x = 1, y = 1 },\n      unlocked = true,\n      discovered = true,\n\t    in_pool = function() return false end or nil,\n      loc_vars = function(self, info_queue)\n        return { vars = { self.config.extra } }\n      end,\n      apply = function(self, tag, context)\n        if context.type == \"final_scoring_step\" then\n          SMODS.calculate_effect({emult=4}, tag)\n        end\n        if context.type == \"eval\" then\n          tag:yep(\"X\", G.C.RED, function()\n            return true\n          end)\n          tag.triggered = true\n        end\n      end,",
      "config": {
        "extra": 4
      },
      "ability": {
        "extra": 4
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "grosmichel",
      "atlas": "mf_enhancers",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "name = \"Gros Michel Deck\",\n\tkey = \"grosmichel\",\n\tconfig = { mf_grosmichel = true },\n\tpos = { x = 0, y = 0 },\n\tatlas = \"mf_enhancers\",\n  unlocked = true,",
      "config": {
        "mf_grosmichel": true
      },
      "ability": {
        "mf_grosmichel": true
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "philosophical",
      "atlas": "mf_enhancers",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "name = \"Philosophical Deck\",\n    key = \"philosophical\",\n    config = { mf_philosophical = true },\n    pos = { x = 1, y = 0 },\n    atlas = \"mf_enhancers\",\n    unlocked = true,",
      "config": {
        "mf_philosophical": true
      },
      "ability": {
        "mf_philosophical": true
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "rainbow",
      "atlas": "mf_enhancers",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "name = \"Rainbow Deck\",\n    key = \"rainbow\",\n    config = { voucher = 'v_mf_paintroller', consumables = {'c_mf_white'} },\n    pos = { x = 2, y = 0 },\n    atlas = \"mf_enhancers\",\n    unlocked = true,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Back",
      "key": "blasphemy",
      "atlas": "mf_enhancers",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "name = \"Blasphemous Deck\",\n    key = \"blasphemy\",\n    config = { mf_blasphemy = true },\n    pos = { x = 3, y = 0 },\n    atlas = \"mf_enhancers\",\n    unlocked = true,",
      "config": {
        "mf_blasphemy": true
      },
      "ability": {
        "mf_blasphemy": true
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "mf_achievements",
      "atlas": null,
      "pos": null,
      "raw": "key = \"mf_achievements\",\n    path = \"mf_achievements.png\",\n    px = 66,\n    py = 66,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Achievement",
      "key": "mf_ten_colour_rounds",
      "atlas": "mf_achievements",
      "pos": null,
      "raw": "key = \"mf_ten_colour_rounds\",\n    order = 1,\n    bypass_all_unlocked = true,\n    atlas = \"mf_achievements\",\n    --reset_on_startup = true,\n    unlock_condition = function(self, args)\n      if\n        args.type == \"mf_ten_colour_rounds\"\n      then\n        return true\n      end\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Achievement",
      "key": "mf_whos_paul",
      "atlas": "mf_achievements",
      "pos": null,
      "raw": "key = \"mf_whos_paul\",\n    order = 2,\n    bypass_all_unlocked = true,\n    atlas = \"mf_achievements\",\n    --reset_on_startup = true,\n    unlock_condition = function(self, args)\n      if\n        args.type == \"mf_trigger_paul\"\n      then\n        return true\n      end\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Achievement",
      "key": "mf_jank_it_up",
      "atlas": "mf_achievements",
      "pos": null,
      "raw": "key = \"mf_jank_it_up\",\n    order = 3,\n    bypass_all_unlocked = true,\n    atlas = \"mf_achievements\",\n    --reset_on_startup = true,\n    unlock_condition = function(self, args)\n      if args.type == \"modify_jokers\" then\n        local jankman_count = 0\n  \n        if G.jokers then\n          for i = 1, #G.jokers.cards do\n            if G.jokers.cards[i].config.center.key == \"j_mf_jankman\" then\n              jankman_count = jankman_count + 1\n            end\n          end\n        end\n  \n        if jankman_count >= 3 then\n          return true\n        end\n      end\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Achievement",
      "key": "mf_dropkick_ten_hands",
      "atlas": "mf_achievements",
      "pos": null,
      "raw": "key = \"mf_dropkick_ten_hands\",\n    order = 4,\n    bypass_all_unlocked = true,\n    atlas = \"mf_achievements\",\n    --reset_on_startup = true,\n    unlock_condition = function(self, args)\n      if\n        args.type == \"mf_dropkick_ten_hands\"\n      then\n        return true\n      end\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Achievement",
      "key": "mf_negative_philosophical",
      "atlas": "mf_achievements",
      "pos": null,
      "raw": "key = \"mf_negative_philosophical\",\n    order = 5,\n    bypass_all_unlocked = true,\n    atlas = \"mf_achievements\",\n    --reset_on_startup = true,\n    unlock_condition = function(self, args)\n      if args.type == \"modify_jokers\" then\n        if G.jokers then\n          for i = 1, #G.jokers.cards do\n            if G.jokers.cards[i].config.center.key == \"j_mf_philosophical\" and \n              (G.jokers.cards[i].edition and G.jokers.cards[i].edition.negative) then\n              return true\n            end\n          end\n        end\n  \n        return false\n      end\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Achievement",
      "key": "mf_huge_and_pixel",
      "atlas": "mf_achievements",
      "pos": null,
      "raw": "key = \"mf_huge_and_pixel\",\n    order = 6,\n    bypass_all_unlocked = true,\n    atlas = \"mf_achievements\",\n    --reset_on_startup = true,\n    unlock_condition = function(self, args)\n      if args.type == \"modify_jokers\" then\n        local has_huge = false\n        local has_pixel = false\n        if G.jokers then\n          for i = 1, #G.jokers.cards do\n            if G.jokers.cards[i].config.center.key == \"j_mf_hugejoker\" then\n              has_huge = true\n            end\n            if G.jokers.cards[i].config.center.key == \"j_mf_pixeljoker\" then\n              has_pixel = true\n            end\n          end\n        end\n  \n        return has_huge and has_pixel\n      end\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "DrawStep",
      "key": "spire_mv",
      "atlas": null,
      "pos": null,
      "raw": "key = \"spire_mv\",\n\torder = 25,\n\tfunc = function(self)\n    if not G.mf_mv_spr then return nil end\n    if mf_config[\"Programmer Art\"] then return nil end\n    local my_key = self.config.center.key\n\n    if \n      my_key ~= \"j_mf_dramaticentrance\" and\n      my_key ~= \"j_mf_dropkick\" and\n      my_key ~= \"j_mf_bladedance\" and\n      my_key ~= \"j_mf_hyperbeam\" and\n      my_key ~= \"j_mf_blasphemy\"\n    then\n      return nil\n    end\n\n    G.mf_mv_spr.role.draw_major = self\n\n    local cost = math.floor(\n      self.cost +\n      (self.ability.extra_value or 0) * 2 +\n      0.5\n    )\n\n    local base_cost = ({\n      j_mf_dramaticentrance = 6,\n      j_mf_dropkick = 8,\n      j_mf_bladedance = 8,\n      j_mf_hyperbeam = 8,\n      j_mf_blasphemy = 5,\n    })[my_key]\n\n    local shader = \"dissolve\"\n    if cost ~= base_cost then shader = \"mf_dissolvegreen\" end\n\n    if cost > 99 then\n      G.mf_mv_spr:set_sprite_pos({x=0, y=3})\n      G.mf_mv_spr:draw_shader(shader, nil, nil, nil, self.children.center)\n    elseif cost <= 9 then\n      G.mf_mv_spr:set_sprite_pos({x=cost, y=0})\n      G.mf_mv_spr:draw_shader(shader, nil, nil, nil, self.children.center)\n    else\n      G.mf_mv_spr:set_sprite_pos({x=math.floor(cost/10), y=1})\n      G.mf_mv_spr:draw_shader(shader, nil, nil, nil, self.children.center)\n      G.mf_mv_spr:set_sprite_pos({x=cost%10, y=2})\n      G.mf_mv_spr:draw_shader(shader, nil, nil, nil, self.children.center)\n    end\n\tend,\n\tconditions = { vortex = false, facing = \"front\" },",
      "config": {
        "j_mf_dramaticentrance": 6,
        "j_mf_dropkick": 8,
        "j_mf_bladedance": 8,
        "j_mf_hyperbeam": 8,
        "j_mf_blasphemy": 5
      },
      "ability": {
        "j_mf_dramaticentrance": 6,
        "j_mf_dropkick": 8,
        "j_mf_bladedance": 8,
        "j_mf_hyperbeam": 8,
        "j_mf_blasphemy": 5
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "soul2",
      "atlas": "mf_soul2",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"soul2\",\n  set = \"Spectral\",\n\n  atlas = \"mf_soul2\",\n  pos = { x = 0, y = 0 },\n  soul_pos = { x = 1, y = 0 },\n\n  unlocked = true,\n  discovered = true,\n  no_collection = true,\n\n  hidden = {\n    soul_rate = 0.000000003,\n    can_repeat_soul = true,\n  },\n  \n  can_use = function(self, card)\n    return #G.jokers.cards < G.jokers.config.card_limit or self.area == G.jokers\n  end,\n  use = function(self, card, area, copier)\n    local used_tarot = copier or card\n    G.E_MANAGER:add_event(Event({\n      func = function() \n        local n_card = create_card('Joker', G.jokers, nil, nil, nil, nil, \"j_mf_johnbalatro\", 'exp')\n        n_card:add_to_deck()\n        G.jokers:emplace(n_card)\n        n_card:start_materialize()\n        used_tarot:juice_up(0.3, 0.5)\n        return true\n      end}))   \n  end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Rarity",
      "key": "superlegendary",
      "atlas": null,
      "pos": null,
      "raw": "key = \"superlegendary\",\n  loc_txt = {\n    name = \"Superlegendary\"\n  },\n  badge_colour = HEX(\"2852FF\")",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "lst",
      "atlas": null,
      "pos": null,
      "raw": "key = \"lst\",\n\tpath = \"lightningstrikesthrice.png\",\n\tpx = 32, py = 32",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "ConsumableType",
      "key": "Colour",
      "atlas": null,
      "pos": null,
      "raw": "key = \"Colour\",\n    primary_colour = HEX(\"4f6367\"),\n    secondary_colour = HEX(\"4f6367\"),\n    collection_rows = { 4, 4 },\n    shop_rate = 1.0, -- originally it was zero because implementing shop items used to be jank but now it isnt so it isnt\n    loc_txt = {},\n    default = \"c_mf_deepblue\",\n    can_stack = false,\n    can_divide = false,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "UndiscoveredSprite",
      "key": "Colour",
      "atlas": "mf_colours",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"Colour\",\n    atlas = \"mf_colours\",\n    path = \"mf_colours_refresh.png\", -- uh. \n    pos = { x = 0, y = 0 },\n    px = 71,\n    py = 95,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "colour_normal_1",
      "atlas": "mf_packs",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"colour_normal_1\",\n    kind = \"Colour\",\n    atlas = \"mf_packs\",\n    pos = { x = 0, y = 0 },\n    config = { extra = 2, choose = 1 },\n    cost = 4,\n    weight = 0.96,\n    unlocked = true,\n    discovered = true,\n    create_card = function(self, card)\n      local n_card = create_card(\"Colour\", G.pack_cards, nil, nil, true, true, nil, \"mf_colour\")\n      local ed_roll = pseudorandom('colour_editionroll')\n      if ed_roll < 0.4 and G.GAME.used_vouchers.v_mf_colourtheory then\n        n_card:set_edition({polychrome = true}, true)\n      elseif ed_roll >= 0.4 and ed_roll < 0.766666 and G.GAME.used_vouchers.v_mf_artprogram then\n        n_card:set_edition({negative = true}, true)\n      end\n      return n_card\n    end,\n    ease_background_colour = function(self)\n      ease_colour(G.C.DYN_UI.MAIN, G.C.SECONDARY_SET.Colour)\n      ease_background_colour({ new_colour = G.C.SECONDARY_SET.Colour, special_colour = G.C.BLACK, contrast = 2 })\n    end,\n    loc_vars = function(self, info_queue, card)\n      return { vars = { card.config and card.config.center.config.choose or 1, card.ability and card.ability.extra or 2} }\n    end,\n    group_key = \"k_colour_pack\",",
      "config": {
        "extra": 2,
        "choose": 1
      },
      "ability": {
        "extra": 2,
        "choose": 1
      },
      "vars": [
        1,
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "colour_normal_2",
      "atlas": "mf_packs",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"colour_normal_2\",\n    kind = \"Colour\",\n    atlas = \"mf_packs\",\n    pos = { x = 1, y = 0 },\n    config = { extra = 2, choose = 1 },\n    cost = 4,\n    weight = 0.96,\n    unlocked = true,\n    discovered = true,\n    create_card = function(self, card)\n      local n_card = create_card(\"Colour\", G.pack_cards, nil, nil, true, true, nil, \"mf_colour\")\n      local ed_roll = pseudorandom('colour_editionroll')\n      if ed_roll < 0.4 and G.GAME.used_vouchers.v_mf_colourtheory then\n        n_card:set_edition({polychrome = true}, true)\n      elseif ed_roll >= 0.4 and ed_roll < 0.766666 and G.GAME.used_vouchers.v_mf_artprogram then\n        n_card:set_edition({negative = true}, true)\n      end\n      return n_card\n    end,\n    ease_background_colour = function(self)\n      ease_colour(G.C.DYN_UI.MAIN, G.C.SECONDARY_SET.Colour)\n      ease_background_colour({ new_colour = G.C.SECONDARY_SET.Colour, special_colour = G.C.BLACK, contrast = 2 })\n    end,\n    loc_vars = function(self, info_queue, card)\n      return { vars = { card.config.center.config.choose, card.ability.extra } }\n    end,\n    group_key = \"k_colour_pack\",",
      "config": {
        "extra": 2,
        "choose": 1
      },
      "ability": {
        "extra": 2,
        "choose": 1
      },
      "vars": [
        null,
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "colour_jumbo_1",
      "atlas": "mf_packs",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"colour_jumbo_1\",\n    kind = \"Colour\",\n    atlas = \"mf_packs\",\n    pos = { x = 2, y = 0 },\n    config = { extra = 4, choose = 1 },\n    cost = 6,\n    weight = 0.48,\n    unlocked = true,\n    discovered = true,\n    create_card = function(self, card)\n      local n_card = create_card(\"Colour\", G.pack_cards, nil, nil, true, true, nil, \"mf_colour\")\n      local ed_roll = pseudorandom('colour_editionroll')\n      if ed_roll < 0.4 and G.GAME.used_vouchers.v_mf_colourtheory then\n        n_card:set_edition({polychrome = true}, true)\n      elseif ed_roll >= 0.4 and ed_roll < 0.766666 and G.GAME.used_vouchers.v_mf_artprogram then\n        n_card:set_edition({negative = true}, true)\n      end\n      return n_card\n    end,\n    ease_background_colour = function(self)\n      ease_colour(G.C.DYN_UI.MAIN, G.C.SECONDARY_SET.Colour)\n      ease_background_colour({ new_colour = G.C.SECONDARY_SET.Colour, special_colour = G.C.BLACK, contrast = 2 })\n    end,\n    loc_vars = function(self, info_queue, card)\n      return { vars = { card.config.center.config.choose, card.ability.extra } }\n    end,\n    group_key = \"k_colour_pack\",",
      "config": {
        "extra": 4,
        "choose": 1
      },
      "ability": {
        "extra": 4,
        "choose": 1
      },
      "vars": [
        null,
        4
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "colour_mega_1",
      "atlas": "mf_packs",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"colour_mega_1\",\n    kind = \"Colour\",\n    atlas = \"mf_packs\",\n    pos = { x = 3, y = 0 },\n    config = { extra = 4, choose = 2 },\n    cost = 8,\n    weight = 0.12,\n    unlocked = true,\n    discovered = true,\n    create_card = function(self, card)\n      local n_card = create_card(\"Colour\", G.pack_cards, nil, nil, true, true, nil, \"mf_colour\")\n      local ed_roll = pseudorandom('colour_editionroll')\n      if ed_roll < 0.4 and G.GAME.used_vouchers.v_mf_colourtheory then\n        n_card:set_edition({polychrome = true}, true)\n      elseif ed_roll >= 0.4 and ed_roll < 0.766666 and G.GAME.used_vouchers.v_mf_artprogram then\n        n_card:set_edition({negative = true}, true)\n      end\n      return n_card\n    end,\n    ease_background_colour = function(self)\n      ease_colour(G.C.DYN_UI.MAIN, G.C.SECONDARY_SET.Colour)\n      ease_background_colour({ new_colour = G.C.SECONDARY_SET.Colour, special_colour = G.C.BLACK, contrast = 2 })\n    end,\n    loc_vars = function(self, info_queue, card)\n      return { vars = { card.config.center.config.choose, card.ability.extra } }\n    end,\n    group_key = \"k_colour_pack\",",
      "config": {
        "extra": 4,
        "choose": 2
      },
      "ability": {
        "extra": 4,
        "choose": 2
      },
      "vars": [
        null,
        4
      ],
      "infoQueue": []
    },
    {
      "type": "Tag",
      "key": "colour",
      "atlas": "mf_tags",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"colour\",\n    atlas = \"mf_tags\",\n    pos = { x = 0, y = 0 },\n    unlocked = true,\n    discovered = true,\n    loc_vars = function(self, info_queue)\n      info_queue[#info_queue + 1] = { set = \"Other\", key = \"p_mf_colour_jumbo_1\", specific_vars = { 1, 4 } }\n      return { vars = {} }\n    end,\n    apply = function(self, tag, context)\n      if context.type == \"new_blind_choice\" then\n        tag:yep(\"+\", G.C.SECONDARY_SET.Code, function()\n          local key = \"p_mf_colour_jumbo_1\"\n          local card = Card(\n            G.play.T.x + G.play.T.w / 2 - G.CARD_W * 1.27 / 2,\n            G.play.T.y + G.play.T.h / 2 - G.CARD_H * 1.27 / 2,\n            G.CARD_W * 1.27,\n            G.CARD_H * 1.27,\n            G.P_CARDS.empty,\n            G.P_CENTERS[key],\n            { bypass_discovery_center = true, bypass_discovery_ui = true }\n          )\n          card.cost = 0\n          card.from_tag = true\n          G.FUNCS.use_card({ config = { ref_table = card } })\n          -- uh. should this be here??\n          if G.GAME.modifiers.cry_force_edition and not G.GAME.modifiers.cry_force_random_edition then\n            card:set_edition(nil, true, true)\n          elseif G.GAME.modifiers.cry_force_random_edition then\n            local edition = Cryptid.poll_random_edition()\n            card:set_edition(edition, true, true)\n          end\n          card:start_materialize()\n          return true\n        end)\n        tag.triggered = true\n        return true\n      end\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "black",
      "atlas": "mf_colours",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Colour\",\n    name = \"col_Black\",\n    key = \"black\",\n    pos = { x = 0, y = 1 },\n    config = {\n      val = 0,\n      partial_rounds = 0,\n      upgrade_rounds = 4,\n    },\n    cost = 4,\n    atlas = \"mf_colours\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 71, h = 87 },\n    pixel_size = { w = 71, h = 87 },\n    can_use = function(self, card)\n      for k, v in pairs(G.jokers.cards) do\n        if v.ability.set == 'Joker' and ((not v.edition) or (v.edition and not v.edition.egative)) then\n          return true\n        end\n      end\n      return false\n    end,\n    use = function(self, card, area, copier)\n      for i = 1, card.ability.val do\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n          local temp_pool = {}\n          local backup_pool = {}\n          for k, v in pairs(G.jokers.cards) do\n            if v.ability.set == 'Joker' and (not v.edition) then\n              table.insert(temp_pool, v)\n            end\n            if v.ability.set == 'Joker' and (v.edition and not v.edition.negative) then\n              table.insert(backup_pool, v)\n            end\n          end\n          if #temp_pool > 0 then\n            local over = false\n            local eligible_card = pseudorandom_element(temp_pool, pseudoseed(\"black\"))\n            local edition = {negative = true}\n            eligible_card:set_edition(edition, true)\n            check_for_unlock({type = 'have_edition'})\n            card:juice_up(0.3, 0.5)\n          elseif #backup_pool > 0 then\n            local over = false\n            local eligible_card = pseudorandom_element(backup_pool, pseudoseed(\"black\"))\n            local edition = {negative = true}\n            eligible_card:set_edition(edition, true)\n            check_for_unlock({type = 'have_edition'})\n            card:juice_up(0.3, 0.5)\n          end\n        return true end }))\n      end\n      delay(0.6)\n    end,\n    loc_vars = function(self, info_queue, card)\n      local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n      return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds} }\n    end",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 4
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 4
      },
      "vars": [
        0,
        null,
        null,
        4
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "deepblue",
      "atlas": "mf_colours",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Colour\",\n    name = \"col_Deep Blue\",\n    key = \"deepblue\",\n    pos = { x = 1, y = 1 },\n    config = {\n      val = 0,\n      partial_rounds = 0,\n      upgrade_rounds = 1,\n    },\n    cost = 4,\n    atlas = \"mf_colours\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 71, h = 87 },\n    pixel_size = { w = 71, h = 87 },\n    can_use = function(self, card)\n      return #G.hand.cards > 1\n    end,\n    use = function(self, card, area, copier)\n      local suit = \"Spades\"\n      local rng_seed = \"deepblue\"\n      local blacklist = {}\n      for i = 1, card.ability.val do\n        local temp_pool = {}\n        for k, v in pairs(G.hand.cards) do\n          if not v:is_suit(suit) and not blacklist[v] then\n            table.insert(temp_pool, v)\n          end\n        end\n        local over = false\n        if #temp_pool == 0 then\n          break\n        end\n        local eligible_card = pseudorandom_element(temp_pool, pseudoseed(rng_seed))\n        blacklist[eligible_card] = true\n        G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.15,func = function() eligible_card:flip();play_sound('card1', 1);eligible_card:juice_up(0.3, 0.3);return true end }))\n        G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.4,func = function() eligible_card:flip();play_sound('tarot2', percent);eligible_card:change_suit(suit);return true end }))\n        card:juice_up(0.3, 0.5)\n      end\n      delay(0.6)\n    end,\n    loc_vars = function(self, info_queue, card)\n      local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n      return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds} }\n    end",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 1
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 1
      },
      "vars": [
        0,
        null,
        null,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "crimson",
      "atlas": "mf_colours",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Colour\",\n    name = \"col_Crimson\",\n    key = \"crimson\",\n    pos = { x = 2, y = 1 },\n    config = {\n      val = 0,\n      partial_rounds = 0,\n      upgrade_rounds = 3,\n    },\n    cost = 4,\n    atlas = \"mf_colours\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 71, h = 87 },\n    pixel_size = { w = 71, h = 87 },\n    can_use = function(self, card)\n      return true\n    end,\n    use = function(self, card, area, copier)\n      local tag_type = \"tag_rare\"\n      for i = 1, card.ability.val do\n        G.E_MANAGER:add_event(Event({\n          func = (function()\n            add_tag(Tag(tag_type))\n            play_sound('generic1', 0.9 + math.random()*0.1, 0.8)\n            play_sound('holo1', 1.2 + math.random()*0.1, 0.4)\n            return true\n          end)\n        }))\n        delay(0.2)\n      end\n      delay(0.6)\n    end,\n    loc_vars = function(self, info_queue, card)\n      local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n      return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds} }\n    end",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 3
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 3
      },
      "vars": [
        0,
        null,
        null,
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "seaweed",
      "atlas": "mf_colours",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Colour\",\n    name = \"col_Seaweed\",\n    key = \"seaweed\",\n    pos = { x = 3, y = 1 },\n    config = {\n      val = 0,\n      partial_rounds = 0,\n      upgrade_rounds = 1,\n    },\n    cost = 4,\n    atlas = \"mf_colours\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 71, h = 87 },\n    pixel_size = { w = 71, h = 87 },\n    can_use = function(self, card)\n      return #G.hand.cards > 1\n    end,\n    use = function(self, card, area, copier)\n      local suit = \"Clubs\"\n      local rng_seed = \"seaweed\"\n      local blacklist = {}\n      for i = 1, card.ability.val do\n        local temp_pool = {}\n        for k, v in pairs(G.hand.cards) do\n          if not v:is_suit(suit) and not blacklist[v] then\n            table.insert(temp_pool, v)\n          end\n        end\n        local over = false\n        if #temp_pool == 0 then\n          break\n        end\n        local eligible_card = pseudorandom_element(temp_pool, pseudoseed(rng_seed))\n        blacklist[eligible_card] = true\n        G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.15,func = function() eligible_card:flip();play_sound('card1', 1);eligible_card:juice_up(0.3, 0.3);return true end }))\n        G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.4,func = function() eligible_card:flip();play_sound('tarot2', percent);eligible_card:change_suit(suit);return true end }))\n        card:juice_up(0.3, 0.5)\n      end\n      delay(0.6)\n    end,\n    loc_vars = function(self, info_queue, card)\n      local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n      return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds} }\n    end",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 1
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 1
      },
      "vars": [
        0,
        null,
        null,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "brown",
      "atlas": "mf_colours",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Colour\",\n    name = \"col_Brown\",\n    key = \"brown\",\n    pos = { x = 0, y = 2 },\n    config = {\n      val = 0,\n      partial_rounds = 0,\n      upgrade_rounds = 1,\n      cash_per = 2\n    },\n    cost = 4,\n    atlas = \"mf_colours\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 71, h = 87 },\n    pixel_size = { w = 71, h = 87 },\n    can_use = function(self, card)\n      return #G.hand.cards > 1\n    end,\n    use = function(self, card, area, copier)\n      local temp_hand = {}\n      local destroyed_cards = {}\n      for k, v in ipairs(G.hand.cards) do temp_hand[#temp_hand+1] = v end\n      table.sort(temp_hand, function (a, b) return not a.playing_card or not b.playing_card or a.playing_card < b.playing_card end)\n      pseudoshuffle(temp_hand, pseudoseed('brown'))\n\n      for i = 1, math.min(#temp_hand, card.ability.val) do destroyed_cards[#destroyed_cards+1] = temp_hand[i] end\n\n      G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n        play_sound('tarot1')\n        card:juice_up(0.3, 0.5)\n        return true end }))\n      G.E_MANAGER:add_event(Event({\n        trigger = 'after',\n        delay = 0.1,\n        func = function() \n          for i=#destroyed_cards, 1, -1 do\n            local card = destroyed_cards[i]\n            if card.ability.name == 'Glass Card' then \n              card:shatter()\n            else\n              card:start_dissolve(nil, i == #destroyed_cards)\n            end\n            card:remove_from_deck()\n          end\n          return true end }))\n      delay(0.5)\n      ease_dollars(card.ability.cash_per * card.ability.val)\n      delay(0.3)\n      for i = 1, #G.jokers.cards do\n        G.jokers.cards[i]:calculate_joker({remove_playing_cards = true, removed = destroyed_cards})\n      end\n      delay(0.6)\n    end,\n    loc_vars = function(self, info_queue, card)\n      local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n      return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds, card.ability.cash_per} }\n    end",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 1,
        "cash_per": 2
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 1,
        "cash_per": 2
      },
      "vars": [
        0,
        null,
        null,
        1,
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "grey",
      "atlas": "mf_colours",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Colour\",\n    name = \"col_Grey\",\n    key = \"grey\",\n    pos = { x = 1, y = 2 },\n    config = {\n      val = 0,\n      partial_rounds = 0,\n      upgrade_rounds = 3,\n    },\n    cost = 4,\n    atlas = \"mf_colours\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 71, h = 87 },\n    pixel_size = { w = 71, h = 87 },\n    can_use = function(self, card)\n      return true\n    end,\n    use = function(self, card, area, copier)\n      local tag_type = \"tag_double\"\n      for i = 1, card.ability.val do\n        G.E_MANAGER:add_event(Event({\n          func = (function()\n            add_tag(Tag(tag_type))\n            play_sound('generic1', 0.9 + math.random()*0.1, 0.8)\n            play_sound('holo1', 1.2 + math.random()*0.1, 0.4)\n            return true\n          end)\n        }))\n        delay(0.2)\n      end\n      delay(0.6)\n    end,\n    loc_vars = function(self, info_queue, card)\n      local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n      return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds} }\n    end",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 3
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 3
      },
      "vars": [
        0,
        null,
        null,
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "silver",
      "atlas": "mf_colours",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Colour\",\n    name = \"col_Silver\",\n    key = \"silver\",\n    pos = { x = 2, y = 2 },\n    config = {\n      val = 0,\n      partial_rounds = 0,\n      upgrade_rounds = 3,\n    },\n    cost = 4,\n    atlas = \"mf_colours\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 71, h = 87 },\n    pixel_size = { w = 71, h = 87 },\n    can_use = function(self, card)\n      return true\n    end,\n    use = function(self, card, area, copier)\n      local tag_type = \"tag_polychrome\"\n      for i = 1, card.ability.val do\n        G.E_MANAGER:add_event(Event({\n          func = (function()\n            add_tag(Tag(tag_type))\n            play_sound('generic1', 0.9 + math.random()*0.1, 0.8)\n            play_sound('holo1', 1.2 + math.random()*0.1, 0.4)\n            return true\n          end)\n        }))\n        delay(0.2)\n      end\n      delay(0.6)\n    end,\n    loc_vars = function(self, info_queue, card)\n      local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n      return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds} }\n    end",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 3
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 3
      },
      "vars": [
        0,
        null,
        null,
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "white",
      "atlas": "mf_colours",
      "pos": {
        "x": 3,
        "y": 2
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Colour\",\n    name = \"col_White\",\n    key = \"white\",\n    pos = { x = 3, y = 2 },\n    config = {\n      val = 0,\n      partial_rounds = 0,\n      upgrade_rounds = 3,\n    },\n    cost = 4,\n    atlas = \"mf_colours\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 71, h = 87 },\n    pixel_size = { w = 71, h = 87 },\n    can_use = function(self, card)\n      return true\n    end,\n    use = function(self, card, area, copier)\n      local card_type = \"Colour\"\n      local rng_seed = \"white\"\n      for i = 1, card.ability.val do\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n          play_sound('timpani')\n          local n_card = create_card(card_type, G.consumeables, nil, nil, nil, nil, nil, rng_seed)\n          n_card:add_to_deck()\n          n_card:set_edition({negative = true}, true)\n          G.consumeables:emplace(n_card)\n          card:juice_up(0.3, 0.5)\n          return true end }))\n      end\n      delay(0.6)\n    end,\n    loc_vars = function(self, info_queue, card)\n      local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n      return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds} }\n    end",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 3
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 3
      },
      "vars": [
        0,
        null,
        null,
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "red",
      "atlas": "mf_colours",
      "pos": {
        "x": 0,
        "y": 3
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Colour\",\n    name = \"col_Red\",\n    key = \"red\",\n    pos = { x = 0, y = 3 },\n    config = {\n      val = 0,\n      partial_rounds = 0,\n      upgrade_rounds = 1,\n    },\n    cost = 4,\n    atlas = \"mf_colours\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 71, h = 87 },\n    pixel_size = { w = 71, h = 87 },\n    can_use = function(self, card)\n      return #G.hand.cards > 1\n    end,\n    use = function(self, card, area, copier)\n      local suit = \"Hearts\"\n      local rng_seed = \"red\"\n      local blacklist = {}\n      for i = 1, card.ability.val do\n        local temp_pool = {}\n        for k, v in pairs(G.hand.cards) do\n          if not v:is_suit(suit) and not blacklist[v] then\n            table.insert(temp_pool, v)\n          end\n        end\n        local over = false\n        if #temp_pool == 0 then\n          break\n        end\n        local eligible_card = pseudorandom_element(temp_pool, pseudoseed(rng_seed))\n        blacklist[eligible_card] = true\n        G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.15,func = function() eligible_card:flip();play_sound('card1', 1);eligible_card:juice_up(0.3, 0.3);return true end }))\n        G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.4,func = function() eligible_card:flip();play_sound('tarot2', percent);eligible_card:change_suit(suit);return true end }))\n        card:juice_up(0.3, 0.5)\n      end\n      delay(0.6)\n    end,\n    loc_vars = function(self, info_queue, card)\n      local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n      return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds} }\n    end",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 1
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 1
      },
      "vars": [
        0,
        null,
        null,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "orange",
      "atlas": "mf_colours",
      "pos": {
        "x": 1,
        "y": 3
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Colour\",\n    name = \"col_Orange\",\n    key = \"orange\",\n    pos = { x = 1, y = 3 },\n    config = {\n      val = 0,\n      partial_rounds = 0,\n      upgrade_rounds = 1,\n    },\n    cost = 4,\n    atlas = \"mf_colours\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 71, h = 87 },\n    pixel_size = { w = 71, h = 87 },\n    can_use = function(self, card)\n      return #G.hand.cards > 1\n    end,\n    use = function(self, card, area, copier)\n      local suit = \"Diamonds\"\n      local rng_seed = \"orange\"\n      local blacklist = {}\n      for i = 1, card.ability.val do\n        local temp_pool = {}\n        for k, v in pairs(G.hand.cards) do\n          if not v:is_suit(suit) and not blacklist[v] then\n            table.insert(temp_pool, v)\n          end\n        end\n        local over = false\n        if #temp_pool == 0 then\n          break\n        end\n        local eligible_card = pseudorandom_element(temp_pool, pseudoseed(rng_seed))\n        blacklist[eligible_card] = true\n        G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.15,func = function() eligible_card:flip();play_sound('card1', 1);eligible_card:juice_up(0.3, 0.3);return true end }))\n        G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.4,func = function() eligible_card:flip();play_sound('tarot2', percent);eligible_card:change_suit(suit);return true end }))\n        card:juice_up(0.3, 0.5)\n      end\n      delay(0.6)\n    end,\n    loc_vars = function(self, info_queue, card)\n      local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n      return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds} }\n    end",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 1
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 1
      },
      "vars": [
        0,
        null,
        null,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "yellow",
      "atlas": "mf_colours",
      "pos": {
        "x": 2,
        "y": 3
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Colour\",\n    name = \"col_Yellow\",\n    key = \"yellow\",\n    pos = { x = 2, y = 3 },\n    config = {\n      val = 0,\n      partial_rounds = 0,\n      upgrade_rounds = 3,\n      value_per = 8,\n    },\n    cost = 4,\n    atlas = \"mf_colours\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 71, h = 87 },\n    pixel_size = { w = 71, h = 87 },\n    can_use = function(self, card)\n      return false\n    end,\n    use = function(self, card, area, copier)\n      \n    end,\n    loc_vars = function(self, info_queue, card)\n      local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n      return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds, card.ability.value_per} }\n    end",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 3,
        "value_per": 8
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 3,
        "value_per": 8
      },
      "vars": [
        0,
        null,
        null,
        3,
        8
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "green",
      "atlas": "mf_colours",
      "pos": {
        "x": 3,
        "y": 3
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Colour\",\n    name = \"col_Green\",\n    key = \"green\",\n    pos = { x = 3, y = 3 },\n    config = {\n      val = 0,\n      partial_rounds = 0,\n      upgrade_rounds = 3,\n    },\n    cost = 4,\n    atlas = \"mf_colours\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 71, h = 87 },\n    pixel_size = { w = 71, h = 87 },\n    can_use = function(self, card)\n      return true\n    end,\n    use = function(self, card, area, copier)\n      for i = 1, card.ability.val do\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n        play_sound('timpani')\n        local n_card = create_card(nil,G.consumeables, nil, nil, nil, nil, 'j_mf_oopsallfives', 'sup')\n        n_card:add_to_deck()\n        n_card:set_edition({negative = true}, true)\n        G.jokers:emplace(n_card)\n        card:juice_up(0.3, 0.5)\n        return true end }))\n      end\n      delay(0.6)\n    end,\n    loc_vars = function(self, info_queue, card)\n      info_queue[#info_queue + 1] = G.P_CENTERS[\"j_mf_oopsallfives\"]\n      local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n      return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds} }\n    end",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 3
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 3
      },
      "vars": [
        0,
        null,
        null,
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "blue",
      "atlas": "mf_colours",
      "pos": {
        "x": 0,
        "y": 4
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Colour\",\n    name = \"col_Blue\",\n    key = \"blue\",\n    pos = { x = 0, y = 4 },\n    config = {\n      val = 0,\n      partial_rounds = 0,\n      upgrade_rounds = 2,\n    },\n    cost = 4,\n    atlas = \"mf_colours\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 71, h = 87 },\n    pixel_size = { w = 71, h = 87 },\n    can_use = function(self, card)\n      return true\n    end,\n    use = function(self, card, area, copier)\n      local card_type = \"Planet\"\n      local rng_seed = \"blue\"\n      for i = 1, card.ability.val do\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n          play_sound('timpani')\n          local n_card = create_card(card_type, G.consumeables, nil, nil, nil, nil, nil, rng_seed)\n          n_card:add_to_deck()\n          n_card:set_edition({negative = true}, true)\n          G.consumeables:emplace(n_card)\n          card:juice_up(0.3, 0.5)\n          return true end }))\n      end\n      delay(0.6)\n    end,\n    loc_vars = function(self, info_queue, card)\n      local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n      return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds} }\n    end",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 2
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 2
      },
      "vars": [
        0,
        null,
        null,
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "lilac",
      "atlas": "mf_colours",
      "pos": {
        "x": 1,
        "y": 4
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Colour\",\n    name = \"col_Lilac\",\n    key = \"lilac\",\n    pos = { x = 1, y = 4 },\n    config = {\n      val = 0,\n      partial_rounds = 0,\n      upgrade_rounds = 2,\n    },\n    cost = 4,\n    atlas = \"mf_colours\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 71, h = 87 },\n    pixel_size = { w = 71, h = 87 },\n    can_use = function(self, card)\n      return true\n    end,\n    use = function(self, card, area, copier)\n      local card_type = \"Tarot\"\n      local rng_seed = \"blue\"\n      for i = 1, card.ability.val do\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n          play_sound('timpani')\n          local n_card = create_card(card_type, G.consumeables, nil, nil, nil, nil, nil, rng_seed)\n          n_card:add_to_deck()\n          n_card:set_edition({negative = true}, true)\n          G.consumeables:emplace(n_card)\n          card:juice_up(0.3, 0.5)\n          return true end }))\n      end\n      delay(0.6)\n    end,\n    loc_vars = function(self, info_queue, card)\n      local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n      return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds} }\n    end",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 2
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 2
      },
      "vars": [
        0,
        null,
        null,
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "pink",
      "atlas": "mf_colours",
      "pos": {
        "x": 2,
        "y": 4
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Colour\",\n    name = \"col_Pink\",\n    key = \"pink\",\n    pos = { x = 2, y = 4 },\n    config = {\n      val = 0,\n      partial_rounds = 0,\n      upgrade_rounds = 2,\n    },\n    cost = 4,\n    atlas = \"mf_colours\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 71, h = 87 },\n    pixel_size = { w = 71, h = 87 },\n    can_use = function(self, card)\n      return true\n    end,\n    use = function(self, card, area, copier)\n      n_random_colour_rounds(card.ability.val)\n    end,\n    loc_vars = function(self, info_queue, card)\n      local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n      return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds} }\n    end",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 2
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 2
      },
      "vars": [
        0,
        null,
        null,
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "peach",
      "atlas": "mf_colours",
      "pos": {
        "x": 3,
        "y": 4
      },
      "raw": "object_type = \"Consumable\",\n      set = \"Colour\",\n      name = \"col_Peach\",\n      key = \"peach\",\n      pos = { x = 3, y = 4 },\n      config = {\n        val = 0,\n        partial_rounds = 0,\n        upgrade_rounds = 2,\n      },\n      cost = 4,\n      atlas = \"mf_colours\",\n      unlocked = true,\n      discovered = true,\n      display_size = { w = 71, h = 87 },\n      pixel_size = { w = 71, h = 87 },\n      can_use = function(self, card)\n        return true\n      end,\n      use = function(self, card, area, copier)\n        local card_type = \"Rotarot\"\n        local rng_seed = \"peach\"\n        for i = 1, card.ability.val do\n          G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n            play_sound('timpani')\n            local n_card = create_card(card_type, G.consumeables, nil, nil, nil, nil, nil, rng_seed)\n            n_card:add_to_deck()\n            n_card:set_edition({negative = true}, true)\n            G.consumeables:emplace(n_card)\n            card:juice_up(0.3, 0.5)\n            return true end }))\n        end\n        delay(0.6)\n      end,\n      loc_vars = function(self, info_queue, card)\n        local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n        return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds} }\n      end",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 2
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 2
      },
      "vars": [
        0,
        null,
        null,
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "new_gold",
      "atlas": "mf_colours",
      "pos": {
        "x": 1,
        "y": 6
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Colour\",\n    name = \"col_Gold\",\n    key = \"new_gold\",\n    pos = { x = 1, y = 6 },\n    config = {\n      val = 0,\n      partial_rounds = 0,\n      upgrade_rounds = 4,\n    },\n    hidden = true,\n    cost = 4,\n    atlas = \"mf_colours\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 71, h = 87 },\n    pixel_size = { w = 71, h = 87 },\n    can_use = function(self, card)\n      return true\n    end,\n    use = function(self, card, area, copier)\n      for i = 1, card.ability.val do\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n          play_sound('timpani')\n          local n_card = create_card(nil,G.consumeables, nil, nil, nil, nil, 'c_soul', 'sup')\n          n_card:add_to_deck()\n          n_card:set_edition({negative = true}, true)\n          G.consumeables:emplace(n_card)\n          card:juice_up(0.3, 0.5)\n          return true end }))\n      end\n      delay(0.6)\n    end,\n    loc_vars = function(self, info_queue, card)\n      local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n      return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds} }\n    end",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 4
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 4
      },
      "vars": [
        0,
        null,
        null,
        4
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "wordlegreen",
      "atlas": "mf_colours",
      "pos": {
        "x": 0,
        "y": 6
      },
      "raw": "object_type = \"Consumable\",\n      set = \"Colour\",\n      name = \"col_WordleGreen\",\n      key = \"wordlegreen\",\n      pos = { x = 0, y = 6 },\n      config = {\n        val = 0,\n        partial_rounds = 0,\n        upgrade_rounds = 1,\n      },\n      cost = 4,\n      atlas = \"mf_colours\",\n      unlocked = true,\n      discovered = true,\n      display_size = { w = 71, h = 87 },\n      pixel_size = { w = 71, h = 87 },\n      can_use = function(self, card)\n        return true\n      end,\n      use = function(self, card, area, copier)\n        local card_type = \"Alphabet\"\n        local rng_seed = \"wordle\"\n        for i = 1, card.ability.val do\n          G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n            play_sound('timpani')\n            local n_card = create_card(card_type, G.consumeables, nil, nil, nil, nil, nil, rng_seed)\n            n_card:add_to_deck()\n            n_card:set_edition({negative = true}, true)\n            G.consumeables:emplace(n_card)\n            card:juice_up(0.3, 0.5)\n            return true end }))\n        end\n        delay(0.6)\n      end,\n      in_pool = function(self, args)\n        return G.GAME.akyrs_character_stickers_enabled and G.GAME.akyrs_wording_enabled\n      end,\n      loc_vars = function(self, info_queue, card)\n        local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n        return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds} }\n      end,\n      set_badges = function (self, card, badges)\n        SMODS.create_mod_badges({ mod = SMODS.find_mod(\"aikoyorisshenanigans\")[1] }, badges)\n      end,",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 1
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 1
      },
      "vars": [
        0,
        null,
        null,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "pastelpink",
      "atlas": "mf_colours",
      "pos": {
        "x": 2,
        "y": 6
      },
      "raw": "object_type = \"Consumable\",\n      set = \"Colour\",\n      name = \"col_PastelPink\",\n      key = \"pastelpink\",\n      pos = { x = 2, y = 6 },\n      config = {\n        val = 0,\n        partial_rounds = 0,\n        upgrade_rounds = 2,\n      },\n      cost = 4,\n      atlas = \"mf_colours\",\n      unlocked = true,\n      discovered = true,\n      display_size = { w = 71, h = 87 },\n      pixel_size = { w = 71, h = 87 },\n      can_use = function(self, card)\n        return true\n      end,\n      use = function(self, card, area, copier)\n        local card_type = \"Silly\"\n        local rng_seed = \"pastel\"\n        for i = 1, card.ability.val do\n          G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n            play_sound('timpani')\n            local n_card = create_card(card_type, G.consumeables, nil, nil, nil, nil, nil, rng_seed)\n            n_card:add_to_deck()\n            n_card:set_edition({negative = true}, true)\n            G.consumeables:emplace(n_card)\n            card:juice_up(0.3, 0.5)\n            return true end }))\n        end\n        delay(0.6)\n      end,\n      loc_vars = function(self, info_queue, card)\n        local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n        return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds, colours = {HEX(\"ff98e2\")}} }\n      end,\n      set_badges = function (self, card, badges)\n        SMODS.create_mod_badges({ mod = SMODS.find_mod(\"LuckyRabbit\")[1] }, badges)\n      end,",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 2
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 2
      },
      "vars": [
        0,
        null,
        null,
        2,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "royalblue",
      "atlas": "mf_colours",
      "pos": {
        "x": 3,
        "y": 6
      },
      "raw": "object_type = \"Consumable\",\n      set = \"Colour\",\n      name = \"col_RoyalBlue\",\n      key = \"royalblue\",\n      pos = { x = 3, y = 6 },\n      config = {\n        val = 0,\n        partial_rounds = 0,\n        upgrade_rounds = 4,\n      },\n      cost = 4,\n      atlas = \"mf_colours\",\n      unlocked = true,\n      discovered = true,\n      hidden = true,\n      soul_rate = 0.03,\n      display_size = { w = 71, h = 87 },\n      pixel_size = { w = 71, h = 87 },\n      can_use = function(self, card)\n        return true\n      end,\n      use = function(self, card, area, copier)\n        for i = 1, card.ability.val do\n          local key = nil\n          if jl.chance('sealspectralpack_legendary', 20, true) then\n            key = pseudorandom_element(Seals.legendary_seal_spectrals, pseudoseed('sealspectrals'))\n          elseif jl.chance('sealspectralpack_epic', 5, true) then\n            key = pseudorandom_element(Seals.epic_seal_spectrals, pseudoseed('sealspectrals'))\n          else\n            key = pseudorandom_element(Seals.rare_seal_spectrals, pseudoseed('sealspectrals'))\n          end\n          G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n            play_sound('timpani')\n            local n_card = create_card(card_type, G.consumeables, nil, nil, nil, nil, key, \"royalblue\")\n            n_card:add_to_deck()\n            n_card:set_edition({negative = true}, true)\n            G.consumeables:emplace(n_card)\n            card:juice_up(0.3, 0.5)\n            return true end }))\n        end\n        delay(0.6)\n      end,\n      loc_vars = function(self, info_queue, card)\n        local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n        return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds} }\n      end,\n      set_badges = function (self, card, badges)\n        SMODS.create_mod_badges({ mod = SMODS.find_mod(\"sillyseals\")[1] }, badges)\n      end,",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 4
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 4
      },
      "vars": [
        0,
        null,
        null,
        4
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "respiceperprisma",
      "atlas": "mf_colours",
      "pos": {
        "x": 3,
        "y": 7
      },
      "raw": "object_type = \"Consumable\",\n      set = \"Colour\",\n      name = \"col_RespicePerPrisma\",\n      key = \"respiceperprisma\",\n      pos = { x = 3, y = 7 },\n      config = {\n        val = 0,\n        partial_rounds = 0,\n        upgrade_rounds = 12,\n      },\n      cost = 4,\n      atlas = \"mf_colours\",\n      unlocked = true,\n      discovered = true,\n      hidden = true,\n      soul_rate = 0.0003,\n      display_size = { w = 71, h = 87 },\n      pixel_size = { w = 71, h = 87 },\n      can_use = function(self, card)\n        return true\n      end,\n      use = function(self, card, area, copier)\n        for i = 1, card.ability.val do\n          local key = \"c_sillyseals_ringularity\"\n          G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n            play_sound('timpani')\n            local n_card = create_card(card_type, G.consumeables, nil, nil, nil, nil, key, \"royalblue\")\n            n_card:add_to_deck()\n            n_card:set_edition({negative = true}, true)\n            G.consumeables:emplace(n_card)\n            card:juice_up(0.3, 0.5)\n            return true end }))\n        end\n        delay(0.6)\n      end,\n      loc_vars = function(self, info_queue, card)\n        local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n        return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds} }\n      end,\n      set_badges = function (self, card, badges)\n        SMODS.create_mod_badges({ mod = SMODS.find_mod(\"sillyseals\")[1] }, badges)\n      end,",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 12
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 12
      },
      "vars": [
        0,
        null,
        null,
        12
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "teal",
      "atlas": "mf_colours",
      "pos": {
        "x": 0,
        "y": 7
      },
      "raw": "object_type = \"Consumable\",\n      set = \"Colour\",\n      name = \"col_Teal\",\n      key = \"teal\",\n      pos = { x = 0, y = 7 },\n      config = {\n        val = 0,\n        partial_rounds = 0,\n        upgrade_rounds = 2,\n      },\n      cost = 4,\n      atlas = \"mf_colours\",\n      unlocked = true,\n      discovered = true,\n      display_size = { w = 71, h = 87 },\n      pixel_size = { w = 71, h = 87 },\n      can_use = function(self, card)\n        return true\n      end,\n      use = function(self, card, area, copier)\n        for i = 1, card.ability.val do\n          G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n            play_sound('timpani')\n            local n_card = create_card(nil,G.jokers, nil, nil, nil, nil, 'j_splash', 'sup')\n            n_card:add_to_deck()\n            n_card:set_edition({negative = true}, true)\n            G.jokers:emplace(n_card)\n            card:juice_up(0.3, 0.5)\n            return true end }))\n        end\n        delay(0.6)\n      end,\n      loc_vars = function(self, info_queue, card)\n        local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n        return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds} }\n      end,\n      set_badges = function (self, card, badges)\n        SMODS.create_mod_badges({ mod = SMODS.find_mod(\"Tsunami\")[1]  }, badges)\n      end,",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 2
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 2
      },
      "vars": [
        0,
        null,
        null,
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "blank",
      "atlas": "mf_colours",
      "pos": {
        "x": 1,
        "y": 7
      },
      "raw": "object_type = \"Consumable\",\n      set = \"Colour\",\n      name = \"col_Blank\",\n      key = \"blank\",\n      pos = { x = 1, y = 7 },\n      config = {\n        val = 0,\n        partial_rounds = 0,\n        upgrade_rounds = 3,\n      },\n      cost = 4,\n      atlas = \"mf_colours\",\n      unlocked = true,\n      discovered = true,\n      display_size = { w = 71, h = 87 },\n      pixel_size = { w = 71, h = 87 },\n      can_use = function(self, card)\n        return true\n      end,\n      use = function(self, card, area, copier)\n        for i = 1, card.ability.val do\n          G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n            play_sound('timpani')\n            local n_card = create_card(nil,G.jokers, nil, nil, nil, nil, 'c_egjs_js_basic', 'sup')\n            n_card:add_to_deck()\n            n_card:set_edition({negative = true}, true)\n            G.consumeables:emplace(n_card)\n            card:juice_up(0.3, 0.5)\n            return true end }))\n        end\n        delay(0.6)\n      end,\n      loc_vars = function(self, info_queue, card)\n        local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n        return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds} }\n      end,\n      set_badges = function (self, card, badges)\n        SMODS.create_mod_badges({ mod = SMODS.find_mod(\"egjs\")[1]  }, badges)\n      end,",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 3
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 3
      },
      "vars": [
        0,
        null,
        null,
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "amber",
      "atlas": "mf_colours",
      "pos": {
        "x": 2,
        "y": 7
      },
      "raw": "object_type = \"Consumable\",\n      set = \"Colour\",\n      name = \"col_Amber\",\n      key = \"amber\",\n      pos = { x = 2, y = 7 },\n      config = {\n        val = 0,\n        partial_rounds = 0,\n        upgrade_rounds = 3,\n      },\n      cost = 4,\n      atlas = \"mf_colours\",\n      unlocked = true,\n      discovered = true,\n      display_size = { w = 71, h = 87 },\n      pixel_size = { w = 71, h = 87 },\n      can_use = function(self, card)\n        return true\n      end,\n      use = function(self, card, area, copier)\n        local card_type = \"Travel\"\n        local rng_seed = \"amber\"\n        for i = 1, card.ability.val do\n          G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n            play_sound('timpani')\n            local n_card = create_card(card_type, G.consumeables, nil, nil, nil, nil, nil, rng_seed)\n            n_card:add_to_deck()\n            n_card:set_edition({negative = true}, true)\n            G.consumeables:emplace(n_card)\n            card:juice_up(0.3, 0.5)\n            return true end }))\n        end\n        delay(0.6)\n      end,\n      loc_vars = function(self, info_queue, card)\n        local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n        return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds} }\n      end,\n      set_badges = function (self, card, badges)\n        SMODS.create_mod_badges({ mod = SMODS.find_mod(\"sarcpot\")[1] }, badges)\n      end,",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 3
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 3
      },
      "vars": [
        0,
        null,
        null,
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "moss",
      "atlas": "mf_colours",
      "pos": {
        "x": 0,
        "y": 8
      },
      "raw": "object_type = \"Consumable\",\n      set = \"Colour\",\n      name = \"col_Moss\",\n      key = \"moss\",\n      pos = { x = 0, y = 8 },\n      config = {\n        val = 0,\n        partial_rounds = 0,\n        upgrade_rounds = 3,\n      },\n      cost = 4,\n      atlas = \"mf_colours\",\n      unlocked = true,\n      discovered = true,\n      display_size = { w = 71, h = 87 },\n      pixel_size = { w = 71, h = 87 },\n      can_use = function(self, card)\n        return true\n      end,\n      use = function(self, card, area, copier)\n        local card_type = \"Myth\"\n        local rng_seed = \"moss\"\n        for i = 1, card.ability.val do\n          G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n            play_sound('timpani')\n            local n_card = create_card(card_type, G.consumeables, nil, nil, nil, nil, nil, rng_seed)\n            n_card:add_to_deck()\n            n_card:set_edition({negative = true}, true)\n            G.consumeables:emplace(n_card)\n            card:juice_up(0.3, 0.5)\n            return true end }))\n        end\n        delay(0.6)\n      end,\n      loc_vars = function(self, info_queue, card)\n        local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n        return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds} }\n      end,\n      set_badges = function (self, card, badges)\n        SMODS.create_mod_badges({ mod = SMODS.find_mod(\"Prism\")[1] }, badges)\n      end,",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 3
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 3
      },
      "vars": [
        0,
        null,
        null,
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "caramel",
      "atlas": "mf_colours",
      "pos": {
        "x": 1,
        "y": 8
      },
      "raw": "object_type = \"Consumable\",\n        set = \"Colour\",\n        name = \"col_Caramel\",\n        key = \"caramel\",\n        pos = { x = 1, y = 8 },\n        config = {\n          val = 0,\n          partial_rounds = 0,\n          upgrade_rounds = 3,\n        },\n        cost = 4,\n        atlas = \"mf_colours\",\n        unlocked = true,\n        discovered = true,\n        display_size = { w = 71, h = 87 },\n        pixel_size = { w = 71, h = 87 },\n        can_use = function(self, card)\n          return true\n        end,\n        use = function(self, card, area, copier)\n          local card_type = \"Bakery\"\n          local rng_seed = \"caramel\"\n          for i = 1, card.ability.val do\n            G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n              play_sound('timpani')\n              local n_card = create_card(card_type, G.consumeables, nil, nil, nil, nil, nil, rng_seed)\n              n_card:add_to_deck()\n              n_card:set_edition({negative = true}, true)\n              G.consumeables:emplace(n_card)\n              card:juice_up(0.3, 0.5)\n              return true end }))\n          end\n          delay(0.6)\n        end,\n        loc_vars = function(self, info_queue, card)\n          local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n          return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds} }\n        end,\n        set_badges = function (self, card, badges)\n          SMODS.create_mod_badges({ mod = SMODS.find_mod(\"sdm0sstuff\")[1] }, badges)\n        end,",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 3
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 3
      },
      "vars": [
        0,
        null,
        null,
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "violet",
      "atlas": "mf_colours",
      "pos": {
        "x": 2,
        "y": 8
      },
      "raw": "object_type = \"Consumable\",\n      set = \"Colour\",\n      name = \"col_Violet\",\n      key = \"violet\",\n      pos = { x = 2, y = 8 },\n      config = {\n        val = 0,\n        partial_rounds = 0,\n        upgrade_rounds = 4,\n      },\n      cost = 4,\n      atlas = \"mf_colours\",\n      unlocked = true,\n      discovered = true,\n      hidden = true,\n      display_size = { w = 71, h = 87 },\n      pixel_size = { w = 71, h = 87 },\n      can_use = function(self, card)\n        return true\n      end,\n      use = function(self, card, area, copier)\n        for i = 1, card.ability.val do\n          G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n            play_sound('timpani')\n            local n_card = create_card(nil,G.consumeables, nil, nil, nil, nil, 'c_finity_finity', 'sup')\n            n_card:add_to_deck()\n            n_card:set_edition({negative = true}, true)\n            G.consumeables:emplace(n_card)\n            card:juice_up(0.3, 0.5)\n            return true end }))\n        end\n        delay(0.6)\n      end,\n      loc_vars = function(self, info_queue, card)\n        local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n        return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds} }\n      end,\n      set_badges = function (self, card, badges)\n        SMODS.create_mod_badges({ mod = SMODS.find_mod(\"finity\")[1] }, badges)\n      end,",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 4
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 4
      },
      "vars": [
        0,
        null,
        null,
        4
      ],
      "infoQueue": []
    },
    {
      "type": "Voucher",
      "key": "paintroller",
      "atlas": "mf_vouchers",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "object_type = \"Voucher\",\n    key = \"paintroller\",\n    atlas = \"mf_vouchers\",\n    pos = { x = 0, y = 0 },\n    unlocked = true,\n    discovered = true,\n    loc_vars = function(self, info_queue)\n      local new_numerator, new_denominator = SMODS.get_probability_vars(card, 1, 2, 'paintroller')\n      return { vars = { new_numerator, new_denominator } }\n    end,",
      "config": {},
      "ability": {},
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Voucher",
      "key": "colourtheory",
      "atlas": "mf_vouchers",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "object_type = \"Voucher\",\n    key = \"colourtheory\",\n    atlas = \"mf_vouchers\",\n    pos = { x = 1, y = 0 },\n    unlocked = true,\n    discovered = true,\n    loc_vars = function(self, info_queue)\n      return { vars = {} }\n    end,\n    requires = { \"v_mf_paintroller\" },",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Voucher",
      "key": "artprogram",
      "atlas": "mf_vouchers",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "object_type = \"Voucher\",\n      key = \"artprogram\",\n      atlas = \"mf_vouchers\",\n      pos = { x = 2, y = 0 },\n      unlocked = true,\n      discovered = true,\n      loc_vars = function(self, info_queue)\n        return { vars = {} }\n      end,\n      requires = { \"v_mf_colourtheory\" },",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "monus",
      "atlas": "mf_enhancers",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"monus\",\n    atlas = \"mf_enhancers\",\n    pos = { x = 3, y = 1 },\n    config = {\n      per_level = 10,\n    },\n    calculate = function (self, card, context)\n      if context.main_scoring and context.cardarea == G.play then\n        local text, disp_text, poker_hands, scoring_hand, non_loc_disp_text = G.FUNCS.get_poker_hand_info(G.play.cards)\n        local level = to_number(G.GAME.hands[text].level)\n        local chip_return = card.ability.per_level * level\n        return {\n          chips = chip_return\n        }\n      end\n    end,\n    loc_vars = function(self, info_queue, card)\n      -- info_queue[#info_queue + 1] = G.P_CENTERS.m_mf_yucky\n  \n      return { vars = { \n        card and card.ability.per_level or self.config.per_level\n      } }\n    end",
      "config": {
        "per_level": 10
      },
      "ability": {
        "per_level": 10
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "cult",
      "atlas": "mf_enhancers",
      "pos": {
        "x": 4,
        "y": 1
      },
      "raw": "key = \"cult\",\n    atlas = \"mf_enhancers\",\n    pos = { x = 4, y = 1 },\n    config = {\n      per_level = 1,\n    },\n    calculate = function (self, card, context)\n      if context.main_scoring and context.cardarea == G.play then\n        local text, disp_text, poker_hands, scoring_hand, non_loc_disp_text = G.FUNCS.get_poker_hand_info(G.play.cards)\n        local level = to_number(G.GAME.hands[text].level)\n        local chip_return = card.ability.per_level * level\n        return {\n          mult = chip_return\n        }\n      end\n    end,\n    loc_vars = function(self, info_queue, card)\n      -- info_queue[#info_queue + 1] = G.P_CENTERS.m_mf_yucky\n  \n      return { vars = { \n        card and card.ability.per_level or self.config.per_level\n      } }\n    end",
      "config": {
        "per_level": 1
      },
      "ability": {
        "per_level": 1
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "styled",
      "atlas": "mf_enhancers",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"styled\",\n    atlas = \"mf_enhancers\",\n    pos = { x = 2, y = 1 },\n    config = {},\n    calculate = function (self, card, context)\n      if context.hand_drawn then\n        local doit = false\n        for _, thing in ipairs(context.hand_drawn) do\n          if thing == card then\n            doit = true\n            goto continue\n          end\n        end\n        ::continue::\n        if doit then\n          G.E_MANAGER:add_event(Event({\n            trigger = \"before\",\n            delay = 0.25,\n            func = function()\n              card:set_seal(\n                SMODS.poll_seal({ guaranteed = true, type_key = \"styledcard\" }),\n                true,\n                false\n              )\n              card:juice_up()\n              play_sound(\"gold_seal\", 1.2, 0.4)\n              return true\n            end,\n          }))\n        end\n      end\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "brass",
      "atlas": "mf_enhancers",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "key = \"brass\",\n    atlas = \"mf_enhancers\",\n    pos = { x = 1, y = 2 },\n    config = {\n      retriggers = 2,\n      chance = 3\n    },\n    calculate = function (self, card, context)\n      if\n        context.repetition and context.cardarea == G.play\n      then\n        return {\n          message = localize(\"k_again_ex\"),\n          repetitions = card.ability.retriggers,\n          card = card,\n        }\n      end\n      if context.destroy_card and context.destroying_card == card and SMODS.pseudorandom_probability(card, 'brass_card', 1, card.ability.chance, 'brass_card') then\n        return {\n          remove = true\n        }\n      end\n    end,\n    loc_vars = function(self, info_queue, card)\n      -- info_queue[#info_queue + 1] = G.P_CENTERS.m_mf_yucky\n      \n      local new_numerator, new_denominator = SMODS.get_probability_vars(card, 1, card and card.ability.chance or self.config.chance, 'brass_card')\n  \n      return { vars = { \n        card and card.ability.retriggers or self.config.retriggers,\n        new_numerator,\n        new_denominator,\n      } }\n    end",
      "config": {
        "retriggers": 2,
        "chance": 3
      },
      "ability": {
        "retriggers": 2,
        "chance": 3
      },
      "vars": [
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "teal",
      "atlas": "mf_enhancers",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"teal\",\n    atlas = \"mf_enhancers\",\n    pos = { x = 1, y = 1 },\n    config = {\n      h_x_chips = 1.5\n    },\n    loc_vars = function(self, info_queue, card)\n      return { vars = { \n        card and card.ability.h_x_chips or self.config.h_x_chips,\n      } }\n    end",
      "config": {
        "h_x_chips": 1.5
      },
      "ability": {
        "h_x_chips": 1.5
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "gemstone",
      "atlas": "mf_enhancers",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "key = \"gemstone\",\n    atlas = \"mf_enhancers\",\n    pos = { x = 2, y = 2 },\n    config = {\n      p_dollars = 3\n    },\n    replace_base_card = true,\n    no_rank = true,\n    no_suit = true,\n    always_scores = true,\n    weight = 4, -- make it slightly rarer (??)\n    loc_vars = function(self, info_queue, card)\n      return { vars = { \n        card and card.ability.p_dollars or self.config.p_dollars,\n      } }\n    end,\n    draw = function(self, card, layer)\n      local notilt = nil\n      if card.area and card.area.config.type == \"deck\" then\n        notilt = true\n      end\n      -- card.children.center:draw_shader(\n      --   \"negative\",\n      --   nil,\n      --   card.ARGS.send_to_shader,\n      --   notilt,\n      --   card.children.center\n      -- )\n      card.children.center:draw_shader(\n        \"voucher\",\n        nil,\n        card.ARGS.send_to_shader,\n        notilt,\n        card.children.center\n      )\n    end,",
      "config": {
        "p_dollars": 3
      },
      "ability": {
        "p_dollars": 3
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "marigold",
      "atlas": "mf_enhancers",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = \"marigold\",\n    atlas = \"mf_enhancers\",\n    pos = { x = 0, y = 2 },\n    config = {\n      cash = 1\n    },\n    calculate = function (self, card, context)\n      if context.playing_card_end_of_round and context.cardarea == G.hand then\n        local c = 1\n        for _, other_card in pairs(G.hand.cards) do\n          if other_card ~= card and other_card.config.center_key == card.config.center_key then\n            c = c + 1\n            G.E_MANAGER:add_event(Event({\n              trigger = \"before\",\n              delay = 0.25,\n              func = function()\n                other_card:juice_up()\n                card:juice_up()\n                play_sound('chips1', 0.8+ (0.9 + 0.2*math.random())*0.2, 1)\n                -- ease_dollars(card.ability.cash)\n                return true\n              end,\n            }))\n          end\n        end\n        -- ease_dollars(card.ability.cash)\n        return {\n          dollars = card.ability.cash * c\n        }\n      end\n    end,\n    loc_vars = function(self, info_queue, card)\n      -- info_queue[#info_queue + 1] = G.P_CENTERS.m_mf_yucky\n  \n      return { vars = {\n        card and card.ability.cash or self.config.cash\n      } }\n    end",
      "config": {
        "cash": 1
      },
      "ability": {
        "cash": 1
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Enhancement",
      "key": "yucky",
      "atlas": "mf_enhancers",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"yucky\",\n    atlas = \"mf_enhancers\",\n    pos = { x = 0, y = 1 },\n    config = {\n      chance = 2\n    },\n    calculate = function (self, card, context)\n      if context.destroy_card and context.destroying_card == card and SMODS.pseudorandom_probability(card, 'yucky', 1, card.ability.chance, 'yucky_card') then\n        return {\n          remove = true\n        }\n      end\n    end,\n    loc_vars = function(self, info_queue, card)\n      -- info_queue[#info_queue + 1] = G.P_CENTERS.m_mf_yucky\n      \n      local new_numerator, new_denominator = SMODS.get_probability_vars(card, 1, card and card.ability.chance or self.config.chance, 'yucky_card')\n  \n      return { vars = { \n        new_numerator,\n        new_denominator\n      } }\n    end",
      "config": {
        "chance": 2
      },
      "ability": {
        "chance": 2
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Rarity",
      "key": "bossblind",
      "atlas": null,
      "pos": null,
      "raw": "key = \"bossblind\",\n    loc_txt = {name = \"Boss Blind\"},\n    badge_colour = HEX(\"690a0f\"),",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Joker",
      "key": "theneedle",
      "atlas": "mf_finity_crossmod",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"theneedle\",\n    name = \"The Needle\",\n    atlas = 'mf_finity_crossmod',\n    config = {\n      extra = {discards_per = 2}\n    },\n    unlocked = true,\n    discovered = true,\n    eternal_compat = true,\n    perishable_compat = true,\n    blueprint_compat = true,\n    rarity = \"mf_bossblind\",\n    pos = { x = 0, y = 0 },\n    cost = 10,\n    soul_pos = { x = 1, y = 0 },\n    calculate = function(self, card, context)\n      if ((context.setting_blind and not card.getting_sliced) or context.forcetrigger) and not (context.blueprint_card or card).getting_sliced then\n        G.E_MANAGER:add_event(Event({func = function()\n          local lost = G.GAME.current_round.hands_left - 1\n          ease_discard(lost * card.ability.extra.discards_per, nil, true)\n          ease_hands_played(-lost)\n        return true end }))\n      end\n    end,\n    loc_vars = function(self, info_queue, center)\n      return {\n        vars = { center.ability.extra.discards_per }\n      }\n    end,\n    set_badges = function (self, card, badges)\n      SMODS.create_mod_badges({ mod = SMODS.find_mod(\"finity\")[1] }, badges)\n    end,",
      "config": {
        "extra": {
          "discards_per": 2
        }
      },
      "ability": {
        "extra": {
          "discards_per": 2
        }
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Atlas",
      "key": "mf_yahi_rotarots",
      "atlas": null,
      "pos": null,
      "raw": "key = \"mf_yahi_rotarots\", \n    atlas_table = \"ASSET_ATLAS\", \n    path = \"mf_yahi_rotarots.png\", \n    px = 107, \n    py = 107",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Sound",
      "key": "e_faithful",
      "atlas": null,
      "pos": null,
      "raw": "key = \"e_faithful\", path = \"e_faithful.ogg\",",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Shader",
      "key": "faithful",
      "atlas": null,
      "pos": null,
      "raw": "key = 'faithful', path = 'faithful.fs'",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "rot_puke",
      "atlas": "mf_yahi_rotarots",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"rot_puke\",\n    set = \"Rotarot\",\n    name = \"rot_puke\",\n    loc_txt = {\n      name = \"Puke!\",\n      text={\n        \"Debuffs blind\",\n        \"{C:inactive}(If in a Pack, is added to consumeable slots instead){}\",\n      },\n    },\n    \n    config = {},\n    pos = {x=0, y= 0},\n\n    unlocked = true,\n    discovered = true,\n    \n    atlas = \"mf_yahi_rotarots\",\n    display_size = { w = 107, h = 107 },\n    cost = 3,\n\n    use = function(self, card, area, copier)\n      play_sound(\"yahimod_catvomit\")\n      if G.GAME.blind and ((not G.GAME.blind.disabled) and (G.GAME.blind:get_type() == 'Boss')) then \n        card_eval_status_text(card, 'extra', nil, nil, nil, {message = localize('ph_boss_disabled')})\n        G.GAME.blind:disable()\n      end\n    end,\n\n    can_use = function(self, card)\n      if G.GAME.blind:get_type() then\n        return true\n      end\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "rot_cashouttf",
      "atlas": "mf_yahi_rotarots",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"rot_cashouttf\",\n    set = \"Rotarot\",\n    name = \"rot_cashouttf\",\n    loc_txt = {\n      name = \"Cashout.tf!\",\n      text={\n        \"Doubles all sell values\",\n        \"of all Jokers\",\n        \"{C:inactive}(this one's an ad too){}\",\n      },\n    },\n    \n    config = {},\n    pos = {x=1, y= 0},\n\n    unlocked = true,\n    discovered = true,\n    \n    atlas = \"mf_yahi_rotarots\",\n    display_size = { w = 107, h = 107 },\n    cost = 3,\n\n    use = function(self, card, area, copier)\n      local used_tarot = copier or card\n      for k, v in ipairs(G.jokers.cards) do\n        if v.set_cost then \n          G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.15,\n            func = function()\n              v.ability.extra_value = (v.ability.extra_value or 0) + v.cost\n              v:set_cost()\n              v:juice_up(0.3, 0.5)\n              used_tarot:juice_up(0.3, 0.5)\n              play_sound('timpani')\n              return true\n            end\n          }))\n        end\n      end\n    end,\n\n    can_use = function(self, card)\n      return true\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "rot_sponsor",
      "atlas": "mf_yahi_rotarots",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"rot_sponsor\",\n    set = \"Rotarot\",\n    name = \"rot_sponsor\",\n    loc_txt = {\n      name = \"Sponsor!\",\n      text={\n        \"Earn {C:money}$1{} for every\",\n        \"{C:money}$5{} you have\",\n      },\n    },\n    \n    config = {},\n    pos = {x=2, y= 0},\n\n    unlocked = true,\n    discovered = true,\n    \n    atlas = \"mf_yahi_rotarots\",\n    display_size = { w = 107, h = 107 },\n    cost = 3,\n\n    use = function(self, card, area, copier)\n      ease_dollars(math.floor(G.GAME.dollars / 5))\n    end,\n\n    can_use = function(self, card)\n      return true\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "rot_fish",
      "atlas": "mf_yahi_rotarots",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"rot_fish\",\n    set = \"Rotarot\",\n    name = \"rot_fish\",\n    loc_txt = {\n      name = \"Fish!\",\n      text={\n        \"Fish...\",\n      },\n    },\n    \n    config = {},\n    pos = {x=3, y= 0},\n\n    unlocked = true,\n    discovered = true,\n    \n    atlas = \"mf_yahi_rotarots\",\n    display_size = { w = 107, h = 107 },\n    cost = 3,\n\n    use = function(self, card, area, copier)\n      G.showfish = 4000\n      play_sound(\"yahimod_fish\")\n    end,\n\n    can_use = function(self, card)\n      return true\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "rot_cardboardbox",
      "atlas": "mf_yahi_rotarots",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"rot_cardboardbox\",\n    set = \"Rotarot\",\n    name = \"rot_cardboardbox\",\n    loc_txt = {\n      name = \"Cardboardbox!\",\n      text={\n        \"Duplicates your held\",\n        \"{C:attention}Cat Jokers{}\",\n        \"{C:inactive}(does not require room){}\",\n      },\n    },\n    \n    config = {},\n    pos = {x=0, y= 1},\n\n    unlocked = true,\n    discovered = true,\n    \n    atlas = \"mf_yahi_rotarots\",\n    display_size = { w = 107, h = 107 },\n    cost = 3,\n\n    use = function(self, card, area, copier)\n      for i = 1, #G.jokers.cards do\n        if G.jokers.cards[i].config.center.pools and G.jokers.cards[i].config.center.pools.Cat then\n          local card = create_card(\"Cat\", G.Jokers, nil, nil, nil, nil, G.jokers.cards[i].config.center.key, 'cardboardbox')\n          card:add_to_deck()\n          G.jokers:emplace(card)\n          play_sound(\"yahimod_mariopaintmeow\")\n        end\n      end\n      G.GAME.joker_buffer = 0\n    end,\n\n    can_use = function(self, card)\n      return true\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "rot_yahiworld",
      "atlas": "mf_yahi_rotarots",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"rot_yahiworld\",\n    set = \"Rotarot\",\n    name = \"rot_yahiworld\",\n    loc_txt = {\n      name = \"Yahiworld!\",\n      text={\n        \"Duplicates your held\",\n        \"{C:attention}Yahimod Jokers{}\",\n        \"{C:inactive}(does not require room){}\",\n      },\n    },\n    \n    config = {},\n    pos = {x=1, y= 1},\n\n    unlocked = true,\n    discovered = true,\n    \n    atlas = \"mf_yahi_rotarots\",\n    display_size = { w = 107, h = 107 },\n    cost = 3,\n\n    use = function(self, card, area, copier)\n      for i = 1, #G.jokers.cards do\n        if G.jokers.cards[i].config.center.pools and G.jokers.cards[i].config.center.pools.Yahimodaddition then\n          local card = create_card(\"Yahimodaddition\", G.Jokers, nil, nil, nil, nil, G.jokers.cards[i].config.center.key, 'cardboardbox')\n          card:add_to_deck()\n          G.jokers:emplace(card)\n          play_sound(\"yahimod_mariopaintmeow\")\n        end\n      end\n      G.GAME.joker_buffer = 0\n    end,\n\n    can_use = function(self, card)\n      return true\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "rot_instantwin",
      "atlas": "mf_yahi_rotarots",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "set = \"Rotarot\",\n    key = \"rot_instantwin\",\n    name = \"rot_instantwin\",\n    loc_txt = {\n      name = \"Instant Win!\",\n      text={\n        \"{C:red,s:1.2}KILL{} target {C:attention}Horse{}......\",\n      },\n    },\n    \n    pos = {x=2, y= 1},\n\n    unlocked = true,\n    discovered = true,\n    \n    atlas = \"mf_yahi_rotarots\",\n    display_size = { w = 107, h = 107 },\n    cost = 3,\n\n    use = function(self, card, area, copier)\n      if #G.jokers.highlighted == 1 or #G.hand.highlighted == 1 then\n        if not (#G.jokers.highlighted == 1 and #G.hand.highlighted == 1) then\n          if #G.jokers.highlighted == 1 and G.jokers.highlighted[1].ability.name == \"j_yahimod_horsewalksin\" then\n            play_sound(\"mf_gun\")\n            play_sound(\"yahimod_horsedeath\")\n\n            G.jokers.highlighted[1].ability.eternal = false\n            G.E_MANAGER:add_event(Event({func = function()\n              G.jokers.highlighted[1]:start_dissolve({G.C.RED}, nil, 1.6)\n            return true end }))\n\n          elseif #G.hand.highlighted == 1 and G.hand.highlighted[1].seal == \"yahimod_horse_seal\" then\n            play_sound(\"mf_gun\")\n            play_sound(\"yahimod_horsedeath\")\n\n            G.hand.highlighted[1]:set_seal()\n            G.hand.highlighted[1]:juice_up(0.5, 0.5)\n          end\n        end\n      end\n    end,\n\n    can_use = function(self, card)\n      local joker_horse = #G.jokers.highlighted == 1 and G.jokers.highlighted[1].ability.name == \"j_yahimod_horsewalksin\"\n      local horseseal = #G.hand.highlighted == 1 and G.hand.highlighted[1].seal == \"yahimod_horse_seal\"\n\n      return joker_horse or horse_seal\n    end,\n\n    can_use = function(self, card)\n      return true\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "rot_hispanicgathering",
      "atlas": "mf_yahi_rotarots",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "set = \"Rotarot\",\n    key = \"rot_hispanicgathering\",\n    config = {\n      -- How many cards can be selected.\n      max_highlighted = 1,\n      -- the key of the seal to change to\n      extra = 'mf_screencap_seal',\n    },\n    loc_vars = function(self, info_queue, card)\n      -- Handle creating a tooltip with seal args.\n      info_queue[#info_queue+1] = G.P_SEALS[(card.ability or self.config).extra]\n      -- Description vars\n      return {vars = {(card.ability or self.config).max_highlighted}}\n    end,\n    loc_txt = {\n      name = 'Hispanic Family Gathering!',\n      text = {\n        \"Select {C:attention}#1#{} card to\",\n        \"apply a {C:blue}Screencap Seal{} to\"\n      }\n    },\n    cost = 3,\n    unlocked = true,\n    discovered = true,\n    \n    atlas = \"mf_yahi_rotarots\",\n    display_size = { w = 107, h = 107 },\n    pos = {x=3, y=1},\n    use = function(self, card, area, copier)\n      for i = 1, math.min(#G.hand.highlighted, card.ability.max_highlighted) do\n        G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.1,func = function()\n          G.hand.highlighted[i].seal = \"mf_screencap_seal\"\n          return true end }))\n        \n        delay(0.5)\n      end\n      G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.2,func = function() G.hand:unhighlight_all(); return true end }))\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Seal",
      "key": "screencap_seal",
      "atlas": "mf_stickers",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "name = \"screencap_seal\",\n    key = \"screencap_seal\",\n    badge_colour = HEX(\"6bf8ee\"),\n    loc_txt = {\n      label = 'Screencap Seal',\n      name = 'Screencap Seal',\n      text = {\n        \"Always drawn first\"\n      }\n    },\n    atlas = \"mf_stickers\",\n    pos = {x=1, y=0},",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "rot_vampire",
      "atlas": "mf_yahi_rotarots",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "set = \"Rotarot\",\n    key = \"rot_vampire\",\n    config = {\n      max_highlighted = 1,\n      extra = 'vampire',\n    },\n    loc_vars = function(self, info_queue, card)\n      info_queue[#info_queue+1] = G.P_CENTERS.e_mf_faithful\n      -- Description vars\n      return {vars = {(card.ability or self.config).max_highlighted}}\n    end,\n    loc_txt = {\n      name = 'Vampire!',\n      text = {\n        \"Select {C:attention}#1#{} card to\",\n        \"turn {C:blue}Faithful{}\"\n      }\n    },\n    cost = 3,\n    pos = {x=0, y=2},\n\n    unlocked = true,\n    discovered = true,\n    \n    atlas = \"mf_yahi_rotarots\",\n    display_size = { w = 107, h = 107 },\n\n    can_use = function(self, card)\n      if #G.hand.highlighted == 1 then\n        return true\n      end\n    end,\n\n    use = function(self, card, area, copier)\n      for i = 1, math.min(#G.hand.highlighted, card.ability.max_highlighted) do\n        G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.1,func = function()\n          play_sound('mf_e_faithful', 1.0, 3.0)\n          G.hand.highlighted[1]:set_edition({ mf_faithful = true })\n          G.hand.highlighted[1]:juice_up(0.3, 0.5)\n          return true end }))\n      \n        delay(0.5)\n      end\n      G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.2,func = function() G.hand:unhighlight_all(); return true end }))\n    end,\n    \n    -- set_badges = function (self, card, badges)\n    --   SMODS.create_mod_badges({ mod = SMODS.find_mod(\"Yahimod\")[1] }, badges)\n    -- end,",
      "config": {
        "max_highlighted": 1,
        "extra": "vampire"
      },
      "ability": {
        "max_highlighted": 1,
        "extra": "vampire"
      },
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Edition",
      "key": "faithful",
      "atlas": null,
      "pos": null,
      "raw": "key = \"faithful\",\n    order = 99,\n    loc_txt = {\n      name = \"Faithful\",\n      label = \"Faithful\",\n      text = {\n        \"{X:dark_edition,C:white}^^1.01{} Chips\",\n      }\n    },\n    weight = 2, -- idk what number this would be\n    shader = \"faithful\",\n    in_shop = true,\n    extra_cost = 7,\n    config = { ee_chips = 1.01 },\n    sound = {\n      sound = \"mf_e_faithful\",\n      per = 1,\n      vol = 0.,\n    },\n    loc_vars = function(self, info_queue, center)\n      info_queue[#info_queue+1] = { key = \"tetr_explainer\", set=\"Other\", specific_vars = { center.ability.val, center.ability.val - 1 } }\n      return {vars = { } }\n    end,\n\n    get_weight = function(self)\n      return G.GAME.edition_rate * self.weight\n    end,\n    loc_vars = function(self, info_queue)\n      return { vars = { self.config.e_chips } }\n    end,\n    calculate = function(self, card, context)\n      if\n        (\n          context.edition -- for when on jonklers\n          and context.cardarea == G.jokers -- checks if should trigger\n          and card.config.trigger -- fixes double trigger\n        ) or (\n          context.main_scoring -- for when on playing cards\n          and context.cardarea == G.play\n        )\n      then\n        if Talisman then\n          return {\n            eechips = self.config.ee_chips,\n          }\n        else\n          return {\n            Xchips_mod = hand_chips ^ hand_chips ^ (self.config.ee_chips - 1),\n            message = \"^^\"..self.config.ee_chips..\" Chips\",\n            colour = G.C.DARK_EDITION\n          }\n        end\n      end\n      if context.joker_main then\n        card.config.trigger = true -- context.edition triggers twice, this makes it only trigger once (only for jonklers)\n      end\n\n      if context.after then\n        card.config.trigger = nil\n      end\n    end,",
      "config": {
        "ee_chips": 1.01
      },
      "ability": {
        "ee_chips": 1.01
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "modded_normal_1",
      "atlas": "mf_packs",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"modded_normal_1\",\n    kind = \"Modded\",\n    atlas = \"mf_packs\",\n    pos = { x = 0, y = 1 },\n    config = { extra = 2, choose = 1, modded_pack = true },\n    cost = 6,\n    weight = 0.96,\n    unlocked = true,\n    discovered = true,\n    create_card = function(self, card)\n      -- ah shit.\n      function temp_ban_joker(key)\n        if G.GAME.banned_keys[key] == true then\n          G.GAME.banned_keys[key] = 214389\n        end\n        if not G.GAME.banned_keys[key] then \n          G.GAME.banned_keys[key] = 214389\n        elseif G.GAME.banned_keys[key] % 214389 == 0 then\n          G.GAME.banned_keys[key] = G.GAME.banned_keys[key] + 214389\n        end\n      end\n      function temp_unban_joker(key)\n        if G.GAME.banned_keys[key] == 214389 then\n          G.GAME.banned_keys[key] = nil\n        elseif G.GAME.banned_keys[key] % 214389 == 0 then \n          G.GAME.banned_keys[key] = G.GAME.banned_keys[key] - 214389\n        end\n      end\n      local vanilla_jokers = {\"j_joker\", \"j_greedy_joker\", \"j_lusty_joker\", \"j_wrathful_joker\", \"j_gluttenous_joker\", \"j_jolly\", \"j_zany\", \"j_mad\", \"j_crazy\", \"j_droll\", \"j_sly\", \"j_wily\", \"j_clever\", \"j_devious\", \"j_crafty\", \"j_half\", \"j_stencil\", \"j_four_fingers\", \"j_mime\", \"j_credit_card\", \"j_ceremonial\", \"j_banner\", \"j_mystic_summit\", \"j_marble\", \"j_loyalty_card\", \"j_8_ball\", \"j_misprint\", \"j_dusk\", \"j_raised_fist\", \"j_chaos\", \"j_fibonacci\", \"j_steel_joker\", \"j_scary_face\", \"j_abstract\", \"j_delayed_grat\", \"j_hack\", \"j_pareidolia\", \"j_gros_michel\", \"j_even_steven\", \"j_odd_todd\", \"j_scholar\", \"j_business\", \"j_supernova\", \"j_ride_the_bus\", \"j_space\", \"j_egg\", \"j_burglar\", \"j_blackboard\", \"j_runner\", \"j_ice_cream\", \"j_dna\", \"j_splash\", \"j_blue_joker\", \"j_sixth_sense\", \"j_constellation\", \"j_hiker\", \"j_faceless\", \"j_green_joker\", \"j_superposition\", \"j_todo_list\", \"j_cavendish\", \"j_card_sharp\", \"j_red_card\", \"j_madness\", \"j_square\", \"j_seance\", \"j_riff_raff\", \"j_vampire\", \"j_shortcut\", \"j_hologram\", \"j_vagabond\", \"j_baron\", \"j_cloud_9\", \"j_rocket\", \"j_obelisk\", \"j_midas_mask\", \"j_luchador\", \"j_photograph\", \"j_gift\", \"j_turtle_bean\", \"j_erosion\", \"j_reserved_parking\", \"j_mail\", \"j_to_the_moon\", \"j_hallucination\", \"j_fortune_teller\", \"j_juggler\", \"j_drunkard\", \"j_stone\", \"j_golden\", \"j_lucky_cat\", \"j_baseball\", \"j_bull\", \"j_diet_cola\", \"j_trading\", \"j_flash\", \"j_popcorn\", \"j_trousers\", \"j_ancient\", \"j_ramen\", \"j_walkie_talkie\", \"j_selzer\", \"j_castle\", \"j_smiley\", \"j_campfire\", \"j_ticket\", \"j_mr_bones\", \"j_acrobat\", \"j_sock_and_buskin\", \"j_swashbuckler\", \"j_troubadour\", \"j_certificate\", \"j_smeared\", \"j_throwback\", \"j_hanging_chad\", \"j_rough_gem\", \"j_bloodstone\", \"j_arrowhead\", \"j_onyx_agate\", \"j_glass\", \"j_ring_master\", \"j_flower_pot\", \"j_blueprint\", \"j_wee\", \"j_merry_andy\", \"j_oops\", \"j_idol\", \"j_seeing_double\", \"j_matador\", \"j_hit_the_road\", \"j_duo\", \"j_trio\", \"j_family\", \"j_order\", \"j_tribe\", \"j_stuntman\", \"j_invisible\", \"j_brainstorm\", \"j_satellite\", \"j_shoot_the_moon\", \"j_drivers_license\", \"j_cartomancer\", \"j_astronomer\", \"j_burnt\", \"j_bootstraps\", \"j_caino\", \"j_triboulet\", \"j_yorick\", \"j_chicot\", \"j_perkeo\"}\n      for i = 1, #vanilla_jokers do\n        temp_ban_joker(vanilla_jokers[i])\n      end\n      local n_card = create_card(\"Joker\", G.pack_cards, nil, nil, true, true, nil, \"mf_modded\")\n      -- local ed = poll_edition(\"mod_pack\", 4, false, false)\n      -- n_card:set_edition(ed)\n      for i = 1, #vanilla_jokers do\n        temp_unban_joker(vanilla_jokers[i])\n      end\n      return n_card\n    end,\n    loc_vars = function(self, info_queue, card)\n      return { vars = { card.config.center.config.choose, card.ability.extra } }\n    end,\n    group_key = \"k_modded_pack\",",
      "config": {
        "extra": 2,
        "choose": 1,
        "modded_pack": true
      },
      "ability": {
        "extra": 2,
        "choose": 1,
        "modded_pack": true
      },
      "vars": [
        null,
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "modded_normal_2",
      "atlas": "mf_packs",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"modded_normal_2\",\n    kind = \"Modded\",\n    atlas = \"mf_packs\",\n    pos = { x = 1, y = 1 },\n    config = { extra = 2, choose = 1, modded_pack = true },\n    cost = 6,\n    weight = 0.96,\n    unlocked = true,\n    discovered = true,\n    create_card = function(self, card)\n      -- ah shit.\n      function temp_ban_joker(key)\n        if G.GAME.banned_keys[key] == true then\n          G.GAME.banned_keys[key] = 214389\n        end\n        if not G.GAME.banned_keys[key] then \n          G.GAME.banned_keys[key] = 214389\n        elseif G.GAME.banned_keys[key] % 214389 == 0 then\n          G.GAME.banned_keys[key] = G.GAME.banned_keys[key] + 214389\n        end\n      end\n      function temp_unban_joker(key)\n        if G.GAME.banned_keys[key] == 214389 then\n          G.GAME.banned_keys[key] = nil\n        elseif G.GAME.banned_keys[key] % 214389 == 0 then \n          G.GAME.banned_keys[key] = G.GAME.banned_keys[key] - 214389\n        end\n      end\n      local vanilla_jokers = {\"j_joker\", \"j_greedy_joker\", \"j_lusty_joker\", \"j_wrathful_joker\", \"j_gluttenous_joker\", \"j_zany\", \"j_mad\", \"j_crazy\", \"j_droll\", \"j_sly\", \"j_wily\", \"j_clever\", \"j_devious\", \"j_crafty\", \"j_half\", \"j_stencil\", \"j_four_fingers\", \"j_mime\", \"j_credit_card\", \"j_ceremonial\", \"j_banner\", \"j_mystic_summit\", \"j_marble\", \"j_loyalty_card\", \"j_8_ball\", \"j_misprint\", \"j_dusk\", \"j_raised_fist\", \"j_chaos\", \"j_fibonacci\", \"j_steel_joker\", \"j_scary_face\", \"j_abstract\", \"j_delayed_grat\", \"j_hack\", \"j_pareidolia\", \"j_gros_michel\", \"j_even_steven\", \"j_odd_todd\", \"j_scholar\", \"j_business\", \"j_supernova\", \"j_ride_the_bus\", \"j_space\", \"j_egg\", \"j_burglar\", \"j_blackboard\", \"j_runner\", \"j_ice_cream\", \"j_dna\", \"j_splash\", \"j_blue_joker\", \"j_sixth_sense\", \"j_constellation\", \"j_hiker\", \"j_faceless\", \"j_green_joker\", \"j_superposition\", \"j_todo_list\", \"j_cavendish\", \"j_card_sharp\", \"j_red_card\", \"j_madness\", \"j_square\", \"j_seance\", \"j_riff_raff\", \"j_vampire\", \"j_shortcut\", \"j_hologram\", \"j_vagabond\", \"j_baron\", \"j_cloud_9\", \"j_rocket\", \"j_obelisk\", \"j_midas_mask\", \"j_luchador\", \"j_photograph\", \"j_gift\", \"j_turtle_bean\", \"j_erosion\", \"j_reserved_parking\", \"j_mail\", \"j_to_the_moon\", \"j_hallucination\", \"j_fortune_teller\", \"j_juggler\", \"j_drunkard\", \"j_stone\", \"j_golden\", \"j_lucky_cat\", \"j_baseball\", \"j_bull\", \"j_diet_cola\", \"j_trading\", \"j_flash\", \"j_popcorn\", \"j_trousers\", \"j_ancient\", \"j_ramen\", \"j_walkie_talkie\", \"j_selzer\", \"j_castle\", \"j_smiley\", \"j_campfire\", \"j_ticket\", \"j_mr_bones\", \"j_acrobat\", \"j_sock_and_buskin\", \"j_swashbuckler\", \"j_troubadour\", \"j_certificate\", \"j_smeared\", \"j_throwback\", \"j_hanging_chad\", \"j_rough_gem\", \"j_bloodstone\", \"j_arrowhead\", \"j_onyx_agate\", \"j_glass\", \"j_ring_master\", \"j_flower_pot\", \"j_blueprint\", \"j_wee\", \"j_merry_andy\", \"j_oops\", \"j_idol\", \"j_seeing_double\", \"j_matador\", \"j_hit_the_road\", \"j_duo\", \"j_trio\", \"j_family\", \"j_order\", \"j_tribe\", \"j_stuntman\", \"j_invisible\", \"j_brainstorm\", \"j_satellite\", \"j_shoot_the_moon\", \"j_drivers_license\", \"j_cartomancer\", \"j_astronomer\", \"j_burnt\", \"j_bootstraps\", \"j_caino\", \"j_triboulet\", \"j_yorick\", \"j_chicot\", \"j_perkeo\"}\n      for i = 1, #vanilla_jokers do\n        temp_ban_joker(vanilla_jokers[i])\n      end\n      local n_card = create_card(\"Joker\", G.pack_cards, nil, nil, true, true, nil, \"mf_modded\")\n      -- local ed = poll_edition(\"mod_pack\", 4, false, false)\n      -- n_card:set_edition(ed)\n      for i = 1, #vanilla_jokers do\n        temp_unban_joker(vanilla_jokers[i])\n      end\n      return n_card\n    end,\n    loc_vars = function(self, info_queue, card)\n      return { vars = { card.config.center.config.choose, card.ability.extra } }\n    end,\n    group_key = \"k_modded_pack\",",
      "config": {
        "extra": 2,
        "choose": 1,
        "modded_pack": true
      },
      "ability": {
        "extra": 2,
        "choose": 1,
        "modded_pack": true
      },
      "vars": [
        null,
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "modded_jumbo_1",
      "atlas": "mf_packs",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"modded_jumbo_1\",\n    kind = \"Modded\",\n    atlas = \"mf_packs\",\n    pos = { x = 2, y = 1 },\n    config = { extra = 4, choose = 1, modded_pack = true },\n    cost = 10,\n    weight = 0.96,\n    unlocked = true,\n    discovered = true,\n    create_card = function(self, card)\n      -- ah shit.\n      function temp_ban_joker(key)\n        if G.GAME.banned_keys[key] == true then\n          G.GAME.banned_keys[key] = 214389\n        end\n        if not G.GAME.banned_keys[key] then \n          G.GAME.banned_keys[key] = 214389\n        elseif G.GAME.banned_keys[key] % 214389 == 0 then\n          G.GAME.banned_keys[key] = G.GAME.banned_keys[key] + 214389\n        end\n      end\n      function temp_unban_joker(key)\n        if G.GAME.banned_keys[key] == 214389 then\n          G.GAME.banned_keys[key] = nil\n        elseif G.GAME.banned_keys[key] % 214389 == 0 then \n          G.GAME.banned_keys[key] = G.GAME.banned_keys[key] - 214389\n        end\n      end\n      local vanilla_jokers = {\"j_joker\", \"j_greedy_joker\", \"j_lusty_joker\", \"j_wrathful_joker\", \"j_gluttenous_joker\", \"j_zany\", \"j_mad\", \"j_crazy\", \"j_droll\", \"j_sly\", \"j_wily\", \"j_clever\", \"j_devious\", \"j_crafty\", \"j_half\", \"j_stencil\", \"j_four_fingers\", \"j_mime\", \"j_credit_card\", \"j_ceremonial\", \"j_banner\", \"j_mystic_summit\", \"j_marble\", \"j_loyalty_card\", \"j_8_ball\", \"j_misprint\", \"j_dusk\", \"j_raised_fist\", \"j_chaos\", \"j_fibonacci\", \"j_steel_joker\", \"j_scary_face\", \"j_abstract\", \"j_delayed_grat\", \"j_hack\", \"j_pareidolia\", \"j_gros_michel\", \"j_even_steven\", \"j_odd_todd\", \"j_scholar\", \"j_business\", \"j_supernova\", \"j_ride_the_bus\", \"j_space\", \"j_egg\", \"j_burglar\", \"j_blackboard\", \"j_runner\", \"j_ice_cream\", \"j_dna\", \"j_splash\", \"j_blue_joker\", \"j_sixth_sense\", \"j_constellation\", \"j_hiker\", \"j_faceless\", \"j_green_joker\", \"j_superposition\", \"j_todo_list\", \"j_cavendish\", \"j_card_sharp\", \"j_red_card\", \"j_madness\", \"j_square\", \"j_seance\", \"j_riff_raff\", \"j_vampire\", \"j_shortcut\", \"j_hologram\", \"j_vagabond\", \"j_baron\", \"j_cloud_9\", \"j_rocket\", \"j_obelisk\", \"j_midas_mask\", \"j_luchador\", \"j_photograph\", \"j_gift\", \"j_turtle_bean\", \"j_erosion\", \"j_reserved_parking\", \"j_mail\", \"j_to_the_moon\", \"j_hallucination\", \"j_fortune_teller\", \"j_juggler\", \"j_drunkard\", \"j_stone\", \"j_golden\", \"j_lucky_cat\", \"j_baseball\", \"j_bull\", \"j_diet_cola\", \"j_trading\", \"j_flash\", \"j_popcorn\", \"j_trousers\", \"j_ancient\", \"j_ramen\", \"j_walkie_talkie\", \"j_selzer\", \"j_castle\", \"j_smiley\", \"j_campfire\", \"j_ticket\", \"j_mr_bones\", \"j_acrobat\", \"j_sock_and_buskin\", \"j_swashbuckler\", \"j_troubadour\", \"j_certificate\", \"j_smeared\", \"j_throwback\", \"j_hanging_chad\", \"j_rough_gem\", \"j_bloodstone\", \"j_arrowhead\", \"j_onyx_agate\", \"j_glass\", \"j_ring_master\", \"j_flower_pot\", \"j_blueprint\", \"j_wee\", \"j_merry_andy\", \"j_oops\", \"j_idol\", \"j_seeing_double\", \"j_matador\", \"j_hit_the_road\", \"j_duo\", \"j_trio\", \"j_family\", \"j_order\", \"j_tribe\", \"j_stuntman\", \"j_invisible\", \"j_brainstorm\", \"j_satellite\", \"j_shoot_the_moon\", \"j_drivers_license\", \"j_cartomancer\", \"j_astronomer\", \"j_burnt\", \"j_bootstraps\", \"j_caino\", \"j_triboulet\", \"j_yorick\", \"j_chicot\", \"j_perkeo\"}\n      for i = 1, #vanilla_jokers do\n        temp_ban_joker(vanilla_jokers[i])\n      end\n      local n_card = create_card(\"Joker\", G.pack_cards, nil, nil, true, true, nil, \"mf_colour\")\n      -- local ed = poll_edition(\"mod_pack\", 4, false, false)\n      -- n_card:set_edition(ed)\n      for i = 1, #vanilla_jokers do\n        temp_unban_joker(vanilla_jokers[i])\n      end\n      return n_card\n    end,\n    loc_vars = function(self, info_queue, card)\n      return { vars = { card.config.center.config.choose, card.ability.extra } }\n    end,\n    group_key = \"k_modded_pack\",",
      "config": {
        "extra": 4,
        "choose": 1,
        "modded_pack": true
      },
      "ability": {
        "extra": 4,
        "choose": 1,
        "modded_pack": true
      },
      "vars": [
        null,
        4
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "modded_mega_1",
      "atlas": "mf_packs",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"modded_mega_1\",\n    kind = \"Modded\",\n    atlas = \"mf_packs\",\n    pos = { x = 3, y = 1 },\n    config = { extra = 4, choose = 2, modded_pack = true },\n    cost = 14,\n    weight = 0.96,\n    unlocked = true,\n    discovered = true,\n    create_card = function(self, card)\n      -- ah shit.\n      function temp_ban_joker(key)\n        if G.GAME.banned_keys[key] == true then\n          G.GAME.banned_keys[key] = 214389\n        end\n        if not G.GAME.banned_keys[key] then \n          G.GAME.banned_keys[key] = 214389\n        elseif G.GAME.banned_keys[key] % 214389 == 0 then\n          G.GAME.banned_keys[key] = G.GAME.banned_keys[key] + 214389\n        end\n      end\n      function temp_unban_joker(key)\n        if G.GAME.banned_keys[key] == 214389 then\n          G.GAME.banned_keys[key] = nil\n        elseif G.GAME.banned_keys[key] % 214389 == 0 then \n          G.GAME.banned_keys[key] = G.GAME.banned_keys[key] - 214389\n        end\n      end\n      local vanilla_jokers = {\"j_joker\", \"j_greedy_joker\", \"j_lusty_joker\", \"j_wrathful_joker\", \"j_gluttenous_joker\", \"j_zany\", \"j_mad\", \"j_crazy\", \"j_droll\", \"j_sly\", \"j_wily\", \"j_clever\", \"j_devious\", \"j_crafty\", \"j_half\", \"j_stencil\", \"j_four_fingers\", \"j_mime\", \"j_credit_card\", \"j_ceremonial\", \"j_banner\", \"j_mystic_summit\", \"j_marble\", \"j_loyalty_card\", \"j_8_ball\", \"j_misprint\", \"j_dusk\", \"j_raised_fist\", \"j_chaos\", \"j_fibonacci\", \"j_steel_joker\", \"j_scary_face\", \"j_abstract\", \"j_delayed_grat\", \"j_hack\", \"j_pareidolia\", \"j_gros_michel\", \"j_even_steven\", \"j_odd_todd\", \"j_scholar\", \"j_business\", \"j_supernova\", \"j_ride_the_bus\", \"j_space\", \"j_egg\", \"j_burglar\", \"j_blackboard\", \"j_runner\", \"j_ice_cream\", \"j_dna\", \"j_splash\", \"j_blue_joker\", \"j_sixth_sense\", \"j_constellation\", \"j_hiker\", \"j_faceless\", \"j_green_joker\", \"j_superposition\", \"j_todo_list\", \"j_cavendish\", \"j_card_sharp\", \"j_red_card\", \"j_madness\", \"j_square\", \"j_seance\", \"j_riff_raff\", \"j_vampire\", \"j_shortcut\", \"j_hologram\", \"j_vagabond\", \"j_baron\", \"j_cloud_9\", \"j_rocket\", \"j_obelisk\", \"j_midas_mask\", \"j_luchador\", \"j_photograph\", \"j_gift\", \"j_turtle_bean\", \"j_erosion\", \"j_reserved_parking\", \"j_mail\", \"j_to_the_moon\", \"j_hallucination\", \"j_fortune_teller\", \"j_juggler\", \"j_drunkard\", \"j_stone\", \"j_golden\", \"j_lucky_cat\", \"j_baseball\", \"j_bull\", \"j_diet_cola\", \"j_trading\", \"j_flash\", \"j_popcorn\", \"j_trousers\", \"j_ancient\", \"j_ramen\", \"j_walkie_talkie\", \"j_selzer\", \"j_castle\", \"j_smiley\", \"j_campfire\", \"j_ticket\", \"j_mr_bones\", \"j_acrobat\", \"j_sock_and_buskin\", \"j_swashbuckler\", \"j_troubadour\", \"j_certificate\", \"j_smeared\", \"j_throwback\", \"j_hanging_chad\", \"j_rough_gem\", \"j_bloodstone\", \"j_arrowhead\", \"j_onyx_agate\", \"j_glass\", \"j_ring_master\", \"j_flower_pot\", \"j_blueprint\", \"j_wee\", \"j_merry_andy\", \"j_oops\", \"j_idol\", \"j_seeing_double\", \"j_matador\", \"j_hit_the_road\", \"j_duo\", \"j_trio\", \"j_family\", \"j_order\", \"j_tribe\", \"j_stuntman\", \"j_invisible\", \"j_brainstorm\", \"j_satellite\", \"j_shoot_the_moon\", \"j_drivers_license\", \"j_cartomancer\", \"j_astronomer\", \"j_burnt\", \"j_bootstraps\", \"j_caino\", \"j_triboulet\", \"j_yorick\", \"j_chicot\", \"j_perkeo\"}\n      for i = 1, #vanilla_jokers do\n        temp_ban_joker(vanilla_jokers[i])\n      end\n      local n_card = create_card(\"Joker\", G.pack_cards, nil, nil, true, true, nil, \"mf_colour\")\n      -- local ed = poll_edition(\"mod_pack\", 4, false, false)\n      -- n_card:set_edition(ed, true, false)\n      for i = 1, #vanilla_jokers do\n        temp_unban_joker(vanilla_jokers[i])\n      end\n      return n_card\n    end,\n    loc_vars = function(self, info_queue, card)\n      return { vars = { card.config.center.config.choose, card.ability.extra } }\n    end,\n    group_key = \"k_modded_pack\",",
      "config": {
        "extra": 4,
        "choose": 2,
        "modded_pack": true
      },
      "ability": {
        "extra": 4,
        "choose": 2,
        "modded_pack": true
      },
      "vars": [
        null,
        4
      ],
      "infoQueue": []
    },
    {
      "type": "Tag",
      "key": "moddedpack",
      "atlas": "mf_tags",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"moddedpack\",\n    atlas = \"mf_tags\",\n    pos = { x = 0, y = 1 },\n    unlocked = true,\n    discovered = true,\n    loc_vars = function(self, info_queue)\n      info_queue[#info_queue + 1] = { set = \"Other\", key = \"p_mf_modded_jumbo_1\", specific_vars = { 1, 4 } }\n      return { vars = {} }\n    end,\n    apply = function(self, tag, context)\n      if context.type == \"new_blind_choice\" then\n        tag:yep(\"+\", G.C.SECONDARY_SET.Code, function()\n          local key = \"p_mf_modded_jumbo_1\"\n          local card = Card(\n            G.play.T.x + G.play.T.w / 2 - G.CARD_W * 1.27 / 2,\n            G.play.T.y + G.play.T.h / 2 - G.CARD_H * 1.27 / 2,\n            G.CARD_W * 1.27,\n            G.CARD_H * 1.27,\n            G.P_CARDS.empty,\n            G.P_CENTERS[key],\n            { bypass_discovery_center = true, bypass_discovery_ui = true }\n          )\n          card.cost = 0\n          card.from_tag = true\n          G.FUNCS.use_card({ config = { ref_table = card } })\n          -- uh. should this be here??\n          if G.GAME.modifiers.cry_force_edition and not G.GAME.modifiers.cry_force_random_edition then\n            card:set_edition(nil, true, true)\n          elseif G.GAME.modifiers.cry_force_random_edition then\n            local edition = Cryptid.poll_random_edition()\n            card:set_edition(edition, true, true)\n          end\n          card:start_materialize()\n          return true\n        end)\n        tag.triggered = true\n        return true\n      end\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Tag",
      "key": "emoddedpack",
      "atlas": "mf_ascendant_tags",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"emoddedpack\",\n      atlas = \"mf_ascendant_tags\",\n      pos = { x = 0, y = 1 },\n      unlocked = true,\n      discovered = true,\n      loc_vars = function(self, info_queue)\n        info_queue[#info_queue + 1] = { set = \"Other\", key = \"p_mf_modded_jumbo_1\", specific_vars = { 1, 4 } }\n        return { vars = {} }\n      end,\n\t    in_pool = function() return false end or nil,\n      apply = function(self, tag, context)\n        if context.type == \"new_blind_choice\" then\n          tag:yep(\"+\", G.C.SECONDARY_SET.Code, function()\n            local key = \"p_mf_modded_jumbo_1\"\n            local card = Card(\n              G.play.T.x + G.play.T.w / 2 - G.CARD_W * 1.27 / 2,\n              G.play.T.y + G.play.T.h / 2 - G.CARD_H * 1.27 / 2,\n              G.CARD_W * 1.27,\n              G.CARD_H * 1.27,\n              G.P_CARDS.empty,\n              G.P_CENTERS[key],\n              { bypass_discovery_center = true, bypass_discovery_ui = true }\n            )\n            card:set_edition(pseudorandom_element(G.P_CENTER_POOLS.Edition, pseudoseed(\"entr_saint\")).key)\n            card.cost = 0\n            card.from_tag = true\n            G.FUNCS.use_card({ config = { ref_table = card } })\n            if G.GAME.modifiers.cry_force_edition and not G.GAME.modifiers.cry_force_random_edition then\n              card:set_edition(nil, true, true)\n            elseif G.GAME.modifiers.cry_force_random_edition then\n              local edition = Cryptid.poll_random_edition()\n              card:set_edition(edition, true, true)\n            end\n            card:start_materialize()\n            return true\n          end)\n          tag.triggered = true\n          return true\n        end\n      end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "jimbophone",
      "atlas": "mf_oddities",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Oddity\",\n    name = \"odd-jimbophone\",\n    key = \"jimbophone\",\n    pos = { x = 1, y = 0 },\n    config = {\n      val = 1,\n    },\n    cost = 3,\n    rarity = 1,\n    atlas = \"mf_oddities\",\n    unlocked = true,\n    discovered = true,\n    can_use = function(self, card)\n      return true\n    end,\n    use = function(self, card, area, copier)\n      for i = 1, card.ability.val do\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n          play_sound('timpani')\n          local n_card = create_card(nil,G.jokers, nil, nil, nil, nil, 'j_joker', 'sup')\n          n_card:add_to_deck()\n          G.jokers:emplace(n_card)\n          card:juice_up(0.3, 0.5)\n          return true end }))\n      end\n      delay(0.6)\n    end,\n    loc_vars = function(self, info_queue, card)\n      return { vars = {card.ability.val} }\n    end",
      "config": {
        "val": 1
      },
      "ability": {
        "val": 1
      },
      "vars": [
        1
      ],
      "infoQueue": []
    },
    {
      "type": "ConsumableType",
      "key": "Rotarot",
      "atlas": null,
      "pos": null,
      "raw": "key = \"Rotarot\",\n    primary_colour = HEX(\"8e73d9\"),\n    secondary_colour = HEX(\"8e73d9\"),\n    collection_rows = { 5, 6 },\n    shop_rate = 2.0,\n    loc_txt = {},\n    default = \"c_mf_rot_strength\",\n    can_stack = true,\n    can_divide = true,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "UndiscoveredSprite",
      "key": "Rotarot",
      "atlas": "mf_rotarots",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"Rotarot\",\n    atlas = \"mf_rotarots\",\n    path = \"mf_rotarots.png\",\n    pos = { x = 0, y = 0 },\n    px = 107,\n    py = 107,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "rotarot_normal_1",
      "atlas": "mf_rotarotpacks",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"rotarot_normal_1\",\n    kind = \"Rotarot\",\n    atlas = \"mf_rotarotpacks\",\n    display_size = { w = 106, h = 106 },\n    -- pixel_size = { w = 106, h = 106 },\n    pos = { x = 0, y = 0 },\n    config = { extra = 3, choose = 1 },\n    draw_hand = true,\n    cost = 4,\n    weight = 0.96,\n    unlocked = true,\n    discovered = true,\n    create_card = function(self, card)\n      local n_card = create_card(\"Rotarot\", G.pack_cards, nil, nil, true, true, nil, \"mf_rotarot\")\n      return n_card\n    end,\n    ease_background_colour = function(self)\n      ease_colour(G.C.DYN_UI.MAIN, G.C.SECONDARY_SET.Rotarot)\n      ease_background_colour({ new_colour = G.C.SECONDARY_SET.Rotarot, special_colour = G.C.BLACK, contrast = 2 })\n    end,\n    loc_vars = function(self, info_queue, card)\n      return { vars = { card.config.center.config.choose, card.ability.extra } }\n    end,\n    group_key = \"k_rotarot_pack\",",
      "config": {
        "extra": 3,
        "choose": 1
      },
      "ability": {
        "extra": 3,
        "choose": 1
      },
      "vars": [
        null,
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "rotarot_normal_2",
      "atlas": "mf_rotarotpacks",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"rotarot_normal_2\",\n    kind = \"Rotarot\",\n    atlas = \"mf_rotarotpacks\",\n    display_size = { w = 106, h = 106 },\n    -- pixel_size = { w = 106, h = 106 },\n    pos = { x = 1, y = 0 },\n    config = { extra = 3, choose = 1 },\n    draw_hand = true,\n    cost = 4,\n    weight = 0.96,\n    unlocked = true,\n    discovered = true,\n    create_card = function(self, card)\n      local n_card = create_card(\"Rotarot\", G.pack_cards, nil, nil, true, true, nil, \"mf_rotarot\")\n      return n_card\n    end,\n    ease_background_colour = function(self)\n      ease_colour(G.C.DYN_UI.MAIN, G.C.SECONDARY_SET.Rotarot)\n      ease_background_colour({ new_colour = G.C.SECONDARY_SET.Rotarot, special_colour = G.C.BLACK, contrast = 2 })\n    end,\n    loc_vars = function(self, info_queue, card)\n      return { vars = { card.config.center.config.choose, card.ability.extra } }\n    end,\n    group_key = \"k_rotarot_pack\",",
      "config": {
        "extra": 3,
        "choose": 1
      },
      "ability": {
        "extra": 3,
        "choose": 1
      },
      "vars": [
        null,
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "rotarot_normal_3",
      "atlas": "mf_rotarotpacks",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"rotarot_normal_3\",\n    kind = \"Rotarot\",\n    atlas = \"mf_rotarotpacks\",\n    display_size = { w = 106, h = 106 },\n    -- pixel_size = { w = 106, h = 106 },\n    pos = { x = 2, y = 0 },\n    config = { extra = 3, choose = 1 },\n    draw_hand = true,\n    cost = 4,\n    weight = 0.96,\n    unlocked = true,\n    discovered = true,\n    create_card = function(self, card)\n      local n_card = create_card(\"Rotarot\", G.pack_cards, nil, nil, true, true, nil, \"mf_rotarot\")\n      return n_card\n    end,\n    ease_background_colour = function(self)\n      ease_colour(G.C.DYN_UI.MAIN, G.C.SECONDARY_SET.Rotarot)\n      ease_background_colour({ new_colour = G.C.SECONDARY_SET.Rotarot, special_colour = G.C.BLACK, contrast = 2 })\n    end,\n    loc_vars = function(self, info_queue, card)\n      return { vars = { card.config.center.config.choose, card.ability.extra } }\n    end,\n    group_key = \"k_rotarot_pack\",",
      "config": {
        "extra": 3,
        "choose": 1
      },
      "ability": {
        "extra": 3,
        "choose": 1
      },
      "vars": [
        null,
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "rotarot_normal_4",
      "atlas": "mf_rotarotpacks",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"rotarot_normal_4\",\n    kind = \"Rotarot\",\n    atlas = \"mf_rotarotpacks\",\n    display_size = { w = 106, h = 106 },\n    -- pixel_size = { w = 106, h = 106 },\n    pos = { x = 3, y = 0 },\n    config = { extra = 3, choose = 1 },\n    draw_hand = true,\n    cost = 4,\n    weight = 0.96,\n    unlocked = true,\n    discovered = true,\n    create_card = function(self, card)\n      local n_card = create_card(\"Rotarot\", G.pack_cards, nil, nil, true, true, nil, \"mf_rotarot\")\n      return n_card\n    end,\n    ease_background_colour = function(self)\n      ease_colour(G.C.DYN_UI.MAIN, G.C.SECONDARY_SET.Rotarot)\n      ease_background_colour({ new_colour = G.C.SECONDARY_SET.Rotarot, special_colour = G.C.BLACK, contrast = 2 })\n    end,\n    loc_vars = function(self, info_queue, card)\n      return { vars = { card.config.center.config.choose, card.ability.extra } }\n    end,\n    group_key = \"k_rotarot_pack\",",
      "config": {
        "extra": 3,
        "choose": 1
      },
      "ability": {
        "extra": 3,
        "choose": 1
      },
      "vars": [
        null,
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "rotarot_jumbo_1",
      "atlas": "mf_rotarotpacks",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"rotarot_jumbo_1\",\n    kind = \"Rotarot\",\n    atlas = \"mf_rotarotpacks\",\n    display_size = { w = 106, h = 106 },\n    -- pixel_size = { w = 106, h = 106 },\n    pos = { x = 0, y = 1 },\n    config = { extra = 5, choose = 1 },\n    draw_hand = true,\n    cost = 6,\n    weight = 0.96,\n    unlocked = true,\n    discovered = true,\n    create_card = function(self, card)\n      local n_card = create_card(\"Rotarot\", G.pack_cards, nil, nil, true, true, nil, \"mf_rotarot\")\n      return n_card\n    end,\n    ease_background_colour = function(self)\n      ease_colour(G.C.DYN_UI.MAIN, G.C.SECONDARY_SET.Rotarot)\n      ease_background_colour({ new_colour = G.C.SECONDARY_SET.Rotarot, special_colour = G.C.BLACK, contrast = 2 })\n    end,\n    loc_vars = function(self, info_queue, card)\n      return { vars = { card.config.center.config.choose, card.ability.extra } }\n    end,\n    group_key = \"k_rotarot_pack\",",
      "config": {
        "extra": 5,
        "choose": 1
      },
      "ability": {
        "extra": 5,
        "choose": 1
      },
      "vars": [
        null,
        5
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "rotarot_jumbo_2",
      "atlas": "mf_rotarotpacks",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "key = \"rotarot_jumbo_2\",\n    kind = \"Rotarot\",\n    atlas = \"mf_rotarotpacks\",\n    display_size = { w = 106, h = 106 },\n    -- pixel_size = { w = 106, h = 106 },\n    pos = { x = 1, y = 1 },\n    config = { extra = 5, choose = 1 },\n    draw_hand = true,\n    cost = 6,\n    weight = 0.96,\n    unlocked = true,\n    discovered = true,\n    create_card = function(self, card)\n      local n_card = create_card(\"Rotarot\", G.pack_cards, nil, nil, true, true, nil, \"mf_rotarot\")\n      return n_card\n    end,\n    ease_background_colour = function(self)\n      ease_colour(G.C.DYN_UI.MAIN, G.C.SECONDARY_SET.Rotarot)\n      ease_background_colour({ new_colour = G.C.SECONDARY_SET.Rotarot, special_colour = G.C.BLACK, contrast = 2 })\n    end,\n    loc_vars = function(self, info_queue, card)\n      return { vars = { card.config.center.config.choose, card.ability.extra } }\n    end,\n    group_key = \"k_rotarot_pack\",",
      "config": {
        "extra": 5,
        "choose": 1
      },
      "ability": {
        "extra": 5,
        "choose": 1
      },
      "vars": [
        null,
        5
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "rotarot_mega_1",
      "atlas": "mf_rotarotpacks",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "key = \"rotarot_mega_1\",\n    kind = \"Rotarot\",\n    atlas = \"mf_rotarotpacks\",\n    display_size = { w = 106, h = 106 },\n    -- pixel_size = { w = 106, h = 106 },\n    pos = { x = 2, y = 1 },\n    config = { extra = 5, choose = 2 },\n    draw_hand = true,\n    cost = 8,\n    weight = 0.48,\n    unlocked = true,\n    discovered = true,\n    create_card = function(self, card)\n      local n_card = create_card(\"Rotarot\", G.pack_cards, nil, nil, true, true, nil, \"mf_rotarot\")\n      return n_card\n    end,\n    ease_background_colour = function(self)\n      ease_colour(G.C.DYN_UI.MAIN, G.C.SECONDARY_SET.Rotarot)\n      ease_background_colour({ new_colour = G.C.SECONDARY_SET.Rotarot, special_colour = G.C.BLACK, contrast = 2 })\n    end,\n    loc_vars = function(self, info_queue, card)\n      return { vars = { card.config.center.config.choose, card.ability.extra } }\n    end,\n    group_key = \"k_rotarot_pack\",",
      "config": {
        "extra": 5,
        "choose": 2
      },
      "ability": {
        "extra": 5,
        "choose": 2
      },
      "vars": [
        null,
        5
      ],
      "infoQueue": []
    },
    {
      "type": "Booster",
      "key": "rotarot_mega_2",
      "atlas": "mf_rotarotpacks",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "key = \"rotarot_mega_2\",\n    kind = \"Rotarot\",\n    atlas = \"mf_rotarotpacks\",\n    display_size = { w = 106, h = 106 },\n    -- pixel_size = { w = 106, h = 106 },\n    pos = { x = 3, y = 1 },\n    config = { extra = 5, choose = 2 },\n    draw_hand = true,\n    cost = 8,\n    weight = 0.48,\n    unlocked = true,\n    discovered = true,\n    create_card = function(self, card)\n      local n_card = create_card(\"Rotarot\", G.pack_cards, nil, nil, true, true, nil, \"mf_rotarot\")\n      return n_card\n    end,\n    ease_background_colour = function(self)\n      ease_colour(G.C.DYN_UI.MAIN, G.C.SECONDARY_SET.Rotarot)\n      ease_background_colour({ new_colour = G.C.SECONDARY_SET.Rotarot, special_colour = G.C.BLACK, contrast = 2 })\n    end,\n    loc_vars = function(self, info_queue, card)\n      return { vars = { card.config.center.config.choose, card.ability.extra } }\n    end,\n    group_key = \"k_rotarot_pack\",",
      "config": {
        "extra": 5,
        "choose": 2
      },
      "ability": {
        "extra": 5,
        "choose": 2
      },
      "vars": [
        null,
        5
      ],
      "infoQueue": []
    },
    {
      "type": "Tag",
      "key": "rotarot",
      "atlas": "mf_tags",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "key = \"rotarot\",\n    atlas = \"mf_tags\",\n    pos = { x = 1, y = 0 },\n    unlocked = true,\n    discovered = true,\n    loc_vars = function(self, info_queue)\n      info_queue[#info_queue + 1] = { set = \"Other\", key = \"p_mf_rotarot_mega_1\", specific_vars = { 2, 5 } }\n      return { vars = {} }\n    end,\n    apply = function(self, tag, context)\n      if context.type == \"new_blind_choice\" then\n        tag:yep(\"+\", G.C.SECONDARY_SET.Code, function()\n          local key = \"p_mf_rotarot_mega_1\"\n          local card = Card(\n            G.play.T.x + G.play.T.w / 2 - G.CARD_W * 1.27 / 2,\n            G.play.T.y + G.play.T.h / 2 - G.CARD_H * 1.27 / 2,\n            G.CARD_W * 1.27,\n            G.CARD_H * 1.27,\n            G.P_CARDS.empty,\n            G.P_CENTERS[key],\n            { bypass_discovery_center = true, bypass_discovery_ui = true }\n          )\n          card.cost = 0\n          card.from_tag = true\n          G.FUNCS.use_card({ config = { ref_table = card } })\n          -- uh. should this be here??\n          if G.GAME.modifiers.cry_force_edition and not G.GAME.modifiers.cry_force_random_edition then\n            card:set_edition(nil, true, true)\n          elseif G.GAME.modifiers.cry_force_random_edition then\n            local edition = Cryptid.poll_random_edition()\n            card:set_edition(edition, true, true)\n          end\n          card:start_materialize()\n          return true\n        end)\n        tag.triggered = true\n        return true\n      end\n    end,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "rot_fool",
      "atlas": "mf_rotarots",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Rotarot\",\n    name = \"rot_Fool\",\n    key = \"rot_fool\",\n    pos = { x = 0, y = 0 },\n    config = {},\n    cost = 3,\n    atlas = \"mf_rotarots\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 107, h = 107 },\n    can_use = function(self, card)\n      if (#G.consumeables.cards < G.consumeables.config.card_limit or card.area == G.consumeables) \n          and G.GAME.last_rot_tarot_colour and G.GAME.last_rot_tarot_colour ~= 'c_mf_rot_fool' then return true end\n    end,\n    use = function(self, card, area, copier)\n      local used_tarot = copier or card\n      if G.GAME.last_rot_tarot_colour and G.GAME.last_rot_tarot_colour ~= \"c_mf_rot_fool\" then\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n          if G.consumeables.config.card_limit > #G.consumeables.cards then\n            play_sound('timpani')\n            local card = create_card('Rot_Tarot_Colour', G.consumeables, nil, nil, nil, nil, G.GAME.last_rot_tarot_colour, 'fool')\n            card:add_to_deck()\n            G.consumeables:emplace(card)\n            used_tarot:juice_up(0.3, 0.5)\n          end\n          return true end }))\n      end\n      delay(0.6)\n    end,\n    loc_vars = function(self, info_queue, card)\n      local fool_c = G.GAME.last_rot_tarot_colour and G.P_CENTERS[G.GAME.last_rot_tarot_colour] or nil\n      local last_tarot_planet = fool_c and localize{type = 'name_text', key = fool_c.key, set = fool_c.set} or localize('k_none')\n      local colour = (not fool_c or fool_c.name == 'rot_Fool') and G.C.RED or G.C.GREEN\n      loc_vars = {last_tarot_planet}\n      if not (not fool_c or fool_c.name == 'rot_Fool') then\n        info_queue[#info_queue+1] = fool_c\n      end\n\n      main_end = {\n        {n=G.UIT.C, config={align = \"bm\", padding = 0.02}, nodes={\n          {n=G.UIT.C, config={align = \"m\", colour = colour, r = 0.05, padding = 0.05}, nodes={\n            {n=G.UIT.T, config={text = ' '..last_tarot_planet..' ', colour = G.C.UI.TEXT_LIGHT, scale = 0.3, shadow = true}},\n          }}\n        }}\n      }\n      return { vars = {last_tarot_planet}, main_end = main_end }\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "rot_magician",
      "atlas": "mf_rotarots",
      "pos": {
        "x": 1,
        "y": 0
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Rotarot\",\n    name = \"rot_Magician\",\n    key = \"rot_magician\",\n    pos = { x = 1, y = 0 },\n    config = {\n      max_highlighted = 5,\n      mod_conv = \"m_mf_yucky\"\n    },\n    cost = 3,\n    atlas = \"mf_rotarots\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 107, h = 107 },\n    can_use = function(self, card)\n      return #G.hand.highlighted >= 1 and #G.hand.highlighted <= card.ability.max_highlighted\n    end,\n    loc_vars = function(self, info_queue, card)\n      info_queue[#info_queue + 1] = G.P_CENTERS.m_mf_yucky\n  \n      return { vars = { \n        card and card.ability.max_highlighted or self.config.max_highlighted,\n        localize{type = 'name_text', set = 'Enhanced', key = self.config.mod_conv}\n      } }\n    end",
      "config": {
        "max_highlighted": 5,
        "mod_conv": "m_mf_yucky"
      },
      "ability": {
        "max_highlighted": 5,
        "mod_conv": "m_mf_yucky"
      },
      "vars": [
        null,
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "rot_high_priestess",
      "atlas": "mf_rotarots",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "object_type = \"Consumable\",\n      set = \"Rotarot\",\n      name = \"rot_HighPriestess\",\n      key = \"rot_high_priestess\",\n      pos = { x = 2, y = 0 },\n      config = {\n        val = 2,\n      },\n      cost = 3,\n      atlas = \"mf_rotarots\",\n      unlocked = true,\n      discovered = true,\n      display_size = { w = 107, h = 107 },\n      can_use = function(self, card)\n        return #G.consumeables.cards < G.consumeables.config.card_limit or card.area == G.consumeables\n      end,\n      use = function(self, card, area, copier)\n        local used_tarot = copier or card\n        for i = 1, math.min(card.ability.val, G.consumeables.config.card_limit - #G.consumeables.cards) do\n          G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n            if G.consumeables.config.card_limit > #G.consumeables.cards then\n              play_sound('timpani')\n              local card = create_card(\"Colour\", G.consumeables, nil, nil, nil, nil, nil, \"pri\")\n              card:add_to_deck()\n              G.consumeables:emplace(card)\n              used_tarot:juice_up(0.3, 0.5)\n            end\n            return true end }))\n        end\n        delay(0.6)\n      end,\n      loc_vars = function(self, info_queue, card)\n        return { vars = {card.ability.val} }\n      end",
      "config": {
        "val": 2
      },
      "ability": {
        "val": 2
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "rot_empress",
      "atlas": "mf_rotarots",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Rotarot\",\n    name = \"rot_Empress\",\n    key = \"rot_empress\",\n    pos = { x = 3, y = 0 },\n    config = {\n      max_highlighted = 2,\n      mod_conv = \"m_mf_cult\"\n    },\n    cost = 3,\n    atlas = \"mf_rotarots\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 107, h = 107 },\n    can_use = function(self, card)\n      return #G.hand.highlighted >= 1 and #G.hand.highlighted <= card.ability.max_highlighted\n    end,\n    loc_vars = function(self, info_queue, card)\n      info_queue[#info_queue + 1] = G.P_CENTERS.m_mf_cult\n  \n      return { vars = { \n        card and card.ability.max_highlighted or self.config.max_highlighted,\n        localize{type = 'name_text', set = 'Enhanced', key = self.config.mod_conv}\n      } }\n    end",
      "config": {
        "max_highlighted": 2,
        "mod_conv": "m_mf_cult"
      },
      "ability": {
        "max_highlighted": 2,
        "mod_conv": "m_mf_cult"
      },
      "vars": [
        null,
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "rot_emperor",
      "atlas": "mf_rotarots",
      "pos": {
        "x": 4,
        "y": 0
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Rotarot\",\n    name = \"rot_Emperor\",\n    key = \"rot_emperor\",\n    pos = { x = 4, y = 0 },\n    config = {\n      val = 2,\n    },\n    cost = 3,\n    atlas = \"mf_rotarots\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 107, h = 107 },\n    can_use = function(self, card)\n      return #G.consumeables.cards < G.consumeables.config.card_limit or card.area == G.consumeables\n    end,\n    use = function(self, card, area, copier)\n      local used_tarot = copier or card\n      for i = 1, math.min(card.ability.val, G.consumeables.config.card_limit - #G.consumeables.cards) do\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n          if G.consumeables.config.card_limit > #G.consumeables.cards then\n            play_sound('timpani')\n            local card = create_card(\"Rotarot\", G.consumeables, nil, nil, nil, nil, nil, \"emp\")\n            card:add_to_deck()\n            G.consumeables:emplace(card)\n            used_tarot:juice_up(0.3, 0.5)\n          end\n          return true end }))\n      end\n      delay(0.6)\n    end,\n    loc_vars = function(self, info_queue, card)\n      return { vars = {card.ability.val} }\n    end",
      "config": {
        "val": 2
      },
      "ability": {
        "val": 2
      },
      "vars": [
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "rot_heirophant",
      "atlas": "mf_rotarots",
      "pos": {
        "x": 5,
        "y": 0
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Rotarot\",\n    name = \"rot_Heirophant\",\n    key = \"rot_heirophant\",\n    pos = { x = 5, y = 0 },\n    config = {\n      max_highlighted = 2,\n      mod_conv = \"m_mf_monus\"\n    },\n    cost = 3,\n    atlas = \"mf_rotarots\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 107, h = 107 },\n    can_use = function(self, card)\n      return #G.hand.highlighted >= 1 and #G.hand.highlighted <= card.ability.max_highlighted\n    end,\n    loc_vars = function(self, info_queue, card)\n      info_queue[#info_queue + 1] = G.P_CENTERS.m_mf_monus\n  \n      return { vars = { \n        card and card.ability.max_highlighted or self.config.max_highlighted,\n        localize{type = 'name_text', set = 'Enhanced', key = self.config.mod_conv}\n      } }\n    end",
      "config": {
        "max_highlighted": 2,
        "mod_conv": "m_mf_monus"
      },
      "ability": {
        "max_highlighted": 2,
        "mod_conv": "m_mf_monus"
      },
      "vars": [
        null,
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "rot_lovers",
      "atlas": "mf_rotarots",
      "pos": {
        "x": 6,
        "y": 0
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Rotarot\",\n    name = \"rot_Lovers\",\n    key = \"rot_lovers\",\n    pos = { x = 6, y = 0 },\n    config = {\n      max_highlighted = 2,\n      mod_conv = \"m_mf_styled\"\n    },\n    cost = 3,\n    atlas = \"mf_rotarots\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 107, h = 107 },\n    can_use = function(self, card)\n      return #G.hand.highlighted >= 1 and #G.hand.highlighted <= card.ability.max_highlighted\n    end,\n    loc_vars = function(self, info_queue, card)\n      info_queue[#info_queue + 1] = G.P_CENTERS.m_mf_styled\n  \n      return { vars = { \n        card and card.ability.max_highlighted or self.config.max_highlighted,\n        localize{type = 'name_text', set = 'Enhanced', key = self.config.mod_conv}\n      } }\n    end",
      "config": {
        "max_highlighted": 2,
        "mod_conv": "m_mf_styled"
      },
      "ability": {
        "max_highlighted": 2,
        "mod_conv": "m_mf_styled"
      },
      "vars": [
        null,
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "rot_chariot",
      "atlas": "mf_rotarots",
      "pos": {
        "x": 7,
        "y": 0
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Rotarot\",\n    name = \"rot_Chariot\",\n    key = \"rot_chariot\",\n    pos = { x = 7, y = 0 },\n    config = {\n      max_highlighted = 1,\n      mod_conv = \"m_mf_teal\"\n    },\n    cost = 3,\n    atlas = \"mf_rotarots\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 107, h = 107 },\n    can_use = function(self, card)\n      return #G.hand.highlighted >= 1 and #G.hand.highlighted <= card.ability.max_highlighted\n    end,\n    loc_vars = function(self, info_queue, card)\n      info_queue[#info_queue + 1] = G.P_CENTERS.m_mf_teal\n  \n      return { vars = { \n        card and card.ability.max_highlighted or self.config.max_highlighted,\n        localize{type = 'name_text', set = 'Enhanced', key = self.config.mod_conv}\n      } }\n    end",
      "config": {
        "max_highlighted": 1,
        "mod_conv": "m_mf_teal"
      },
      "ability": {
        "max_highlighted": 1,
        "mod_conv": "m_mf_teal"
      },
      "vars": [
        null,
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "rot_justice",
      "atlas": "mf_rotarots",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Rotarot\",\n    name = \"rot_Justice\",\n    key = \"rot_justice\",\n    pos = { x = 0, y = 1 },\n    config = {\n      max_highlighted = 1,\n      mod_conv = \"m_mf_brass\"\n    },\n    cost = 3,\n    atlas = \"mf_rotarots\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 107, h = 107 },\n    can_use = function(self, card)\n      return #G.hand.highlighted >= 1 and #G.hand.highlighted <= card.ability.max_highlighted\n    end,\n    loc_vars = function(self, info_queue, card)\n      info_queue[#info_queue + 1] = G.P_CENTERS.m_mf_brass\n  \n      return { vars = { \n        card and card.ability.max_highlighted or self.config.max_highlighted,\n        localize{type = 'name_text', set = 'Enhanced', key = self.config.mod_conv}\n      } }\n    end",
      "config": {
        "max_highlighted": 1,
        "mod_conv": "m_mf_brass"
      },
      "ability": {
        "max_highlighted": 1,
        "mod_conv": "m_mf_brass"
      },
      "vars": [
        null,
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "rot_hermit",
      "atlas": "mf_rotarots",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Rotarot\",\n    name = \"rot_Hermit\",\n    key = \"rot_hermit\",\n    pos = { x = 1, y = 1 },\n    config = {\n      val = 25,\n    },\n    cost = 3,\n    atlas = \"mf_rotarots\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 107, h = 107 },\n    can_use = function(self, card)\n      return true\n    end,\n    use = function(self, card, area, copier)\n      give = card.ability.val - math.fmod(to_number(G.GAME.dollars), card.ability.val)\n      if give == card.ability.val then\n        give = 0\n      end\n      ease_dollars(give)\n    end,\n    loc_vars = function(self, info_queue, card)\n      return { vars = {card.ability.val} }\n    end",
      "config": {
        "val": 25
      },
      "ability": {
        "val": 25
      },
      "vars": [
        25
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "rot_wheel",
      "atlas": "mf_rotarots",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Rotarot\",\n    name = \"rot_Wheel\",\n    key = \"rot_wheel\",\n    pos = { x = 2, y = 1 },\n    config = {\n      chance = 5\n    },\n    cost = 3,\n    atlas = \"mf_rotarots\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 107, h = 107 },\n    can_use = function(self, card)\n      return #card.eligible_strength_jokers >= 1\n    end,\n    update = function(self, card, dt)\n      if G.jokers then\n        card.eligible_strength_jokers = EMPTY(card.eligible_strength_jokers)\n        for k, v in pairs(G.jokers.cards) do\n          if v.ability.set == 'Joker' and (not v.edition) then\n            table.insert(card.eligible_strength_jokers, v)\n          end\n        end\n      end\n    end,\n    use = function(self, card, area, copier)\n      local used_tarot = copier or card\n      if SMODS.pseudorandom_probability(card, 'rot_wheel', 1, card.ability.odds, 'rot_wheel')  then\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n          local over = false\n          local eligible_card = pseudorandom_element(card.eligible_strength_jokers, pseudoseed(\"evil_wheel_roll\"))\n          local edition_pool = {}\n          for _, ed in pairs(G.P_CENTER_POOLS[\"Edition\"]) do\n            for _, bl_ed in pairs(blacklisted_editions) do\n              if ed.key == bl_ed then\n                goto wof_continue\n              end\n            end\n            edition_pool[#edition_pool + 1] = ed.key\n            ::wof_continue::\n          end\n          local edition = pseudorandom_element(edition_pool, pseudoseed(\"evil_wheel_roll\"))\n          eligible_card:set_edition(edition, true)\n          check_for_unlock({type = 'have_edition'})\n          used_tarot:juice_up(0.3, 0.5)\n        return true end }))\n      else\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n          attention_text({\n            text = localize('k_nope_ex'),\n            scale = 1.3, \n            hold = 1.4,\n            major = used_tarot,\n            backdrop_colour = G.C.SECONDARY_SET.Tarot,\n            align = (G.STATE == G.STATES.TAROT_PACK or G.STATE == G.STATES.SPECTRAL_PACK) and 'tm' or 'cm',\n            offset = {x = 0, y = (G.STATE == G.STATES.TAROT_PACK or G.STATE == G.STATES.SPECTRAL_PACK) and -0.2 or 0},\n            silent = true\n            })\n            G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.06*G.SETTINGS.GAMESPEED, blockable = false, blocking = false, func = function()\n              play_sound('tarot2', 0.76, 0.4);return true end}))\n            play_sound('tarot2', 1, 0.4)\n            used_tarot:juice_up(0.3, 0.5)\n        return true end }))\n      end\n    end,\n    loc_vars = function(self, info_queue, card)\n      for _, thing in pairs(G.P_CENTER_POOLS[\"Edition\"]) do\n        for _, bl_ed in pairs(blacklisted_editions) do\n          if thing.key == bl_ed then\n            goto wof_loc_continue\n          end\n        end\n        info_queue[#info_queue + 1] = thing\n        ::wof_loc_continue::\n      end\n\n      local new_numerator, new_denominator = SMODS.get_probability_vars(card, 1, card.ability.chance, 'rot_wheel')\n\n      return { vars = {\n        new_numerator,\n        new_denominator\n      } }\n    end",
      "config": {
        "chance": 5
      },
      "ability": {
        "chance": 5
      },
      "vars": [
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "rot_strength",
      "atlas": "mf_rotarots",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Rotarot\",\n    name = \"rot_Strength\",\n    key = \"rot_strength\",\n    pos = { x = 3, y = 1 },\n    config = {\n      max_highlighted = 3,\n    },\n    cost = 3,\n    atlas = \"mf_rotarots\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 107, h = 107 },\n    can_use = function(self, card)\n      return #G.hand.highlighted >= 1 and #G.hand.highlighted <= card.ability.max_highlighted\n    end,\n    use = function(self, card, area, copier)\n      local used_tarot = copier or card\n      G.E_MANAGER:add_event(Event({\n        trigger = 'after',\n        delay = 0.4,\n        func = function()\n          play_sound('tarot1')\n          used_tarot:juice_up(0.3, 0.5)\n          return true\n        end\n      }))\n      for i = 1, #G.hand.highlighted do\n        local percent = 1.15 - (i - 0.999) / (#G.hand.highlighted - 0.998) * 0.3\n        G.E_MANAGER:add_event(Event({\n          trigger = 'after',\n          delay = 0.15,\n          func = function()\n            G.hand.highlighted[i]:flip(); play_sound('card1', percent); G.hand.highlighted[i]:juice_up(0.3,\n              0.3); return true\n          end\n        }))\n      end\n      delay(0.2)\n      for i = 1, #G.hand.highlighted do\n        G.E_MANAGER:add_event(Event({\n          trigger = 'after',\n          delay = 0.1,\n          func = function()\n            local _card = G.hand.highlighted[i]\n            local new_rank = pseudorandom_element(SMODS.Ranks, pseudoseed(\"rot_strength\"))\n            assert(SMODS.change_base(_card, nil, new_rank.key))\n            return true\n          end\n        }))\n      end\n      for i = 1, #G.hand.highlighted do\n        local percent = 0.85 + (i - 0.999) / (#G.hand.highlighted - 0.998) * 0.3\n        G.E_MANAGER:add_event(Event({\n          trigger = 'after',\n          delay = 0.15,\n          func = function()\n            G.hand.highlighted[i]:flip(); play_sound('tarot2', percent, 0.6); G.hand.highlighted[i]\n              :juice_up(\n                0.3, 0.3); return true\n          end\n        }))\n      end\n      G.E_MANAGER:add_event(Event({\n        trigger = 'after',\n        delay = 0.2,\n        func = function()\n          G.hand:unhighlight_all(); return true\n        end\n      }))\n      delay(0.5)\n    end,\n    loc_vars = function(self, info_queue, card)\n      return { vars = {card.ability.max_highlighted} }\n    end",
      "config": {
        "max_highlighted": 3
      },
      "ability": {
        "max_highlighted": 3
      },
      "vars": [
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "rot_hanged_man",
      "atlas": "mf_rotarots",
      "pos": {
        "x": 4,
        "y": 1
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Rotarot\",\n    name = \"rot_Hanged\",\n    key = \"rot_hanged_man\",\n    pos = { x = 4, y = 1 },\n    config = {\n      val = 3,\n    },\n    cost = 3,\n    atlas = \"mf_rotarots\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 107, h = 107 },\n    can_use = function(self, card)\n      return #G.hand.cards >= 1\n    end,\n    use = function(self, card, area, copier)\n      local temp_hand = {}\n      local destroyed_cards = {}\n      for k, v in ipairs(G.hand.cards) do temp_hand[#temp_hand+1] = v end\n      table.sort(temp_hand, function (a, b) return not a.playing_card or not b.playing_card or a.playing_card < b.playing_card end)\n      pseudoshuffle(temp_hand, pseudoseed('brown'))\n\n      for i = 1, math.min(#temp_hand, card.ability.val) do destroyed_cards[#destroyed_cards+1] = temp_hand[i] end\n\n      G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n        play_sound('tarot1')\n        card:juice_up(0.3, 0.5)\n        return true end }))\n      G.E_MANAGER:add_event(Event({\n        trigger = 'after',\n        delay = 0.1,\n        func = function() \n          for i=#destroyed_cards, 1, -1 do\n            local card = destroyed_cards[i]\n            if card.ability.name == 'Glass Card' then \n              card:shatter()\n            else\n              card:start_dissolve(nil, i == #destroyed_cards)\n            end\n            card:remove_from_deck()\n          end\n          return true end }))\n      delay(0.5)\n      for i = 1, #G.jokers.cards do\n        G.jokers.cards[i]:calculate_joker({remove_playing_cards = true, removed = destroyed_cards})\n      end\n      delay(0.6)\n    end,\n    loc_vars = function(self, info_queue, card)\n      return { vars = {card.ability.val} }\n    end",
      "config": {
        "val": 3
      },
      "ability": {
        "val": 3
      },
      "vars": [
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "rot_death",
      "atlas": "mf_rotarots",
      "pos": {
        "x": 5,
        "y": 1
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Rotarot\",\n    name = \"rot_Death\",\n    key = \"rot_death\",\n    pos = { x = 5, y = 1 },\n    config = {\n      max_highlighted = 3,\n    },\n    cost = 3,\n    atlas = \"mf_rotarots\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 107, h = 107 },\n    can_use = function(self, card)\n      return #G.hand.highlighted >= 1 and #G.hand.highlighted <= card.ability.max_highlighted\n    end,\n    use = function(self, card, area, copier)\n      local used_tarot = copier or card\n      G.E_MANAGER:add_event(Event({\n        trigger = 'after',\n        delay = 0.4,\n        func = function()\n          play_sound('tarot1')\n          used_tarot:juice_up(0.3, 0.5)\n          return true\n        end\n      }))\n      delay(0.2)\n      for i = 1, #G.hand.highlighted do\n        local percent = 0.85 + (i - 0.999) / (#G.hand.highlighted - 0.998) * 0.3\n        G.E_MANAGER:add_event(Event({\n          trigger = 'after',\n          delay = 0.15,\n          func = function()\n            G.hand.highlighted[i]:flip(); play_sound('tarot2', percent, 0.6); G.hand.highlighted[i]\n              :juice_up(\n                0.3, 0.3); return true\n          end\n        }))\n      end\n      local rightmost = pseudorandom_element(G.hand.highlighted, pseudoseed(\"rot_death\"))\n      for i=1, #G.hand.highlighted do\n        G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0.1,func = function()\n          if G.hand.highlighted[i] ~= rightmost then\n              copy_card(rightmost, G.hand.highlighted[i])\n          end\n          return true end }))\n      end  \n      delay(0.2)\n      for i = 1, #G.hand.highlighted do\n        local percent = 0.85 + (i - 0.999) / (#G.hand.highlighted - 0.998) * 0.3\n        G.E_MANAGER:add_event(Event({\n          trigger = 'after',\n          delay = 0.15,\n          func = function()\n            G.hand.highlighted[i]:flip(); play_sound('tarot2', percent, 0.6); G.hand.highlighted[i]\n              :juice_up(\n                0.3, 0.3); return true\n          end\n        }))\n      end\n      G.E_MANAGER:add_event(Event({\n        trigger = 'after',\n        delay = 0.2,\n        func = function()\n          G.hand:unhighlight_all(); return true\n        end\n      }))\n      delay(0.5)\n    end,\n    loc_vars = function(self, info_queue, card)\n      return { vars = {card.ability.max_highlighted} }\n    end",
      "config": {
        "max_highlighted": 3
      },
      "ability": {
        "max_highlighted": 3
      },
      "vars": [
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "rot_temperance",
      "atlas": "mf_rotarots",
      "pos": {
        "x": 6,
        "y": 1
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Rotarot\",\n    name = \"rot_Temperance\",\n    key = \"rot_temperance\",\n    pos = { x = 6, y = 1 },\n    config = {\n      val = 3,\n    },\n    cost = 3,\n    atlas = \"mf_rotarots\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 107, h = 107 },\n    can_use = function(self, card)\n      return #G.jokers.cards >= 1 or #G.consumeables.cards >= 1\n    end,\n    use = function(self, card, area, copier)\n      local used_tarot = copier or card\n      for k, v in ipairs(G.jokers.cards) do\n        if v.set_cost then \n          G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.15,\n            func = function()\n              v.ability.extra_value = (v.ability.extra_value or 0) + card.ability.val\n              v:set_cost()\n              v:juice_up(0.3, 0.5)\n              used_tarot:juice_up(0.3, 0.5)\n              play_sound('timpani')\n              return true\n            end\n          }))\n        end\n      end\n      for k, v in ipairs(G.consumeables.cards) do\n        if v.set_cost then \n          G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.15,\n            func = function()\n              v.ability.extra_value = (v.ability.extra_value or 0) + card.ability.val\n              v:set_cost()\n              v:juice_up(0.3, 0.5)\n              used_tarot:juice_up(0.3, 0.5)\n              play_sound('timpani')\n              return true\n            end\n          }))\n        end\n      end\n    end,\n    loc_vars = function(self, info_queue, card)\n      return { vars = {card.ability.val} }\n    end",
      "config": {
        "val": 3
      },
      "ability": {
        "val": 3
      },
      "vars": [
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "rot_devil",
      "atlas": "mf_rotarots",
      "pos": {
        "x": 7,
        "y": 1
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Rotarot\",\n    name = \"rot_Devil\",\n    key = \"rot_devil\",\n    pos = { x = 7, y = 1 },\n    config = {\n      max_highlighted = 3,\n      mod_conv = \"m_mf_marigold\"\n    },\n    cost = 3,\n    atlas = \"mf_rotarots\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 107, h = 107 },\n    can_use = function(self, card)\n      return #G.hand.highlighted >= 1 and #G.hand.highlighted <= card.ability.max_highlighted\n    end,\n    loc_vars = function(self, info_queue, card)\n      info_queue[#info_queue + 1] = G.P_CENTERS.m_mf_marigold\n  \n      return { vars = { \n        card and card.ability.max_highlighted or self.config.max_highlighted,\n        localize{type = 'name_text', set = 'Enhanced', key = self.config.mod_conv}\n      } }\n    end",
      "config": {
        "max_highlighted": 3,
        "mod_conv": "m_mf_marigold"
      },
      "ability": {
        "max_highlighted": 3,
        "mod_conv": "m_mf_marigold"
      },
      "vars": [
        null,
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "rot_tower",
      "atlas": "mf_rotarots",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Rotarot\",\n    name = \"rot_Tower\",\n    key = \"rot_tower\",\n    pos = { x = 0, y = 2 },\n    config = {\n      max_highlighted = 1,\n      mod_conv = \"m_mf_gemstone\"\n    },\n    cost = 3,\n    atlas = \"mf_rotarots\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 107, h = 107 },\n    can_use = function(self, card)\n      return #G.hand.highlighted >= 1 and #G.hand.highlighted <= card.ability.max_highlighted\n    end,\n    loc_vars = function(self, info_queue, card)\n      info_queue[#info_queue + 1] = G.P_CENTERS.m_mf_gemstone\n  \n      return { vars = { \n        card and card.ability.max_highlighted or self.config.max_highlighted,\n        localize{type = 'name_text', set = 'Enhanced', key = self.config.mod_conv}\n      } }\n    end",
      "config": {
        "max_highlighted": 1,
        "mod_conv": "m_mf_gemstone"
      },
      "ability": {
        "max_highlighted": 1,
        "mod_conv": "m_mf_gemstone"
      },
      "vars": [
        null,
        null,
        null,
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "rot_star",
      "atlas": "mf_rotarots",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Rotarot\",\n    name = \"rot_Star\",\n    key = \"rot_star\",\n    pos = { x = 1, y = 2 },\n    config = {\n      val = 3,\n      suit = \"D\"\n    },\n    cost = 3,\n    atlas = \"mf_rotarots\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 107, h = 107 },\n    can_use = function(self, card)\n      return true\n    end,\n    use = function(self, card, area, copier)\n      do_suit_shit(card, copier)\n    end,\n    loc_vars = function(self, info_queue, card)\n      return { vars = {card.ability.val} }\n    end",
      "config": {
        "val": 3,
        "suit": "D"
      },
      "ability": {
        "val": 3,
        "suit": "D"
      },
      "vars": [
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "rot_moon",
      "atlas": "mf_rotarots",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Rotarot\",\n    name = \"rot_Moon\",\n    key = \"rot_moon\",\n    pos = { x = 2, y = 2 },\n    config = {\n      val = 3,\n      suit = \"C\"\n    },\n    cost = 3,\n    atlas = \"mf_rotarots\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 107, h = 107 },\n    can_use = function(self, card)\n      return true\n    end,\n    use = function(self, card, area, copier)\n      do_suit_shit(card, copier)\n    end,\n    loc_vars = function(self, info_queue, card)\n      return { vars = {card.ability.val} }\n    end",
      "config": {
        "val": 3,
        "suit": "C"
      },
      "ability": {
        "val": 3,
        "suit": "C"
      },
      "vars": [
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "rot_sun",
      "atlas": "mf_rotarots",
      "pos": {
        "x": 3,
        "y": 2
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Rotarot\",\n    name = \"rot_Sun\",\n    key = \"rot_sun\",\n    pos = { x = 3, y = 2 },\n    config = {\n      val = 3,\n      suit = \"H\"\n    },\n    cost = 3,\n    atlas = \"mf_rotarots\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 107, h = 107 },\n    can_use = function(self, card)\n      return true\n    end,\n    use = function(self, card, area, copier)\n      do_suit_shit(card, copier)\n    end,\n    loc_vars = function(self, info_queue, card)\n      return { vars = {card.ability.val} }\n    end",
      "config": {
        "val": 3,
        "suit": "H"
      },
      "ability": {
        "val": 3,
        "suit": "H"
      },
      "vars": [
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "rot_judgement",
      "atlas": "mf_rotarots",
      "pos": {
        "x": 4,
        "y": 2
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Rotarot\",\n    name = \"rot_Judgement\",\n    key = \"rot_judgement\",\n    pos = { x = 4, y = 2 },\n    config = {},\n    cost = 3,\n    atlas = \"mf_rotarots\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 107, h = 107 },\n    can_use = function(self, card)\n      return #G.jokers.cards < G.jokers.config.card_limit or self.area == G.jokers\n    end,\n    use = function(self, card, area, copier)\n      local used_tarot = copier or card\n      -- ah shit.\n      function temp_ban_joker(key)\n        if G.GAME.banned_keys[key] == true then\n          G.GAME.banned_keys[key] = 214389\n        end\n        if not G.GAME.banned_keys[key] then \n          G.GAME.banned_keys[key] = 214389\n        elseif G.GAME.banned_keys[key] % 214389 == 0 then\n          G.GAME.banned_keys[key] = G.GAME.banned_keys[key] + 214389\n        end\n      end\n      local vanilla_jokers = {\"j_joker\", \"j_greedy_joker\", \"j_lusty_joker\", \"j_wrathful_joker\", \"j_gluttenous_joker\", \"j_zany\", \"j_mad\", \"j_crazy\", \"j_droll\", \"j_sly\", \"j_wily\", \"j_clever\", \"j_devious\", \"j_crafty\", \"j_half\", \"j_stencil\", \"j_four_fingers\", \"j_mime\", \"j_credit_card\", \"j_ceremonial\", \"j_banner\", \"j_mystic_summit\", \"j_marble\", \"j_loyalty_card\", \"j_8_ball\", \"j_misprint\", \"j_dusk\", \"j_raised_fist\", \"j_chaos\", \"j_fibonacci\", \"j_steel_joker\", \"j_scary_face\", \"j_abstract\", \"j_delayed_grat\", \"j_hack\", \"j_pareidolia\", \"j_gros_michel\", \"j_even_steven\", \"j_odd_todd\", \"j_scholar\", \"j_business\", \"j_supernova\", \"j_ride_the_bus\", \"j_space\", \"j_egg\", \"j_burglar\", \"j_blackboard\", \"j_runner\", \"j_ice_cream\", \"j_dna\", \"j_splash\", \"j_blue_joker\", \"j_sixth_sense\", \"j_constellation\", \"j_hiker\", \"j_faceless\", \"j_green_joker\", \"j_superposition\", \"j_todo_list\", \"j_cavendish\", \"j_card_sharp\", \"j_red_card\", \"j_madness\", \"j_square\", \"j_seance\", \"j_riff_raff\", \"j_vampire\", \"j_shortcut\", \"j_hologram\", \"j_vagabond\", \"j_baron\", \"j_cloud_9\", \"j_rocket\", \"j_obelisk\", \"j_midas_mask\", \"j_luchador\", \"j_photograph\", \"j_gift\", \"j_turtle_bean\", \"j_erosion\", \"j_reserved_parking\", \"j_mail\", \"j_to_the_moon\", \"j_hallucination\", \"j_fortune_teller\", \"j_juggler\", \"j_drunkard\", \"j_stone\", \"j_golden\", \"j_lucky_cat\", \"j_baseball\", \"j_bull\", \"j_diet_cola\", \"j_trading\", \"j_flash\", \"j_popcorn\", \"j_trousers\", \"j_ancient\", \"j_ramen\", \"j_walkie_talkie\", \"j_selzer\", \"j_castle\", \"j_smiley\", \"j_campfire\", \"j_ticket\", \"j_mr_bones\", \"j_acrobat\", \"j_sock_and_buskin\", \"j_swashbuckler\", \"j_troubadour\", \"j_certificate\", \"j_smeared\", \"j_throwback\", \"j_hanging_chad\", \"j_rough_gem\", \"j_bloodstone\", \"j_arrowhead\", \"j_onyx_agate\", \"j_glass\", \"j_ring_master\", \"j_flower_pot\", \"j_blueprint\", \"j_wee\", \"j_merry_andy\", \"j_oops\", \"j_idol\", \"j_seeing_double\", \"j_matador\", \"j_hit_the_road\", \"j_duo\", \"j_trio\", \"j_family\", \"j_order\", \"j_tribe\", \"j_stuntman\", \"j_invisible\", \"j_brainstorm\", \"j_satellite\", \"j_shoot_the_moon\", \"j_drivers_license\", \"j_cartomancer\", \"j_astronomer\", \"j_burnt\", \"j_bootstraps\", \"j_caino\", \"j_triboulet\", \"j_yorick\", \"j_chicot\", \"j_perkeo\"}\n      for i = 1, #vanilla_jokers do\n          temp_ban_joker(vanilla_jokers[i])\n      end\n      G.E_MANAGER:add_event(Event({\n        func = function() \n          local n_card = create_card('Joker', G.jokers, nil, nil, nil, nil, nil, 'exp')\n          n_card:add_to_deck()\n          G.jokers:emplace(n_card)\n          n_card:start_materialize()\n          used_tarot:juice_up(0.3, 0.5)\n          G.GAME.joker_buffer = 0\n          local vanilla_jokers = {\"j_joker\", \"j_greedy_joker\", \"j_lusty_joker\", \"j_wrathful_joker\", \"j_gluttenous_joker\", \"j_zany\", \"j_mad\", \"j_crazy\", \"j_droll\", \"j_sly\", \"j_wily\", \"j_clever\", \"j_devious\", \"j_crafty\", \"j_half\", \"j_stencil\", \"j_four_fingers\", \"j_mime\", \"j_credit_card\", \"j_ceremonial\", \"j_banner\", \"j_mystic_summit\", \"j_marble\", \"j_loyalty_card\", \"j_8_ball\", \"j_misprint\", \"j_dusk\", \"j_raised_fist\", \"j_chaos\", \"j_fibonacci\", \"j_steel_joker\", \"j_scary_face\", \"j_abstract\", \"j_delayed_grat\", \"j_hack\", \"j_pareidolia\", \"j_gros_michel\", \"j_even_steven\", \"j_odd_todd\", \"j_scholar\", \"j_business\", \"j_supernova\", \"j_ride_the_bus\", \"j_space\", \"j_egg\", \"j_burglar\", \"j_blackboard\", \"j_runner\", \"j_ice_cream\", \"j_dna\", \"j_splash\", \"j_blue_joker\", \"j_sixth_sense\", \"j_constellation\", \"j_hiker\", \"j_faceless\", \"j_green_joker\", \"j_superposition\", \"j_todo_list\", \"j_cavendish\", \"j_card_sharp\", \"j_red_card\", \"j_madness\", \"j_square\", \"j_seance\", \"j_riff_raff\", \"j_vampire\", \"j_shortcut\", \"j_hologram\", \"j_vagabond\", \"j_baron\", \"j_cloud_9\", \"j_rocket\", \"j_obelisk\", \"j_midas_mask\", \"j_luchador\", \"j_photograph\", \"j_gift\", \"j_turtle_bean\", \"j_erosion\", \"j_reserved_parking\", \"j_mail\", \"j_to_the_moon\", \"j_hallucination\", \"j_fortune_teller\", \"j_juggler\", \"j_drunkard\", \"j_stone\", \"j_golden\", \"j_lucky_cat\", \"j_baseball\", \"j_bull\", \"j_diet_cola\", \"j_trading\", \"j_flash\", \"j_popcorn\", \"j_trousers\", \"j_ancient\", \"j_ramen\", \"j_walkie_talkie\", \"j_selzer\", \"j_castle\", \"j_smiley\", \"j_campfire\", \"j_ticket\", \"j_mr_bones\", \"j_acrobat\", \"j_sock_and_buskin\", \"j_swashbuckler\", \"j_troubadour\", \"j_certificate\", \"j_smeared\", \"j_throwback\", \"j_hanging_chad\", \"j_rough_gem\", \"j_bloodstone\", \"j_arrowhead\", \"j_onyx_agate\", \"j_glass\", \"j_ring_master\", \"j_flower_pot\", \"j_blueprint\", \"j_wee\", \"j_merry_andy\", \"j_oops\", \"j_idol\", \"j_seeing_double\", \"j_matador\", \"j_hit_the_road\", \"j_duo\", \"j_trio\", \"j_family\", \"j_order\", \"j_tribe\", \"j_stuntman\", \"j_invisible\", \"j_brainstorm\", \"j_satellite\", \"j_shoot_the_moon\", \"j_drivers_license\", \"j_cartomancer\", \"j_astronomer\", \"j_burnt\", \"j_bootstraps\", \"j_caino\", \"j_triboulet\", \"j_yorick\", \"j_chicot\", \"j_perkeo\"}\n          function temp_unban_joker(key)\n            if G.GAME.banned_keys[key] == 214389 then\n              G.GAME.banned_keys[key] = nil\n            elseif G.GAME.banned_keys[key] % 214389 == 0 then \n              G.GAME.banned_keys[key] = G.GAME.banned_keys[key] - 214389\n            end\n          end\n          for i = 1, #vanilla_jokers do\n            temp_unban_joker(vanilla_jokers[i])\n          end\n          return true\n        end}))   \n    end,\n    loc_vars = function(self, info_queue, card)\n      return { vars = {card.ability.val} }\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "rot_world",
      "atlas": "mf_rotarots",
      "pos": {
        "x": 5,
        "y": 2
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Rotarot\",\n    name = \"rot_World\",\n    key = \"rot_world\",\n    pos = { x = 5, y = 2 },\n    config = {\n      val = 3,\n      suit = \"S\"\n    },\n    cost = 3,\n    atlas = \"mf_rotarots\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 107, h = 107 },\n    can_use = function(self, card)\n      return true\n    end,\n    use = function(self, card, area, copier)\n      do_suit_shit(card, copier)\n    end,\n    loc_vars = function(self, info_queue, card)\n      return { vars = {card.ability.val} }\n    end",
      "config": {
        "val": 3,
        "suit": "S"
      },
      "ability": {
        "val": 3,
        "suit": "S"
      },
      "vars": [
        3
      ],
      "infoQueue": []
    },
    {
      "type": "ConsumableType",
      "key": "Shape",
      "atlas": null,
      "pos": null,
      "raw": "key = \"Shape\",\n    primary_colour = HEX(\"316ea0\"),\n    secondary_colour = HEX(\"316ea0\"),\n    collection_rows = { 4, 4 },\n    loc_txt = {},\n    default = \"c_mf_black\",\n    can_stack = false,\n    can_divide = false,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "UndiscoveredSprite",
      "key": "Shape",
      "atlas": "mf_shapes",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"Shape\",\n    atlas = \"mf_shapes\",\n    path = \"mf_shapes.png\",\n    pos = { x = 0, y = 0 },\n    px = 71,\n    py = 95,",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Tag",
      "key": "colour",
      "atlas": "mf_tags",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "--   key = \"colour\",\n  --   atlas = \"mf_tags\",\n  --   pos = { x = 0, y = 0 },\n  --   unlocked = true,\n  --   discovered = true,\n  --   loc_vars = function(self, info_queue)\n  --     info_queue[#info_queue + 1] = { set = \"Other\", key = \"p_mf_colour_jumbo_1\", specific_vars = { 1, 4 } }\n  --     return { vars = {} }\n  --   end,\n  --   apply = function(self, tag, context)\n  --     if context.type == \"new_blind_choice\" then\n  --       tag:yep(\"+\", G.C.SECONDARY_SET.Code, function()\n  --         local key = \"p_mf_colour_jumbo_1\"\n  --         local card = Card(\n  --           G.play.T.x + G.play.T.w / 2 - G.CARD_W * 1.27 / 2,\n  --           G.play.T.y + G.play.T.h / 2 - G.CARD_H * 1.27 / 2,\n  --           G.CARD_W * 1.27,\n  --           G.CARD_H * 1.27,\n  --           G.P_CARDS.empty,\n  --           G.P_CENTERS[key],\n  --           { bypass_discovery_center = true, bypass_discovery_ui = true }\n  --         )\n  --         card.cost = 0\n  --         card.from_tag = true\n  --         G.FUNCS.use_card({ config = { ref_table = card } })\n  --         -- uh. should this be here??\n  --         if G.GAME.modifiers.cry_force_edition and not G.GAME.modifiers.cry_force_random_edition then\n  --           card:set_edition(nil, true, true)\n  --         elseif G.GAME.modifiers.cry_force_random_edition then\n  --           local edition = Cryptid.poll_random_edition()\n  --           card:set_edition(edition, true, true)\n  --         end\n  --         card:start_materialize()\n  --         return true\n  --       end)\n  --       tag.triggered = true\n  --       return true\n  --     end\n  --   end,\n  --",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Tag",
      "key": "absolute",
      "atlas": "mf_tags",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"absolute\",\n    atlas = \"mf_tags\",\n    pos = { x = 2, y = 0 },\n    unlocked = true,\n    discovered = true,\n    loc_vars = function(self, info_queue)\n      info_queue[#info_queue + 1] = { set = \"Other\", key = \"cry_absolute\" }\n      return { vars = {} }\n    end,\n    in_pool = function() return false end or nil,\n    config = { type = \"store_joker_modify\", sticker = \"cry_absolute\" },\n    apply = function(self, tag, context)\n      if context.type == \"store_joker_modify\" then\n        local _applied = nil\n        if Cryptid.forced_edition() then\n          tag:nope()\n        end\n        if not context.card.temp_edition and context.card.ability.set == \"Joker\" then\n          local lock = tag.ID\n          G.CONTROLLER.locks[lock] = true\n          context.card.temp_edition = true\n          tag:yep(\"+\", G.C.DARK_EDITION, function()\n            context.card.cry_absolute = true\n            context.card.ability.couponed = true\n            context.card:set_cost()\n            context.card:juice_up(0.5, 0.5)\n            context.card.temp_edition = nil\n            G.CONTROLLER.locks[lock] = nil\n            return true\n          end)\n          _applied = true\n          tag.triggered = true\n        end\n      end\n    end,\n    set_badges = function (self, card, badges)\n      SMODS.create_mod_badges({ mod = SMODS.find_mod(\"entr\")[1] }, badges)\n    end,",
      "config": {
        "type": "store_joker_modify",
        "sticker": "cry_absolute"
      },
      "ability": {
        "type": "store_joker_modify",
        "sticker": "cry_absolute"
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Tag",
      "key": "eabsolute",
      "atlas": "mf_ascendant_tags",
      "pos": {
        "x": 2,
        "y": 0
      },
      "raw": "key = \"eabsolute\",\n    atlas = \"mf_ascendant_tags\",\n    pos = { x = 2, y = 0 },\n    unlocked = true,\n    discovered = true,\n    loc_vars = function(self, info_queue)\n      info_queue[#info_queue + 1] = { set = \"Other\", key = \"cry_absolute\" }\n      return { vars = {} }\n    end,\n    config = { type = \"store_joker_modify\", sticker = \"cry_absolute\" },\n    in_pool = function() return false end or nil,\n    apply = function(self, tag, context)\n      if context.type == \"store_joker_modify\" then\n        if not context.card.temp_edition and context.card.ability.set == \"Joker\" then\n          tag:yep(\"+\", G.C.RARITY[colour], function()\n            for i, v in pairs(G.shop_jokers.cards) do\n              v.cry_absolute = true\n            end\n            for i, v in pairs(G.shop_booster.cards) do\n              v.cry_absolute = true\n            end\n            for i, v in pairs(G.shop_vouchers.cards) do\n              v.cry_absolute = true\n            end\n            return true\n          end)\n          tag.triggered = true\n        end\n      end\n    end,\n    set_badges = function (self, card, badges)\n      SMODS.create_mod_badges({ mod = SMODS.find_mod(\"entr\")[1] }, badges)\n    end,",
      "config": {
        "type": "store_joker_modify",
        "sticker": "cry_absolute"
      },
      "ability": {
        "type": "store_joker_modify",
        "sticker": "cry_absolute"
      },
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "cloud",
      "atlas": "mf_shapes",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Shape\",\n    name = \"shape_Cloud\",\n    key = \"cloud\",\n    pos = { x = 0, y = 1 },\n    config = {\n      val = 0,\n      partial_rounds = 0,\n      upgrade_rounds = 5,\n    },\n    cost = 4,\n    atlas = \"mf_shapes\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 71, h = 87 },\n    pixel_size = { w = 71, h = 87 },\n    can_use = function(self, card)\n      return true\n    end,\n    use = function(self, card, area, copier)\n      for i = 1, card.ability.val do\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n        play_sound('timpani')\n        local n_card = create_card(nil,G.consumeables, nil, nil, nil, nil, 'j_mf_philosophical', 'sup')\n        n_card:add_to_deck()\n        n_card:set_edition({negative = true}, true)\n        G.jokers:emplace(n_card)\n        card:juice_up(0.3, 0.5)\n        return true end }))\n      end\n      delay(0.6)\n    end,\n    loc_vars = function(self, info_queue, card)\n      local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n      return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds} }\n    end,\n    set_badges = function (self, card, badges)\n      SMODS.create_mod_badges({ mod = SMODS.find_mod(\"entr\")[1] }, badges)\n    end,",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 5
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 5
      },
      "vars": [
        0,
        null,
        null,
        5
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "spade",
      "atlas": "mf_shapes",
      "pos": {
        "x": 1,
        "y": 1
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Shape\",\n    name = \"shape_Spade\",\n    key = \"spade\",\n    pos = { x = 1, y = 1 },\n    config = {\n      val = 0,\n      partial_rounds = 0,\n      upgrade_rounds = 1,\n    },\n    cost = 4,\n    atlas = \"mf_shapes\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 71, h = 87 },\n    pixel_size = { w = 71, h = 87 },\n    can_use = function(self, card)\n      return true\n    end,\n    use = function(self, card, area, copier)\n      full_deck_suit_stuff(card, copier, \"Spades\")\n    end,\n    loc_vars = function(self, info_queue, card)\n      local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n      return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds} }\n    end,\n    set_badges = function (self, card, badges)\n      SMODS.create_mod_badges({ mod = SMODS.find_mod(\"entr\")[1] }, badges)\n    end,",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 1
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 1
      },
      "vars": [
        0,
        null,
        null,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "omega",
      "atlas": "mf_shapes",
      "pos": {
        "x": 2,
        "y": 1
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Shape\",\n    name = \"shape_Omega\",\n    key = \"omega\",\n    pos = { x = 2, y = 1 },\n    config = {\n      val = 0,\n      partial_rounds = 0,\n      upgrade_rounds = 2,\n    },\n    cost = 4,\n    atlas = \"mf_shapes\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 71, h = 87 },\n    pixel_size = { w = 71, h = 87 },\n    can_use = function(self, card)\n      return true\n    end,\n    use = function(self, card, area, copier)\n      local tag_type = \"tag_mf_absolute\"\n      for i = 1, card.ability.val do\n        G.E_MANAGER:add_event(Event({\n          func = (function()\n            add_tag(Tag(tag_type))\n            play_sound('generic1', 0.9 + math.random()*0.1, 0.8)\n            play_sound('holo1', 1.2 + math.random()*0.1, 0.4)\n            return true\n          end)\n        }))\n        delay(0.2)\n      end\n      delay(0.6)\n    end,\n    loc_vars = function(self, info_queue, card)\n      local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n      return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds} }\n    end,\n    set_badges = function (self, card, badges)\n      SMODS.create_mod_badges({ mod = SMODS.find_mod(\"entr\")[1] }, badges)\n    end,",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 2
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 2
      },
      "vars": [
        0,
        null,
        null,
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "club",
      "atlas": "mf_shapes",
      "pos": {
        "x": 3,
        "y": 1
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Shape\",\n    name = \"shape_Club\",\n    key = \"club\",\n    pos = { x = 3, y = 1 },\n    config = {\n      val = 0,\n      partial_rounds = 0,\n      upgrade_rounds = 1,\n    },\n    cost = 4,\n    atlas = \"mf_shapes\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 71, h = 87 },\n    pixel_size = { w = 71, h = 87 },\n    can_use = function(self, card)\n      return true\n    end,\n    use = function(self, card, area, copier)\n      full_deck_suit_stuff(card, copier, \"Clubs\")\n    end,\n    loc_vars = function(self, info_queue, card)\n      local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n      return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds} }\n    end,\n    set_badges = function (self, card, badges)\n      SMODS.create_mod_badges({ mod = SMODS.find_mod(\"entr\")[1] }, badges)\n    end,",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 1
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 1
      },
      "vars": [
        0,
        null,
        null,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "rectangle",
      "atlas": "mf_shapes",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Shape\",\n    name = \"shape_Rectangle\",\n    key = \"rectangle\",\n    pos = { x = 0, y = 2 },\n    config = {\n      val = 0,\n      partial_rounds = 0,\n      upgrade_rounds = 1,\n    },\n    cost = 4,\n    atlas = \"mf_shapes\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 71, h = 87 },\n    pixel_size = { w = 71, h = 87 },\n    can_use = function(self, card)\n      return #G.hand.cards > 0\n    end,\n    use = function(self, card, area, copier)\n      for i = 1, card.ability.val do\n        G.E_MANAGER:add_event(Event({\n          func = (function()\n            local _edition = poll_edition('standard_edition'..G.GAME.round_resets.ante, 2, true)\n            local _seal = SMODS.poll_seal({mod = 10})\n            local n_card = SMODS.create_card {set = (pseudorandom(pseudoseed('stdset'..G.GAME.round_resets.ante)) > 0.4) and \"Enhanced\" or \"Base\", edition = _edition, seal = _seal, area = G.pack_cards, skip_materialize = true, soulable = true, key_append = \"sta\"}\n            G.playing_card = (G.playing_card and G.playing_card + 1) or 1\n            n_card.playing_card = G.playing_card\n            n_card:add_to_deck()\n            G.hand:emplace(n_card)\n            card:juice_up(0.3, 0.5)\n            table.insert(G.playing_cards, n_card)\n\n            playing_card_joker_effects({n_card})\n            play_sound('timpani')\n\n            return true\n          end)\n        }))\n        delay(0.2)\n      end\n      delay(0.6)\n    end,\n    loc_vars = function(self, info_queue, card)\n      local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n      return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds} }\n    end,\n    set_badges = function (self, card, badges)\n      SMODS.create_mod_badges({ mod = SMODS.find_mod(\"entr\")[1] }, badges)\n    end,",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 1
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 1
      },
      "vars": [
        0,
        null,
        null,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "squircle",
      "atlas": "mf_shapes",
      "pos": {
        "x": 1,
        "y": 2
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Shape\",\n    name = \"shape_Squircle\",\n    key = \"squircle\",\n    pos = { x = 1, y = 2 },\n    config = {\n      val = 0,\n      partial_rounds = 0,\n      upgrade_rounds = 2,\n    },\n    cost = 4,\n    atlas = \"mf_shapes\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 71, h = 87 },\n    pixel_size = { w = 71, h = 87 },\n    can_use = function(self, card)\n      return true\n    end,\n    use = function(self, card, area, copier)\n      for i = 1, card.ability.val do\n      local tag_type = get_next_tag_key()\n        G.E_MANAGER:add_event(Event({\n          func = (function()\n            add_tag(Tag(tag_type))\n            play_sound('generic1', 0.9 + math.random()*0.1, 0.8)\n            play_sound('holo1', 1.2 + math.random()*0.1, 0.4)\n            return true\n          end)\n        }))\n        delay(0.2)\n      end\n      delay(0.6)\n    end,\n    loc_vars = function(self, info_queue, card)\n      local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n      return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds} }\n    end,\n    set_badges = function (self, card, badges)\n      SMODS.create_mod_badges({ mod = SMODS.find_mod(\"entr\")[1] }, badges)\n    end,",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 2
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 2
      },
      "vars": [
        0,
        null,
        null,
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "arrow",
      "atlas": "mf_shapes",
      "pos": {
        "x": 2,
        "y": 2
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Shape\",\n    name = \"shape_arrow\",\n    key = \"arrow\",\n    pos = { x = 2, y = 2 },\n    config = {\n      val = 0,\n      partial_rounds = 0,\n      upgrade_rounds = 5,\n    },\n    cost = 4,\n    atlas = \"mf_shapes\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 71, h = 87 },\n    pixel_size = { w = 71, h = 87 },\n    can_use = function(self, card)\n      return true\n    end,\n    use = function(self, card, area, copier)\n      local tag_type = \"tag_entr_solar\"\n      for i = 1, card.ability.val do\n        G.E_MANAGER:add_event(Event({\n          func = (function()\n            add_tag(Tag(tag_type))\n            play_sound('generic1', 0.9 + math.random()*0.1, 0.8)\n            play_sound('holo1', 1.2 + math.random()*0.1, 0.4)\n            return true\n          end)\n        }))\n        delay(0.2)\n      end\n      delay(0.6)\n    end,\n    loc_vars = function(self, info_queue, card)\n      local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n      return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds} }\n    end,\n    set_badges = function (self, card, badges)\n      SMODS.create_mod_badges({ mod = SMODS.find_mod(\"entr\")[1] }, badges)\n    end,",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 5
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 5
      },
      "vars": [
        0,
        null,
        null,
        5
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "circle",
      "atlas": "mf_shapes",
      "pos": {
        "x": 3,
        "y": 2
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Shape\",\n    name = \"shape_Circle\",\n    key = \"circle\",\n    pos = { x = 3, y = 2 },\n    config = {\n      val = 0,\n      partial_rounds = 0,\n      upgrade_rounds = 3,\n    },\n    cost = 4,\n    atlas = \"mf_shapes\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 71, h = 87 },\n    pixel_size = { w = 71, h = 87 },\n    can_use = function(self, card)\n      return true\n    end,\n    use = function(self, card, area, copier)\n      local card_type = \"Shape\"\n      local rng_seed = \"circle\"\n      for i = 1, card.ability.val do\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n          play_sound('timpani')\n          local n_card = create_card(card_type, G.consumeables, nil, nil, nil, nil, nil, rng_seed)\n          n_card:add_to_deck()\n          n_card:set_edition({negative = true}, true)\n          G.consumeables:emplace(n_card)\n          card:juice_up(0.3, 0.5)\n          return true end }))\n      end\n      delay(0.6)\n    end,\n    loc_vars = function(self, info_queue, card)\n      local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n      return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds} }\n    end",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 3
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 3
      },
      "vars": [
        0,
        null,
        null,
        3
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "heart",
      "atlas": "mf_shapes",
      "pos": {
        "x": 0,
        "y": 3
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Shape\",\n    name = \"shape_Heart\",\n    key = \"heart\",\n    pos = { x = 0, y = 3 },\n    config = {\n      val = 0,\n      partial_rounds = 0,\n      upgrade_rounds = 1,\n    },\n    cost = 4,\n    atlas = \"mf_shapes\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 71, h = 87 },\n    pixel_size = { w = 71, h = 87 },\n    can_use = function(self, card)\n      return true\n    end,\n    use = function(self, card, area, copier)\n      full_deck_suit_stuff(card, copier, \"Hearts\")\n    end,\n    loc_vars = function(self, info_queue, card)\n      local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n      return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds} }\n    end,\n    set_badges = function (self, card, badges)\n      SMODS.create_mod_badges({ mod = SMODS.find_mod(\"entr\")[1] }, badges)\n    end,",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 1
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 1
      },
      "vars": [
        0,
        null,
        null,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "diamond",
      "atlas": "mf_shapes",
      "pos": {
        "x": 1,
        "y": 3
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Shape\",\n    name = \"shape_Diamond\",\n    key = \"diamond\",\n    pos = { x = 1, y = 3 },\n    config = {\n      val = 0,\n      partial_rounds = 0,\n      upgrade_rounds = 1,\n    },\n    cost = 4,\n    atlas = \"mf_shapes\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 71, h = 87 },\n    pixel_size = { w = 71, h = 87 },\n    can_use = function(self, card)\n      return true\n    end,\n    use = function(self, card, area, copier)\n      full_deck_suit_stuff(card, copier, \"Diamonds\")\n    end,\n    loc_vars = function(self, info_queue, card)\n      local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n      return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds} }\n    end,\n    set_badges = function (self, card, badges)\n      SMODS.create_mod_badges({ mod = SMODS.find_mod(\"entr\")[1] }, badges)\n    end,",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 1
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 1
      },
      "vars": [
        0,
        null,
        null,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "dollar",
      "atlas": "mf_shapes",
      "pos": {
        "x": 2,
        "y": 3
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Shape\",\n    name = \"shape_Dollar\",\n    key = \"dollar\",\n    pos = { x = 2, y = 3 },\n    config = {\n      val = 0,\n      partial_rounds = 0,\n      upgrade_rounds = 1,\n    },\n    cost = 4,\n    atlas = \"mf_shapes\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 71, h = 87 },\n    pixel_size = { w = 71, h = 87 },\n    can_use = function(self, card)\n      return true\n    end,\n    use = function(self, card, area, copier)\n      local sell_pool = {}\n      for _, c in pairs(G.jokers.cards) do\n        if not c.cry_absolute then sell_pool[#sell_pool + 1] = c end\n      end\n      for _, c in pairs(G.consumeables.cards) do\n        if not c.cry_absolute then sell_pool[#sell_pool + 1] = c end\n      end\n\n      if #sell_pool == 0 then\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n          attention_text({\n            text = localize('k_nope_ex'),\n            scale = 1.3, \n            hold = 1.4,\n            major = card,\n            backdrop_colour = G.C.SECONDARY_SET.Tarot,\n            align = (G.STATE == G.STATES.TAROT_PACK or G.STATE == G.STATES.SPECTRAL_PACK) and 'tm' or 'cm',\n            offset = {x = 0, y = (G.STATE == G.STATES.TAROT_PACK or G.STATE == G.STATES.SPECTRAL_PACK) and -0.2 or 0},\n            silent = true\n            })\n            G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.06*G.SETTINGS.GAMESPEED, blockable = false, blocking = false, func = function()\n              play_sound('tarot2', 0.76, 0.4);return true end}))\n            play_sound('tarot2', 1, 0.4)\n            card:juice_up(0.3, 0.5)\n        return true end }))\n      else\n        local sell_card = pseudorandom_element(sell_pool, pseudoseed(\"dollar\"))\n        \n        sell_card.ability.eternal = false\n        \n        sell_card.bonus_cost = (sell_card.cost) * (card.ability.val - 1)\n        sell_card:set_cost()\n        \n        G.FUNCS.sell_card (\n          {\n            config = {\n              ref_table = sell_card -- love that janker\n            }\n          }\n        )\n      end\n    end,\n    loc_vars = function(self, info_queue, card)\n      local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n      return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds} }\n    end,\n    set_badges = function (self, card, badges)\n      SMODS.create_mod_badges({ mod = SMODS.find_mod(\"entr\")[1] }, badges)\n    end,",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 1
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 1
      },
      "vars": [
        0,
        null,
        null,
        1
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "star",
      "atlas": "mf_shapes",
      "pos": {
        "x": 0,
        "y": 4
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Shape\",\n    name = \"shape_Star\",\n    key = \"star\",\n    pos = { x = 0, y = 4 },\n    config = {\n      val = 0,\n      partial_rounds = 0,\n      upgrade_rounds = 2,\n    },\n    cost = 4,\n    atlas = \"mf_shapes\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 71, h = 87 },\n    pixel_size = { w = 71, h = 87 },\n    can_use = function(self, card)\n      return true\n    end,\n    use = function(self, card, area, copier)\n      local card_type = \"RPlanet\"\n      local rng_seed = \"star\"\n      for i = 1, card.ability.val do\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n          play_sound('timpani')\n          local n_card = create_card(card_type, G.consumeables, nil, nil, nil, nil, nil, rng_seed)\n          n_card:add_to_deck()\n          n_card:set_edition({negative = true}, true)\n          G.consumeables:emplace(n_card)\n          card:juice_up(0.3, 0.5)\n          return true end }))\n      end\n      delay(0.6)\n    end,\n    loc_vars = function(self, info_queue, card)\n      local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n      return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds} }\n    end",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 2
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 2
      },
      "vars": [
        0,
        null,
        null,
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Sticker",
      "key": "halted",
      "atlas": "mf_stickers",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"halted\",\n    atlas = \"mf_stickers\",\n    pos = { x = 0, y = 0 },\n    badge_colour = HEX(\"1b4484\"),\n    no_sticker_sheet = true,\n    should_apply = function(self, card, center, area, bypass_roll)\n      return false\n    end,\n    draw = function(self, card) --don't draw shine\n      local notilt = nil\n      if card.area and card.area.config.type == \"deck\" then\n        notilt = true\n      end\n\n      G.shared_stickers[self.key].role.draw_major = card\n\n      G.shared_stickers[self.key]:draw_shader(\"dissolve\", nil, nil, notilt, card.children.center)\n    end,",
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "pause",
      "atlas": "mf_shapes",
      "pos": {
        "x": 2,
        "y": 4
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Shape\",\n    name = \"shape_Pause\",\n    key = \"pause\",\n    pos = { x = 2, y = 4 },\n    config = {\n      val = 0,\n      partial_rounds = 0,\n      upgrade_rounds = 2,\n    },\n    cost = 4,\n    atlas = \"mf_shapes\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 71, h = 87 },\n    pixel_size = { w = 71, h = 87 },\n    can_use = function(self, card)\n      return true\n    end,\n    use = function(self, card, area, copier)\n      for i = 1, card.ability.val do\n        colour_end_of_round_effects()\n      end\n      for _, v in pairs(G.consumeables.cards) do\n        if v.ability.set == \"Shape\" or v.ability.set == \"Colour\" then\n          G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n            play_sound('timpani')\n            v.ability[\"mf_halted\"] = true\n            v:juice_up(0.5, 0.5)\n            play_sound('generic1', 0.9 + math.random()*0.1, 0.8)\n            play_sound('holo1', 1.2 + math.random()*0.1, 0.4)\n            return true end }))\n        end\n      end\n      delay(0.6)\n    end,\n    loc_vars = function(self, info_queue, card)\n      info_queue[#info_queue + 1] = {key = \"mf_halted\", set=\"Other\"}\n      local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n      return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds} }\n    end",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 2
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 2
      },
      "vars": [
        0,
        null,
        null,
        2
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "gem",
      "atlas": "mf_shapes",
      "pos": {
        "x": 0,
        "y": 6
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Shape\",\n    name = \"shape_gem\",\n    key = \"gem\",\n    pos = { x = 0, y = 6 },\n    soul_pos = { x = 1, y = 6 },\n    config = {\n      val = 0,\n      partial_rounds = 0,\n      upgrade_rounds = 4,\n    },\n    cost = 4,\n    atlas = \"mf_shapes\",\n    hidden = true,\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 71, h = 87 },\n    pixel_size = { w = 71, h = 87 },\n    can_use = function(self, card)\n      return true\n    end,\n    use = function(self, card, area, copier)\n      for i = 1, card.ability.val do\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n          play_sound('timpani')\n          local n_card = create_card(nil,G.consumeables, nil, nil, nil, nil, 'c_entr_fervour', 'sup')\n          n_card.no_omega = true\n          n_card:add_to_deck()\n          n_card:set_edition({negative = true}, true)\n          G.consumeables:emplace(n_card)\n          card:juice_up(0.3, 0.5)\n          return true end }))\n      end\n      delay(0.6)\n    end,\n    loc_vars = function(self, info_queue, card)\n      local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n      return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds} }\n    end,\n    set_badges = function (self, card, badges)\n      SMODS.create_mod_badges({ mod = SMODS.find_mod(\"entr\")[1] }, badges)\n    end,",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 4
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 4
      },
      "vars": [
        0,
        null,
        null,
        4
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "house",
      "atlas": "mf_shapes",
      "pos": {
        "x": 0,
        "y": 5
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Shape\",\n    name = \"shape_house\",\n    key = \"house\",\n    pos = { x = 0, y = 5 },\n    config = {\n      val = 0,\n      partial_rounds = 0,\n      upgrade_rounds = 4,\n    },\n    cost = 4,\n    atlas = \"mf_shapes\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 71, h = 87 },\n    pixel_size = { w = 71, h = 87 },\n    can_use = function(self, card)\n      return true\n    end,\n    use = function(self, card, area, copier)\n      local tag_type = \"tag_entr_ascendant_reference\"\n      for i = 1, card.ability.val do\n        G.E_MANAGER:add_event(Event({\n          func = (function()\n            add_tag(Tag(tag_type))\n            play_sound('generic1', 0.9 + math.random()*0.1, 0.8)\n            play_sound('holo1', 1.2 + math.random()*0.1, 0.4)\n            return true\n          end)\n        }))\n        delay(0.2)\n      end\n      delay(0.6)\n    end,\n    loc_vars = function(self, info_queue, card)\n      local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n      return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds} }\n    end,\n    set_badges = function (self, card, badges)\n      SMODS.create_mod_badges({ mod = SMODS.find_mod(\"entr\")[1] }, badges)\n    end,",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 4
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 4
      },
      "vars": [
        0,
        null,
        null,
        4
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "loss",
      "atlas": "mf_shapes",
      "pos": {
        "x": 1,
        "y": 5
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Shape\",\n    name = \"shape_loss\",\n    key = \"loss\",\n    pos = { x = 1, y = 5 },\n    config = {\n      val = 0,\n      partial_rounds = 0,\n      upgrade_rounds = 4,\n    },\n    cost = 4,\n    atlas = \"mf_shapes\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 71, h = 87 },\n    pixel_size = { w = 71, h = 87 },\n    can_use = function(self, card)\n      return true\n    end,\n    use = function(self, card, area, copier)\n      local tag_type = \"tag_cry_loss\"\n      for i = 1, card.ability.val do\n        G.E_MANAGER:add_event(Event({\n          func = (function()\n            add_tag(Tag(tag_type))\n            play_sound('generic1', 0.9 + math.random()*0.1, 0.8)\n            play_sound('holo1', 1.2 + math.random()*0.1, 0.4)\n            return true\n          end)\n        }))\n        delay(0.2)\n      end\n      delay(0.6)\n    end,\n    loc_vars = function(self, info_queue, card)\n      local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n      return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds} }\n    end,\n    set_badges = function (self, card, badges)\n      SMODS.create_mod_badges({ mod = SMODS.find_mod(\"entr\")[1] }, badges)\n    end,",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 4
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 4
      },
      "vars": [
        0,
        null,
        null,
        4
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "prism",
      "atlas": "mf_shapes",
      "pos": {
        "x": 2,
        "y": 5
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Shape\",\n    name = \"shape_prism\",\n    key = \"prism\",\n    pos = { x = 2, y = 5 },\n    soul_pos = { x = 2, y = 6 },\n    config = {\n      val = 0,\n      partial_rounds = 0,\n      upgrade_rounds = 12,\n    },\n    cost = 4,\n    atlas = \"mf_shapes\",\n    hidden = true,\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 71, h = 87 },\n    pixel_size = { w = 71, h = 87 },\n    can_use = function(self, card)\n      return true\n    end,\n    use = function(self, card, area, copier)\n      for i = 1, card.ability.val do\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n          play_sound('timpani')\n          local n_card = create_card(nil,G.consumeables, nil, nil, nil, nil, 'c_entr_beyond', 'sup')\n          n_card.no_omega = true\n          n_card:add_to_deck()\n          n_card:set_edition({negative = true}, true)\n          G.consumeables:emplace(n_card)\n          card:juice_up(0.3, 0.5)\n          return true end }))\n      end\n      delay(0.6)\n    end,\n    loc_vars = function(self, info_queue, card)\n      local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n      return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds} }\n    end,\n    set_badges = function (self, card, badges)\n      SMODS.create_mod_badges({ mod = SMODS.find_mod(\"entr\")[1] }, badges)\n    end,",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 12
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 12
      },
      "vars": [
        0,
        null,
        null,
        12
      ],
      "infoQueue": []
    },
    {
      "type": "Consumable",
      "key": "brackets",
      "atlas": "mf_shapes",
      "pos": {
        "x": 3,
        "y": 5
      },
      "raw": "object_type = \"Consumable\",\n    set = \"Shape\",\n    name = \"shape_Brackets\",\n    key = \"brackets\",\n    pos = { x = 3, y = 5 },\n    config = {\n      val = 0,\n      partial_rounds = 0,\n      upgrade_rounds = 4,\n    },\n    cost = 4,\n    atlas = \"mf_shapes\",\n    unlocked = true,\n    discovered = true,\n    display_size = { w = 71, h = 87 },\n    pixel_size = { w = 71, h = 87 },\n    can_use = function(self, card)\n      return true\n    end,\n    use = function(self, card, area, copier)\n      local card_type = \"RCode\"\n      local rng_seed = \"brackets\"\n      for i = 1, card.ability.val do\n        G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()\n          play_sound('timpani')\n          local n_card = create_card(card_type, G.consumeables, nil, nil, nil, nil, nil, rng_seed)\n          n_card:add_to_deck()\n          n_card:set_edition({negative = true}, true)\n          G.consumeables:emplace(n_card)\n          card:juice_up(0.3, 0.5)\n          return true end }))\n      end\n      delay(0.6)\n    end,\n    loc_vars = function(self, info_queue, card)\n      local val, max = progressbar(card.ability.partial_rounds, card.ability.upgrade_rounds)\n      return { vars = {card.ability.val, val, max, card.ability.upgrade_rounds} }\n    end",
      "config": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 4
      },
      "ability": {
        "val": 0,
        "partial_rounds": 0,
        "upgrade_rounds": 4
      },
      "vars": [
        0,
        null,
        null,
        4
      ],
      "infoQueue": []
    },
    {
      "type": "Voucher",
      "key": "superboss_ticket",
      "atlas": "mf_vouchers",
      "pos": {
        "x": 3,
        "y": 0
      },
      "raw": "key = \"superboss_ticket\",\n    atlas = \"mf_vouchers\",\n    pos = { x = 3, y = 0 },\n\n    no_collection = true,\n\n    cost = 0,\n\n    loc_vars = function(self)\n      return {\n        vars = {\n          G.GAME.win_ante or 8,\n          (G.GAME.win_ante and G.GAME.round_resets.ante) and math.floor(\n            G.GAME.round_resets.ante + (G.GAME.win_ante - G.GAME.round_resets.ante % G.GAME.win_ante)\n          ) or 8,\n        },\n      }\n    end,\n\n    redeem = function(self, card)\n      G.GAME.superboss_active = true\n\n      -- Increase ante scaling\n      G.GAME.modifiers.scaling = G.GAME.modifiers.scaling or 1\n      G.GAME.modifiers.bonus_scaling = 3\n\n      G.GAME.modifiers.scaling = G.GAME.modifiers.scaling + G.GAME.modifiers.bonus_scaling\n\n      G.GAME.round_resets.blind_choices.Small = \"bl_mf_bigger_blind\"\n      G.GAME.round_resets.blind_choices.Big = get_new_boss()\n      G.GAME.round_resets.blind_choices.Boss = G.get_new_superboss()\n\n      ease_background_colour_blind(G.STATE, 'Small Blind')\n    end,\n\n    requires = {\"v_mf_impossiblevoucher\"},",
      "config": {},
      "ability": {},
      "vars": [
        8,
        8
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "bigger_blind",
      "atlas": "mf_blinds",
      "pos": {
        "x": 0,
        "y": 0
      },
      "raw": "key = \"bigger_blind\",\n    name = \"Bigger Blind\",\n\n    atlas = \"mf_blinds\",\n    pos = {x=0,y=0},\n\n    dollars = 6,\n    mult = 1,\n\n    boss_colour = HEX('793aab'),\n\n    no_collection = true,\n\n    in_pool = function(self) return false end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "violet_vessel_dx",
      "atlas": "mf_blinds",
      "pos": {
        "x": 0,
        "y": 1
      },
      "raw": "key = \"violet_vessel_dx\",\n    name = \"Violet Vessel DX\",\n\n    atlas = \"mf_blinds\",\n    pos = {x=0,y=1},\n\n    discovered = true,\n\n    dollars = 10,\n    mult = 24,\n\n    boss_colour = HEX('ac3232'),\n    \n    debuff = { -- if you have aiko installed it gets more difficult lolollolol\n      superboss = true,\n\n      akyrs_blind_difficulty = \"dx\",\n      akyrs_cannot_be_disabled = true,\n    },\n\n    boss = {\n      min=9, max=10, showdown = true\n    },\n\n    disable = function(self)\n      G.GAME.blind.chips = G.GAME.blind.chips/8\n      G.GAME.blind.chip_text = number_format(G.GAME.blind.chips)\n    end,\n\n    in_pool = function(self) \n      return G.GAME.round_resets.ante > G.GAME.win_ante\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "cerulean_bell_dx",
      "atlas": "mf_blinds",
      "pos": {
        "x": 0,
        "y": 2
      },
      "raw": "key = \"cerulean_bell_dx\",\n    name = \"Cerulean Bell DX\",\n\n    atlas = \"mf_blinds\",\n    pos = {x=0,y=2},\n\n    discovered = true,\n\n    dollars = 10,\n    mult = 3,\n\n    boss_colour = HEX('ac3232'),\n    \n    debuff = {\n      superboss = true,\n\n      akyrs_blind_difficulty = \"dx\",\n      akyrs_cannot_be_disabled = true,\n\n      force_select_count = 3,\n    },\n\n    loc_vars = function(self)\n      return { vars = { self.debuff.force_select_count } }\n    end,\n\n    disable = function(self)\n      for k, v in ipairs(G.playing_cards) do\n        v.ability.forced_selection = nil\n      end\n    end,\n\n    drawn_to_hand = function(self)\n      local any_forced = nil\n      for k, v in ipairs(G.hand.cards) do\n        if v.ability.forced_selection then\n          any_forced = true\n        end\n      end\n      if not any_forced then \n        G.hand:unhighlight_all()\n        local cb_dx_pool = {}\n        for _, card in pairs(G.hand.cards) do\n          cb_dx_pool[#cb_dx_pool + 1] = card\n        end\n        for _ = 1, self.debuff.force_select_count do\n          if #cb_dx_pool == 0 then break end\n          local forced_card = pseudorandom_element(cb_dx_pool, pseudoseed('cerulean_bell_dx'))\n          -- table.remove(cb_dx_pool, forced_card)\n          \n          for i = 1,#cb_dx_pool do\n            if cb_dx_pool[i] == forced_card then\n              table.remove(cb_dx_pool, i)\n              break\n            end\n          end\n\n          forced_card.ability.forced_selection = true\n          G.hand:add_to_highlighted(forced_card)\n        end\n      end\n    end,\n\n    boss = {\n      min=9, max=10, showdown = true\n    },\n\n    in_pool = function(self) \n      return G.GAME.round_resets.ante > G.GAME.win_ante\n    end",
      "config": {},
      "ability": {},
      "vars": [
        null
      ],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "needle_dx",
      "atlas": "mf_blinds",
      "pos": {
        "x": 0,
        "y": 3
      },
      "raw": "key = \"needle_dx\",\n    name = \"The Needle DX\",\n\n    atlas = \"mf_blinds\",\n    pos = {x=0,y=3},\n\n    discovered = true,\n\n    dollars = 10,\n    mult = 1,\n\n    boss_colour = HEX('ac3232'),\n    \n    debuff = {\n      superboss = true,\n\n      akyrs_blind_difficulty = \"dx\",\n      akyrs_cannot_be_disabled = true,\n    },\n\n    disable = function(self)\n      ease_hands_played(G.GAME.blind.hands_sub)\n      ease_discard(G.GAME.blind.discards_sub)\n      G.GAME.current_round.discards_used = G.GAME.current_round.discards_used - G.GAME.blind.discards_sub\n    end,\n\n    set_blind = function(self)\n      G.GAME.blind.hands_sub = G.GAME.round_resets.hands - 1\n      ease_hands_played(-G.GAME.blind.hands_sub)\n      G.GAME.blind.discards_sub = G.GAME.round_resets.discards - 1\n      ease_discard(-G.GAME.blind.discards_sub)\n      G.GAME.current_round.discards_used = G.GAME.current_round.discards_used + G.GAME.blind.discards_sub\n    end,\n\n    boss = {\n      min=9, max=10, showdown = true\n    },\n\n    in_pool = function(self) \n      return G.GAME.round_resets.ante > G.GAME.win_ante\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "manacle_dx",
      "atlas": "mf_blinds",
      "pos": {
        "x": 0,
        "y": 4
      },
      "raw": "key = \"manacle_dx\",\n    name = \"The Manacle DX\",\n\n    atlas = \"mf_blinds\",\n    pos = {x=0,y=4},\n\n    discovered = true,\n\n    dollars = 10,\n    mult = 3,\n\n    boss_colour = HEX('ac3232'),\n    \n    debuff = {\n      superboss = true,\n\n      akyrs_blind_difficulty = \"dx\",\n      akyrs_cannot_be_disabled = true,\n    },\n\n    disable = function(self)\n      if not G.GAME.blind.disabled then\n        G.hand:change_size(3)\n        \n        G.FUNCS.draw_from_deck_to_hand(3)\n      end\n    end,\n\n    defeat = function(self)\n      if not G.GAME.blind.disabled then\n        G.hand:change_size(3)\n      end\n    end,\n\n    set_blind = function(self)\n      G.hand:change_size(-3)\n    end,\n\n    boss = {\n      min=9, max=10, showdown = true\n    },\n\n    in_pool = function(self) \n      return G.GAME.round_resets.ante > G.GAME.win_ante\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "pillar_dx",
      "atlas": "mf_blinds",
      "pos": {
        "x": 0,
        "y": 5
      },
      "raw": "key = \"pillar_dx\",\n    name = \"The Pillar DX\",\n\n    atlas = \"mf_blinds\",\n    pos = {x=0,y=5},\n\n    discovered = true,\n\n    dollars = 10,\n    mult = 3,\n\n    boss_colour = HEX('ac3232'),\n    \n    debuff = {\n      superboss = true,\n\n      akyrs_blind_difficulty = \"dx\",\n      akyrs_cannot_be_disabled = true,\n    },\n\n    set_blind = function(self)\n      for _, card in pairs(G.playing_cards) do\n        if card.ability.mf_played_this_game and pseudorandom('pillar_dx') < 1 / 2 then\n          card.ability.mf_played_this_game = false\n        end\n      end\n    end,\n\n    recalc_debuff = function(self, card, from_blind)\n      if not G.GAME.blind.disabled and card.area ~= G.jokers then\n        if card.ability.mf_played_this_game then\n          return true\n        end\n      end\n      return false\n    end,\n\n    boss = {\n      min=9, max=10, showdown = true\n    },\n\n    in_pool = function(self) \n      return G.GAME.round_resets.ante > G.GAME.win_ante\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "serpent_dx",
      "atlas": "mf_blinds",
      "pos": {
        "x": 0,
        "y": 6
      },
      "raw": "key = \"serpent_dx\",\n    name = \"The Serpent DX\",\n\n    atlas = \"mf_blinds\",\n    pos = {x=0,y=6},\n\n    discovered = true,\n\n    dollars = 10,\n    mult = 3,\n\n    boss_colour = HEX('ac3232'),\n    \n    debuff = {\n      superboss = true,\n\n      akyrs_blind_difficulty = \"dx\",\n      akyrs_cannot_be_disabled = true,\n    },\n\n    boss = {\n      min=9, max=10, showdown = true\n    },\n\n    in_pool = function(self) \n      return G.GAME.round_resets.ante > G.GAME.win_ante\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "club_dx",
      "atlas": "mf_blinds",
      "pos": {
        "x": 0,
        "y": 7
      },
      "raw": "key = \"club_dx\",\n    name = \"The Club DX\",\n\n    atlas = \"mf_blinds\",\n    pos = {x=0,y=7},\n\n    discovered = true,\n\n    dollars = 10,\n    mult = 3,\n\n    boss_colour = HEX('ac3232'),\n    \n    debuff = {\n      superboss = true,\n\n      akyrs_blind_difficulty = \"dx\",\n      akyrs_cannot_be_disabled = true,\n    },\n\n    recalc_debuff = function(self, card, from_blind)\n      if not G.GAME.blind.disabled and card.area ~= G.jokers then\n        if not card:is_suit(\"Clubs\") then\n          return true\n        end\n      end\n      return false\n    end,\n\n    boss = {\n      min=9, max=10, showdown = true\n    },\n\n    in_pool = function(self) \n      return G.GAME.round_resets.ante > G.GAME.win_ante\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "goad_dx",
      "atlas": "mf_blinds",
      "pos": {
        "x": 0,
        "y": 8
      },
      "raw": "key = \"goad_dx\",\n    name = \"The Goad DX\",\n\n    atlas = \"mf_blinds\",\n    pos = {x=0,y=8},\n\n    discovered = true,\n\n    dollars = 10,\n    mult = 3,\n\n    boss_colour = HEX('ac3232'),\n    \n    debuff = {\n      superboss = true,\n\n      akyrs_blind_difficulty = \"dx\",\n      akyrs_cannot_be_disabled = true,\n    },\n\n    recalc_debuff = function(self, card, from_blind)\n      if not G.GAME.blind.disabled and card.area ~= G.jokers then\n        if not card:is_suit(\"Spades\") then\n          return true\n        end\n      end\n      return false\n    end,\n\n    boss = {\n      min=9, max=10, showdown = true\n    },\n\n    in_pool = function(self) \n      return G.GAME.round_resets.ante > G.GAME.win_ante\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "window_dx",
      "atlas": "mf_blinds",
      "pos": {
        "x": 0,
        "y": 9
      },
      "raw": "key = \"window_dx\",\n    name = \"The Window DX\",\n\n    atlas = \"mf_blinds\",\n    pos = {x=0,y=9},\n\n    discovered = true,\n\n    dollars = 10,\n    mult = 3,\n\n    boss_colour = HEX('ac3232'),\n    \n    debuff = {\n      superboss = true,\n\n      akyrs_blind_difficulty = \"dx\",\n      akyrs_cannot_be_disabled = true,\n    },\n\n    recalc_debuff = function(self, card, from_blind)\n      if not G.GAME.blind.disabled and card.area ~= G.jokers then\n        if not card:is_suit(\"Diamonds\") then\n          return true\n        end\n      end\n      return false\n    end,\n\n    boss = {\n      min=9, max=10, showdown = true\n    },\n\n    in_pool = function(self) \n      return G.GAME.round_resets.ante > G.GAME.win_ante\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "head_dx",
      "atlas": "mf_blinds",
      "pos": {
        "x": 0,
        "y": 10
      },
      "raw": "key = \"head_dx\",\n    name = \"The Head DX\",\n\n    atlas = \"mf_blinds\",\n    pos = {x=0,y=10},\n\n    discovered = true,\n\n    dollars = 10,\n    mult = 3,\n\n    boss_colour = HEX('ac3232'),\n    \n    debuff = {\n      superboss = true,\n\n      akyrs_blind_difficulty = \"dx\",\n      akyrs_cannot_be_disabled = true,\n    },\n\n    recalc_debuff = function(self, card, from_blind)\n      if not G.GAME.blind.disabled and card.area ~= G.jokers then\n        if not card:is_suit(\"Hearts\") then\n          return true\n        end\n      end\n      return false\n    end,\n\n    boss = {\n      min=9, max=10, showdown = true\n    },\n\n    in_pool = function(self) \n      return G.GAME.round_resets.ante > G.GAME.win_ante\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "arm_dx",
      "atlas": "mf_blinds",
      "pos": {
        "x": 0,
        "y": 11
      },
      "raw": "key = \"arm_dx\",\n    name = \"The Arm DX\",\n\n    atlas = \"mf_blinds\",\n    pos = {x=0,y=11},\n\n    discovered = true,\n\n    dollars = 10,\n    mult = 3,\n\n    boss_colour = HEX('ac3232'),\n    \n    debuff = {\n      superboss = true,\n\n      akyrs_blind_difficulty = \"dx\",\n      akyrs_cannot_be_disabled = true,\n    },\n\n    boss = {\n      min=9, max=10, showdown = true\n    },\n\n    debuff_hand = function(self, cards, hand, handname, check)\n      if G.GAME.blind.disabled then return end\n      G.GAME.blind.triggered = false\n      if to_number(G.GAME.hands[handname].level) > 0 then\n        G.GAME.blind.triggered = true\n        if not check then\n          level_up_hand(nil, handname, nil, -G.GAME.hands[handname].level)\n        end\n      end \n    end,\n\n    in_pool = function(self) \n      return G.GAME.round_resets.ante > G.GAME.win_ante\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "wheel_dx",
      "atlas": "mf_blinds",
      "pos": {
        "x": 0,
        "y": 12
      },
      "raw": "key = \"wheel_dx\",\n    name = \"The Wheel DX\",\n\n    atlas = \"mf_blinds\",\n    pos = {x=0,y=12},\n\n    discovered = true,\n\n    dollars = 10,\n    mult = 3,\n\n    boss_colour = HEX('ac3232'),\n    \n    debuff = {\n      superboss = true,\n\n      akyrs_blind_difficulty = \"dx\",\n      akyrs_cannot_be_disabled = true,\n    },\n\n    boss = {\n      min=9, max=10, showdown = true\n    },\n\n    stay_flipped = function(self, area, card)\n      if not G.GAME.blind.disabled then\n        if area == G.hand then\n          for _, other_card in pairs(G.hand.cards) do\n            if other_card.facing == \"front\" then\n              return true\n            end\n          end\n        end\n      end\n      return false\n    end,\n\n    in_pool = function(self) \n      return G.GAME.round_resets.ante > G.GAME.win_ante\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "house_dx",
      "atlas": "mf_blinds",
      "pos": {
        "x": 0,
        "y": 13
      },
      "raw": "key = \"house_dx\",\n    name = \"The House DX\",\n\n    atlas = \"mf_blinds\",\n    pos = {x=0,y=13},\n\n    discovered = true,\n\n    dollars = 10,\n    mult = 3,\n\n    boss_colour = HEX('ac3232'),\n    \n    debuff = {\n      superboss = true,\n\n      akyrs_blind_difficulty = \"dx\",\n      akyrs_cannot_be_disabled = true,\n    },\n\n    boss = {\n      min=9, max=10, showdown = true\n    },\n\n    drawn_to_hand = function(self)\n      if not G.GAME.blind.has_discarded then\n        for _, v in ipairs(G.hand.cards) do\n          G.hand.highlighted[#G.hand.highlighted+1] = v\n          v:highlight(true)\n        end\n        G.FUNCS.discard_cards_from_highlighted(nil, true)\n        G.GAME.blind.has_discarded = true\n      end\n    end,\n\n    in_pool = function(self) \n      return G.GAME.round_resets.ante > G.GAME.win_ante\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "psychic_dx",
      "atlas": "mf_blinds",
      "pos": {
        "x": 0,
        "y": 14
      },
      "raw": "key = \"psychic_dx\",\n    name = \"The Psychic DX\",\n\n    atlas = \"mf_blinds\",\n    pos = {x=0,y=14},\n\n    discovered = true,\n\n    dollars = 10,\n    mult = 3,\n\n    boss_colour = HEX('ac3232'),\n    \n    debuff = {\n      superboss = true,\n\n      h_size_le = 4,\n\n      akyrs_blind_difficulty = \"dx\",\n      akyrs_cannot_be_disabled = true,\n    },\n\n    boss = {\n      min=9, max=10, showdown = true\n    },\n\n    in_pool = function(self) \n      return G.GAME.round_resets.ante > G.GAME.win_ante\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Blind",
      "key": "hook_dx",
      "atlas": "mf_blinds",
      "pos": {
        "x": 0,
        "y": 15
      },
      "raw": "key = \"hook_dx\",\n    name = \"The Hook DX\",\n\n    atlas = \"mf_blinds\",\n    pos = {x=0,y=15},\n\n    discovered = true,\n\n    dollars = 10,\n    mult = 3,\n\n    boss_colour = HEX('ac3232'),\n    \n    debuff = {\n      superboss = true,\n\n      akyrs_blind_difficulty = \"dx\",\n      akyrs_cannot_be_disabled = true,\n    },\n\n    boss = {\n      min=9, max=10, showdown = true\n    },\n\n    drawn_to_hand = function(self)\n      if G.GAME.blind.should_discard then\n        for _, v in ipairs(G.hand.cards) do\n          G.hand.highlighted[#G.hand.highlighted+1] = v\n          v:highlight(true)\n        end\n        G.FUNCS.discard_cards_from_highlighted(nil, true)\n        G.GAME.blind.should_discard = false\n      end\n    end,\n\n    press_play = function(self)\n      G.GAME.blind.should_discard = true\n    end,\n\n    in_pool = function(self) \n      return G.GAME.round_resets.ante > G.GAME.win_ante\n    end",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    },
    {
      "type": "Challenge",
      "key": "superboss_always",
      "atlas": null,
      "pos": null,
      "raw": "key = \"superboss_always\",\n    rules = {\n      custom = {\n        { id = \"mf_superboss_active\" },\n        { id = \"scaling\", value = 4 },\n        { id = \"bonus_scaling\", value = 4 },\n      },\n      modifiers = {\n        { id = \"dollars\", value = 14 },\n      },\n    },\n    consumeables = {\n      { id = \"c_judgement\" },\n    },",
      "config": {},
      "ability": {},
      "vars": [],
      "infoQueue": []
    }
  ],
  "version": "1.5.6"
}